'use strict';
/**
 * Field Add/Copy CLI (minimal, no deps)
 * Usage:
 *   npm run fields:add -- --entity OrganizationUnit --field alias --preset "text.like(description)" --persist --nullable true --bcId organization --ui.group "基本信息" --ui.order 45
 *   npm run fields:add -- --entity Position --field alternateTitle --copy-from title --persist
 *
 * Notes:
 * - Contract is SSOT. This script generates:
 *   1) Goose migration file (Up/Down) if --persist
 *   2) Suggested patches under scripts/fields/out/*.patch for GraphQL/OpenAPI
 * - Keep ASCII; avoid external libs.
 */
const fs = require('fs');
const path = require('path');

function parseArgs(argv) {
  const args = {};
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a.startsWith('--')) {
      const key = a.slice(2);
      const next = argv[i + 1];
      if (!next || next.startsWith('--')) {
        args[key] = true;
      } else {
        args[key] = next;
        i++;
      }
    }
  }
  return args;
}

function readJSON(p) {
  return JSON.parse(fs.readFileSync(p, 'utf8'));
}

function ensureDir(d) {
  if (!fs.existsSync(d)) fs.mkdirSync(d, { recursive: true });
}

function timestamp() {
  const now = new Date();
  const pad = (n) => String(n).padStart(2, '0');
  return (
    now.getFullYear().toString() +
    pad(now.getMonth() + 1) +
    pad(now.getDate()) +
    pad(now.getHours()) +
    pad(now.getMinutes()) +
    pad(now.getSeconds())
  );
}

function loadSchemaGraphQL(repoRoot) {
  const p = path.join(repoRoot, 'docs', 'api', 'schema.graphql');
  if (!fs.existsSync(p)) return null;
  return fs.readFileSync(p, 'utf8');
}

function inferFromCopyField(schemaText, entity, copyField) {
  if (!schemaText) return null;
  const typeStart = schemaText.indexOf(`type ${entity} {`);
  if (typeStart === -1) return null;
  const block = schemaText.slice(typeStart);
  const end = block.indexOf('}');
  if (end === -1) return null;
  const body = block.slice(0, end);
  const lines = body.split('\n').map((s) => s.trim());
  const target = lines.find((l) => l.startsWith(copyField + ':'));
  if (!target) return null;
  // e.g. "description: String"
  const parts = target.split(':').map((s) => s.trim());
  const gqlType = parts[1] || 'String';
  return gqlType;
}

function selectPreset(presets, presetName) {
  const p = presets.presets[presetName];
  if (!p) throw new Error(`Unknown preset: ${presetName}`);
  return p;
}

function resolveEntityMeta(presets, entity) {
  const meta = presets.entities[entity];
  if (!meta) throw new Error(`Unsupported entity: ${entity}`);
  return meta;
}

function validateBcId(presets, bcId) {
  if (!bcId) return;
  const ok = presets.bcIds.includes(bcId);
  if (!ok) {
    throw new Error(
      `bcId "${bcId}" not in allowed list (${presets.bcIds.join(', ')})`
    );
  }
}

function createMigration(repoRoot, table, field, sqlType, nullable, defaultValue) {
  const dir = path.join(repoRoot, 'database', 'migrations');
  ensureDir(dir);
  const ts = timestamp();
  const fname = `${ts}_add_${table}_${field}.sql`;
  const fpath = path.join(dir, fname);
  const notNull = nullable ? '' : ' NOT NULL';
  const def = defaultValue !== undefined && defaultValue !== null ? ` DEFAULT ${defaultValue}` : '';
  const up = `-- +goose Up
-- auto-generated by scripts/fields/add.js
ALTER TABLE ${table}
  ADD COLUMN ${field} ${sqlType}${def}${notNull};`;
  const down = `-- +goose Down
-- auto-generated by scripts/fields/add.js
ALTER TABLE ${table}
  DROP COLUMN IF EXISTS ${field};`;
  fs.writeFileSync(fpath, up + '\n' + down + '\n', 'utf8');
  return fpath;
}

function writePatches(repoRoot, entity, field, gqlType, openapiType, uiHints, bcId) {
  const outDir = path.join(repoRoot, 'scripts', 'fields', 'out');
  ensureDir(outDir);
  const gqlPatch = [
    '# Suggested GraphQL patch (apply manually into docs/api/schema.graphql)',
    `# Entity type: ${entity}`,
    `# Add field in "type ${entity} { ... }":`,
    `#   ${field}: ${gqlType}`,
    '# Optionally add to input objects (Create/Update) if needed.',
    ''
  ].join('\n');
  const openapiPatch = [
    '# Suggested OpenAPI patch (apply manually into docs/api/openapi.yaml)',
    '# In relevant request/response schemas add:',
    `#   ${field}:`,
    `#     type: ${openapiType.type || 'string'}`,
    openapiType.format ? `#     format: ${openapiType.format}` : null,
    uiHints ? `#     x-ui:` : null,
    uiHints && uiHints.label ? `#       label: "${uiHints.label}"` : null,
    uiHints && uiHints.group ? `#       group: "${uiHints.group}"` : null,
    uiHints && uiHints.order !== undefined ? `#       order: ${uiHints.order}` : null,
    uiHints && uiHints.control ? `#       control: ${uiHints.control}` : null,
    bcId ? `#     x-bcId: ${bcId}` : null,
    ''
  ].filter(Boolean).join('\n');
  const readme = [
    '# Field generation summary',
    `entity: ${entity}`,
    `field: ${field}`,
    `bcId: ${bcId || '(not provided)'}`,
    `graphQL.type: ${gqlType}`,
    `openapi.type: ${openapiType.type || 'string'}`,
    `openapi.format: ${openapiType.format || '(none)'}`,
    `ui.control: ${uiHints && uiHints.control ? uiHints.control : '(default)'}`,
    '',
    'Next steps:',
    '- Apply patches to docs/api files.',
    '- Run migrations (make db-migrate-all).',
    '- Update repository/DTO/resolver/handler if needed.',
    '- Run frontend contract:generate and verify UI.'
  ].join('\n');
  fs.writeFileSync(path.join(outDir, `${entity}.${field}.graphql.patch`), gqlPatch, 'utf8');
  fs.writeFileSync(path.join(outDir, `${entity}.${field}.openapi.patch`), openapiPatch, 'utf8');
  fs.writeFileSync(path.join(outDir, `${entity}.${field}.README.txt`), readme, 'utf8');
  return outDir;
}

function main() {
  const repoRoot = path.resolve(__dirname, '..', '..');
  const argv = process.argv.slice(2);
  const args = parseArgs(argv);
  const required = ['entity', 'field'];
  for (const r of required) {
    if (!args[r]) {
      console.error(`Missing --${r}`);
      process.exit(2);
    }
  }
  const entity = args.entity;
  const field = args.field;
  const bcId = args['bcId'];
  const persist = !!args['persist'];
  const nullable = args['nullable'] !== 'false'; // default true
  const presetName = args['preset'];
  const copyFrom = args['copy-from'];
  const uiGroup = args['ui.group'];
  const uiOrder = args['ui.order'] ? Number(args['ui.order']) : undefined;

  const presetData = readJSON(path.join(__dirname, 'presets.json'));
  validateBcId(presetData, bcId);
  const entityMeta = resolveEntityMeta(presetData, entity);

  let gqlType = 'String';
  let openapiType = { type: 'string' };
  let sqlType = 'text';
  let uiHints = { control: 'TextInput', group: uiGroup, order: uiOrder };

  const schemaText = loadSchemaGraphQL(repoRoot);
  if (copyFrom) {
    const inferred = inferFromCopyField(schemaText, entityMeta.graphQLType, copyFrom);
    if (!inferred) {
      console.error(`Failed to infer type from copy-from field "${copyFrom}".`);
      process.exit(3);
    }
    gqlType = inferred;
    // map simple gql types to sql/openapi
    if (/^String!?$/.test(gqlType)) {
      sqlType = 'text';
      openapiType = { type: 'string' };
    } else if (/^Date!?$/.test(gqlType)) {
      sqlType = 'date';
      openapiType = { type: 'string', format: 'date' };
      uiHints.control = 'DatePicker';
    } else {
      // default string
      sqlType = 'text';
      openapiType = { type: 'string' };
    }
  } else if (presetName) {
    const p = selectPreset(presetData, presetName);
    gqlType = p.graphql.type + (p.graphql.nullable ? '' : '!');
    sqlType = p.sql.type;
    openapiType = { type: p.openapi.type };
    if (p.openapi.format) openapiType.format = p.openapi.format;
    uiHints.control = p.ui.control || uiHints.control;
  } else {
    console.error('Either --preset or --copy-from must be provided.');
    process.exit(2);
  }

  let migrationPath = null;
  if (persist) {
    migrationPath = createMigration(
      repoRoot,
      entityMeta.table,
      field,
      sqlType,
      nullable,
      undefined
    );
  }
  const outDir = writePatches(repoRoot, entityMeta.graphQLType, field, gqlType.replace(/!$/, ''), openapiType, uiHints, bcId);

  console.log('✅ Field generation completed');
  if (migrationPath) console.log('  migration:', path.relative(repoRoot, migrationPath));
  console.log('  patches dir:', path.relative(repoRoot, outDir));
  console.log('Next:');
  console.log('  1) Apply suggested patches to docs/api/schema.graphql and openapi.yaml');
  console.log('  2) make db-migrate-all');
  console.log('  3) Update service/repository/resolver/handler if needed');
  console.log('  4) npm --prefix frontend run contract:generate');
  console.log('  5) Run preflight and E2E, then register evidence in Plan 215');
}

if (require.main === module) {
  try {
    main();
  } catch (e) {
    console.error('Error:', e.message);
    process.exit(1);
  }
}

