#!/usr/bin/env node
/**
 * generate-ts-types.js
 *
 * 根据 shared/contracts/organization.json 生成 TypeScript 枚举与常量定义，
 * 输出至 frontend/src/shared/types/contract_gen.ts，作为前端枚举/约束的权威来源。
 */

const fs = require('fs');
const path = require('path');

const PROJECT_ROOT = path.resolve(__dirname, '../..');
const CONTRACT_PATH = path.join(PROJECT_ROOT, 'shared/contracts/organization.json');
const OUTPUT_PATH = path.join(PROJECT_ROOT, 'frontend/src/shared/types/contract_gen.ts');

const ACRONYM_MAP = {
  API: 'API',
  ID: 'ID',
  UUID: 'UUID',
  URL: 'URL',
  HTTP: 'HTTP',
  HTTPS: 'HTTPS',
  SQL: 'SQL',
  PBAC: 'PBAC',
  CQRS: 'CQRS',
};

function loadContract() {
  if (!fs.existsSync(CONTRACT_PATH)) {
    throw new Error('契约文件不存在，请先运行 openapi-to-json.js');
  }
  return JSON.parse(fs.readFileSync(CONTRACT_PATH, 'utf8'));
}

function toPascalCase(value) {
  if (!value) return '';
  const cleaned = value.replace(/[^A-Za-z0-9]+/g, ' ').trim();
  if (!cleaned) return '';
  return cleaned
    .split(/\s+/)
    .map((part) => {
      const upper = part.toUpperCase();
      if (ACRONYM_MAP[upper]) {
        return ACRONYM_MAP[upper];
      }
      return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
    })
    .join('');
}

function buildEnum(name, values = []) {
  if (!values.length) return '';
  const members = values
    .map((value) => {
      const key = toPascalCase(value);
      return `  ${key} = '${value}',`;
    })
    .join('\n');

  return [
    `export enum ${name} {`,
    members,
    '}',
    '',
  ].join('\n');
}

function buildTypeGuards(name) {
  return [
    `export const ${name}Values = Object.values(${name}) as ${name}[];`,
    '',
    `export function is${name}(value: unknown): value is ${name} {`,
    '  return typeof value === \'string\' &&',
    `    ${name}Values.includes(value as ${name});`,
    '}',
    '',
  ].join('\n');
}

function buildConstraints(constraints = {}) {
  const lines = [];

  const addString = (key, value, comment) => {
    if (typeof value === 'string' && value.length > 0) {
      lines.push(`  /** ${comment} */`);
      lines.push(`  ${key}: '${value}',`);
    }
  };

  const addNumber = (key, value, comment) => {
    if (typeof value === 'number' && Number.isFinite(value)) {
      lines.push(`  /** ${comment} */`);
      lines.push(`  ${key}: ${value},`);
    }
  };

  if (constraints.code) {
    addString('codePattern', constraints.code.pattern, '组织编码正则约束');
  }
  if (constraints.parentCode) {
    addString('parentCodePattern', constraints.parentCode.pattern, '父级组织编码正则约束');
  }
  if (constraints.name) {
    addNumber('nameMaxLength', constraints.name.maxLength, '组织名称最大长度');
  }
  if (constraints.description) {
    addNumber('descriptionMaxLength', constraints.description.maxLength, '组织描述最大长度');
  }
  if (constraints.level) {
    addNumber('levelMin', constraints.level.min, '组织层级最小值');
    addNumber('levelMax', constraints.level.max, '组织层级最大值');
  }
  if (constraints.sortOrder) {
    addNumber('sortOrderDefault', constraints.sortOrder.default, '组织排序默认值');
  }
  if (constraints.operationReason) {
    addNumber('operationReasonMaxLength', constraints.operationReason.maxLength, '操作原因最大长度');
  }
  if (constraints.effectiveDate) {
    addString('effectiveDateFormat', constraints.effectiveDate.format, '生效日期格式');
  }

  if (!lines.length) {
    return '';
  }

  return [
    'export const OrganizationConstraints = {',
    ...lines,
    '} as const;',
    '',
  ].join('\n');
}

function buildWarningComment(contract) {
  const restStatus = contract.enums?.status || [];
  const gqlStatus = contract.graphql?.enums?.status || [];
  const diff = gqlStatus.filter((value) => !restStatus.includes(value));

  if (!diff.length) {
    return '';
  }

  return [
    '/**',
    ' * ⚠️ 枚举差异提示：GraphQL 定义的状态在 REST 契约中缺失，需要在后续阶段补齐。',
    ` * 缺失项: ${diff.join(', ')}`,
    ' */',
    '',
  ].join('\n');
}

function buildFile(contract) {
  const header = [
    '// Code generated by scripts/contract/generate-ts-types.js. DO NOT EDIT.',
    '// Source: shared/contracts/organization.json',
    '',
  ].join('\n');

  const enums = contract.enums || {};

  const unitTypeEnum = buildEnum('OrganizationUnitTypeEnum', enums.unitType);
  const statusComment = buildWarningComment(contract);
  const statusEnum = buildEnum('OrganizationStatusEnum', enums.status);
  const operationEnum = buildEnum('OrganizationOperationTypeEnum', enums.operationType);

  const typeGuards = [
    buildTypeGuards('OrganizationUnitTypeEnum'),
    buildTypeGuards('OrganizationStatusEnum'),
    buildTypeGuards('OrganizationOperationTypeEnum'),
  ].join('\n');

  const constraints = buildConstraints(contract.constraints);

  const exports = [
    'export type OrganizationUnitType = OrganizationUnitTypeEnum;',
    'export type OrganizationStatus = OrganizationStatusEnum;',
    'export type OrganizationOperationType = OrganizationOperationTypeEnum;',
    '',
  ].join('\n');

  return [
    header,
    unitTypeEnum,
    statusComment,
    statusEnum,
    operationEnum,
    typeGuards,
    constraints,
    exports,
  ]
    .filter(Boolean)
    .join('\n');
}

function ensureOutputDir() {
  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
}

function writeTsFile(content) {
  fs.writeFileSync(OUTPUT_PATH, `${content}\n`, 'utf8');
}

function main() {
  try {
    const contract = loadContract();
    ensureOutputDir();
    const content = buildFile(contract);
    writeTsFile(content);
    console.log('[TypeScript] ✓ 类型已生成');
    console.log(`  → ${OUTPUT_PATH}`);
  } catch (error) {
    console.error('[TypeScript] ✗ 生成失败:', error.message);
    process.exit(1);
  }
}

main();
