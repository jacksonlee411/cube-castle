#!/usr/bin/env node
/**
 * generate-go-types.js
 *
 * 根据 shared/contracts/organization.json 生成 Go 侧的枚举与常量定义，
 * 输出至 cmd/organization-command-service/internal/types/contract_gen.go
 * 作为契约枚举与约束的唯一事实来源。
 */

const fs = require('fs');
const path = require('path');

const PROJECT_ROOT = path.resolve(__dirname, '../..');
const CONTRACT_PATH = path.join(PROJECT_ROOT, 'shared/contracts/organization.json');
const OUTPUT_PATH = path.join(
  PROJECT_ROOT,
  'cmd/organization-command-service/internal/types/contract_gen.go'
);

const ACRONYM_MAP = {
  API: 'API',
  ID: 'ID',
  UUID: 'UUID',
  URL: 'URL',
  HTTP: 'HTTP',
  HTTPS: 'HTTPS',
  SQL: 'SQL',
  PBAC: 'PBAC',
  CQRS: 'CQRS',
};

function loadContract() {
  if (!fs.existsSync(CONTRACT_PATH)) {
    throw new Error('契约文件不存在，请先运行 openapi-to-json.js');
  }
  const content = fs.readFileSync(CONTRACT_PATH, 'utf8');
  return JSON.parse(content);
}

function toPascalCase(value) {
  if (!value) return '';
  const cleaned = value.replace(/[^A-Za-z0-9]+/g, ' ').trim();
  if (!cleaned) return '';
  return cleaned
    .split(/\s+/)
    .map((part) => {
      const upper = part.toUpperCase();
      if (ACRONYM_MAP[upper]) {
        return ACRONYM_MAP[upper];
      }
      return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
    })
    .join('');
}

function buildEnumBlock(typeName, enumKey, values) {
  if (!values || values.length === 0) {
    return '';
  }
  const comment = `// ${typeName} 由契约生成`;
  const typeAlias = `type ${typeName} string`;
  const constLines = values.map((value) => {
    const constName = `${typeName}${toPascalCase(value)}`;
    return `\t${constName} ${typeName} = "${value}"`;
  });

  return [
    comment,
    typeAlias,
    'const (',
    ...constLines,
    ')',
    '',
  ].join('\n');
}

function buildConstraintConstants(constraints = {}) {
  const lines = [];
  const addStringConst = (name, value, comment) => {
    if (typeof value === 'string' && value.length > 0) {
      lines.push(`\t// ${comment}`);
      lines.push(`\t${name} = "${value}"`);
    }
  };
  const addIntConst = (name, value, comment) => {
    if (typeof value === 'number' && Number.isFinite(value)) {
      lines.push(`\t// ${comment}`);
      lines.push(`\t${name} = ${value}`);
    }
  };

  if (constraints.code) {
    addStringConst('OrganizationCodePattern', constraints.code.pattern, '组织编码正则约束');
  }
  if (constraints.parentCode) {
    addStringConst('OrganizationParentCodePattern', constraints.parentCode.pattern, '父级组织编码正则约束');
  }
  if (constraints.name) {
    addIntConst('OrganizationNameMaxLength', constraints.name.maxLength, '组织名称最大长度');
  }
  if (constraints.description) {
    addIntConst('OrganizationDescriptionMaxLength', constraints.description.maxLength, '组织描述最大长度');
  }
  if (constraints.level) {
    addIntConst('OrganizationLevelMin', constraints.level.min, '组织层级最小值');
    addIntConst('OrganizationLevelMax', constraints.level.max, '组织层级最大值');
  }
  if (constraints.sortOrder) {
    addIntConst('OrganizationSortOrderDefault', constraints.sortOrder.default, '组织排序默认值');
  }
  if (constraints.operationReason) {
    addIntConst('OrganizationOperationReasonMaxLength', constraints.operationReason.maxLength, '操作原因最大长度');
  }
  if (constraints.effectiveDate) {
    addStringConst('OrganizationEffectiveDateFormat', constraints.effectiveDate.format, '生效日期格式');
  }

  if (lines.length === 0) {
    return '';
  }

  return [
    '// OrganizationConstraints 契约约束常量（由 generate-go-types.js 生成）',
    'const (',
    ...lines,
    ')',
    '',
  ].join('\n');
}

function buildGoFile(contract) {
  const header = [
    '// Code generated by scripts/contract/generate-go-types.js. DO NOT EDIT.',
    '// Source: shared/contracts/organization.json',
    '',
    'package types',
    '',
  ].join('\n');

  const enums = contract.enums || {};

  const unitTypeBlock = buildEnumBlock('UnitType', 'unitType', enums.unitType);
  const statusBlock = buildEnumBlock('OrganizationStatus', 'status', enums.status);
  const operationBlock = buildEnumBlock('OperationType', 'operationType', enums.operationType);
  const constraintsBlock = buildConstraintConstants(contract.constraints);

  return [
    header,
    unitTypeBlock,
    statusBlock,
    operationBlock,
    constraintsBlock,
  ]
    .filter(Boolean)
    .join('\n');
}

function ensureOutputDir() {
  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
}

function writeGoFile(content) {
  fs.writeFileSync(OUTPUT_PATH, `${content}\n`, 'utf8');
}

function runGoFmt() {
  try {
    const { spawnSync } = require('child_process');
    const result = spawnSync('gofmt', ['-w', OUTPUT_PATH], {
      stdio: 'inherit',
    });
    if (result.error) {
      console.warn('[Go] ⚠ gofmt 执行失败:', result.error.message);
    }
  } catch (error) {
    console.warn('[Go] ⚠ 无法执行 gofmt:', error.message);
  }
}

function main() {
  try {
    const contract = loadContract();
    ensureOutputDir();
    const goContent = buildGoFile(contract);
    writeGoFile(goContent);
    runGoFmt();
    console.log('[Go] ✓ 类型已生成');
    console.log(`  → ${OUTPUT_PATH}`);
  } catch (error) {
    console.error('[Go] ✗ 生成失败:', error.message);
    process.exit(1);
  }
}

main();
