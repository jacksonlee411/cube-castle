package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	graphqlruntime "cube-castle/cmd/hrms-server/query/internal/graphql"
	"cube-castle/cmd/hrms-server/query/internal/graphql/model"
	"cube-castle/internal/organization/dto"
)

// Organizations is the resolver for the organizations field.
func (r *queryResolver) Organizations(ctx context.Context, filter *model.OrganizationFilter, pagination *model.PaginationInput) (*model.OrganizationConnection, error) {
	dtoFilter, err := convertInput[model.OrganizationFilter, dto.OrganizationFilter](filter)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.Organizations(ctx, struct {
		Filter     *dto.OrganizationFilter
		Pagination *dto.PaginationInput
	}{
		Filter:     dtoFilter,
		Pagination: dtoPagination,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.OrganizationConnection](res)
}

// Organization is the resolver for the organization field.
func (r *queryResolver) Organization(ctx context.Context, code string, asOfDate *string) (*model.Organization, error) {
	res, err := r.QueryResolver.Organization(ctx, struct {
		Code     string
		AsOfDate *string
	}{
		Code:     code,
		AsOfDate: asOfDate,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.Organization](res)
}

// OrganizationStats is the resolver for the organizationStats field.
func (r *queryResolver) OrganizationStats(ctx context.Context, asOfDate *string, includeHistorical *bool) (*model.OrganizationStats, error) {
	include := false
	if includeHistorical != nil {
		include = *includeHistorical
	}
	res, err := r.QueryResolver.OrganizationStats(ctx, struct {
		AsOfDate          *string
		IncludeHistorical bool
	}{
		AsOfDate:          asOfDate,
		IncludeHistorical: include,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.OrganizationStats](res)
}

// OrganizationHierarchy is the resolver for the organizationHierarchy field.
func (r *queryResolver) OrganizationHierarchy(ctx context.Context, code string, tenantID string) (*model.OrganizationHierarchy, error) {
	res, err := r.QueryResolver.OrganizationHierarchy(ctx, struct {
		Code     string
		TenantId string
	}{
		Code:     code,
		TenantId: tenantID,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.OrganizationHierarchy](res)
}

// OrganizationSubtree is the resolver for the organizationSubtree field.
func (r *queryResolver) OrganizationSubtree(ctx context.Context, code string, tenantID string, maxDepth *int, includeInactive *bool) ([]model.OrganizationHierarchy, error) {
	md := 0
	if maxDepth != nil {
		md = *maxDepth
	}
	inactive := false
	if includeInactive != nil {
		inactive = *includeInactive
	}
	res, err := r.QueryResolver.OrganizationSubtree(ctx, struct {
		Code            string
		TenantId        string
		MaxDepth        int32
		IncludeInactive bool
	}{
		Code:            code,
		TenantId:        tenantID,
		MaxDepth:        int32(md),
		IncludeInactive: inactive,
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.OrganizationHierarchy](res)
}

// HierarchyStatistics is the resolver for the hierarchyStatistics field.
func (r *queryResolver) HierarchyStatistics(ctx context.Context, tenantID string, includeIntegrityCheck *bool) (*model.HierarchyStatistics, error) {
	include := false
	if includeIntegrityCheck != nil {
		include = *includeIntegrityCheck
	}
	res, err := r.QueryResolver.HierarchyStatistics(ctx, struct {
		TenantId              string
		IncludeIntegrityCheck bool
	}{
		TenantId:              tenantID,
		IncludeIntegrityCheck: include,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.HierarchyStatistics](res)
}

// Positions is the resolver for the positions field.
func (r *queryResolver) Positions(ctx context.Context, filter *model.PositionFilterInput, pagination *model.PaginationInput, sorting []model.PositionSortInput) (*model.PositionConnection, error) {
	dtoFilter, err := convertInput[model.PositionFilterInput, dto.PositionFilterInput](filter)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	dtoSorting, err := convertInputSlicePointer[model.PositionSortInput, dto.PositionSortInput](sorting)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.Positions(ctx, struct {
		Filter     *dto.PositionFilterInput
		Pagination *dto.PaginationInput
		Sorting    *[]dto.PositionSortInput
	}{
		Filter:     dtoFilter,
		Pagination: dtoPagination,
		Sorting:    dtoSorting,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.PositionConnection](res)
}

// Position is the resolver for the position field.
func (r *queryResolver) Position(ctx context.Context, code dto.PositionCode, asOfDate *dto.Date) (*model.Position, error) {
	res, err := r.QueryResolver.Position(ctx, struct {
		Code     string
		AsOfDate *string
	}{
		Code:     scalarToString(code),
		AsOfDate: dateToStringPtr(asOfDate),
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.Position](res)
}

// PositionTimeline is the resolver for the positionTimeline field.
func (r *queryResolver) PositionTimeline(ctx context.Context, code dto.PositionCode, startDate *dto.Date, endDate *dto.Date) ([]model.PositionTimelineEntry, error) {
	res, err := r.QueryResolver.PositionTimeline(ctx, struct {
		Code      string
		StartDate *string
		EndDate   *string
	}{
		Code:      scalarToString(code),
		StartDate: dateToStringPtr(startDate),
		EndDate:   dateToStringPtr(endDate),
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.PositionTimelineEntry](res)
}

// PositionVersions is the resolver for the positionVersions field.
func (r *queryResolver) PositionVersions(ctx context.Context, code dto.PositionCode, includeDeleted *bool) ([]model.Position, error) {
	res, err := r.QueryResolver.PositionVersions(ctx, struct {
		Code           string
		IncludeDeleted *bool
	}{
		Code:           scalarToString(code),
		IncludeDeleted: includeDeleted,
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.Position](res)
}

// PositionAssignments is the resolver for the positionAssignments field.
func (r *queryResolver) PositionAssignments(ctx context.Context, positionCode dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) (*model.PositionAssignmentConnection, error) {
	dtoFilter, err := convertInput[model.PositionAssignmentFilterInput, dto.PositionAssignmentFilterInput](filter)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	dtoSorting, err := convertInputSlicePointer[model.PositionAssignmentSortInput, dto.PositionAssignmentSortInput](sorting)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.PositionAssignments(ctx, struct {
		PositionCode string
		Filter       *dto.PositionAssignmentFilterInput
		Pagination   *dto.PaginationInput
		Sorting      *[]dto.PositionAssignmentSortInput
	}{
		PositionCode: scalarToString(positionCode),
		Filter:       dtoFilter,
		Pagination:   dtoPagination,
		Sorting:      dtoSorting,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.PositionAssignmentConnection](res)
}

// PositionAssignmentAudit is the resolver for the positionAssignmentAudit field.
func (r *queryResolver) PositionAssignmentAudit(ctx context.Context, positionCode dto.PositionCode, assignmentID *dto.UUID, dateRange *model.DateRangeInput, pagination *model.PaginationInput) (*model.PositionAssignmentAuditConnection, error) {
	dtoDateRange, err := convertInput[model.DateRangeInput, dto.DateRangeInput](dateRange)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.PositionAssignmentAudit(ctx, struct {
		PositionCode string
		AssignmentId *string
		DateRange    *dto.DateRangeInput
		Pagination   *dto.PaginationInput
	}{
		PositionCode: scalarToString(positionCode),
		AssignmentId: scalarPtrToStringPtr(assignmentID),
		DateRange:    dtoDateRange,
		Pagination:   dtoPagination,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.PositionAssignmentAuditConnection](res)
}

// Assignments is the resolver for the assignments field.
func (r *queryResolver) Assignments(ctx context.Context, organizationCode *string, positionCode *dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) (*model.PositionAssignmentConnection, error) {
	dtoFilter, err := convertInput[model.PositionAssignmentFilterInput, dto.PositionAssignmentFilterInput](filter)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	dtoSorting, err := convertInputSlicePointer[model.PositionAssignmentSortInput, dto.PositionAssignmentSortInput](sorting)
	if err != nil {
		return nil, err
	}
	var positionPtr *string
	if positionCode != nil {
		positionPtr = scalarPtrToStringPtr(positionCode)
	}
	res, err := r.QueryResolver.Assignments(ctx, struct {
		OrganizationCode *string
		PositionCode     *string
		Filter           *dto.PositionAssignmentFilterInput
		Pagination       *dto.PaginationInput
		Sorting          *[]dto.PositionAssignmentSortInput
	}{
		OrganizationCode: organizationCode,
		PositionCode:     positionPtr,
		Filter:           dtoFilter,
		Pagination:       dtoPagination,
		Sorting:          dtoSorting,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.PositionAssignmentConnection](res)
}

// AssignmentHistory is the resolver for the assignmentHistory field.
func (r *queryResolver) AssignmentHistory(ctx context.Context, positionCode dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) (*model.PositionAssignmentConnection, error) {
	dtoFilter, err := convertInput[model.PositionAssignmentFilterInput, dto.PositionAssignmentFilterInput](filter)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	dtoSorting, err := convertInputSlicePointer[model.PositionAssignmentSortInput, dto.PositionAssignmentSortInput](sorting)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.AssignmentHistory(ctx, struct {
		PositionCode string
		Filter       *dto.PositionAssignmentFilterInput
		Pagination   *dto.PaginationInput
		Sorting      *[]dto.PositionAssignmentSortInput
	}{
		PositionCode: scalarToString(positionCode),
		Filter:       dtoFilter,
		Pagination:   dtoPagination,
		Sorting:      dtoSorting,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.PositionAssignmentConnection](res)
}

// AssignmentStats is the resolver for the assignmentStats field.
func (r *queryResolver) AssignmentStats(ctx context.Context, organizationCode *string, positionCode *dto.PositionCode) (*model.AssignmentStats, error) {
	var positionPtr *string
	if positionCode != nil {
		positionPtr = scalarPtrToStringPtr(positionCode)
	}
	res, err := r.QueryResolver.AssignmentStats(ctx, struct {
		OrganizationCode *string
		PositionCode     *string
	}{
		OrganizationCode: organizationCode,
		PositionCode:     positionPtr,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.AssignmentStats](res)
}

// VacantPositions is the resolver for the vacantPositions field.
func (r *queryResolver) VacantPositions(ctx context.Context, filter *model.VacantPositionFilterInput, pagination *model.PaginationInput, sorting []model.VacantPositionSortInput) (*model.VacantPositionConnection, error) {
	dtoFilter, err := convertInput[model.VacantPositionFilterInput, dto.VacantPositionFilterInput](filter)
	if err != nil {
		return nil, err
	}
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	dtoSorting, err := convertInputSlicePointer[model.VacantPositionSortInput, dto.VacantPositionSortInput](sorting)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.VacantPositions(ctx, struct {
		Filter     *dto.VacantPositionFilterInput
		Pagination *dto.PaginationInput
		Sorting    *[]dto.VacantPositionSortInput
	}{
		Filter:     dtoFilter,
		Pagination: dtoPagination,
		Sorting:    dtoSorting,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.VacantPositionConnection](res)
}

// PositionTransfers is the resolver for the positionTransfers field.
func (r *queryResolver) PositionTransfers(ctx context.Context, positionCode *dto.PositionCode, organizationCode *string, pagination *model.PaginationInput) (*model.PositionTransferConnection, error) {
	dtoPagination, err := convertInput[model.PaginationInput, dto.PaginationInput](pagination)
	if err != nil {
		return nil, err
	}
	res, err := r.QueryResolver.PositionTransfers(ctx, struct {
		PositionCode     *string
		OrganizationCode *string
		Pagination       *dto.PaginationInput
	}{
		PositionCode:     scalarPtrToStringPtr(positionCode),
		OrganizationCode: organizationCode,
		Pagination:       dtoPagination,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.PositionTransferConnection](res)
}

// PositionHeadcountStats is the resolver for the positionHeadcountStats field.
func (r *queryResolver) PositionHeadcountStats(ctx context.Context, organizationCode string, includeSubordinates *bool) (*model.HeadcountStats, error) {
	res, err := r.QueryResolver.PositionHeadcountStats(ctx, struct {
		OrganizationCode    string
		IncludeSubordinates *bool
	}{
		OrganizationCode:    organizationCode,
		IncludeSubordinates: includeSubordinates,
	})
	if err != nil {
		return nil, err
	}
	return convertToModel[model.HeadcountStats](res)
}

// AuditHistory is the resolver for the auditHistory field.
func (r *queryResolver) AuditHistory(ctx context.Context, recordID string, startDate *string, endDate *string, operation *model.OperationType, userID *string, limit *int) ([]model.AuditLogDetail, error) {
	op := (*string)(nil)
	if operation != nil {
		val := string(*operation)
		op = &val
	}
	lim := 0
	if limit != nil {
		lim = *limit
	}
	res, err := r.QueryResolver.AuditHistory(ctx, struct {
		RecordId  string
		StartDate *string
		EndDate   *string
		Operation *string
		UserId    *string
		Limit     int32
	}{
		RecordId:  recordID,
		StartDate: startDate,
		EndDate:   endDate,
		Operation: op,
		UserId:    userID,
		Limit:     int32(lim),
	})
	if err != nil {
		return nil, err
	}
	// Specialized mapping to ensure operation field is populated (event_type)
	return convertAuditSlice(res)
}

// AuditLog is the resolver for the auditLog field.
func (r *queryResolver) AuditLog(ctx context.Context, auditID string) (*model.AuditLogDetail, error) {
	res, err := r.QueryResolver.AuditLog(ctx, struct {
		AuditId string
	}{AuditId: auditID})
	if err != nil {
		return nil, err
	}
	return convertAuditSingle(res)
}

// OrganizationVersions is the resolver for the organizationVersions field.
func (r *queryResolver) OrganizationVersions(ctx context.Context, code string, includeDeleted *bool) ([]model.Organization, error) {
	res, err := r.QueryResolver.OrganizationVersions(ctx, struct {
		Code           string
		IncludeDeleted *bool
	}{
		Code:           code,
		IncludeDeleted: includeDeleted,
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.Organization](res)
}

// JobFamilyGroups is the resolver for the jobFamilyGroups field.
func (r *queryResolver) JobFamilyGroups(ctx context.Context, includeInactive *bool, asOfDate *dto.Date) ([]model.JobFamilyGroup, error) {
	res, err := r.QueryResolver.JobFamilyGroups(ctx, struct {
		IncludeInactive *bool
		AsOfDate        *string
	}{
		IncludeInactive: includeInactive,
		AsOfDate:        dateToStringPtr(asOfDate),
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.JobFamilyGroup](res)
}

// JobFamilies is the resolver for the jobFamilies field.
func (r *queryResolver) JobFamilies(ctx context.Context, groupCode dto.JobFamilyGroupCode, includeInactive *bool, asOfDate *dto.Date) ([]model.JobFamily, error) {
	res, err := r.QueryResolver.JobFamilies(ctx, struct {
		GroupCode       string
		IncludeInactive *bool
		AsOfDate        *string
	}{
		GroupCode:       scalarToString(groupCode),
		IncludeInactive: includeInactive,
		AsOfDate:        dateToStringPtr(asOfDate),
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.JobFamily](res)
}

// JobRoles is the resolver for the jobRoles field.
func (r *queryResolver) JobRoles(ctx context.Context, familyCode dto.JobFamilyCode, includeInactive *bool, asOfDate *dto.Date) ([]model.JobRole, error) {
	res, err := r.QueryResolver.JobRoles(ctx, struct {
		FamilyCode      string
		IncludeInactive *bool
		AsOfDate        *string
	}{
		FamilyCode:      scalarToString(familyCode),
		IncludeInactive: includeInactive,
		AsOfDate:        dateToStringPtr(asOfDate),
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.JobRole](res)
}

// JobLevels is the resolver for the jobLevels field.
func (r *queryResolver) JobLevels(ctx context.Context, roleCode dto.JobRoleCode, includeInactive *bool, asOfDate *dto.Date) ([]model.JobLevel, error) {
	res, err := r.QueryResolver.JobLevels(ctx, struct {
		RoleCode        string
		IncludeInactive *bool
		AsOfDate        *string
	}{
		RoleCode:        scalarToString(roleCode),
		IncludeInactive: includeInactive,
		AsOfDate:        dateToStringPtr(asOfDate),
	})
	if err != nil {
		return nil, err
	}
	return convertSlice[model.JobLevel](res)
}

// Query returns graphqlruntime.QueryResolver implementation.
func (r *Resolver) Query() graphqlruntime.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
