// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphqlruntime

import (
	"bytes"
	"context"
	"cube-castle/cmd/hrms-server/query/internal/graphql/model"
	"cube-castle/internal/organization/dto"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AssignmentStats struct {
		ActingAssignments    func(childComplexity int) int
		ActiveAssignments    func(childComplexity int) int
		EndedAssignments     func(childComplexity int) int
		LastUpdatedAt        func(childComplexity int) int
		OrganizationCode     func(childComplexity int) int
		PendingAssignments   func(childComplexity int) int
		PositionCode         func(childComplexity int) int
		PrimaryAssignments   func(childComplexity int) int
		SecondaryAssignments func(childComplexity int) int
		TotalAssignments     func(childComplexity int) int
	}

	AuditLogDetail struct {
		AfterData       func(childComplexity int) int
		AuditID         func(childComplexity int) int
		BeforeData      func(childComplexity int) int
		Changes         func(childComplexity int) int
		ModifiedFields  func(childComplexity int) int
		Operation       func(childComplexity int) int
		OperationReason func(childComplexity int) int
		RecordID        func(childComplexity int) int
		Timestamp       func(childComplexity int) int
	}

	CacheInconsistency struct {
		CachedValue     func(childComplexity int) int
		CalculatedValue func(childComplexity int) int
		Code            func(childComplexity int) int
		FieldName       func(childComplexity int) int
		ImpactLevel     func(childComplexity int) int
	}

	CircularReference struct {
		AffectedCodes func(childComplexity int) int
		CircularPath  func(childComplexity int) int
		Severity      func(childComplexity int) int
	}

	ConsistencyFindings struct {
		CacheInconsistencies func(childComplexity int) int
		CircularReferences   func(childComplexity int) int
		DepthViolations      func(childComplexity int) int
		LevelInconsistencies func(childComplexity int) int
		OrphanedNodes        func(childComplexity int) int
		PathMismatches       func(childComplexity int) int
	}

	DataChanges struct {
		AfterData      func(childComplexity int) int
		BeforeData     func(childComplexity int) int
		ModifiedFields func(childComplexity int) int
	}

	DateRange struct {
		Earliest func(childComplexity int) int
		Latest   func(childComplexity int) int
	}

	DepthDistribution struct {
		Count func(childComplexity int) int
		Depth func(childComplexity int) int
	}

	DepthViolation struct {
		Code            func(childComplexity int) int
		CurrentDepth    func(childComplexity int) int
		MaxAllowedDepth func(childComplexity int) int
		ParentChain     func(childComplexity int) int
	}

	FamilyHeadcount struct {
		Available     func(childComplexity int) int
		Capacity      func(childComplexity int) int
		JobFamilyCode func(childComplexity int) int
		JobFamilyName func(childComplexity int) int
		Utilized      func(childComplexity int) int
	}

	FieldChange struct {
		DataType func(childComplexity int) int
		Field    func(childComplexity int) int
		NewValue func(childComplexity int) int
		OldValue func(childComplexity int) int
	}

	HeadcountStats struct {
		ByFamily         func(childComplexity int) int
		ByLevel          func(childComplexity int) int
		ByType           func(childComplexity int) int
		FillRate         func(childComplexity int) int
		OrganizationCode func(childComplexity int) int
		OrganizationName func(childComplexity int) int
		TotalAvailable   func(childComplexity int) int
		TotalCapacity    func(childComplexity int) int
		TotalFilled      func(childComplexity int) int
	}

	HierarchyConsistencyReport struct {
		CheckID            func(childComplexity int) int
		CheckMode          func(childComplexity int) int
		ConsistencyReport  func(childComplexity int) int
		ExecutedAt         func(childComplexity int) int
		ExecutionTimeMs    func(childComplexity int) int
		HealthScore        func(childComplexity int) int
		IssuesFound        func(childComplexity int) int
		RecommendedActions func(childComplexity int) int
		RepairSuggestions  func(childComplexity int) int
		TenantID           func(childComplexity int) int
		TotalChecked       func(childComplexity int) int
	}

	HierarchyStatistics struct {
		AvgDepth           func(childComplexity int) int
		DepthDistribution  func(childComplexity int) int
		IntegrityIssues    func(childComplexity int) int
		LastAnalyzed       func(childComplexity int) int
		LeafOrganizations  func(childComplexity int) int
		MaxDepth           func(childComplexity int) int
		RootOrganizations  func(childComplexity int) int
		TenantID           func(childComplexity int) int
		TotalOrganizations func(childComplexity int) int
	}

	IntegrityIssue struct {
		AffectedCodes func(childComplexity int) int
		Count         func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	JobFamily struct {
		Code          func(childComplexity int) int
		Description   func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		EndDate       func(childComplexity int) int
		GroupCode     func(childComplexity int) int
		Name          func(childComplexity int) int
		RecordID      func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	JobFamilyGroup struct {
		Code          func(childComplexity int) int
		Description   func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		EndDate       func(childComplexity int) int
		Name          func(childComplexity int) int
		RecordID      func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	JobLevel struct {
		Code          func(childComplexity int) int
		Description   func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		EndDate       func(childComplexity int) int
		LevelRank     func(childComplexity int) int
		Name          func(childComplexity int) int
		RecordID      func(childComplexity int) int
		RoleCode      func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	JobRole struct {
		Code          func(childComplexity int) int
		Description   func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		EndDate       func(childComplexity int) int
		FamilyCode    func(childComplexity int) int
		Name          func(childComplexity int) int
		RecordID      func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	LevelHeadcount struct {
		Available    func(childComplexity int) int
		Capacity     func(childComplexity int) int
		JobLevelCode func(childComplexity int) int
		Utilized     func(childComplexity int) int
	}

	LevelInconsistency struct {
		ActualLevel   func(childComplexity int) int
		Code          func(childComplexity int) int
		ExpectedLevel func(childComplexity int) int
		ParentCode    func(childComplexity int) int
		Reason        func(childComplexity int) int
	}

	LevelStatistic struct {
		Count func(childComplexity int) int
		Level func(childComplexity int) int
	}

	OperatedBy struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	OperationsSummary struct {
		Create     func(childComplexity int) int
		Delete     func(childComplexity int) int
		Reactivate func(childComplexity int) int
		Suspend    func(childComplexity int) int
		Update     func(childComplexity int) int
	}

	Organization struct {
		ChangeReason     func(childComplexity int) int
		ChildrenCount    func(childComplexity int) int
		Code             func(childComplexity int) int
		CodePath         func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DeletedAt        func(childComplexity int) int
		DeletedBy        func(childComplexity int) int
		DeletionReason   func(childComplexity int) int
		Description      func(childComplexity int) int
		EffectiveDate    func(childComplexity int) int
		EndDate          func(childComplexity int) int
		HierarchyDepth   func(childComplexity int) int
		IsCurrent        func(childComplexity int) int
		IsFuture         func(childComplexity int) int
		IsTemporal       func(childComplexity int) int
		Level            func(childComplexity int) int
		Name             func(childComplexity int) int
		NamePath         func(childComplexity int) int
		ParentCode       func(childComplexity int) int
		Path             func(childComplexity int) int
		Profile          func(childComplexity int) int
		RecordID         func(childComplexity int) int
		SortOrder        func(childComplexity int) int
		Status           func(childComplexity int) int
		SuspendedAt      func(childComplexity int) int
		SuspendedBy      func(childComplexity int) int
		SuspensionReason func(childComplexity int) int
		TenantID         func(childComplexity int) int
		UnitType         func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	OrganizationConnection struct {
		Data       func(childComplexity int) int
		Pagination func(childComplexity int) int
		Temporal   func(childComplexity int) int
	}

	OrganizationHierarchy struct {
		Children       func(childComplexity int) int
		ChildrenCount  func(childComplexity int) int
		Code           func(childComplexity int) int
		CodePath       func(childComplexity int) int
		HierarchyDepth func(childComplexity int) int
		IsLeaf         func(childComplexity int) int
		IsRoot         func(childComplexity int) int
		Level          func(childComplexity int) int
		Name           func(childComplexity int) int
		NamePath       func(childComplexity int) int
		ParentChain    func(childComplexity int) int
	}

	OrganizationStats struct {
		ActiveCount   func(childComplexity int) int
		ByLevel       func(childComplexity int) int
		ByStatus      func(childComplexity int) int
		ByType        func(childComplexity int) int
		DeletedCount  func(childComplexity int) int
		InactiveCount func(childComplexity int) int
		PlannedCount  func(childComplexity int) int
		TemporalStats func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	OrphanedNode struct {
		Code       func(childComplexity int) int
		Name       func(childComplexity int) int
		ParentCode func(childComplexity int) int
		Reason     func(childComplexity int) int
	}

	PaginationInfo struct {
		HasNext     func(childComplexity int) int
		HasPrevious func(childComplexity int) int
		Page        func(childComplexity int) int
		PageSize    func(childComplexity int) int
		Total       func(childComplexity int) int
	}

	PathMismatch struct {
		ActualCodePath   func(childComplexity int) int
		ActualNamePath   func(childComplexity int) int
		Code             func(childComplexity int) int
		ExpectedCodePath func(childComplexity int) int
		ExpectedNamePath func(childComplexity int) int
		Severity         func(childComplexity int) int
	}

	Position struct {
		AssignmentHistory     func(childComplexity int) int
		AvailableHeadcount    func(childComplexity int) int
		Code                  func(childComplexity int) int
		CreatedAt             func(childComplexity int) int
		CurrentAssignment     func(childComplexity int) int
		EffectiveDate         func(childComplexity int) int
		EmploymentType        func(childComplexity int) int
		EndDate               func(childComplexity int) int
		GradeLevel            func(childComplexity int) int
		HeadcountCapacity     func(childComplexity int) int
		HeadcountInUse        func(childComplexity int) int
		IsCurrent             func(childComplexity int) int
		IsFuture              func(childComplexity int) int
		JobFamilyCode         func(childComplexity int) int
		JobFamilyGroupCode    func(childComplexity int) int
		JobLevelCode          func(childComplexity int) int
		JobProfileCode        func(childComplexity int) int
		JobProfileName        func(childComplexity int) int
		JobRoleCode           func(childComplexity int) int
		OrganizationCode      func(childComplexity int) int
		OrganizationName      func(childComplexity int) int
		PositionType          func(childComplexity int) int
		RecordID              func(childComplexity int) int
		ReportsToPositionCode func(childComplexity int) int
		Status                func(childComplexity int) int
		TenantID              func(childComplexity int) int
		Title                 func(childComplexity int) int
		UpdatedAt             func(childComplexity int) int
	}

	PositionAssignment struct {
		ActingUntil      func(childComplexity int) int
		AssignmentID     func(childComplexity int) int
		AssignmentStatus func(childComplexity int) int
		AssignmentType   func(childComplexity int) int
		AutoRevert       func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		EffectiveDate    func(childComplexity int) int
		EmployeeID       func(childComplexity int) int
		EmployeeName     func(childComplexity int) int
		EmployeeNumber   func(childComplexity int) int
		EndDate          func(childComplexity int) int
		Fte              func(childComplexity int) int
		IsCurrent        func(childComplexity int) int
		Notes            func(childComplexity int) int
		PositionCode     func(childComplexity int) int
		PositionRecordID func(childComplexity int) int
		ReminderSentAt   func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	PositionAssignmentAudit struct {
		Actor         func(childComplexity int) int
		AssignmentID  func(childComplexity int) int
		Changes       func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		EndDate       func(childComplexity int) int
		EventType     func(childComplexity int) int
	}

	PositionAssignmentAuditConnection struct {
		Data       func(childComplexity int) int
		Pagination func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PositionAssignmentConnection struct {
		Data       func(childComplexity int) int
		Edges      func(childComplexity int) int
		Pagination func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PositionAssignmentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PositionConnection struct {
		Data       func(childComplexity int) int
		Edges      func(childComplexity int) int
		Pagination func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PositionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PositionTimelineEntry struct {
		AssignmentStatus func(childComplexity int) int
		AssignmentType   func(childComplexity int) int
		ChangeReason     func(childComplexity int) int
		EffectiveDate    func(childComplexity int) int
		EndDate          func(childComplexity int) int
		IsCurrent        func(childComplexity int) int
		RecordID         func(childComplexity int) int
		Status           func(childComplexity int) int
		TimelineCategory func(childComplexity int) int
		Title            func(childComplexity int) int
	}

	PositionTransfer struct {
		CreatedAt            func(childComplexity int) int
		EffectiveDate        func(childComplexity int) int
		FromOrganizationCode func(childComplexity int) int
		InitiatedBy          func(childComplexity int) int
		OperationReason      func(childComplexity int) int
		PositionCode         func(childComplexity int) int
		ToOrganizationCode   func(childComplexity int) int
		TransferID           func(childComplexity int) int
	}

	PositionTransferConnection struct {
		Data       func(childComplexity int) int
		Edges      func(childComplexity int) int
		Pagination func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PositionTransferEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		AssignmentHistory       func(childComplexity int, positionCode dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) int
		AssignmentStats         func(childComplexity int, organizationCode *string, positionCode *dto.PositionCode) int
		Assignments             func(childComplexity int, organizationCode *string, positionCode *dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) int
		AuditHistory            func(childComplexity int, recordID string, startDate *string, endDate *string, operation *model.OperationType, userID *string, limit *int) int
		AuditLog                func(childComplexity int, auditID string) int
		HierarchyStatistics     func(childComplexity int, tenantID string, includeIntegrityCheck *bool) int
		JobFamilies             func(childComplexity int, groupCode dto.JobFamilyGroupCode, includeInactive *bool, asOfDate *dto.Date) int
		JobFamilyGroups         func(childComplexity int, includeInactive *bool, asOfDate *dto.Date) int
		JobLevels               func(childComplexity int, roleCode dto.JobRoleCode, includeInactive *bool, asOfDate *dto.Date) int
		JobRoles                func(childComplexity int, familyCode dto.JobFamilyCode, includeInactive *bool, asOfDate *dto.Date) int
		Organization            func(childComplexity int, code string, asOfDate *string) int
		OrganizationHierarchy   func(childComplexity int, code string, tenantID string) int
		OrganizationStats       func(childComplexity int, asOfDate *string, includeHistorical *bool) int
		OrganizationSubtree     func(childComplexity int, code string, tenantID string, maxDepth *int, includeInactive *bool) int
		OrganizationVersions    func(childComplexity int, code string, includeDeleted *bool) int
		Organizations           func(childComplexity int, filter *model.OrganizationFilter, pagination *model.PaginationInput) int
		Position                func(childComplexity int, code dto.PositionCode, asOfDate *dto.Date) int
		PositionAssignmentAudit func(childComplexity int, positionCode dto.PositionCode, assignmentID *dto.UUID, dateRange *model.DateRangeInput, pagination *model.PaginationInput) int
		PositionAssignments     func(childComplexity int, positionCode dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) int
		PositionHeadcountStats  func(childComplexity int, organizationCode string, includeSubordinates *bool) int
		PositionTimeline        func(childComplexity int, code dto.PositionCode, startDate *dto.Date, endDate *dto.Date) int
		PositionTransfers       func(childComplexity int, positionCode *dto.PositionCode, organizationCode *string, pagination *model.PaginationInput) int
		PositionVersions        func(childComplexity int, code dto.PositionCode, includeDeleted *bool) int
		Positions               func(childComplexity int, filter *model.PositionFilterInput, pagination *model.PaginationInput, sorting []model.PositionSortInput) int
		VacantPositions         func(childComplexity int, filter *model.VacantPositionFilterInput, pagination *model.PaginationInput, sorting []model.VacantPositionSortInput) int
	}

	RepairSuggestion struct {
		AffectedCodes   func(childComplexity int) int
		Automatable     func(childComplexity int) int
		IssueType       func(childComplexity int) int
		RiskLevel       func(childComplexity int) int
		SuggestedAction func(childComplexity int) int
	}

	StatusStatistic struct {
		Count  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	TemporalInfo struct {
		AsOfDate        func(childComplexity int) int
		CurrentCount    func(childComplexity int) int
		FutureCount     func(childComplexity int) int
		HistoricalCount func(childComplexity int) int
	}

	TemporalStatistics struct {
		AverageVersionsPerOrg func(childComplexity int) int
		NewestEffectiveDate   func(childComplexity int) int
		OldestEffectiveDate   func(childComplexity int) int
		TotalVersions         func(childComplexity int) int
	}

	TypeHeadcount struct {
		Available    func(childComplexity int) int
		Capacity     func(childComplexity int) int
		Filled       func(childComplexity int) int
		PositionType func(childComplexity int) int
	}

	TypeStatistic struct {
		Count    func(childComplexity int) int
		UnitType func(childComplexity int) int
	}

	UserInfo struct {
		Role     func(childComplexity int) int
		UserID   func(childComplexity int) int
		UserName func(childComplexity int) int
	}

	VacantPosition struct {
		HeadcountAvailable func(childComplexity int) int
		HeadcountCapacity  func(childComplexity int) int
		JobFamilyCode      func(childComplexity int) int
		JobLevelCode       func(childComplexity int) int
		JobRoleCode        func(childComplexity int) int
		OrganizationCode   func(childComplexity int) int
		OrganizationName   func(childComplexity int) int
		PositionCode       func(childComplexity int) int
		TotalAssignments   func(childComplexity int) int
		VacantSince        func(childComplexity int) int
	}

	VacantPositionConnection struct {
		Data       func(childComplexity int) int
		Edges      func(childComplexity int) int
		Pagination func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	VacantPositionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type QueryResolver interface {
	Organizations(ctx context.Context, filter *model.OrganizationFilter, pagination *model.PaginationInput) (*model.OrganizationConnection, error)
	Organization(ctx context.Context, code string, asOfDate *string) (*model.Organization, error)
	OrganizationStats(ctx context.Context, asOfDate *string, includeHistorical *bool) (*model.OrganizationStats, error)
	OrganizationHierarchy(ctx context.Context, code string, tenantID string) (*model.OrganizationHierarchy, error)
	OrganizationSubtree(ctx context.Context, code string, tenantID string, maxDepth *int, includeInactive *bool) ([]model.OrganizationHierarchy, error)
	HierarchyStatistics(ctx context.Context, tenantID string, includeIntegrityCheck *bool) (*model.HierarchyStatistics, error)
	Positions(ctx context.Context, filter *model.PositionFilterInput, pagination *model.PaginationInput, sorting []model.PositionSortInput) (*model.PositionConnection, error)
	Position(ctx context.Context, code dto.PositionCode, asOfDate *dto.Date) (*model.Position, error)
	PositionTimeline(ctx context.Context, code dto.PositionCode, startDate *dto.Date, endDate *dto.Date) ([]model.PositionTimelineEntry, error)
	PositionVersions(ctx context.Context, code dto.PositionCode, includeDeleted *bool) ([]model.Position, error)
	PositionAssignments(ctx context.Context, positionCode dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) (*model.PositionAssignmentConnection, error)
	PositionAssignmentAudit(ctx context.Context, positionCode dto.PositionCode, assignmentID *dto.UUID, dateRange *model.DateRangeInput, pagination *model.PaginationInput) (*model.PositionAssignmentAuditConnection, error)
	Assignments(ctx context.Context, organizationCode *string, positionCode *dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) (*model.PositionAssignmentConnection, error)
	AssignmentHistory(ctx context.Context, positionCode dto.PositionCode, filter *model.PositionAssignmentFilterInput, pagination *model.PaginationInput, sorting []model.PositionAssignmentSortInput) (*model.PositionAssignmentConnection, error)
	AssignmentStats(ctx context.Context, organizationCode *string, positionCode *dto.PositionCode) (*model.AssignmentStats, error)
	VacantPositions(ctx context.Context, filter *model.VacantPositionFilterInput, pagination *model.PaginationInput, sorting []model.VacantPositionSortInput) (*model.VacantPositionConnection, error)
	PositionTransfers(ctx context.Context, positionCode *dto.PositionCode, organizationCode *string, pagination *model.PaginationInput) (*model.PositionTransferConnection, error)
	PositionHeadcountStats(ctx context.Context, organizationCode string, includeSubordinates *bool) (*model.HeadcountStats, error)
	AuditHistory(ctx context.Context, recordID string, startDate *string, endDate *string, operation *model.OperationType, userID *string, limit *int) ([]model.AuditLogDetail, error)
	AuditLog(ctx context.Context, auditID string) (*model.AuditLogDetail, error)
	OrganizationVersions(ctx context.Context, code string, includeDeleted *bool) ([]model.Organization, error)
	JobFamilyGroups(ctx context.Context, includeInactive *bool, asOfDate *dto.Date) ([]model.JobFamilyGroup, error)
	JobFamilies(ctx context.Context, groupCode dto.JobFamilyGroupCode, includeInactive *bool, asOfDate *dto.Date) ([]model.JobFamily, error)
	JobRoles(ctx context.Context, familyCode dto.JobFamilyCode, includeInactive *bool, asOfDate *dto.Date) ([]model.JobRole, error)
	JobLevels(ctx context.Context, roleCode dto.JobRoleCode, includeInactive *bool, asOfDate *dto.Date) ([]model.JobLevel, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AssignmentStats.actingAssignments":
		if e.complexity.AssignmentStats.ActingAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.ActingAssignments(childComplexity), true

	case "AssignmentStats.activeAssignments":
		if e.complexity.AssignmentStats.ActiveAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.ActiveAssignments(childComplexity), true

	case "AssignmentStats.endedAssignments":
		if e.complexity.AssignmentStats.EndedAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.EndedAssignments(childComplexity), true

	case "AssignmentStats.lastUpdatedAt":
		if e.complexity.AssignmentStats.LastUpdatedAt == nil {
			break
		}

		return e.complexity.AssignmentStats.LastUpdatedAt(childComplexity), true

	case "AssignmentStats.organizationCode":
		if e.complexity.AssignmentStats.OrganizationCode == nil {
			break
		}

		return e.complexity.AssignmentStats.OrganizationCode(childComplexity), true

	case "AssignmentStats.pendingAssignments":
		if e.complexity.AssignmentStats.PendingAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.PendingAssignments(childComplexity), true

	case "AssignmentStats.positionCode":
		if e.complexity.AssignmentStats.PositionCode == nil {
			break
		}

		return e.complexity.AssignmentStats.PositionCode(childComplexity), true

	case "AssignmentStats.primaryAssignments":
		if e.complexity.AssignmentStats.PrimaryAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.PrimaryAssignments(childComplexity), true

	case "AssignmentStats.secondaryAssignments":
		if e.complexity.AssignmentStats.SecondaryAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.SecondaryAssignments(childComplexity), true

	case "AssignmentStats.totalAssignments":
		if e.complexity.AssignmentStats.TotalAssignments == nil {
			break
		}

		return e.complexity.AssignmentStats.TotalAssignments(childComplexity), true

	case "AuditLogDetail.afterData":
		if e.complexity.AuditLogDetail.AfterData == nil {
			break
		}

		return e.complexity.AuditLogDetail.AfterData(childComplexity), true

	case "AuditLogDetail.auditId":
		if e.complexity.AuditLogDetail.AuditID == nil {
			break
		}

		return e.complexity.AuditLogDetail.AuditID(childComplexity), true

	case "AuditLogDetail.beforeData":
		if e.complexity.AuditLogDetail.BeforeData == nil {
			break
		}

		return e.complexity.AuditLogDetail.BeforeData(childComplexity), true

	case "AuditLogDetail.changes":
		if e.complexity.AuditLogDetail.Changes == nil {
			break
		}

		return e.complexity.AuditLogDetail.Changes(childComplexity), true

	case "AuditLogDetail.modifiedFields":
		if e.complexity.AuditLogDetail.ModifiedFields == nil {
			break
		}

		return e.complexity.AuditLogDetail.ModifiedFields(childComplexity), true

	case "AuditLogDetail.operation":
		if e.complexity.AuditLogDetail.Operation == nil {
			break
		}

		return e.complexity.AuditLogDetail.Operation(childComplexity), true

	case "AuditLogDetail.operationReason":
		if e.complexity.AuditLogDetail.OperationReason == nil {
			break
		}

		return e.complexity.AuditLogDetail.OperationReason(childComplexity), true

	case "AuditLogDetail.recordId":
		if e.complexity.AuditLogDetail.RecordID == nil {
			break
		}

		return e.complexity.AuditLogDetail.RecordID(childComplexity), true

	case "AuditLogDetail.timestamp":
		if e.complexity.AuditLogDetail.Timestamp == nil {
			break
		}

		return e.complexity.AuditLogDetail.Timestamp(childComplexity), true

	case "CacheInconsistency.cachedValue":
		if e.complexity.CacheInconsistency.CachedValue == nil {
			break
		}

		return e.complexity.CacheInconsistency.CachedValue(childComplexity), true

	case "CacheInconsistency.calculatedValue":
		if e.complexity.CacheInconsistency.CalculatedValue == nil {
			break
		}

		return e.complexity.CacheInconsistency.CalculatedValue(childComplexity), true

	case "CacheInconsistency.code":
		if e.complexity.CacheInconsistency.Code == nil {
			break
		}

		return e.complexity.CacheInconsistency.Code(childComplexity), true

	case "CacheInconsistency.fieldName":
		if e.complexity.CacheInconsistency.FieldName == nil {
			break
		}

		return e.complexity.CacheInconsistency.FieldName(childComplexity), true

	case "CacheInconsistency.impactLevel":
		if e.complexity.CacheInconsistency.ImpactLevel == nil {
			break
		}

		return e.complexity.CacheInconsistency.ImpactLevel(childComplexity), true

	case "CircularReference.affectedCodes":
		if e.complexity.CircularReference.AffectedCodes == nil {
			break
		}

		return e.complexity.CircularReference.AffectedCodes(childComplexity), true

	case "CircularReference.circularPath":
		if e.complexity.CircularReference.CircularPath == nil {
			break
		}

		return e.complexity.CircularReference.CircularPath(childComplexity), true

	case "CircularReference.severity":
		if e.complexity.CircularReference.Severity == nil {
			break
		}

		return e.complexity.CircularReference.Severity(childComplexity), true

	case "ConsistencyFindings.cacheInconsistencies":
		if e.complexity.ConsistencyFindings.CacheInconsistencies == nil {
			break
		}

		return e.complexity.ConsistencyFindings.CacheInconsistencies(childComplexity), true

	case "ConsistencyFindings.circularReferences":
		if e.complexity.ConsistencyFindings.CircularReferences == nil {
			break
		}

		return e.complexity.ConsistencyFindings.CircularReferences(childComplexity), true

	case "ConsistencyFindings.depthViolations":
		if e.complexity.ConsistencyFindings.DepthViolations == nil {
			break
		}

		return e.complexity.ConsistencyFindings.DepthViolations(childComplexity), true

	case "ConsistencyFindings.levelInconsistencies":
		if e.complexity.ConsistencyFindings.LevelInconsistencies == nil {
			break
		}

		return e.complexity.ConsistencyFindings.LevelInconsistencies(childComplexity), true

	case "ConsistencyFindings.orphanedNodes":
		if e.complexity.ConsistencyFindings.OrphanedNodes == nil {
			break
		}

		return e.complexity.ConsistencyFindings.OrphanedNodes(childComplexity), true

	case "ConsistencyFindings.pathMismatches":
		if e.complexity.ConsistencyFindings.PathMismatches == nil {
			break
		}

		return e.complexity.ConsistencyFindings.PathMismatches(childComplexity), true

	case "DataChanges.afterData":
		if e.complexity.DataChanges.AfterData == nil {
			break
		}

		return e.complexity.DataChanges.AfterData(childComplexity), true

	case "DataChanges.beforeData":
		if e.complexity.DataChanges.BeforeData == nil {
			break
		}

		return e.complexity.DataChanges.BeforeData(childComplexity), true

	case "DataChanges.modifiedFields":
		if e.complexity.DataChanges.ModifiedFields == nil {
			break
		}

		return e.complexity.DataChanges.ModifiedFields(childComplexity), true

	case "DateRange.earliest":
		if e.complexity.DateRange.Earliest == nil {
			break
		}

		return e.complexity.DateRange.Earliest(childComplexity), true

	case "DateRange.latest":
		if e.complexity.DateRange.Latest == nil {
			break
		}

		return e.complexity.DateRange.Latest(childComplexity), true

	case "DepthDistribution.count":
		if e.complexity.DepthDistribution.Count == nil {
			break
		}

		return e.complexity.DepthDistribution.Count(childComplexity), true

	case "DepthDistribution.depth":
		if e.complexity.DepthDistribution.Depth == nil {
			break
		}

		return e.complexity.DepthDistribution.Depth(childComplexity), true

	case "DepthViolation.code":
		if e.complexity.DepthViolation.Code == nil {
			break
		}

		return e.complexity.DepthViolation.Code(childComplexity), true

	case "DepthViolation.currentDepth":
		if e.complexity.DepthViolation.CurrentDepth == nil {
			break
		}

		return e.complexity.DepthViolation.CurrentDepth(childComplexity), true

	case "DepthViolation.maxAllowedDepth":
		if e.complexity.DepthViolation.MaxAllowedDepth == nil {
			break
		}

		return e.complexity.DepthViolation.MaxAllowedDepth(childComplexity), true

	case "DepthViolation.parentChain":
		if e.complexity.DepthViolation.ParentChain == nil {
			break
		}

		return e.complexity.DepthViolation.ParentChain(childComplexity), true

	case "FamilyHeadcount.available":
		if e.complexity.FamilyHeadcount.Available == nil {
			break
		}

		return e.complexity.FamilyHeadcount.Available(childComplexity), true

	case "FamilyHeadcount.capacity":
		if e.complexity.FamilyHeadcount.Capacity == nil {
			break
		}

		return e.complexity.FamilyHeadcount.Capacity(childComplexity), true

	case "FamilyHeadcount.jobFamilyCode":
		if e.complexity.FamilyHeadcount.JobFamilyCode == nil {
			break
		}

		return e.complexity.FamilyHeadcount.JobFamilyCode(childComplexity), true

	case "FamilyHeadcount.jobFamilyName":
		if e.complexity.FamilyHeadcount.JobFamilyName == nil {
			break
		}

		return e.complexity.FamilyHeadcount.JobFamilyName(childComplexity), true

	case "FamilyHeadcount.utilized":
		if e.complexity.FamilyHeadcount.Utilized == nil {
			break
		}

		return e.complexity.FamilyHeadcount.Utilized(childComplexity), true

	case "FieldChange.dataType":
		if e.complexity.FieldChange.DataType == nil {
			break
		}

		return e.complexity.FieldChange.DataType(childComplexity), true

	case "FieldChange.field":
		if e.complexity.FieldChange.Field == nil {
			break
		}

		return e.complexity.FieldChange.Field(childComplexity), true

	case "FieldChange.newValue":
		if e.complexity.FieldChange.NewValue == nil {
			break
		}

		return e.complexity.FieldChange.NewValue(childComplexity), true

	case "FieldChange.oldValue":
		if e.complexity.FieldChange.OldValue == nil {
			break
		}

		return e.complexity.FieldChange.OldValue(childComplexity), true

	case "HeadcountStats.byFamily":
		if e.complexity.HeadcountStats.ByFamily == nil {
			break
		}

		return e.complexity.HeadcountStats.ByFamily(childComplexity), true

	case "HeadcountStats.byLevel":
		if e.complexity.HeadcountStats.ByLevel == nil {
			break
		}

		return e.complexity.HeadcountStats.ByLevel(childComplexity), true

	case "HeadcountStats.byType":
		if e.complexity.HeadcountStats.ByType == nil {
			break
		}

		return e.complexity.HeadcountStats.ByType(childComplexity), true

	case "HeadcountStats.fillRate":
		if e.complexity.HeadcountStats.FillRate == nil {
			break
		}

		return e.complexity.HeadcountStats.FillRate(childComplexity), true

	case "HeadcountStats.organizationCode":
		if e.complexity.HeadcountStats.OrganizationCode == nil {
			break
		}

		return e.complexity.HeadcountStats.OrganizationCode(childComplexity), true

	case "HeadcountStats.organizationName":
		if e.complexity.HeadcountStats.OrganizationName == nil {
			break
		}

		return e.complexity.HeadcountStats.OrganizationName(childComplexity), true

	case "HeadcountStats.totalAvailable":
		if e.complexity.HeadcountStats.TotalAvailable == nil {
			break
		}

		return e.complexity.HeadcountStats.TotalAvailable(childComplexity), true

	case "HeadcountStats.totalCapacity":
		if e.complexity.HeadcountStats.TotalCapacity == nil {
			break
		}

		return e.complexity.HeadcountStats.TotalCapacity(childComplexity), true

	case "HeadcountStats.totalFilled":
		if e.complexity.HeadcountStats.TotalFilled == nil {
			break
		}

		return e.complexity.HeadcountStats.TotalFilled(childComplexity), true

	case "HierarchyConsistencyReport.checkId":
		if e.complexity.HierarchyConsistencyReport.CheckID == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.CheckID(childComplexity), true

	case "HierarchyConsistencyReport.checkMode":
		if e.complexity.HierarchyConsistencyReport.CheckMode == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.CheckMode(childComplexity), true

	case "HierarchyConsistencyReport.consistencyReport":
		if e.complexity.HierarchyConsistencyReport.ConsistencyReport == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.ConsistencyReport(childComplexity), true

	case "HierarchyConsistencyReport.executedAt":
		if e.complexity.HierarchyConsistencyReport.ExecutedAt == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.ExecutedAt(childComplexity), true

	case "HierarchyConsistencyReport.executionTimeMs":
		if e.complexity.HierarchyConsistencyReport.ExecutionTimeMs == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.ExecutionTimeMs(childComplexity), true

	case "HierarchyConsistencyReport.healthScore":
		if e.complexity.HierarchyConsistencyReport.HealthScore == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.HealthScore(childComplexity), true

	case "HierarchyConsistencyReport.issuesFound":
		if e.complexity.HierarchyConsistencyReport.IssuesFound == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.IssuesFound(childComplexity), true

	case "HierarchyConsistencyReport.recommendedActions":
		if e.complexity.HierarchyConsistencyReport.RecommendedActions == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.RecommendedActions(childComplexity), true

	case "HierarchyConsistencyReport.repairSuggestions":
		if e.complexity.HierarchyConsistencyReport.RepairSuggestions == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.RepairSuggestions(childComplexity), true

	case "HierarchyConsistencyReport.tenantId":
		if e.complexity.HierarchyConsistencyReport.TenantID == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.TenantID(childComplexity), true

	case "HierarchyConsistencyReport.totalChecked":
		if e.complexity.HierarchyConsistencyReport.TotalChecked == nil {
			break
		}

		return e.complexity.HierarchyConsistencyReport.TotalChecked(childComplexity), true

	case "HierarchyStatistics.avgDepth":
		if e.complexity.HierarchyStatistics.AvgDepth == nil {
			break
		}

		return e.complexity.HierarchyStatistics.AvgDepth(childComplexity), true

	case "HierarchyStatistics.depthDistribution":
		if e.complexity.HierarchyStatistics.DepthDistribution == nil {
			break
		}

		return e.complexity.HierarchyStatistics.DepthDistribution(childComplexity), true

	case "HierarchyStatistics.integrityIssues":
		if e.complexity.HierarchyStatistics.IntegrityIssues == nil {
			break
		}

		return e.complexity.HierarchyStatistics.IntegrityIssues(childComplexity), true

	case "HierarchyStatistics.lastAnalyzed":
		if e.complexity.HierarchyStatistics.LastAnalyzed == nil {
			break
		}

		return e.complexity.HierarchyStatistics.LastAnalyzed(childComplexity), true

	case "HierarchyStatistics.leafOrganizations":
		if e.complexity.HierarchyStatistics.LeafOrganizations == nil {
			break
		}

		return e.complexity.HierarchyStatistics.LeafOrganizations(childComplexity), true

	case "HierarchyStatistics.maxDepth":
		if e.complexity.HierarchyStatistics.MaxDepth == nil {
			break
		}

		return e.complexity.HierarchyStatistics.MaxDepth(childComplexity), true

	case "HierarchyStatistics.rootOrganizations":
		if e.complexity.HierarchyStatistics.RootOrganizations == nil {
			break
		}

		return e.complexity.HierarchyStatistics.RootOrganizations(childComplexity), true

	case "HierarchyStatistics.tenantId":
		if e.complexity.HierarchyStatistics.TenantID == nil {
			break
		}

		return e.complexity.HierarchyStatistics.TenantID(childComplexity), true

	case "HierarchyStatistics.totalOrganizations":
		if e.complexity.HierarchyStatistics.TotalOrganizations == nil {
			break
		}

		return e.complexity.HierarchyStatistics.TotalOrganizations(childComplexity), true

	case "IntegrityIssue.affectedCodes":
		if e.complexity.IntegrityIssue.AffectedCodes == nil {
			break
		}

		return e.complexity.IntegrityIssue.AffectedCodes(childComplexity), true

	case "IntegrityIssue.count":
		if e.complexity.IntegrityIssue.Count == nil {
			break
		}

		return e.complexity.IntegrityIssue.Count(childComplexity), true

	case "IntegrityIssue.type":
		if e.complexity.IntegrityIssue.Type == nil {
			break
		}

		return e.complexity.IntegrityIssue.Type(childComplexity), true

	case "JobFamily.code":
		if e.complexity.JobFamily.Code == nil {
			break
		}

		return e.complexity.JobFamily.Code(childComplexity), true

	case "JobFamily.description":
		if e.complexity.JobFamily.Description == nil {
			break
		}

		return e.complexity.JobFamily.Description(childComplexity), true

	case "JobFamily.effectiveDate":
		if e.complexity.JobFamily.EffectiveDate == nil {
			break
		}

		return e.complexity.JobFamily.EffectiveDate(childComplexity), true

	case "JobFamily.endDate":
		if e.complexity.JobFamily.EndDate == nil {
			break
		}

		return e.complexity.JobFamily.EndDate(childComplexity), true

	case "JobFamily.groupCode":
		if e.complexity.JobFamily.GroupCode == nil {
			break
		}

		return e.complexity.JobFamily.GroupCode(childComplexity), true

	case "JobFamily.name":
		if e.complexity.JobFamily.Name == nil {
			break
		}

		return e.complexity.JobFamily.Name(childComplexity), true

	case "JobFamily.recordId":
		if e.complexity.JobFamily.RecordID == nil {
			break
		}

		return e.complexity.JobFamily.RecordID(childComplexity), true

	case "JobFamily.status":
		if e.complexity.JobFamily.Status == nil {
			break
		}

		return e.complexity.JobFamily.Status(childComplexity), true

	case "JobFamilyGroup.code":
		if e.complexity.JobFamilyGroup.Code == nil {
			break
		}

		return e.complexity.JobFamilyGroup.Code(childComplexity), true

	case "JobFamilyGroup.description":
		if e.complexity.JobFamilyGroup.Description == nil {
			break
		}

		return e.complexity.JobFamilyGroup.Description(childComplexity), true

	case "JobFamilyGroup.effectiveDate":
		if e.complexity.JobFamilyGroup.EffectiveDate == nil {
			break
		}

		return e.complexity.JobFamilyGroup.EffectiveDate(childComplexity), true

	case "JobFamilyGroup.endDate":
		if e.complexity.JobFamilyGroup.EndDate == nil {
			break
		}

		return e.complexity.JobFamilyGroup.EndDate(childComplexity), true

	case "JobFamilyGroup.name":
		if e.complexity.JobFamilyGroup.Name == nil {
			break
		}

		return e.complexity.JobFamilyGroup.Name(childComplexity), true

	case "JobFamilyGroup.recordId":
		if e.complexity.JobFamilyGroup.RecordID == nil {
			break
		}

		return e.complexity.JobFamilyGroup.RecordID(childComplexity), true

	case "JobFamilyGroup.status":
		if e.complexity.JobFamilyGroup.Status == nil {
			break
		}

		return e.complexity.JobFamilyGroup.Status(childComplexity), true

	case "JobLevel.code":
		if e.complexity.JobLevel.Code == nil {
			break
		}

		return e.complexity.JobLevel.Code(childComplexity), true

	case "JobLevel.description":
		if e.complexity.JobLevel.Description == nil {
			break
		}

		return e.complexity.JobLevel.Description(childComplexity), true

	case "JobLevel.effectiveDate":
		if e.complexity.JobLevel.EffectiveDate == nil {
			break
		}

		return e.complexity.JobLevel.EffectiveDate(childComplexity), true

	case "JobLevel.endDate":
		if e.complexity.JobLevel.EndDate == nil {
			break
		}

		return e.complexity.JobLevel.EndDate(childComplexity), true

	case "JobLevel.levelRank":
		if e.complexity.JobLevel.LevelRank == nil {
			break
		}

		return e.complexity.JobLevel.LevelRank(childComplexity), true

	case "JobLevel.name":
		if e.complexity.JobLevel.Name == nil {
			break
		}

		return e.complexity.JobLevel.Name(childComplexity), true

	case "JobLevel.recordId":
		if e.complexity.JobLevel.RecordID == nil {
			break
		}

		return e.complexity.JobLevel.RecordID(childComplexity), true

	case "JobLevel.roleCode":
		if e.complexity.JobLevel.RoleCode == nil {
			break
		}

		return e.complexity.JobLevel.RoleCode(childComplexity), true

	case "JobLevel.status":
		if e.complexity.JobLevel.Status == nil {
			break
		}

		return e.complexity.JobLevel.Status(childComplexity), true

	case "JobRole.code":
		if e.complexity.JobRole.Code == nil {
			break
		}

		return e.complexity.JobRole.Code(childComplexity), true

	case "JobRole.description":
		if e.complexity.JobRole.Description == nil {
			break
		}

		return e.complexity.JobRole.Description(childComplexity), true

	case "JobRole.effectiveDate":
		if e.complexity.JobRole.EffectiveDate == nil {
			break
		}

		return e.complexity.JobRole.EffectiveDate(childComplexity), true

	case "JobRole.endDate":
		if e.complexity.JobRole.EndDate == nil {
			break
		}

		return e.complexity.JobRole.EndDate(childComplexity), true

	case "JobRole.familyCode":
		if e.complexity.JobRole.FamilyCode == nil {
			break
		}

		return e.complexity.JobRole.FamilyCode(childComplexity), true

	case "JobRole.name":
		if e.complexity.JobRole.Name == nil {
			break
		}

		return e.complexity.JobRole.Name(childComplexity), true

	case "JobRole.recordId":
		if e.complexity.JobRole.RecordID == nil {
			break
		}

		return e.complexity.JobRole.RecordID(childComplexity), true

	case "JobRole.status":
		if e.complexity.JobRole.Status == nil {
			break
		}

		return e.complexity.JobRole.Status(childComplexity), true

	case "LevelHeadcount.available":
		if e.complexity.LevelHeadcount.Available == nil {
			break
		}

		return e.complexity.LevelHeadcount.Available(childComplexity), true

	case "LevelHeadcount.capacity":
		if e.complexity.LevelHeadcount.Capacity == nil {
			break
		}

		return e.complexity.LevelHeadcount.Capacity(childComplexity), true

	case "LevelHeadcount.jobLevelCode":
		if e.complexity.LevelHeadcount.JobLevelCode == nil {
			break
		}

		return e.complexity.LevelHeadcount.JobLevelCode(childComplexity), true

	case "LevelHeadcount.utilized":
		if e.complexity.LevelHeadcount.Utilized == nil {
			break
		}

		return e.complexity.LevelHeadcount.Utilized(childComplexity), true

	case "LevelInconsistency.actualLevel":
		if e.complexity.LevelInconsistency.ActualLevel == nil {
			break
		}

		return e.complexity.LevelInconsistency.ActualLevel(childComplexity), true

	case "LevelInconsistency.code":
		if e.complexity.LevelInconsistency.Code == nil {
			break
		}

		return e.complexity.LevelInconsistency.Code(childComplexity), true

	case "LevelInconsistency.expectedLevel":
		if e.complexity.LevelInconsistency.ExpectedLevel == nil {
			break
		}

		return e.complexity.LevelInconsistency.ExpectedLevel(childComplexity), true

	case "LevelInconsistency.parentCode":
		if e.complexity.LevelInconsistency.ParentCode == nil {
			break
		}

		return e.complexity.LevelInconsistency.ParentCode(childComplexity), true

	case "LevelInconsistency.reason":
		if e.complexity.LevelInconsistency.Reason == nil {
			break
		}

		return e.complexity.LevelInconsistency.Reason(childComplexity), true

	case "LevelStatistic.count":
		if e.complexity.LevelStatistic.Count == nil {
			break
		}

		return e.complexity.LevelStatistic.Count(childComplexity), true

	case "LevelStatistic.level":
		if e.complexity.LevelStatistic.Level == nil {
			break
		}

		return e.complexity.LevelStatistic.Level(childComplexity), true

	case "OperatedBy.id":
		if e.complexity.OperatedBy.ID == nil {
			break
		}

		return e.complexity.OperatedBy.ID(childComplexity), true

	case "OperatedBy.name":
		if e.complexity.OperatedBy.Name == nil {
			break
		}

		return e.complexity.OperatedBy.Name(childComplexity), true

	case "OperationsSummary.create":
		if e.complexity.OperationsSummary.Create == nil {
			break
		}

		return e.complexity.OperationsSummary.Create(childComplexity), true

	case "OperationsSummary.delete":
		if e.complexity.OperationsSummary.Delete == nil {
			break
		}

		return e.complexity.OperationsSummary.Delete(childComplexity), true

	case "OperationsSummary.reactivate":
		if e.complexity.OperationsSummary.Reactivate == nil {
			break
		}

		return e.complexity.OperationsSummary.Reactivate(childComplexity), true

	case "OperationsSummary.suspend":
		if e.complexity.OperationsSummary.Suspend == nil {
			break
		}

		return e.complexity.OperationsSummary.Suspend(childComplexity), true

	case "OperationsSummary.update":
		if e.complexity.OperationsSummary.Update == nil {
			break
		}

		return e.complexity.OperationsSummary.Update(childComplexity), true

	case "Organization.changeReason":
		if e.complexity.Organization.ChangeReason == nil {
			break
		}

		return e.complexity.Organization.ChangeReason(childComplexity), true

	case "Organization.childrenCount":
		if e.complexity.Organization.ChildrenCount == nil {
			break
		}

		return e.complexity.Organization.ChildrenCount(childComplexity), true

	case "Organization.code":
		if e.complexity.Organization.Code == nil {
			break
		}

		return e.complexity.Organization.Code(childComplexity), true

	case "Organization.codePath":
		if e.complexity.Organization.CodePath == nil {
			break
		}

		return e.complexity.Organization.CodePath(childComplexity), true

	case "Organization.createdAt":
		if e.complexity.Organization.CreatedAt == nil {
			break
		}

		return e.complexity.Organization.CreatedAt(childComplexity), true

	case "Organization.deletedAt":
		if e.complexity.Organization.DeletedAt == nil {
			break
		}

		return e.complexity.Organization.DeletedAt(childComplexity), true

	case "Organization.deletedBy":
		if e.complexity.Organization.DeletedBy == nil {
			break
		}

		return e.complexity.Organization.DeletedBy(childComplexity), true

	case "Organization.deletionReason":
		if e.complexity.Organization.DeletionReason == nil {
			break
		}

		return e.complexity.Organization.DeletionReason(childComplexity), true

	case "Organization.description":
		if e.complexity.Organization.Description == nil {
			break
		}

		return e.complexity.Organization.Description(childComplexity), true

	case "Organization.effectiveDate":
		if e.complexity.Organization.EffectiveDate == nil {
			break
		}

		return e.complexity.Organization.EffectiveDate(childComplexity), true

	case "Organization.endDate":
		if e.complexity.Organization.EndDate == nil {
			break
		}

		return e.complexity.Organization.EndDate(childComplexity), true

	case "Organization.hierarchyDepth":
		if e.complexity.Organization.HierarchyDepth == nil {
			break
		}

		return e.complexity.Organization.HierarchyDepth(childComplexity), true

	case "Organization.isCurrent":
		if e.complexity.Organization.IsCurrent == nil {
			break
		}

		return e.complexity.Organization.IsCurrent(childComplexity), true

	case "Organization.isFuture":
		if e.complexity.Organization.IsFuture == nil {
			break
		}

		return e.complexity.Organization.IsFuture(childComplexity), true

	case "Organization.isTemporal":
		if e.complexity.Organization.IsTemporal == nil {
			break
		}

		return e.complexity.Organization.IsTemporal(childComplexity), true

	case "Organization.level":
		if e.complexity.Organization.Level == nil {
			break
		}

		return e.complexity.Organization.Level(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Organization.namePath":
		if e.complexity.Organization.NamePath == nil {
			break
		}

		return e.complexity.Organization.NamePath(childComplexity), true

	case "Organization.parentCode":
		if e.complexity.Organization.ParentCode == nil {
			break
		}

		return e.complexity.Organization.ParentCode(childComplexity), true

	case "Organization.path":
		if e.complexity.Organization.Path == nil {
			break
		}

		return e.complexity.Organization.Path(childComplexity), true

	case "Organization.profile":
		if e.complexity.Organization.Profile == nil {
			break
		}

		return e.complexity.Organization.Profile(childComplexity), true

	case "Organization.recordId":
		if e.complexity.Organization.RecordID == nil {
			break
		}

		return e.complexity.Organization.RecordID(childComplexity), true

	case "Organization.sortOrder":
		if e.complexity.Organization.SortOrder == nil {
			break
		}

		return e.complexity.Organization.SortOrder(childComplexity), true

	case "Organization.status":
		if e.complexity.Organization.Status == nil {
			break
		}

		return e.complexity.Organization.Status(childComplexity), true

	case "Organization.suspendedAt":
		if e.complexity.Organization.SuspendedAt == nil {
			break
		}

		return e.complexity.Organization.SuspendedAt(childComplexity), true

	case "Organization.suspendedBy":
		if e.complexity.Organization.SuspendedBy == nil {
			break
		}

		return e.complexity.Organization.SuspendedBy(childComplexity), true

	case "Organization.suspensionReason":
		if e.complexity.Organization.SuspensionReason == nil {
			break
		}

		return e.complexity.Organization.SuspensionReason(childComplexity), true

	case "Organization.tenantId":
		if e.complexity.Organization.TenantID == nil {
			break
		}

		return e.complexity.Organization.TenantID(childComplexity), true

	case "Organization.unitType":
		if e.complexity.Organization.UnitType == nil {
			break
		}

		return e.complexity.Organization.UnitType(childComplexity), true

	case "Organization.updatedAt":
		if e.complexity.Organization.UpdatedAt == nil {
			break
		}

		return e.complexity.Organization.UpdatedAt(childComplexity), true

	case "OrganizationConnection.data":
		if e.complexity.OrganizationConnection.Data == nil {
			break
		}

		return e.complexity.OrganizationConnection.Data(childComplexity), true

	case "OrganizationConnection.pagination":
		if e.complexity.OrganizationConnection.Pagination == nil {
			break
		}

		return e.complexity.OrganizationConnection.Pagination(childComplexity), true

	case "OrganizationConnection.temporal":
		if e.complexity.OrganizationConnection.Temporal == nil {
			break
		}

		return e.complexity.OrganizationConnection.Temporal(childComplexity), true

	case "OrganizationHierarchy.children":
		if e.complexity.OrganizationHierarchy.Children == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.Children(childComplexity), true

	case "OrganizationHierarchy.childrenCount":
		if e.complexity.OrganizationHierarchy.ChildrenCount == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.ChildrenCount(childComplexity), true

	case "OrganizationHierarchy.code":
		if e.complexity.OrganizationHierarchy.Code == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.Code(childComplexity), true

	case "OrganizationHierarchy.codePath":
		if e.complexity.OrganizationHierarchy.CodePath == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.CodePath(childComplexity), true

	case "OrganizationHierarchy.hierarchyDepth":
		if e.complexity.OrganizationHierarchy.HierarchyDepth == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.HierarchyDepth(childComplexity), true

	case "OrganizationHierarchy.isLeaf":
		if e.complexity.OrganizationHierarchy.IsLeaf == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.IsLeaf(childComplexity), true

	case "OrganizationHierarchy.isRoot":
		if e.complexity.OrganizationHierarchy.IsRoot == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.IsRoot(childComplexity), true

	case "OrganizationHierarchy.level":
		if e.complexity.OrganizationHierarchy.Level == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.Level(childComplexity), true

	case "OrganizationHierarchy.name":
		if e.complexity.OrganizationHierarchy.Name == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.Name(childComplexity), true

	case "OrganizationHierarchy.namePath":
		if e.complexity.OrganizationHierarchy.NamePath == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.NamePath(childComplexity), true

	case "OrganizationHierarchy.parentChain":
		if e.complexity.OrganizationHierarchy.ParentChain == nil {
			break
		}

		return e.complexity.OrganizationHierarchy.ParentChain(childComplexity), true

	case "OrganizationStats.activeCount":
		if e.complexity.OrganizationStats.ActiveCount == nil {
			break
		}

		return e.complexity.OrganizationStats.ActiveCount(childComplexity), true

	case "OrganizationStats.byLevel":
		if e.complexity.OrganizationStats.ByLevel == nil {
			break
		}

		return e.complexity.OrganizationStats.ByLevel(childComplexity), true

	case "OrganizationStats.byStatus":
		if e.complexity.OrganizationStats.ByStatus == nil {
			break
		}

		return e.complexity.OrganizationStats.ByStatus(childComplexity), true

	case "OrganizationStats.byType":
		if e.complexity.OrganizationStats.ByType == nil {
			break
		}

		return e.complexity.OrganizationStats.ByType(childComplexity), true

	case "OrganizationStats.deletedCount":
		if e.complexity.OrganizationStats.DeletedCount == nil {
			break
		}

		return e.complexity.OrganizationStats.DeletedCount(childComplexity), true

	case "OrganizationStats.inactiveCount":
		if e.complexity.OrganizationStats.InactiveCount == nil {
			break
		}

		return e.complexity.OrganizationStats.InactiveCount(childComplexity), true

	case "OrganizationStats.plannedCount":
		if e.complexity.OrganizationStats.PlannedCount == nil {
			break
		}

		return e.complexity.OrganizationStats.PlannedCount(childComplexity), true

	case "OrganizationStats.temporalStats":
		if e.complexity.OrganizationStats.TemporalStats == nil {
			break
		}

		return e.complexity.OrganizationStats.TemporalStats(childComplexity), true

	case "OrganizationStats.totalCount":
		if e.complexity.OrganizationStats.TotalCount == nil {
			break
		}

		return e.complexity.OrganizationStats.TotalCount(childComplexity), true

	case "OrphanedNode.code":
		if e.complexity.OrphanedNode.Code == nil {
			break
		}

		return e.complexity.OrphanedNode.Code(childComplexity), true

	case "OrphanedNode.name":
		if e.complexity.OrphanedNode.Name == nil {
			break
		}

		return e.complexity.OrphanedNode.Name(childComplexity), true

	case "OrphanedNode.parentCode":
		if e.complexity.OrphanedNode.ParentCode == nil {
			break
		}

		return e.complexity.OrphanedNode.ParentCode(childComplexity), true

	case "OrphanedNode.reason":
		if e.complexity.OrphanedNode.Reason == nil {
			break
		}

		return e.complexity.OrphanedNode.Reason(childComplexity), true

	case "PaginationInfo.hasNext":
		if e.complexity.PaginationInfo.HasNext == nil {
			break
		}

		return e.complexity.PaginationInfo.HasNext(childComplexity), true

	case "PaginationInfo.hasPrevious":
		if e.complexity.PaginationInfo.HasPrevious == nil {
			break
		}

		return e.complexity.PaginationInfo.HasPrevious(childComplexity), true

	case "PaginationInfo.page":
		if e.complexity.PaginationInfo.Page == nil {
			break
		}

		return e.complexity.PaginationInfo.Page(childComplexity), true

	case "PaginationInfo.pageSize":
		if e.complexity.PaginationInfo.PageSize == nil {
			break
		}

		return e.complexity.PaginationInfo.PageSize(childComplexity), true

	case "PaginationInfo.total":
		if e.complexity.PaginationInfo.Total == nil {
			break
		}

		return e.complexity.PaginationInfo.Total(childComplexity), true

	case "PathMismatch.actualCodePath":
		if e.complexity.PathMismatch.ActualCodePath == nil {
			break
		}

		return e.complexity.PathMismatch.ActualCodePath(childComplexity), true

	case "PathMismatch.actualNamePath":
		if e.complexity.PathMismatch.ActualNamePath == nil {
			break
		}

		return e.complexity.PathMismatch.ActualNamePath(childComplexity), true

	case "PathMismatch.code":
		if e.complexity.PathMismatch.Code == nil {
			break
		}

		return e.complexity.PathMismatch.Code(childComplexity), true

	case "PathMismatch.expectedCodePath":
		if e.complexity.PathMismatch.ExpectedCodePath == nil {
			break
		}

		return e.complexity.PathMismatch.ExpectedCodePath(childComplexity), true

	case "PathMismatch.expectedNamePath":
		if e.complexity.PathMismatch.ExpectedNamePath == nil {
			break
		}

		return e.complexity.PathMismatch.ExpectedNamePath(childComplexity), true

	case "PathMismatch.severity":
		if e.complexity.PathMismatch.Severity == nil {
			break
		}

		return e.complexity.PathMismatch.Severity(childComplexity), true

	case "Position.assignmentHistory":
		if e.complexity.Position.AssignmentHistory == nil {
			break
		}

		return e.complexity.Position.AssignmentHistory(childComplexity), true

	case "Position.availableHeadcount":
		if e.complexity.Position.AvailableHeadcount == nil {
			break
		}

		return e.complexity.Position.AvailableHeadcount(childComplexity), true

	case "Position.code":
		if e.complexity.Position.Code == nil {
			break
		}

		return e.complexity.Position.Code(childComplexity), true

	case "Position.createdAt":
		if e.complexity.Position.CreatedAt == nil {
			break
		}

		return e.complexity.Position.CreatedAt(childComplexity), true

	case "Position.currentAssignment":
		if e.complexity.Position.CurrentAssignment == nil {
			break
		}

		return e.complexity.Position.CurrentAssignment(childComplexity), true

	case "Position.effectiveDate":
		if e.complexity.Position.EffectiveDate == nil {
			break
		}

		return e.complexity.Position.EffectiveDate(childComplexity), true

	case "Position.employmentType":
		if e.complexity.Position.EmploymentType == nil {
			break
		}

		return e.complexity.Position.EmploymentType(childComplexity), true

	case "Position.endDate":
		if e.complexity.Position.EndDate == nil {
			break
		}

		return e.complexity.Position.EndDate(childComplexity), true

	case "Position.gradeLevel":
		if e.complexity.Position.GradeLevel == nil {
			break
		}

		return e.complexity.Position.GradeLevel(childComplexity), true

	case "Position.headcountCapacity":
		if e.complexity.Position.HeadcountCapacity == nil {
			break
		}

		return e.complexity.Position.HeadcountCapacity(childComplexity), true

	case "Position.headcountInUse":
		if e.complexity.Position.HeadcountInUse == nil {
			break
		}

		return e.complexity.Position.HeadcountInUse(childComplexity), true

	case "Position.isCurrent":
		if e.complexity.Position.IsCurrent == nil {
			break
		}

		return e.complexity.Position.IsCurrent(childComplexity), true

	case "Position.isFuture":
		if e.complexity.Position.IsFuture == nil {
			break
		}

		return e.complexity.Position.IsFuture(childComplexity), true

	case "Position.jobFamilyCode":
		if e.complexity.Position.JobFamilyCode == nil {
			break
		}

		return e.complexity.Position.JobFamilyCode(childComplexity), true

	case "Position.jobFamilyGroupCode":
		if e.complexity.Position.JobFamilyGroupCode == nil {
			break
		}

		return e.complexity.Position.JobFamilyGroupCode(childComplexity), true

	case "Position.jobLevelCode":
		if e.complexity.Position.JobLevelCode == nil {
			break
		}

		return e.complexity.Position.JobLevelCode(childComplexity), true

	case "Position.jobProfileCode":
		if e.complexity.Position.JobProfileCode == nil {
			break
		}

		return e.complexity.Position.JobProfileCode(childComplexity), true

	case "Position.jobProfileName":
		if e.complexity.Position.JobProfileName == nil {
			break
		}

		return e.complexity.Position.JobProfileName(childComplexity), true

	case "Position.jobRoleCode":
		if e.complexity.Position.JobRoleCode == nil {
			break
		}

		return e.complexity.Position.JobRoleCode(childComplexity), true

	case "Position.organizationCode":
		if e.complexity.Position.OrganizationCode == nil {
			break
		}

		return e.complexity.Position.OrganizationCode(childComplexity), true

	case "Position.organizationName":
		if e.complexity.Position.OrganizationName == nil {
			break
		}

		return e.complexity.Position.OrganizationName(childComplexity), true

	case "Position.positionType":
		if e.complexity.Position.PositionType == nil {
			break
		}

		return e.complexity.Position.PositionType(childComplexity), true

	case "Position.recordId":
		if e.complexity.Position.RecordID == nil {
			break
		}

		return e.complexity.Position.RecordID(childComplexity), true

	case "Position.reportsToPositionCode":
		if e.complexity.Position.ReportsToPositionCode == nil {
			break
		}

		return e.complexity.Position.ReportsToPositionCode(childComplexity), true

	case "Position.status":
		if e.complexity.Position.Status == nil {
			break
		}

		return e.complexity.Position.Status(childComplexity), true

	case "Position.tenantId":
		if e.complexity.Position.TenantID == nil {
			break
		}

		return e.complexity.Position.TenantID(childComplexity), true

	case "Position.title":
		if e.complexity.Position.Title == nil {
			break
		}

		return e.complexity.Position.Title(childComplexity), true

	case "Position.updatedAt":
		if e.complexity.Position.UpdatedAt == nil {
			break
		}

		return e.complexity.Position.UpdatedAt(childComplexity), true

	case "PositionAssignment.actingUntil":
		if e.complexity.PositionAssignment.ActingUntil == nil {
			break
		}

		return e.complexity.PositionAssignment.ActingUntil(childComplexity), true

	case "PositionAssignment.assignmentId":
		if e.complexity.PositionAssignment.AssignmentID == nil {
			break
		}

		return e.complexity.PositionAssignment.AssignmentID(childComplexity), true

	case "PositionAssignment.assignmentStatus":
		if e.complexity.PositionAssignment.AssignmentStatus == nil {
			break
		}

		return e.complexity.PositionAssignment.AssignmentStatus(childComplexity), true

	case "PositionAssignment.assignmentType":
		if e.complexity.PositionAssignment.AssignmentType == nil {
			break
		}

		return e.complexity.PositionAssignment.AssignmentType(childComplexity), true

	case "PositionAssignment.autoRevert":
		if e.complexity.PositionAssignment.AutoRevert == nil {
			break
		}

		return e.complexity.PositionAssignment.AutoRevert(childComplexity), true

	case "PositionAssignment.createdAt":
		if e.complexity.PositionAssignment.CreatedAt == nil {
			break
		}

		return e.complexity.PositionAssignment.CreatedAt(childComplexity), true

	case "PositionAssignment.effectiveDate":
		if e.complexity.PositionAssignment.EffectiveDate == nil {
			break
		}

		return e.complexity.PositionAssignment.EffectiveDate(childComplexity), true

	case "PositionAssignment.employeeId":
		if e.complexity.PositionAssignment.EmployeeID == nil {
			break
		}

		return e.complexity.PositionAssignment.EmployeeID(childComplexity), true

	case "PositionAssignment.employeeName":
		if e.complexity.PositionAssignment.EmployeeName == nil {
			break
		}

		return e.complexity.PositionAssignment.EmployeeName(childComplexity), true

	case "PositionAssignment.employeeNumber":
		if e.complexity.PositionAssignment.EmployeeNumber == nil {
			break
		}

		return e.complexity.PositionAssignment.EmployeeNumber(childComplexity), true

	case "PositionAssignment.endDate":
		if e.complexity.PositionAssignment.EndDate == nil {
			break
		}

		return e.complexity.PositionAssignment.EndDate(childComplexity), true

	case "PositionAssignment.fte":
		if e.complexity.PositionAssignment.Fte == nil {
			break
		}

		return e.complexity.PositionAssignment.Fte(childComplexity), true

	case "PositionAssignment.isCurrent":
		if e.complexity.PositionAssignment.IsCurrent == nil {
			break
		}

		return e.complexity.PositionAssignment.IsCurrent(childComplexity), true

	case "PositionAssignment.notes":
		if e.complexity.PositionAssignment.Notes == nil {
			break
		}

		return e.complexity.PositionAssignment.Notes(childComplexity), true

	case "PositionAssignment.positionCode":
		if e.complexity.PositionAssignment.PositionCode == nil {
			break
		}

		return e.complexity.PositionAssignment.PositionCode(childComplexity), true

	case "PositionAssignment.positionRecordId":
		if e.complexity.PositionAssignment.PositionRecordID == nil {
			break
		}

		return e.complexity.PositionAssignment.PositionRecordID(childComplexity), true

	case "PositionAssignment.reminderSentAt":
		if e.complexity.PositionAssignment.ReminderSentAt == nil {
			break
		}

		return e.complexity.PositionAssignment.ReminderSentAt(childComplexity), true

	case "PositionAssignment.updatedAt":
		if e.complexity.PositionAssignment.UpdatedAt == nil {
			break
		}

		return e.complexity.PositionAssignment.UpdatedAt(childComplexity), true

	case "PositionAssignmentAudit.actor":
		if e.complexity.PositionAssignmentAudit.Actor == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.Actor(childComplexity), true

	case "PositionAssignmentAudit.assignmentId":
		if e.complexity.PositionAssignmentAudit.AssignmentID == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.AssignmentID(childComplexity), true

	case "PositionAssignmentAudit.changes":
		if e.complexity.PositionAssignmentAudit.Changes == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.Changes(childComplexity), true

	case "PositionAssignmentAudit.createdAt":
		if e.complexity.PositionAssignmentAudit.CreatedAt == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.CreatedAt(childComplexity), true

	case "PositionAssignmentAudit.effectiveDate":
		if e.complexity.PositionAssignmentAudit.EffectiveDate == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.EffectiveDate(childComplexity), true

	case "PositionAssignmentAudit.endDate":
		if e.complexity.PositionAssignmentAudit.EndDate == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.EndDate(childComplexity), true

	case "PositionAssignmentAudit.eventType":
		if e.complexity.PositionAssignmentAudit.EventType == nil {
			break
		}

		return e.complexity.PositionAssignmentAudit.EventType(childComplexity), true

	case "PositionAssignmentAuditConnection.data":
		if e.complexity.PositionAssignmentAuditConnection.Data == nil {
			break
		}

		return e.complexity.PositionAssignmentAuditConnection.Data(childComplexity), true

	case "PositionAssignmentAuditConnection.pagination":
		if e.complexity.PositionAssignmentAuditConnection.Pagination == nil {
			break
		}

		return e.complexity.PositionAssignmentAuditConnection.Pagination(childComplexity), true

	case "PositionAssignmentAuditConnection.totalCount":
		if e.complexity.PositionAssignmentAuditConnection.TotalCount == nil {
			break
		}

		return e.complexity.PositionAssignmentAuditConnection.TotalCount(childComplexity), true

	case "PositionAssignmentConnection.data":
		if e.complexity.PositionAssignmentConnection.Data == nil {
			break
		}

		return e.complexity.PositionAssignmentConnection.Data(childComplexity), true

	case "PositionAssignmentConnection.edges":
		if e.complexity.PositionAssignmentConnection.Edges == nil {
			break
		}

		return e.complexity.PositionAssignmentConnection.Edges(childComplexity), true

	case "PositionAssignmentConnection.pagination":
		if e.complexity.PositionAssignmentConnection.Pagination == nil {
			break
		}

		return e.complexity.PositionAssignmentConnection.Pagination(childComplexity), true

	case "PositionAssignmentConnection.totalCount":
		if e.complexity.PositionAssignmentConnection.TotalCount == nil {
			break
		}

		return e.complexity.PositionAssignmentConnection.TotalCount(childComplexity), true

	case "PositionAssignmentEdge.cursor":
		if e.complexity.PositionAssignmentEdge.Cursor == nil {
			break
		}

		return e.complexity.PositionAssignmentEdge.Cursor(childComplexity), true

	case "PositionAssignmentEdge.node":
		if e.complexity.PositionAssignmentEdge.Node == nil {
			break
		}

		return e.complexity.PositionAssignmentEdge.Node(childComplexity), true

	case "PositionConnection.data":
		if e.complexity.PositionConnection.Data == nil {
			break
		}

		return e.complexity.PositionConnection.Data(childComplexity), true

	case "PositionConnection.edges":
		if e.complexity.PositionConnection.Edges == nil {
			break
		}

		return e.complexity.PositionConnection.Edges(childComplexity), true

	case "PositionConnection.pagination":
		if e.complexity.PositionConnection.Pagination == nil {
			break
		}

		return e.complexity.PositionConnection.Pagination(childComplexity), true

	case "PositionConnection.totalCount":
		if e.complexity.PositionConnection.TotalCount == nil {
			break
		}

		return e.complexity.PositionConnection.TotalCount(childComplexity), true

	case "PositionEdge.cursor":
		if e.complexity.PositionEdge.Cursor == nil {
			break
		}

		return e.complexity.PositionEdge.Cursor(childComplexity), true

	case "PositionEdge.node":
		if e.complexity.PositionEdge.Node == nil {
			break
		}

		return e.complexity.PositionEdge.Node(childComplexity), true

	case "PositionTimelineEntry.assignmentStatus":
		if e.complexity.PositionTimelineEntry.AssignmentStatus == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.AssignmentStatus(childComplexity), true

	case "PositionTimelineEntry.assignmentType":
		if e.complexity.PositionTimelineEntry.AssignmentType == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.AssignmentType(childComplexity), true

	case "PositionTimelineEntry.changeReason":
		if e.complexity.PositionTimelineEntry.ChangeReason == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.ChangeReason(childComplexity), true

	case "PositionTimelineEntry.effectiveDate":
		if e.complexity.PositionTimelineEntry.EffectiveDate == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.EffectiveDate(childComplexity), true

	case "PositionTimelineEntry.endDate":
		if e.complexity.PositionTimelineEntry.EndDate == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.EndDate(childComplexity), true

	case "PositionTimelineEntry.isCurrent":
		if e.complexity.PositionTimelineEntry.IsCurrent == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.IsCurrent(childComplexity), true

	case "PositionTimelineEntry.recordId":
		if e.complexity.PositionTimelineEntry.RecordID == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.RecordID(childComplexity), true

	case "PositionTimelineEntry.status":
		if e.complexity.PositionTimelineEntry.Status == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.Status(childComplexity), true

	case "PositionTimelineEntry.timelineCategory":
		if e.complexity.PositionTimelineEntry.TimelineCategory == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.TimelineCategory(childComplexity), true

	case "PositionTimelineEntry.title":
		if e.complexity.PositionTimelineEntry.Title == nil {
			break
		}

		return e.complexity.PositionTimelineEntry.Title(childComplexity), true

	case "PositionTransfer.createdAt":
		if e.complexity.PositionTransfer.CreatedAt == nil {
			break
		}

		return e.complexity.PositionTransfer.CreatedAt(childComplexity), true

	case "PositionTransfer.effectiveDate":
		if e.complexity.PositionTransfer.EffectiveDate == nil {
			break
		}

		return e.complexity.PositionTransfer.EffectiveDate(childComplexity), true

	case "PositionTransfer.fromOrganizationCode":
		if e.complexity.PositionTransfer.FromOrganizationCode == nil {
			break
		}

		return e.complexity.PositionTransfer.FromOrganizationCode(childComplexity), true

	case "PositionTransfer.initiatedBy":
		if e.complexity.PositionTransfer.InitiatedBy == nil {
			break
		}

		return e.complexity.PositionTransfer.InitiatedBy(childComplexity), true

	case "PositionTransfer.operationReason":
		if e.complexity.PositionTransfer.OperationReason == nil {
			break
		}

		return e.complexity.PositionTransfer.OperationReason(childComplexity), true

	case "PositionTransfer.positionCode":
		if e.complexity.PositionTransfer.PositionCode == nil {
			break
		}

		return e.complexity.PositionTransfer.PositionCode(childComplexity), true

	case "PositionTransfer.toOrganizationCode":
		if e.complexity.PositionTransfer.ToOrganizationCode == nil {
			break
		}

		return e.complexity.PositionTransfer.ToOrganizationCode(childComplexity), true

	case "PositionTransfer.transferId":
		if e.complexity.PositionTransfer.TransferID == nil {
			break
		}

		return e.complexity.PositionTransfer.TransferID(childComplexity), true

	case "PositionTransferConnection.data":
		if e.complexity.PositionTransferConnection.Data == nil {
			break
		}

		return e.complexity.PositionTransferConnection.Data(childComplexity), true

	case "PositionTransferConnection.edges":
		if e.complexity.PositionTransferConnection.Edges == nil {
			break
		}

		return e.complexity.PositionTransferConnection.Edges(childComplexity), true

	case "PositionTransferConnection.pagination":
		if e.complexity.PositionTransferConnection.Pagination == nil {
			break
		}

		return e.complexity.PositionTransferConnection.Pagination(childComplexity), true

	case "PositionTransferConnection.totalCount":
		if e.complexity.PositionTransferConnection.TotalCount == nil {
			break
		}

		return e.complexity.PositionTransferConnection.TotalCount(childComplexity), true

	case "PositionTransferEdge.cursor":
		if e.complexity.PositionTransferEdge.Cursor == nil {
			break
		}

		return e.complexity.PositionTransferEdge.Cursor(childComplexity), true

	case "PositionTransferEdge.node":
		if e.complexity.PositionTransferEdge.Node == nil {
			break
		}

		return e.complexity.PositionTransferEdge.Node(childComplexity), true

	case "Query.assignmentHistory":
		if e.complexity.Query.AssignmentHistory == nil {
			break
		}

		args, err := ec.field_Query_assignmentHistory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AssignmentHistory(childComplexity, args["positionCode"].(dto.PositionCode), args["filter"].(*model.PositionAssignmentFilterInput), args["pagination"].(*model.PaginationInput), args["sorting"].([]model.PositionAssignmentSortInput)), true

	case "Query.assignmentStats":
		if e.complexity.Query.AssignmentStats == nil {
			break
		}

		args, err := ec.field_Query_assignmentStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AssignmentStats(childComplexity, args["organizationCode"].(*string), args["positionCode"].(*dto.PositionCode)), true

	case "Query.assignments":
		if e.complexity.Query.Assignments == nil {
			break
		}

		args, err := ec.field_Query_assignments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assignments(childComplexity, args["organizationCode"].(*string), args["positionCode"].(*dto.PositionCode), args["filter"].(*model.PositionAssignmentFilterInput), args["pagination"].(*model.PaginationInput), args["sorting"].([]model.PositionAssignmentSortInput)), true

	case "Query.auditHistory":
		if e.complexity.Query.AuditHistory == nil {
			break
		}

		args, err := ec.field_Query_auditHistory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AuditHistory(childComplexity, args["recordId"].(string), args["startDate"].(*string), args["endDate"].(*string), args["operation"].(*model.OperationType), args["userId"].(*string), args["limit"].(*int)), true

	case "Query.auditLog":
		if e.complexity.Query.AuditLog == nil {
			break
		}

		args, err := ec.field_Query_auditLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AuditLog(childComplexity, args["auditId"].(string)), true

	case "Query.hierarchyStatistics":
		if e.complexity.Query.HierarchyStatistics == nil {
			break
		}

		args, err := ec.field_Query_hierarchyStatistics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HierarchyStatistics(childComplexity, args["tenantId"].(string), args["includeIntegrityCheck"].(*bool)), true

	case "Query.jobFamilies":
		if e.complexity.Query.JobFamilies == nil {
			break
		}

		args, err := ec.field_Query_jobFamilies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.JobFamilies(childComplexity, args["groupCode"].(dto.JobFamilyGroupCode), args["includeInactive"].(*bool), args["asOfDate"].(*dto.Date)), true

	case "Query.jobFamilyGroups":
		if e.complexity.Query.JobFamilyGroups == nil {
			break
		}

		args, err := ec.field_Query_jobFamilyGroups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.JobFamilyGroups(childComplexity, args["includeInactive"].(*bool), args["asOfDate"].(*dto.Date)), true

	case "Query.jobLevels":
		if e.complexity.Query.JobLevels == nil {
			break
		}

		args, err := ec.field_Query_jobLevels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.JobLevels(childComplexity, args["roleCode"].(dto.JobRoleCode), args["includeInactive"].(*bool), args["asOfDate"].(*dto.Date)), true

	case "Query.jobRoles":
		if e.complexity.Query.JobRoles == nil {
			break
		}

		args, err := ec.field_Query_jobRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.JobRoles(childComplexity, args["familyCode"].(dto.JobFamilyCode), args["includeInactive"].(*bool), args["asOfDate"].(*dto.Date)), true

	case "Query.organization":
		if e.complexity.Query.Organization == nil {
			break
		}

		args, err := ec.field_Query_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organization(childComplexity, args["code"].(string), args["asOfDate"].(*string)), true

	case "Query.organizationHierarchy":
		if e.complexity.Query.OrganizationHierarchy == nil {
			break
		}

		args, err := ec.field_Query_organizationHierarchy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OrganizationHierarchy(childComplexity, args["code"].(string), args["tenantId"].(string)), true

	case "Query.organizationStats":
		if e.complexity.Query.OrganizationStats == nil {
			break
		}

		args, err := ec.field_Query_organizationStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OrganizationStats(childComplexity, args["asOfDate"].(*string), args["includeHistorical"].(*bool)), true

	case "Query.organizationSubtree":
		if e.complexity.Query.OrganizationSubtree == nil {
			break
		}

		args, err := ec.field_Query_organizationSubtree_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OrganizationSubtree(childComplexity, args["code"].(string), args["tenantId"].(string), args["maxDepth"].(*int), args["includeInactive"].(*bool)), true

	case "Query.organizationVersions":
		if e.complexity.Query.OrganizationVersions == nil {
			break
		}

		args, err := ec.field_Query_organizationVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OrganizationVersions(childComplexity, args["code"].(string), args["includeDeleted"].(*bool)), true

	case "Query.organizations":
		if e.complexity.Query.Organizations == nil {
			break
		}

		args, err := ec.field_Query_organizations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organizations(childComplexity, args["filter"].(*model.OrganizationFilter), args["pagination"].(*model.PaginationInput)), true

	case "Query.position":
		if e.complexity.Query.Position == nil {
			break
		}

		args, err := ec.field_Query_position_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Position(childComplexity, args["code"].(dto.PositionCode), args["asOfDate"].(*dto.Date)), true

	case "Query.positionAssignmentAudit":
		if e.complexity.Query.PositionAssignmentAudit == nil {
			break
		}

		args, err := ec.field_Query_positionAssignmentAudit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PositionAssignmentAudit(childComplexity, args["positionCode"].(dto.PositionCode), args["assignmentId"].(*dto.UUID), args["dateRange"].(*model.DateRangeInput), args["pagination"].(*model.PaginationInput)), true

	case "Query.positionAssignments":
		if e.complexity.Query.PositionAssignments == nil {
			break
		}

		args, err := ec.field_Query_positionAssignments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PositionAssignments(childComplexity, args["positionCode"].(dto.PositionCode), args["filter"].(*model.PositionAssignmentFilterInput), args["pagination"].(*model.PaginationInput), args["sorting"].([]model.PositionAssignmentSortInput)), true

	case "Query.positionHeadcountStats":
		if e.complexity.Query.PositionHeadcountStats == nil {
			break
		}

		args, err := ec.field_Query_positionHeadcountStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PositionHeadcountStats(childComplexity, args["organizationCode"].(string), args["includeSubordinates"].(*bool)), true

	case "Query.positionTimeline":
		if e.complexity.Query.PositionTimeline == nil {
			break
		}

		args, err := ec.field_Query_positionTimeline_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PositionTimeline(childComplexity, args["code"].(dto.PositionCode), args["startDate"].(*dto.Date), args["endDate"].(*dto.Date)), true

	case "Query.positionTransfers":
		if e.complexity.Query.PositionTransfers == nil {
			break
		}

		args, err := ec.field_Query_positionTransfers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PositionTransfers(childComplexity, args["positionCode"].(*dto.PositionCode), args["organizationCode"].(*string), args["pagination"].(*model.PaginationInput)), true

	case "Query.positionVersions":
		if e.complexity.Query.PositionVersions == nil {
			break
		}

		args, err := ec.field_Query_positionVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PositionVersions(childComplexity, args["code"].(dto.PositionCode), args["includeDeleted"].(*bool)), true

	case "Query.positions":
		if e.complexity.Query.Positions == nil {
			break
		}

		args, err := ec.field_Query_positions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Positions(childComplexity, args["filter"].(*model.PositionFilterInput), args["pagination"].(*model.PaginationInput), args["sorting"].([]model.PositionSortInput)), true

	case "Query.vacantPositions":
		if e.complexity.Query.VacantPositions == nil {
			break
		}

		args, err := ec.field_Query_vacantPositions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.VacantPositions(childComplexity, args["filter"].(*model.VacantPositionFilterInput), args["pagination"].(*model.PaginationInput), args["sorting"].([]model.VacantPositionSortInput)), true

	case "RepairSuggestion.affectedCodes":
		if e.complexity.RepairSuggestion.AffectedCodes == nil {
			break
		}

		return e.complexity.RepairSuggestion.AffectedCodes(childComplexity), true

	case "RepairSuggestion.automatable":
		if e.complexity.RepairSuggestion.Automatable == nil {
			break
		}

		return e.complexity.RepairSuggestion.Automatable(childComplexity), true

	case "RepairSuggestion.issueType":
		if e.complexity.RepairSuggestion.IssueType == nil {
			break
		}

		return e.complexity.RepairSuggestion.IssueType(childComplexity), true

	case "RepairSuggestion.riskLevel":
		if e.complexity.RepairSuggestion.RiskLevel == nil {
			break
		}

		return e.complexity.RepairSuggestion.RiskLevel(childComplexity), true

	case "RepairSuggestion.suggestedAction":
		if e.complexity.RepairSuggestion.SuggestedAction == nil {
			break
		}

		return e.complexity.RepairSuggestion.SuggestedAction(childComplexity), true

	case "StatusStatistic.count":
		if e.complexity.StatusStatistic.Count == nil {
			break
		}

		return e.complexity.StatusStatistic.Count(childComplexity), true

	case "StatusStatistic.status":
		if e.complexity.StatusStatistic.Status == nil {
			break
		}

		return e.complexity.StatusStatistic.Status(childComplexity), true

	case "TemporalInfo.asOfDate":
		if e.complexity.TemporalInfo.AsOfDate == nil {
			break
		}

		return e.complexity.TemporalInfo.AsOfDate(childComplexity), true

	case "TemporalInfo.currentCount":
		if e.complexity.TemporalInfo.CurrentCount == nil {
			break
		}

		return e.complexity.TemporalInfo.CurrentCount(childComplexity), true

	case "TemporalInfo.futureCount":
		if e.complexity.TemporalInfo.FutureCount == nil {
			break
		}

		return e.complexity.TemporalInfo.FutureCount(childComplexity), true

	case "TemporalInfo.historicalCount":
		if e.complexity.TemporalInfo.HistoricalCount == nil {
			break
		}

		return e.complexity.TemporalInfo.HistoricalCount(childComplexity), true

	case "TemporalStatistics.averageVersionsPerOrg":
		if e.complexity.TemporalStatistics.AverageVersionsPerOrg == nil {
			break
		}

		return e.complexity.TemporalStatistics.AverageVersionsPerOrg(childComplexity), true

	case "TemporalStatistics.newestEffectiveDate":
		if e.complexity.TemporalStatistics.NewestEffectiveDate == nil {
			break
		}

		return e.complexity.TemporalStatistics.NewestEffectiveDate(childComplexity), true

	case "TemporalStatistics.oldestEffectiveDate":
		if e.complexity.TemporalStatistics.OldestEffectiveDate == nil {
			break
		}

		return e.complexity.TemporalStatistics.OldestEffectiveDate(childComplexity), true

	case "TemporalStatistics.totalVersions":
		if e.complexity.TemporalStatistics.TotalVersions == nil {
			break
		}

		return e.complexity.TemporalStatistics.TotalVersions(childComplexity), true

	case "TypeHeadcount.available":
		if e.complexity.TypeHeadcount.Available == nil {
			break
		}

		return e.complexity.TypeHeadcount.Available(childComplexity), true

	case "TypeHeadcount.capacity":
		if e.complexity.TypeHeadcount.Capacity == nil {
			break
		}

		return e.complexity.TypeHeadcount.Capacity(childComplexity), true

	case "TypeHeadcount.filled":
		if e.complexity.TypeHeadcount.Filled == nil {
			break
		}

		return e.complexity.TypeHeadcount.Filled(childComplexity), true

	case "TypeHeadcount.positionType":
		if e.complexity.TypeHeadcount.PositionType == nil {
			break
		}

		return e.complexity.TypeHeadcount.PositionType(childComplexity), true

	case "TypeStatistic.count":
		if e.complexity.TypeStatistic.Count == nil {
			break
		}

		return e.complexity.TypeStatistic.Count(childComplexity), true

	case "TypeStatistic.unitType":
		if e.complexity.TypeStatistic.UnitType == nil {
			break
		}

		return e.complexity.TypeStatistic.UnitType(childComplexity), true

	case "UserInfo.role":
		if e.complexity.UserInfo.Role == nil {
			break
		}

		return e.complexity.UserInfo.Role(childComplexity), true

	case "UserInfo.userId":
		if e.complexity.UserInfo.UserID == nil {
			break
		}

		return e.complexity.UserInfo.UserID(childComplexity), true

	case "UserInfo.userName":
		if e.complexity.UserInfo.UserName == nil {
			break
		}

		return e.complexity.UserInfo.UserName(childComplexity), true

	case "VacantPosition.headcountAvailable":
		if e.complexity.VacantPosition.HeadcountAvailable == nil {
			break
		}

		return e.complexity.VacantPosition.HeadcountAvailable(childComplexity), true

	case "VacantPosition.headcountCapacity":
		if e.complexity.VacantPosition.HeadcountCapacity == nil {
			break
		}

		return e.complexity.VacantPosition.HeadcountCapacity(childComplexity), true

	case "VacantPosition.jobFamilyCode":
		if e.complexity.VacantPosition.JobFamilyCode == nil {
			break
		}

		return e.complexity.VacantPosition.JobFamilyCode(childComplexity), true

	case "VacantPosition.jobLevelCode":
		if e.complexity.VacantPosition.JobLevelCode == nil {
			break
		}

		return e.complexity.VacantPosition.JobLevelCode(childComplexity), true

	case "VacantPosition.jobRoleCode":
		if e.complexity.VacantPosition.JobRoleCode == nil {
			break
		}

		return e.complexity.VacantPosition.JobRoleCode(childComplexity), true

	case "VacantPosition.organizationCode":
		if e.complexity.VacantPosition.OrganizationCode == nil {
			break
		}

		return e.complexity.VacantPosition.OrganizationCode(childComplexity), true

	case "VacantPosition.organizationName":
		if e.complexity.VacantPosition.OrganizationName == nil {
			break
		}

		return e.complexity.VacantPosition.OrganizationName(childComplexity), true

	case "VacantPosition.positionCode":
		if e.complexity.VacantPosition.PositionCode == nil {
			break
		}

		return e.complexity.VacantPosition.PositionCode(childComplexity), true

	case "VacantPosition.totalAssignments":
		if e.complexity.VacantPosition.TotalAssignments == nil {
			break
		}

		return e.complexity.VacantPosition.TotalAssignments(childComplexity), true

	case "VacantPosition.vacantSince":
		if e.complexity.VacantPosition.VacantSince == nil {
			break
		}

		return e.complexity.VacantPosition.VacantSince(childComplexity), true

	case "VacantPositionConnection.data":
		if e.complexity.VacantPositionConnection.Data == nil {
			break
		}

		return e.complexity.VacantPositionConnection.Data(childComplexity), true

	case "VacantPositionConnection.edges":
		if e.complexity.VacantPositionConnection.Edges == nil {
			break
		}

		return e.complexity.VacantPositionConnection.Edges(childComplexity), true

	case "VacantPositionConnection.pagination":
		if e.complexity.VacantPositionConnection.Pagination == nil {
			break
		}

		return e.complexity.VacantPositionConnection.Pagination(childComplexity), true

	case "VacantPositionConnection.totalCount":
		if e.complexity.VacantPositionConnection.TotalCount == nil {
			break
		}

		return e.complexity.VacantPositionConnection.TotalCount(childComplexity), true

	case "VacantPositionEdge.cursor":
		if e.complexity.VacantPositionEdge.Cursor == nil {
			break
		}

		return e.complexity.VacantPositionEdge.Cursor(childComplexity), true

	case "VacantPositionEdge.node":
		if e.complexity.VacantPositionEdge.Node == nil {
			break
		}

		return e.complexity.VacantPositionEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputDateRangeInput,
		ec.unmarshalInputOrganizationFilter,
		ec.unmarshalInputPaginationInput,
		ec.unmarshalInputPositionAssignmentFilterInput,
		ec.unmarshalInputPositionAssignmentSortInput,
		ec.unmarshalInputPositionFilterInput,
		ec.unmarshalInputPositionSortInput,
		ec.unmarshalInputVacantPositionFilterInput,
		ec.unmarshalInputVacantPositionSortInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../../docs/api/schema.graphql", Input: `# Organization Units Management GraphQL Schema
# Version: 4.7.0
# Architecture: CQRS Query Layer (Read Operations Only)
# Data Source: PostgreSQL with temporal data support
# Authentication: OAuth 2.0 Bearer Token required
#
# Features:
# - Temporal data queries with asOfDate parameter
# - 17-level hierarchy depth support with intelligent caching
# - Precise audit trail tracking individual temporal versions (recordId)
# - Multi-tenant isolation and security
# - Index-optimized for common filters and access patterns
#
# Permission Requirements:
# - organizations, organization: org:read
# - organizationAtDate, organizationHistory, organizationVersions: org:read:history  
# - organizationHierarchy, organizationSubtree: org:read:hierarchy
# - organizationStats: org:read:stats
# - auditHistory: org:read:audit
#
# Recent Changes (v4.6.0):
# - BREAKING: Audit system redesigned for precise recordId tracking
# - Removed organizationAuditHistory query (replaced with auditHistory)
# - AuditLogDetail now tracks specific temporal versions via recordId field only
# - Simplified audit queries: single auditHistory(recordId) for precise tracking
# - Removed businessEntityId field from AuditLogDetail (replaced by recordId)
# - Enhanced audit precision: each temporal version has independent audit lifecycle

"""
Root Query type providing all organization management query operations.
All queries require appropriate OAuth 2.0 permissions and support multi-tenant isolation.
"""
type Query {
  # Basic Organization Queries
  
  """
  Get paginated list of organization units with advanced filtering and temporal support.
  
  Permissions Required: org:read
  Performance: Optimized with specialized indexes, typical response < 50ms
  """
  organizations(
    filter: OrganizationFilter
    pagination: PaginationInput
  ): OrganizationConnection!
  
  """
  Get single organization unit by business code with temporal support.
  
  Permissions Required: org:read
  Performance: Index-optimized single record retrieval < 10ms
  """
  organization(
    code: String!
    asOfDate: String
  ): Organization
  
  """
  Get comprehensive organization statistics with temporal breakdown.
  
  Permissions Required: org:read:stats
  Performance: Cached aggregation queries < 100ms
  """
  organizationStats(
    asOfDate: String
    includeHistorical: Boolean = false
  ): OrganizationStats!
  
  # Advanced Hierarchy Queries
  
  """
  Get complete hierarchy information for an organization including paths and relationships.
  
  Permissions Required: org:read:hierarchy
  Performance: Path-optimized queries with hierarchy cache < 30ms
  """
  organizationHierarchy(
    code: String!
    tenantId: String!
  ): OrganizationHierarchy
  
  """
  Get organization subtree with configurable depth limits and relationship details.
  Use this for multi-level hierarchy display (depth >= 2).
  For direct children only, use organizations(filter: {parentCode: "code"}) instead.
  
  Permissions Required: org:read:hierarchy
  Performance: Recursive CTE queries, optimized for display < 200ms
  """
  organizationSubtree(
    code: String!
    tenantId: String!
    maxDepth: Int = 10
    includeInactive: Boolean = false
  ): [OrganizationHierarchy!]!
  
  """
  Get hierarchy distribution statistics and integrity analysis.
  
  Permissions Required: org:read:hierarchy
  Performance: Aggregation with hierarchy statistics < 150ms
  """
  hierarchyStatistics(
    tenantId: String!
    includeIntegrityCheck: Boolean = false
  ): HierarchyStatistics!

  # Position Queries
  
  """
  Get paginated position list with temporal awareness.
  
  Permissions Required: position:read
  """
  positions(
    filter: PositionFilterInput
    pagination: PaginationInput
    sorting: [PositionSortInput!]
  ): PositionConnection!
  
  """
  Get single position by code with optional temporal perspective.
  
  Permissions Required: position:read
  """
  position(
    code: PositionCode!
    asOfDate: Date
  ): Position
  
  """
  Get temporal timeline for a specific position.
  
  Permissions Required: position:read:history
  """
  positionTimeline(
    code: PositionCode!
    startDate: Date
    endDate: Date
  ): [PositionTimelineEntry!]!

  """
  List temporal versions for a position.

  Permissions Required: position:read:history
  """
  positionVersions(
    code: PositionCode!
    includeDeleted: Boolean = false
  ): [Position!]!

  """
  Get paginated assignment records for a position.

  Permissions Required: position:read
  """
  positionAssignments(
    positionCode: PositionCode!
    filter: PositionAssignmentFilterInput
    pagination: PaginationInput
    sorting: [PositionAssignmentSortInput!]
  ): PositionAssignmentConnection!

  """
  Export assignment audit events for a position.

  Permissions Required: position:assignments:audit
  """
  positionAssignmentAudit(
    positionCode: PositionCode!
    assignmentId: UUID
    dateRange: DateRangeInput
    pagination: PaginationInput
  ): PositionAssignmentAuditConnection!

  """
  List current assignments with optional filters for a single position.

  Permissions Required: position:read
  """
  assignments(
    organizationCode: String
    positionCode: PositionCode
    filter: PositionAssignmentFilterInput
    pagination: PaginationInput
    sorting: [PositionAssignmentSortInput!]
  ): PositionAssignmentConnection!

  """
  Retrieve full assignment history for a position, including ended records.

  Permissions Required: position:read:history
  """
  assignmentHistory(
    positionCode: PositionCode!
    filter: PositionAssignmentFilterInput
    pagination: PaginationInput
    sorting: [PositionAssignmentSortInput!]
  ): PositionAssignmentConnection!

  """
  Aggregate assignment statistics scoped by position or organization.

  Permissions Required: position:read:stats
  """
  assignmentStats(
    organizationCode: String
    positionCode: PositionCode
  ): AssignmentStats!

  """
  Get vacant positions with optional filters.

  Permissions Required: position:read
  """
  vacantPositions(
    filter: VacantPositionFilterInput
    pagination: PaginationInput
    sorting: [VacantPositionSortInput!]
  ): VacantPositionConnection!

  """
  Get transfer history for positions.

  Permissions Required: position:read:history
  """
  positionTransfers(
    positionCode: PositionCode
    organizationCode: String
    pagination: PaginationInput
  ): PositionTransferConnection!
  
  """
  Get headcount statistics for positions under an organization.
  
  Permissions Required: position:read:stats
  """
  positionHeadcountStats(
    organizationCode: String!
    includeSubordinates: Boolean = true
  ): HeadcountStats!

  # Audit and Analysis Queries
  
  """
  Get complete audit history for a specific temporal record (organization units, positions, or job catalog entries).
  This query returns audit records for a specific recordId, allowing precise tracking
  of individual temporal version lifecycle changes.
  
  Permissions Required: org:read:audit
  Performance: Record-specific audit queries with optimized indexing < 50ms
  """
  auditHistory(
    recordId: String!
    startDate: String
    endDate: String
    operation: OperationType
    userId: String
    limit: Int = 50
  ): [AuditLogDetail!]!
  
  """
  Get detailed audit record with before/after data snapshots and field-level changes.
  
  Permissions Required: org:read:audit
  Performance: Single audit record retrieval < 20ms
  """
  auditLog(
    auditId: String!
  ): AuditLogDetail

  """
  Return all temporal versions for an organization code (ascending by effectiveDate).
  Requires scope: org:read:history
  """
  organizationVersions(
    code: String!
    includeDeleted: Boolean
  ): [Organization!]!

  # Job Catalog Queries
  
  """
  Get job family groups with optional historical inclusion.
  
  Permissions Required: job-catalog:read
  """
  jobFamilyGroups(
    includeInactive: Boolean = false
    asOfDate: Date
  ): [JobFamilyGroup!]!
  
  """
  Get job families under a specified group.
  
  Permissions Required: job-catalog:read
  """
  jobFamilies(
    groupCode: JobFamilyGroupCode!
    includeInactive: Boolean = false
    asOfDate: Date
  ): [JobFamily!]!
  
  """
  Get job roles under a specified family.
  
  Permissions Required: job-catalog:read
  """
  jobRoles(
    familyCode: JobFamilyCode!
    includeInactive: Boolean = false
    asOfDate: Date
  ): [JobRole!]!
  
  """
  Get job levels under a specified role.
  
  Permissions Required: job-catalog:read
  """
  jobLevels(
    roleCode: JobRoleCode!
    includeInactive: Boolean = false
    asOfDate: Date
  ): [JobLevel!]!


  # System Maintenance and Monitoring

# Hierarchy consistency check temporarily removed for startup
}

# Core Data Types

"""
Organization unit entity with complete temporal and audit information.
Represents the current state based on asOfDate parameter or latest effective record.
"""
type Organization {
  # Business Identifiers
  code: String!
  parentCode: String!  # Parent organization code. Use "0" for root organizations, or valid 7-digit code for child organizations
  tenantId: String!

  # Basic Information
  name: String!
  unitType: UnitType!
  # Business status (one-dimensional): ACTIVE | INACTIVE | DELETED
  # Soft-delete DELETED 
  # ADR-008: INACTIVE /
  status: Status!
  # Hierarchy Information
  level: Int!
  sortOrder: Int
  codePath: String!
  namePath: String!
  path: String @deprecated(reason: " codePath/namePath path ")

  # Configuration
  description: String
  profile: String
  changeReason: String

  # Temporal Information
  # Notes:
  # - isTemporal is a derived concept (NOT a stored column): endDate != null
  # - isFuture is derived using Beijing business day (UTC+8): effectiveDate > today(CN)
  effectiveDate: String!
  endDate: String

  # Audit Information
  createdAt: String!
  updatedAt: String!
  recordId: String!

  # Temporal Status Information (derived)
  isCurrent: Boolean!
  isTemporal: Boolean!
  isFuture: Boolean!
  hierarchyDepth: Int!
  childrenCount: Int!

  # Soft delete & suspension audit fields (optional)
  deletedAt: String
  deletedBy: String
  deletionReason: String
  suspendedAt: String
  suspendedBy: String
  suspensionReason: String
}

"""
Connection type for paginated organization results with metadata.
"""
type OrganizationConnection {
  data: [Organization!]!
  pagination: PaginationInfo!
  temporal: TemporalInfo!
}

"""
Hierarchy-specific organization information with relationship context.
"""
type OrganizationHierarchy {
  code: String!
  name: String!
  level: Int!
  hierarchyDepth: Int!
  codePath: String!
  namePath: String!
  parentChain: [String!]!
  childrenCount: Int!
  isRoot: Boolean!
  isLeaf: Boolean!
  children: [OrganizationHierarchy!]!
}

"""
Comprehensive organization statistics with temporal breakdown.
"""
type OrganizationStats {
  totalCount: Int!
  activeCount: Int!
  inactiveCount: Int!
  plannedCount: Int!
  deletedCount: Int!
  byType: [TypeStatistic!]!
  byStatus: [StatusStatistic!]!
  byLevel: [LevelStatistic!]!
  temporalStats: TemporalStatistics!
}

"""
Hierarchy distribution statistics and integrity analysis.
"""
type HierarchyStatistics {
  tenantId: String!
  totalOrganizations: Int!
  maxDepth: Int!
  avgDepth: Float!
  depthDistribution: [DepthDistribution!]!
  rootOrganizations: Int!
  leafOrganizations: Int!
  integrityIssues: [IntegrityIssue!]!
  lastAnalyzed: String!
}


"""
Comprehensive audit log entry with complete change tracking information.
Each audit record tracks changes to a specific organization temporal version (recordId).
"""
type AuditLogDetail {
  auditId: String!
  recordId: String!                  # Specific organization temporal version being audited
  operation: String!
  timestamp: String!
  operationReason: String

  # Change tracking data
  beforeData: String                 # Organization state before the change (JSON string)
  afterData: String                  # Organization state after the change (JSON string)
  modifiedFields: [String!]!         # List of field names that were modified
  changes: [FieldChange!]!           # Detailed field-level changes
}

"""
Detailed field-level change information for audit tracking.
"""
type FieldChange {
  field: String!                     # Name of the changed field
  oldValue: String                   # Previous value as string (null for CREATE operations)
  newValue: String                   # New value as string (null for DELETE operations)
  dataType: String!                  # Data type of the field (string, int, date, boolean, etc.)
}


"""
Hierarchy consistency check report with detailed findings and repair suggestions.
"""
type HierarchyConsistencyReport {
  checkId: String!
  tenantId: String!
  executedAt: DateTime!
  executionTimeMs: Int!
  totalChecked: Int!
  issuesFound: Int!
  checkMode: ConsistencyCheckMode!
  consistencyReport: ConsistencyFindings!
  repairSuggestions: [RepairSuggestion!]!
  healthScore: Float!
  recommendedActions: [String!]!
}

# Supporting Types

"""
Standard operator information with ID and display name.
"""
type OperatedBy {
  id: String!
  name: String!
}

"""
Pagination information for connection types.
"""
type PaginationInfo {
  total: Int!
  page: Int!
  pageSize: Int!
  hasNext: Boolean!
  hasPrevious: Boolean!
}

"""
Temporal context information for queries.
"""
type TemporalInfo {
  asOfDate: String!
  currentCount: Int!
  futureCount: Int!
  historicalCount: Int!
}

"""
Entry describing a specific temporal version of a position.
"""
type PositionTimelineEntry {
  recordId: UUID!
  status: PositionStatus!
  title: String!
  effectiveDate: Date!
  endDate: Date
  isCurrent: Boolean!
  changeReason: String
  timelineCategory: PositionTimelineCategory!
  assignmentType: PositionAssignmentType
  assignmentStatus: PositionAssignmentStatus
}

enum PositionTimelineCategory {
  POSITION_VERSION
  POSITION_ASSIGNMENT
}

"""
Position resource exposed via GraphQL.
"""
type Position {
  code: PositionCode!
  recordId: UUID!
  tenantId: UUID!
  title: String!
  jobProfileCode: String
  jobProfileName: String
  jobFamilyGroupCode: JobFamilyGroupCode!
  jobFamilyCode: JobFamilyCode!
  jobRoleCode: JobRoleCode!
  jobLevelCode: JobLevelCode!
  organizationCode: String!
  organizationName: String
  positionType: PositionType!
  employmentType: EmploymentType!
  gradeLevel: String
  headcountCapacity: Float!
  headcountInUse: Float!
  availableHeadcount: Float!
  currentAssignment: PositionAssignment
  assignmentHistory: [PositionAssignment!]!
  reportsToPositionCode: PositionCode
  status: PositionStatus!
  effectiveDate: Date!
  endDate: Date
  isCurrent: Boolean!
  isFuture: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PositionEdge {
  cursor: String!
  node: Position!
}

type PositionConnection {
  edges: [PositionEdge!]!
  pagination: PaginationInfo!
  data: [Position!]!
  totalCount: Int!
}

type PositionAssignment {
  assignmentId: UUID!
  positionCode: PositionCode!
  positionRecordId: UUID!
  employeeId: UUID!
  employeeName: String!
  employeeNumber: String
  assignmentType: PositionAssignmentType!
  assignmentStatus: PositionAssignmentStatus!
  fte: Float!
  effectiveDate: Date!
  endDate: Date
  actingUntil: Date
  autoRevert: Boolean!
  reminderSentAt: DateTime
  isCurrent: Boolean!
  notes: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PositionAssignmentEdge {
  cursor: String!
  node: PositionAssignment!
}

type PositionAssignmentConnection {
  edges: [PositionAssignmentEdge!]!
  pagination: PaginationInfo!
  data: [PositionAssignment!]!
  totalCount: Int!
}

type PositionAssignmentAuditConnection {
  data: [PositionAssignmentAudit!]!
  pagination: PaginationInfo!
  totalCount: Int!
}

type PositionAssignmentAudit {
  assignmentId: UUID!
  eventType: String!
  effectiveDate: Date!
  endDate: Date
  actor: String!
  changes: JSON
  createdAt: DateTime!
}

type AssignmentStats {
  positionCode: PositionCode
  organizationCode: String
  totalAssignments: Int!
  activeAssignments: Int!
  pendingAssignments: Int!
  endedAssignments: Int!
  primaryAssignments: Int!
  secondaryAssignments: Int!
  actingAssignments: Int!
  lastUpdatedAt: DateTime!
}

type VacantPosition {
  positionCode: PositionCode!
  organizationCode: String!
  organizationName: String
  jobFamilyCode: JobFamilyCode!
  jobRoleCode: JobRoleCode!
  jobLevelCode: JobLevelCode!
  vacantSince: Date!
  headcountCapacity: Float!
  headcountAvailable: Float!
  totalAssignments: Int!
}

type VacantPositionEdge {
  cursor: String!
  node: VacantPosition!
}

type VacantPositionConnection {
  edges: [VacantPositionEdge!]!
  pagination: PaginationInfo!
  data: [VacantPosition!]!
  totalCount: Int!
}

type PositionTransfer {
  transferId: UUID!
  positionCode: PositionCode!
  fromOrganizationCode: String!
  toOrganizationCode: String!
  effectiveDate: Date!
  initiatedBy: OperatedBy!
  operationReason: String
  createdAt: DateTime!
}

type PositionTransferEdge {
  cursor: String!
  node: PositionTransfer!
}

type PositionTransferConnection {
  edges: [PositionTransferEdge!]!
  pagination: PaginationInfo!
  data: [PositionTransfer!]!
  totalCount: Int!
}

type LevelHeadcount {
  jobLevelCode: JobLevelCode!
  capacity: Float!
  utilized: Float!
  available: Float!
}

type TypeHeadcount {
  positionType: PositionType!
  capacity: Float!
  filled: Float!
  available: Float!
}

type FamilyHeadcount {
  jobFamilyCode: JobFamilyCode!
  jobFamilyName: String
  capacity: Float!
  utilized: Float!
  available: Float!
}

type HeadcountStats {
  organizationCode: String!
  organizationName: String!
  totalCapacity: Float!
  totalFilled: Float!
  totalAvailable: Float!
  fillRate: Float!
  byLevel: [LevelHeadcount!]!
  byType: [TypeHeadcount!]!
  byFamily: [FamilyHeadcount!]!
}

type JobFamilyGroup {
  code: JobFamilyGroupCode!
  recordId: UUID!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  description: String
}

type JobFamily {
  code: JobFamilyCode!
  recordId: UUID!
  groupCode: JobFamilyGroupCode!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  description: String
}

type JobRole {
  code: JobRoleCode!
  recordId: UUID!
  familyCode: JobFamilyCode!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  description: String
}

type JobLevel {
  code: JobLevelCode!
  recordId: UUID!
  roleCode: JobRoleCode!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  levelRank: Int!
  description: String
}

"""
Statistics by organization unit type.
"""
type TypeStatistic {
  unitType: UnitType!
  count: Int!
}

"""
Statistics by organization status.
"""
type StatusStatistic {
  status: Status!
  count: Int!
}

"""
Statistics by hierarchy level.
"""
type LevelStatistic {
  level: Int!
  count: Int!
}

"""
Temporal statistics breakdown.
"""
type TemporalStatistics {
  totalVersions: Int!
  averageVersionsPerOrg: Float!
  oldestEffectiveDate: String!
  newestEffectiveDate: String!
}

"""
Hierarchy depth distribution analysis.
"""
type DepthDistribution {
  depth: Int!
  count: Int!
}

"""
Hierarchy integrity issue detection.
"""
type IntegrityIssue {
  type: String!
  count: Int!
  affectedCodes: [String!]!
}


"""
User information for audit trails.
"""
type UserInfo {
  userId: String!
  userName: String!
  role: String
}


"""
Simplified data changes with before/after comparison.
"""
type DataChanges {
  beforeData: JSON
  afterData: JSON
  modifiedFields: [String!]!
}







"""
Date range specification.
"""
type DateRange {
  earliest: DateTime!
  latest: DateTime!
}

"""
Operations summary statistics.
"""
type OperationsSummary {
  create: Int!
  update: Int!
  suspend: Int!
  reactivate: Int!
  delete: Int!
}

"""
Consistency check findings with detailed issues.
"""
type ConsistencyFindings {
  pathMismatches: [PathMismatch!]!
  levelInconsistencies: [LevelInconsistency!]!
  orphanedNodes: [OrphanedNode!]!
  circularReferences: [CircularReference!]!
  depthViolations: [DepthViolation!]!
  cacheInconsistencies: [CacheInconsistency!]!
}

"""
Path mismatch detection result.
"""
type PathMismatch {
  code: String!
  expectedCodePath: String!
  actualCodePath: String!
  expectedNamePath: String!
  actualNamePath: String!
  severity: String!
}

"""
Level inconsistency detection result.
"""
type LevelInconsistency {
  code: String!
  expectedLevel: Int!
  actualLevel: Int!
  parentCode: String!
  reason: String!
}

"""
Orphaned node detection result.
"""
type OrphanedNode {
  code: String!
  name: String!
  parentCode: String!
  reason: String!
}

"""
Circular reference detection result.
"""
type CircularReference {
  affectedCodes: [String!]!
  circularPath: [String!]!
  severity: String!
}

"""
Depth violation detection result.
"""
type DepthViolation {
  code: String!
  currentDepth: Int!
  maxAllowedDepth: Int!
  parentChain: [String!]!
}

"""
Cache inconsistency detection result.
"""
type CacheInconsistency {
  code: String!
  fieldName: String!
  cachedValue: String!
  calculatedValue: String!
  impactLevel: String!
}

"""
Repair suggestion with automation capability.
"""
type RepairSuggestion {
  issueType: String!
  affectedCodes: [String!]!
  suggestedAction: String!
  automatable: Boolean!
  riskLevel: String!
}

# Input Types

"""
Comprehensive filter for organization queries with temporal support.
"""
input OrganizationFilter {
  # Temporal Filtering
  asOfDate: String
  includeFuture: Boolean = false
  onlyFuture: Boolean = false
  
  # Business Filtering
  unitType: UnitType
  status: Status
  parentCode: String
  codes: [String!]
  excludeCodes: [String!]
  excludeDescendantsOf: String
  includeDisabledAncestors: Boolean = false
  
  # Hierarchy Filtering
  level: Int
  minLevel: Int
  maxLevel: Int
  rootsOnly: Boolean = false
  leavesOnly: Boolean = false
  
  # Text Search
  searchText: String
  searchFields: [SearchField!] = [NAME, DESCRIPTION]
  
  # Advanced Filtering
  hasChildren: Boolean
  hasProfile: Boolean
  profileContains: JSON
  
  # Audit Filtering
  operationType: OperationType
  operatedBy: String
  operationDateRange: DateRangeInput
}

"""
Pagination configuration for result sets.
"""
input PaginationInput {
  page: Int = 1
  pageSize: Int = 50  # Max 1000
  sortBy: String = "code"
  sortOrder: String = "asc"
}

"""
Date range input for filtering.
"""
input DateRangeInput {
  from: String
  to: String
}

"""
Filter options for position queries.
"""
input PositionFilterInput {
  organizationCode: String
  positionCodes: [PositionCode!]
  status: PositionStatus
  jobFamilyGroupCodes: [JobFamilyGroupCode!]
  jobFamilyCodes: [JobFamilyCode!]
  jobRoleCodes: [JobRoleCode!]
  jobLevelCodes: [JobLevelCode!]
  positionTypes: [PositionType!]
  employmentTypes: [EmploymentType!]
  effectiveRange: DateRangeInput
}

"""
Supported position sorting fields.
"""
enum PositionSortField {
  CODE
  TITLE
  EFFECTIVE_DATE
  STATUS
}

"""
Sorting input for position queries.
"""
input PositionSortInput {
  field: PositionSortField!
  direction: SortOrder = ASC
}

"""
Filter options for position assignment queries.
"""
input PositionAssignmentFilterInput {
  employeeId: UUID
  status: PositionAssignmentStatus
  assignmentTypes: [PositionAssignmentType!]
  dateRange: DateRangeInput
  asOfDate: Date
  includeHistorical: Boolean = true
  includeActingOnly: Boolean = false
}

"""
Supported assignment sorting fields.
"""
enum PositionAssignmentSortField {
  EFFECTIVE_DATE
  END_DATE
  CREATED_AT
}

"""
Sorting input for assignment queries.
"""
input PositionAssignmentSortInput {
  field: PositionAssignmentSortField!
  direction: SortOrder = DESC
}

"""
Filter options for vacant position queries.
"""
input VacantPositionFilterInput {
  organizationCodes: [String!]
  jobFamilyCodes: [JobFamilyCode!]
  jobRoleCodes: [JobRoleCode!]
  jobLevelCodes: [JobLevelCode!]
  positionTypes: [PositionType!]
  minimumVacantDays: Int
  asOfDate: Date
}

"""
Supported vacant position sorting fields.
"""
enum VacantPositionSortField {
  VACANT_SINCE
  HEADCOUNT_AVAILABLE
  HEADCOUNT_CAPACITY
}

"""
Sorting input for vacant position queries.
"""
input VacantPositionSortInput {
  field: VacantPositionSortField!
  direction: SortOrder = DESC
}

# Enums

"""
Organization unit types with specific business semantics.
"""
enum UnitType {
  DEPARTMENT      # Regular business department
  ORGANIZATION_UNIT  # Generic organizational unit
  COMPANY        # Legal entity company
  PROJECT_TEAM   # Temporary project team
}

"""
Organization business status (ADR-008: ).
"""
enum Status {
  ACTIVE         # Actively operating unit
  INACTIVE       # Non-active but existing unit (/)
  PLANNED        # Planned unit ()
  DELETED        # Deleted unit ()
}

"""
Operation types for audit and temporal tracking.
"""
enum OperationType {
  CREATE         # New organization creation
  UPDATE         # Data modification (PUT/PATCH)  
  SUSPEND        # Suspension operation (endpoint: POST /suspend)
  REACTIVATE     # Reactivation operation (endpoint: POST /activate)
  DEACTIVATE     # Deactivation (timeline correction / planned removal)
  DELETE         # Deletion operation
  
  # ADR-008REACTIVATE
  # /activateHTTP
}


"""
Consistency check modes with different performance characteristics.
"""
enum ConsistencyCheckMode {
  FAST          # Cache field consistency only (< 5s)
  DEEP          # Full recursive validation (30s-5min)
  TARGETED      # Specific area focus (< 30s)
}

"""
Search fields for text-based filtering.
"""
enum SearchField {
  NAME
  DESCRIPTION
  CODE_PATH
  NAME_PATH
}

"""
Sorting field options.
"""
enum SortField {
  CODE
  NAME
  CREATED_AT
  UPDATED_AT
  EFFECTIVE_DATE
  LEVEL
  SORT_ORDER
}

"""
Sorting order options.
"""
enum SortOrder {
  ASC
  DESC
}

"""
Lifecycle status for positions.
"""
enum PositionStatus {
  PLANNED
  ACTIVE
  FILLED
  VACANT
  INACTIVE
  DELETED
}

"""
Contract type for positions.
"""
enum PositionType {
  REGULAR
  TEMPORARY
  CONTRACTOR
}

"""
Employment type for position assignments.
"""
enum EmploymentType {
  FULL_TIME
  PART_TIME
  INTERN
}

"""
Assignment type within a position.
"""
enum PositionAssignmentType {
  PRIMARY
  SECONDARY
  ACTING
}

"""
Lifecycle status for a position assignment.
"""
enum PositionAssignmentStatus {
  PENDING
  ACTIVE
  ENDED
}

"""
Status for job catalog entries.
"""
enum JobCatalogStatus {
  ACTIVE
  INACTIVE
}

# Scalar Types

"""
Date scalar for date-only values (YYYY-MM-DD format).
"""
scalar Date

"""
DateTime scalar for timestamp values (ISO 8601 format).
"""
scalar DateTime

"""
UUID scalar for universally unique identifiers.
"""
scalar UUID

"""
JSON scalar for arbitrary JSON data structures.
"""
scalar JSON

"""
Position code scalar (P + 7 digits).
"""
scalar PositionCode

"""
Job family group code scalar (4-6 uppercase letters).
"""
scalar JobFamilyGroupCode

"""
Job family code scalar (group + '-' + 3-6 alphanumeric characters).
"""
scalar JobFamilyCode

"""
Job role code scalar (family + '-' + 3-6 alphanumeric characters).
"""
scalar JobRoleCode

"""
Job level code scalar (uppercase letter + 1-2 digits).
"""
scalar JobLevelCode

# Schema Directives and Documentation

"""
This schema represents the complete query interface for the Organization Units Management system.
It follows GraphQL best practices and provides comprehensive temporal data access with
performance optimization through specialized PostgreSQL indexes.

Key Features:
- Temporal queries with asOfDate parameter for historical data access
- Comprehensive hierarchy management with 17-level depth support
- Complete audit trail with essential change analysis (v4.3.0 simplified)
- Performance-optimized with response times < 200ms for most queries
- Multi-tenant security with permission-based access control

Design Principles (v4.4.0):
- API-first development: remove unused/over-engineered endpoints
- Focus on essential audit information for practical decision-making
- Maintain small, focused API surface area for better maintainability

Authentication:
All queries require OAuth 2.0 Bearer token with appropriate permissions.
Refer to the API documentation for detailed permission requirements.

Performance Guidelines:
- Use pagination for large result sets (default pageSize: 50, max: 1000)
- Leverage temporal filtering to reduce query scope
- Use specific field selection to minimize response payload
- Consider using organizationSubtree only for multi-level hierarchies (depth >= 2)
"""

# Schema Metadata
schema {
  query: Query
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_assignmentHistory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.PositionCode
	if tmp, ok := rawArgs["positionCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCode"))
		arg0, err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["positionCode"] = arg0
	var arg1 *model.PositionAssignmentFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOPositionAssignmentFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	var arg3 []model.PositionAssignmentSortInput
	if tmp, ok := rawArgs["sorting"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorting"))
		arg3, err = ec.unmarshalOPositionAssignmentSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sorting"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_assignmentStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["organizationCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationCode"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["organizationCode"] = arg0
	var arg1 *dto.PositionCode
	if tmp, ok := rawArgs["positionCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCode"))
		arg1, err = ec.unmarshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["positionCode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_assignments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["organizationCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationCode"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["organizationCode"] = arg0
	var arg1 *dto.PositionCode
	if tmp, ok := rawArgs["positionCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCode"))
		arg1, err = ec.unmarshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["positionCode"] = arg1
	var arg2 *model.PositionAssignmentFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg2, err = ec.unmarshalOPositionAssignmentFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	var arg3 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg3, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg3
	var arg4 []model.PositionAssignmentSortInput
	if tmp, ok := rawArgs["sorting"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorting"))
		arg4, err = ec.unmarshalOPositionAssignmentSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sorting"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_auditHistory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["recordId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recordId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["recordId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["startDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startDate"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["endDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["endDate"] = arg2
	var arg3 *model.OperationType
	if tmp, ok := rawArgs["operation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operation"))
		arg3, err = ec.unmarshalOOperationType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOperationType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operation"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg5, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_auditLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["auditId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auditId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["auditId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hierarchyStatistics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tenantId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantId"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeIntegrityCheck"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeIntegrityCheck"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeIntegrityCheck"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_jobFamilies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.JobFamilyGroupCode
	if tmp, ok := rawArgs["groupCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupCode"))
		arg0, err = ec.unmarshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupCode"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeInactive"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeInactive"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeInactive"] = arg1
	var arg2 *dto.Date
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg2, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_jobFamilyGroups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["includeInactive"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeInactive"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeInactive"] = arg0
	var arg1 *dto.Date
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg1, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_jobLevels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.JobRoleCode
	if tmp, ok := rawArgs["roleCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleCode"))
		arg0, err = ec.unmarshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roleCode"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeInactive"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeInactive"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeInactive"] = arg1
	var arg2 *dto.Date
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg2, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_jobRoles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.JobFamilyCode
	if tmp, ok := rawArgs["familyCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("familyCode"))
		arg0, err = ec.unmarshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["familyCode"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeInactive"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeInactive"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeInactive"] = arg1
	var arg2 *dto.Date
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg2, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_organizationHierarchy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["tenantId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_organizationStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeHistorical"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeHistorical"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeHistorical"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_organizationSubtree_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["tenantId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantId"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["maxDepth"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDepth"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxDepth"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["includeInactive"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeInactive"))
		arg3, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeInactive"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_organizationVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeDeleted"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeleted"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeleted"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_organizations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.OrganizationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOOrganizationFilter2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_positionAssignmentAudit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.PositionCode
	if tmp, ok := rawArgs["positionCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCode"))
		arg0, err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["positionCode"] = arg0
	var arg1 *dto.UUID
	if tmp, ok := rawArgs["assignmentId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assignmentId"))
		arg1, err = ec.unmarshalOUUID2cubecastleinternalorganizationdtoUUID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["assignmentId"] = arg1
	var arg2 *model.DateRangeInput
	if tmp, ok := rawArgs["dateRange"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateRange"))
		arg2, err = ec.unmarshalODateRangeInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDateRangeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dateRange"] = arg2
	var arg3 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg3, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_positionAssignments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.PositionCode
	if tmp, ok := rawArgs["positionCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCode"))
		arg0, err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["positionCode"] = arg0
	var arg1 *model.PositionAssignmentFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOPositionAssignmentFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	var arg3 []model.PositionAssignmentSortInput
	if tmp, ok := rawArgs["sorting"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorting"))
		arg3, err = ec.unmarshalOPositionAssignmentSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sorting"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_positionHeadcountStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["organizationCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationCode"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["organizationCode"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeSubordinates"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeSubordinates"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeSubordinates"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_positionTimeline_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.PositionCode
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 *dto.Date
	if tmp, ok := rawArgs["startDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
		arg1, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startDate"] = arg1
	var arg2 *dto.Date
	if tmp, ok := rawArgs["endDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
		arg2, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["endDate"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_positionTransfers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *dto.PositionCode
	if tmp, ok := rawArgs["positionCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCode"))
		arg0, err = ec.unmarshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["positionCode"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["organizationCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationCode"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["organizationCode"] = arg1
	var arg2 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_positionVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.PositionCode
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeDeleted"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeleted"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeleted"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_position_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.PositionCode
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 *dto.Date
	if tmp, ok := rawArgs["asOfDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
		arg1, err = ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["asOfDate"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_positions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PositionFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOPositionFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	var arg2 []model.PositionSortInput
	if tmp, ok := rawArgs["sorting"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorting"))
		arg2, err = ec.unmarshalOPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sorting"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_vacantPositions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.VacantPositionFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVacantPositionFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	var arg2 []model.VacantPositionSortInput
	if tmp, ok := rawArgs["sorting"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorting"))
		arg2, err = ec.unmarshalOVacantPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sorting"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AssignmentStats_positionCode(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_positionCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.PositionCode)
	fc.Result = res
	return ec.marshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_positionCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_organizationCode(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_organizationCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_organizationCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_totalAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_totalAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_totalAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_activeAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_activeAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_activeAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_pendingAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_pendingAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_pendingAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_endedAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_endedAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndedAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_endedAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_primaryAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_primaryAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimaryAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_primaryAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_secondaryAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_secondaryAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecondaryAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_secondaryAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_actingAssignments(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_actingAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActingAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_actingAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssignmentStats_lastUpdatedAt(ctx context.Context, field graphql.CollectedField, obj *model.AssignmentStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssignmentStats_lastUpdatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssignmentStats_lastUpdatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssignmentStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_auditId(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_auditId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuditID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_auditId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_recordId(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_operation(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_operation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_operation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_operationReason(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_operationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_operationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_beforeData(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_beforeData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BeforeData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_beforeData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_afterData(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_afterData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_afterData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_modifiedFields(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_modifiedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_modifiedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuditLogDetail_changes(ctx context.Context, field graphql.CollectedField, obj *model.AuditLogDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuditLogDetail_changes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FieldChange)
	fc.Result = res
	return ec.marshalNFieldChange2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFieldChange(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuditLogDetail_changes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuditLogDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_FieldChange_field(ctx, field)
			case "oldValue":
				return ec.fieldContext_FieldChange_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_FieldChange_newValue(ctx, field)
			case "dataType":
				return ec.fieldContext_FieldChange_dataType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FieldChange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CacheInconsistency_code(ctx context.Context, field graphql.CollectedField, obj *model.CacheInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CacheInconsistency_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CacheInconsistency_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CacheInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CacheInconsistency_fieldName(ctx context.Context, field graphql.CollectedField, obj *model.CacheInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CacheInconsistency_fieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CacheInconsistency_fieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CacheInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CacheInconsistency_cachedValue(ctx context.Context, field graphql.CollectedField, obj *model.CacheInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CacheInconsistency_cachedValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CachedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CacheInconsistency_cachedValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CacheInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CacheInconsistency_calculatedValue(ctx context.Context, field graphql.CollectedField, obj *model.CacheInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CacheInconsistency_calculatedValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalculatedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CacheInconsistency_calculatedValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CacheInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CacheInconsistency_impactLevel(ctx context.Context, field graphql.CollectedField, obj *model.CacheInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CacheInconsistency_impactLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImpactLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CacheInconsistency_impactLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CacheInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircularReference_affectedCodes(ctx context.Context, field graphql.CollectedField, obj *model.CircularReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircularReference_affectedCodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedCodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircularReference_affectedCodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircularReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircularReference_circularPath(ctx context.Context, field graphql.CollectedField, obj *model.CircularReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircularReference_circularPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CircularPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircularReference_circularPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircularReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircularReference_severity(ctx context.Context, field graphql.CollectedField, obj *model.CircularReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircularReference_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircularReference_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircularReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConsistencyFindings_pathMismatches(ctx context.Context, field graphql.CollectedField, obj *model.ConsistencyFindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConsistencyFindings_pathMismatches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathMismatches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PathMismatch)
	fc.Result = res
	return ec.marshalNPathMismatch2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPathMismatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConsistencyFindings_pathMismatches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConsistencyFindings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_PathMismatch_code(ctx, field)
			case "expectedCodePath":
				return ec.fieldContext_PathMismatch_expectedCodePath(ctx, field)
			case "actualCodePath":
				return ec.fieldContext_PathMismatch_actualCodePath(ctx, field)
			case "expectedNamePath":
				return ec.fieldContext_PathMismatch_expectedNamePath(ctx, field)
			case "actualNamePath":
				return ec.fieldContext_PathMismatch_actualNamePath(ctx, field)
			case "severity":
				return ec.fieldContext_PathMismatch_severity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PathMismatch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConsistencyFindings_levelInconsistencies(ctx context.Context, field graphql.CollectedField, obj *model.ConsistencyFindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConsistencyFindings_levelInconsistencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelInconsistencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.LevelInconsistency)
	fc.Result = res
	return ec.marshalNLevelInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelInconsistency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConsistencyFindings_levelInconsistencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConsistencyFindings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_LevelInconsistency_code(ctx, field)
			case "expectedLevel":
				return ec.fieldContext_LevelInconsistency_expectedLevel(ctx, field)
			case "actualLevel":
				return ec.fieldContext_LevelInconsistency_actualLevel(ctx, field)
			case "parentCode":
				return ec.fieldContext_LevelInconsistency_parentCode(ctx, field)
			case "reason":
				return ec.fieldContext_LevelInconsistency_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LevelInconsistency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConsistencyFindings_orphanedNodes(ctx context.Context, field graphql.CollectedField, obj *model.ConsistencyFindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConsistencyFindings_orphanedNodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrphanedNodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.OrphanedNode)
	fc.Result = res
	return ec.marshalNOrphanedNode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrphanedNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConsistencyFindings_orphanedNodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConsistencyFindings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_OrphanedNode_code(ctx, field)
			case "name":
				return ec.fieldContext_OrphanedNode_name(ctx, field)
			case "parentCode":
				return ec.fieldContext_OrphanedNode_parentCode(ctx, field)
			case "reason":
				return ec.fieldContext_OrphanedNode_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrphanedNode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConsistencyFindings_circularReferences(ctx context.Context, field graphql.CollectedField, obj *model.ConsistencyFindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConsistencyFindings_circularReferences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CircularReferences, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.CircularReference)
	fc.Result = res
	return ec.marshalNCircularReference2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCircularReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConsistencyFindings_circularReferences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConsistencyFindings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "affectedCodes":
				return ec.fieldContext_CircularReference_affectedCodes(ctx, field)
			case "circularPath":
				return ec.fieldContext_CircularReference_circularPath(ctx, field)
			case "severity":
				return ec.fieldContext_CircularReference_severity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircularReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConsistencyFindings_depthViolations(ctx context.Context, field graphql.CollectedField, obj *model.ConsistencyFindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConsistencyFindings_depthViolations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DepthViolations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DepthViolation)
	fc.Result = res
	return ec.marshalNDepthViolation2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthViolation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConsistencyFindings_depthViolations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConsistencyFindings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_DepthViolation_code(ctx, field)
			case "currentDepth":
				return ec.fieldContext_DepthViolation_currentDepth(ctx, field)
			case "maxAllowedDepth":
				return ec.fieldContext_DepthViolation_maxAllowedDepth(ctx, field)
			case "parentChain":
				return ec.fieldContext_DepthViolation_parentChain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DepthViolation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConsistencyFindings_cacheInconsistencies(ctx context.Context, field graphql.CollectedField, obj *model.ConsistencyFindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConsistencyFindings_cacheInconsistencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CacheInconsistencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.CacheInconsistency)
	fc.Result = res
	return ec.marshalNCacheInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCacheInconsistency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConsistencyFindings_cacheInconsistencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConsistencyFindings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_CacheInconsistency_code(ctx, field)
			case "fieldName":
				return ec.fieldContext_CacheInconsistency_fieldName(ctx, field)
			case "cachedValue":
				return ec.fieldContext_CacheInconsistency_cachedValue(ctx, field)
			case "calculatedValue":
				return ec.fieldContext_CacheInconsistency_calculatedValue(ctx, field)
			case "impactLevel":
				return ec.fieldContext_CacheInconsistency_impactLevel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CacheInconsistency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataChanges_beforeData(ctx context.Context, field graphql.CollectedField, obj *model.DataChanges) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataChanges_beforeData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BeforeData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(dto.JSON)
	fc.Result = res
	return ec.marshalOJSON2cubecastleinternalorganizationdtoJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataChanges_beforeData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataChanges",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataChanges_afterData(ctx context.Context, field graphql.CollectedField, obj *model.DataChanges) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataChanges_afterData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(dto.JSON)
	fc.Result = res
	return ec.marshalOJSON2cubecastleinternalorganizationdtoJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataChanges_afterData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataChanges",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataChanges_modifiedFields(ctx context.Context, field graphql.CollectedField, obj *model.DataChanges) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataChanges_modifiedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataChanges_modifiedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataChanges",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DateRange_earliest(ctx context.Context, field graphql.CollectedField, obj *model.DateRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DateRange_earliest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Earliest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DateRange_earliest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DateRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DateRange_latest(ctx context.Context, field graphql.CollectedField, obj *model.DateRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DateRange_latest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DateRange_latest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DateRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DepthDistribution_depth(ctx context.Context, field graphql.CollectedField, obj *model.DepthDistribution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DepthDistribution_depth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Depth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DepthDistribution_depth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DepthDistribution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DepthDistribution_count(ctx context.Context, field graphql.CollectedField, obj *model.DepthDistribution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DepthDistribution_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DepthDistribution_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DepthDistribution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DepthViolation_code(ctx context.Context, field graphql.CollectedField, obj *model.DepthViolation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DepthViolation_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DepthViolation_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DepthViolation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DepthViolation_currentDepth(ctx context.Context, field graphql.CollectedField, obj *model.DepthViolation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DepthViolation_currentDepth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DepthViolation_currentDepth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DepthViolation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DepthViolation_maxAllowedDepth(ctx context.Context, field graphql.CollectedField, obj *model.DepthViolation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DepthViolation_maxAllowedDepth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxAllowedDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DepthViolation_maxAllowedDepth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DepthViolation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DepthViolation_parentChain(ctx context.Context, field graphql.CollectedField, obj *model.DepthViolation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DepthViolation_parentChain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentChain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DepthViolation_parentChain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DepthViolation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FamilyHeadcount_jobFamilyCode(ctx context.Context, field graphql.CollectedField, obj *model.FamilyHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FamilyHeadcount_jobFamilyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobFamilyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyCode)
	fc.Result = res
	return ec.marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FamilyHeadcount_jobFamilyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FamilyHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FamilyHeadcount_jobFamilyName(ctx context.Context, field graphql.CollectedField, obj *model.FamilyHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FamilyHeadcount_jobFamilyName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobFamilyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FamilyHeadcount_jobFamilyName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FamilyHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FamilyHeadcount_capacity(ctx context.Context, field graphql.CollectedField, obj *model.FamilyHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FamilyHeadcount_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FamilyHeadcount_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FamilyHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FamilyHeadcount_utilized(ctx context.Context, field graphql.CollectedField, obj *model.FamilyHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FamilyHeadcount_utilized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FamilyHeadcount_utilized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FamilyHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FamilyHeadcount_available(ctx context.Context, field graphql.CollectedField, obj *model.FamilyHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FamilyHeadcount_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FamilyHeadcount_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FamilyHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FieldChange_field(ctx context.Context, field graphql.CollectedField, obj *model.FieldChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FieldChange_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FieldChange_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FieldChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FieldChange_oldValue(ctx context.Context, field graphql.CollectedField, obj *model.FieldChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FieldChange_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FieldChange_oldValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FieldChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FieldChange_newValue(ctx context.Context, field graphql.CollectedField, obj *model.FieldChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FieldChange_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FieldChange_newValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FieldChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FieldChange_dataType(ctx context.Context, field graphql.CollectedField, obj *model.FieldChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FieldChange_dataType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FieldChange_dataType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FieldChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_organizationCode(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_organizationCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_organizationCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_organizationName(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_organizationName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_organizationName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_totalCapacity(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_totalCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_totalCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_totalFilled(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_totalFilled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalFilled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_totalFilled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_totalAvailable(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_totalAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_totalAvailable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_fillRate(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_fillRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FillRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_fillRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_byLevel(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_byLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ByLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.LevelHeadcount)
	fc.Result = res
	return ec.marshalNLevelHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelHeadcount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_byLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobLevelCode":
				return ec.fieldContext_LevelHeadcount_jobLevelCode(ctx, field)
			case "capacity":
				return ec.fieldContext_LevelHeadcount_capacity(ctx, field)
			case "utilized":
				return ec.fieldContext_LevelHeadcount_utilized(ctx, field)
			case "available":
				return ec.fieldContext_LevelHeadcount_available(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LevelHeadcount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_byType(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_byType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ByType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TypeHeadcount)
	fc.Result = res
	return ec.marshalNTypeHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeHeadcount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_byType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "positionType":
				return ec.fieldContext_TypeHeadcount_positionType(ctx, field)
			case "capacity":
				return ec.fieldContext_TypeHeadcount_capacity(ctx, field)
			case "filled":
				return ec.fieldContext_TypeHeadcount_filled(ctx, field)
			case "available":
				return ec.fieldContext_TypeHeadcount_available(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeHeadcount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HeadcountStats_byFamily(ctx context.Context, field graphql.CollectedField, obj *model.HeadcountStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HeadcountStats_byFamily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ByFamily, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FamilyHeadcount)
	fc.Result = res
	return ec.marshalNFamilyHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFamilyHeadcount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HeadcountStats_byFamily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HeadcountStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobFamilyCode":
				return ec.fieldContext_FamilyHeadcount_jobFamilyCode(ctx, field)
			case "jobFamilyName":
				return ec.fieldContext_FamilyHeadcount_jobFamilyName(ctx, field)
			case "capacity":
				return ec.fieldContext_FamilyHeadcount_capacity(ctx, field)
			case "utilized":
				return ec.fieldContext_FamilyHeadcount_utilized(ctx, field)
			case "available":
				return ec.fieldContext_FamilyHeadcount_available(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FamilyHeadcount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_checkId(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_checkId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_checkId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_tenantId(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_executedAt(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_executedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_executedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_executionTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_executionTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_executionTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_totalChecked(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_totalChecked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalChecked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_totalChecked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_issuesFound(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_issuesFound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssuesFound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_issuesFound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_checkMode(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_checkMode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckMode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConsistencyCheckMode)
	fc.Result = res
	return ec.marshalNConsistencyCheckMode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelConsistencyCheckMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_checkMode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConsistencyCheckMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_consistencyReport(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_consistencyReport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsistencyReport, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConsistencyFindings)
	fc.Result = res
	return ec.marshalNConsistencyFindings2cubecastlecmdhrmsserverqueryinternalgraphqlmodelConsistencyFindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_consistencyReport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pathMismatches":
				return ec.fieldContext_ConsistencyFindings_pathMismatches(ctx, field)
			case "levelInconsistencies":
				return ec.fieldContext_ConsistencyFindings_levelInconsistencies(ctx, field)
			case "orphanedNodes":
				return ec.fieldContext_ConsistencyFindings_orphanedNodes(ctx, field)
			case "circularReferences":
				return ec.fieldContext_ConsistencyFindings_circularReferences(ctx, field)
			case "depthViolations":
				return ec.fieldContext_ConsistencyFindings_depthViolations(ctx, field)
			case "cacheInconsistencies":
				return ec.fieldContext_ConsistencyFindings_cacheInconsistencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConsistencyFindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_repairSuggestions(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_repairSuggestions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepairSuggestions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.RepairSuggestion)
	fc.Result = res
	return ec.marshalNRepairSuggestion2cubecastlecmdhrmsserverqueryinternalgraphqlmodelRepairSuggestion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_repairSuggestions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issueType":
				return ec.fieldContext_RepairSuggestion_issueType(ctx, field)
			case "affectedCodes":
				return ec.fieldContext_RepairSuggestion_affectedCodes(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_RepairSuggestion_suggestedAction(ctx, field)
			case "automatable":
				return ec.fieldContext_RepairSuggestion_automatable(ctx, field)
			case "riskLevel":
				return ec.fieldContext_RepairSuggestion_riskLevel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepairSuggestion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_healthScore(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_healthScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_healthScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyConsistencyReport_recommendedActions(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyConsistencyReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyConsistencyReport_recommendedActions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecommendedActions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyConsistencyReport_recommendedActions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyConsistencyReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_tenantId(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_totalOrganizations(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_totalOrganizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalOrganizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_totalOrganizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_maxDepth(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_maxDepth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_maxDepth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_avgDepth(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_avgDepth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvgDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_avgDepth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_depthDistribution(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_depthDistribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DepthDistribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DepthDistribution)
	fc.Result = res
	return ec.marshalNDepthDistribution2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthDistribution(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_depthDistribution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "depth":
				return ec.fieldContext_DepthDistribution_depth(ctx, field)
			case "count":
				return ec.fieldContext_DepthDistribution_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DepthDistribution", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_rootOrganizations(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_rootOrganizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootOrganizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_rootOrganizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_leafOrganizations(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_leafOrganizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LeafOrganizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_leafOrganizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_integrityIssues(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_integrityIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntegrityIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.IntegrityIssue)
	fc.Result = res
	return ec.marshalNIntegrityIssue2cubecastlecmdhrmsserverqueryinternalgraphqlmodelIntegrityIssue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_integrityIssues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_IntegrityIssue_type(ctx, field)
			case "count":
				return ec.fieldContext_IntegrityIssue_count(ctx, field)
			case "affectedCodes":
				return ec.fieldContext_IntegrityIssue_affectedCodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrityIssue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HierarchyStatistics_lastAnalyzed(ctx context.Context, field graphql.CollectedField, obj *model.HierarchyStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HierarchyStatistics_lastAnalyzed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastAnalyzed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HierarchyStatistics_lastAnalyzed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HierarchyStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrityIssue_type(ctx context.Context, field graphql.CollectedField, obj *model.IntegrityIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrityIssue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrityIssue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrityIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrityIssue_count(ctx context.Context, field graphql.CollectedField, obj *model.IntegrityIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrityIssue_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrityIssue_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrityIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrityIssue_affectedCodes(ctx context.Context, field graphql.CollectedField, obj *model.IntegrityIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrityIssue_affectedCodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedCodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrityIssue_affectedCodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrityIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_code(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyCode)
	fc.Result = res
	return ec.marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_recordId(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_groupCode(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_groupCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyGroupCode)
	fc.Result = res
	return ec.marshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_groupCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyGroupCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_name(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_status(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JobCatalogStatus)
	fc.Result = res
	return ec.marshalNJobCatalogStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobCatalogStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobCatalogStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_endDate(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamily_description(ctx context.Context, field graphql.CollectedField, obj *model.JobFamily) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamily_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamily_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamily",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_code(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyGroupCode)
	fc.Result = res
	return ec.marshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyGroupCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_recordId(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_name(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_status(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JobCatalogStatus)
	fc.Result = res
	return ec.marshalNJobCatalogStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobCatalogStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobCatalogStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_endDate(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobFamilyGroup_description(ctx context.Context, field graphql.CollectedField, obj *model.JobFamilyGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobFamilyGroup_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobFamilyGroup_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobFamilyGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_code(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobLevelCode)
	fc.Result = res
	return ec.marshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobLevelCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_recordId(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_roleCode(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_roleCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoleCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobRoleCode)
	fc.Result = res
	return ec.marshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_roleCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRoleCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_name(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_status(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JobCatalogStatus)
	fc.Result = res
	return ec.marshalNJobCatalogStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobCatalogStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobCatalogStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_endDate(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_levelRank(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_levelRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_levelRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLevel_description(ctx context.Context, field graphql.CollectedField, obj *model.JobLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobLevel_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobLevel_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_code(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobRoleCode)
	fc.Result = res
	return ec.marshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRoleCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_recordId(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_familyCode(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_familyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FamilyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyCode)
	fc.Result = res
	return ec.marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_familyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_name(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_status(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JobCatalogStatus)
	fc.Result = res
	return ec.marshalNJobCatalogStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobCatalogStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobCatalogStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_endDate(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobRole_description(ctx context.Context, field graphql.CollectedField, obj *model.JobRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JobRole_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JobRole_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelHeadcount_jobLevelCode(ctx context.Context, field graphql.CollectedField, obj *model.LevelHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelHeadcount_jobLevelCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobLevelCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobLevelCode)
	fc.Result = res
	return ec.marshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelHeadcount_jobLevelCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobLevelCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelHeadcount_capacity(ctx context.Context, field graphql.CollectedField, obj *model.LevelHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelHeadcount_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelHeadcount_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelHeadcount_utilized(ctx context.Context, field graphql.CollectedField, obj *model.LevelHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelHeadcount_utilized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Utilized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelHeadcount_utilized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelHeadcount_available(ctx context.Context, field graphql.CollectedField, obj *model.LevelHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelHeadcount_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelHeadcount_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelInconsistency_code(ctx context.Context, field graphql.CollectedField, obj *model.LevelInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelInconsistency_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelInconsistency_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelInconsistency_expectedLevel(ctx context.Context, field graphql.CollectedField, obj *model.LevelInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelInconsistency_expectedLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelInconsistency_expectedLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelInconsistency_actualLevel(ctx context.Context, field graphql.CollectedField, obj *model.LevelInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelInconsistency_actualLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActualLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelInconsistency_actualLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelInconsistency_parentCode(ctx context.Context, field graphql.CollectedField, obj *model.LevelInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelInconsistency_parentCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelInconsistency_parentCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelInconsistency_reason(ctx context.Context, field graphql.CollectedField, obj *model.LevelInconsistency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelInconsistency_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelInconsistency_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelInconsistency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelStatistic_level(ctx context.Context, field graphql.CollectedField, obj *model.LevelStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelStatistic_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelStatistic_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelStatistic_count(ctx context.Context, field graphql.CollectedField, obj *model.LevelStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelStatistic_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelStatistic_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperatedBy_id(ctx context.Context, field graphql.CollectedField, obj *model.OperatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperatedBy_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperatedBy_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperatedBy_name(ctx context.Context, field graphql.CollectedField, obj *model.OperatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperatedBy_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperatedBy_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationsSummary_create(ctx context.Context, field graphql.CollectedField, obj *model.OperationsSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationsSummary_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Create, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationsSummary_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationsSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationsSummary_update(ctx context.Context, field graphql.CollectedField, obj *model.OperationsSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationsSummary_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Update, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationsSummary_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationsSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationsSummary_suspend(ctx context.Context, field graphql.CollectedField, obj *model.OperationsSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationsSummary_suspend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suspend, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationsSummary_suspend(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationsSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationsSummary_reactivate(ctx context.Context, field graphql.CollectedField, obj *model.OperationsSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationsSummary_reactivate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reactivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationsSummary_reactivate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationsSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationsSummary_delete(ctx context.Context, field graphql.CollectedField, obj *model.OperationsSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationsSummary_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationsSummary_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationsSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_code(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_parentCode(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_parentCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_parentCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_tenantId(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_unitType(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_unitType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnitType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UnitType)
	fc.Result = res
	return ec.marshalNUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_unitType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UnitType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_status(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Status)
	fc.Result = res
	return ec.marshalNStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Status does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_level(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_sortOrder(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_sortOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_sortOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_codePath(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_codePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CodePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_codePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_namePath(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_namePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NamePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_namePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_path(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_description(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_profile(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Profile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_profile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_changeReason(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_changeReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_changeReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_endDate(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_recordId(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_isTemporal(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_isTemporal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsTemporal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_isTemporal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_isFuture(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_isFuture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsFuture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_isFuture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_hierarchyDepth(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_hierarchyDepth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HierarchyDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_hierarchyDepth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_childrenCount(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_childrenCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildrenCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_childrenCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_deletedBy(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_deletionReason(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_deletionReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_deletionReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_suspendedAt(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_suspendedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspendedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_suspendedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_suspendedBy(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_suspendedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspendedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_suspendedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_suspensionReason(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_suspensionReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspensionReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_suspensionReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationConnection_data(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationConnection_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationConnection_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Organization_code(ctx, field)
			case "parentCode":
				return ec.fieldContext_Organization_parentCode(ctx, field)
			case "tenantId":
				return ec.fieldContext_Organization_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "unitType":
				return ec.fieldContext_Organization_unitType(ctx, field)
			case "status":
				return ec.fieldContext_Organization_status(ctx, field)
			case "level":
				return ec.fieldContext_Organization_level(ctx, field)
			case "sortOrder":
				return ec.fieldContext_Organization_sortOrder(ctx, field)
			case "codePath":
				return ec.fieldContext_Organization_codePath(ctx, field)
			case "namePath":
				return ec.fieldContext_Organization_namePath(ctx, field)
			case "path":
				return ec.fieldContext_Organization_path(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "profile":
				return ec.fieldContext_Organization_profile(ctx, field)
			case "changeReason":
				return ec.fieldContext_Organization_changeReason(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Organization_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Organization_endDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "recordId":
				return ec.fieldContext_Organization_recordId(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Organization_isCurrent(ctx, field)
			case "isTemporal":
				return ec.fieldContext_Organization_isTemporal(ctx, field)
			case "isFuture":
				return ec.fieldContext_Organization_isFuture(ctx, field)
			case "hierarchyDepth":
				return ec.fieldContext_Organization_hierarchyDepth(ctx, field)
			case "childrenCount":
				return ec.fieldContext_Organization_childrenCount(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "deletionReason":
				return ec.fieldContext_Organization_deletionReason(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_Organization_suspendedAt(ctx, field)
			case "suspendedBy":
				return ec.fieldContext_Organization_suspendedBy(ctx, field)
			case "suspensionReason":
				return ec.fieldContext_Organization_suspensionReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationConnection_pagination(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationConnection_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PaginationInfo)
	fc.Result = res
	return ec.marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationConnection_pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginationInfo_pageSize(ctx, field)
			case "hasNext":
				return ec.fieldContext_PaginationInfo_hasNext(ctx, field)
			case "hasPrevious":
				return ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationConnection_temporal(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationConnection_temporal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temporal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TemporalInfo)
	fc.Result = res
	return ec.marshalNTemporalInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTemporalInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationConnection_temporal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "asOfDate":
				return ec.fieldContext_TemporalInfo_asOfDate(ctx, field)
			case "currentCount":
				return ec.fieldContext_TemporalInfo_currentCount(ctx, field)
			case "futureCount":
				return ec.fieldContext_TemporalInfo_futureCount(ctx, field)
			case "historicalCount":
				return ec.fieldContext_TemporalInfo_historicalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TemporalInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_code(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_name(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_level(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_hierarchyDepth(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_hierarchyDepth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HierarchyDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_hierarchyDepth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_codePath(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_codePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CodePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_codePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_namePath(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_namePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NamePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_namePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_parentChain(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_parentChain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentChain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_parentChain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_childrenCount(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_childrenCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildrenCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_childrenCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_isRoot(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_isRoot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRoot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_isRoot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_isLeaf(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_isLeaf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLeaf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_isLeaf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationHierarchy_children(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationHierarchy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationHierarchy_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.OrganizationHierarchy)
	fc.Result = res
	return ec.marshalNOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationHierarchy_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationHierarchy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_OrganizationHierarchy_code(ctx, field)
			case "name":
				return ec.fieldContext_OrganizationHierarchy_name(ctx, field)
			case "level":
				return ec.fieldContext_OrganizationHierarchy_level(ctx, field)
			case "hierarchyDepth":
				return ec.fieldContext_OrganizationHierarchy_hierarchyDepth(ctx, field)
			case "codePath":
				return ec.fieldContext_OrganizationHierarchy_codePath(ctx, field)
			case "namePath":
				return ec.fieldContext_OrganizationHierarchy_namePath(ctx, field)
			case "parentChain":
				return ec.fieldContext_OrganizationHierarchy_parentChain(ctx, field)
			case "childrenCount":
				return ec.fieldContext_OrganizationHierarchy_childrenCount(ctx, field)
			case "isRoot":
				return ec.fieldContext_OrganizationHierarchy_isRoot(ctx, field)
			case "isLeaf":
				return ec.fieldContext_OrganizationHierarchy_isLeaf(ctx, field)
			case "children":
				return ec.fieldContext_OrganizationHierarchy_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationHierarchy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_activeCount(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_activeCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_activeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_inactiveCount(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_inactiveCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InactiveCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_inactiveCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_plannedCount(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_plannedCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannedCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_plannedCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_deletedCount(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_deletedCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_deletedCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_byType(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_byType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ByType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TypeStatistic)
	fc.Result = res
	return ec.marshalNTypeStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeStatistic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_byType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unitType":
				return ec.fieldContext_TypeStatistic_unitType(ctx, field)
			case "count":
				return ec.fieldContext_TypeStatistic_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeStatistic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_byStatus(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_byStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ByStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.StatusStatistic)
	fc.Result = res
	return ec.marshalNStatusStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatusStatistic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_byStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_StatusStatistic_status(ctx, field)
			case "count":
				return ec.fieldContext_StatusStatistic_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusStatistic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_byLevel(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_byLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ByLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.LevelStatistic)
	fc.Result = res
	return ec.marshalNLevelStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelStatistic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_byLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "level":
				return ec.fieldContext_LevelStatistic_level(ctx, field)
			case "count":
				return ec.fieldContext_LevelStatistic_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LevelStatistic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationStats_temporalStats(ctx context.Context, field graphql.CollectedField, obj *model.OrganizationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationStats_temporalStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemporalStats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TemporalStatistics)
	fc.Result = res
	return ec.marshalNTemporalStatistics2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTemporalStatistics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationStats_temporalStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalVersions":
				return ec.fieldContext_TemporalStatistics_totalVersions(ctx, field)
			case "averageVersionsPerOrg":
				return ec.fieldContext_TemporalStatistics_averageVersionsPerOrg(ctx, field)
			case "oldestEffectiveDate":
				return ec.fieldContext_TemporalStatistics_oldestEffectiveDate(ctx, field)
			case "newestEffectiveDate":
				return ec.fieldContext_TemporalStatistics_newestEffectiveDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TemporalStatistics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrphanedNode_code(ctx context.Context, field graphql.CollectedField, obj *model.OrphanedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrphanedNode_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrphanedNode_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrphanedNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrphanedNode_name(ctx context.Context, field graphql.CollectedField, obj *model.OrphanedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrphanedNode_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrphanedNode_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrphanedNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrphanedNode_parentCode(ctx context.Context, field graphql.CollectedField, obj *model.OrphanedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrphanedNode_parentCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrphanedNode_parentCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrphanedNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrphanedNode_reason(ctx context.Context, field graphql.CollectedField, obj *model.OrphanedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrphanedNode_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrphanedNode_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrphanedNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_total(ctx context.Context, field graphql.CollectedField, obj *model.PaginationInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginationInfo_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginationInfo_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_page(ctx context.Context, field graphql.CollectedField, obj *model.PaginationInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginationInfo_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Page, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginationInfo_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_pageSize(ctx context.Context, field graphql.CollectedField, obj *model.PaginationInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginationInfo_pageSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginationInfo_pageSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_hasNext(ctx context.Context, field graphql.CollectedField, obj *model.PaginationInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginationInfo_hasNext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNext, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginationInfo_hasNext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginationInfo_hasPrevious(ctx context.Context, field graphql.CollectedField, obj *model.PaginationInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPrevious, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginationInfo_hasPrevious(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginationInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PathMismatch_code(ctx context.Context, field graphql.CollectedField, obj *model.PathMismatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PathMismatch_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PathMismatch_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PathMismatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PathMismatch_expectedCodePath(ctx context.Context, field graphql.CollectedField, obj *model.PathMismatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PathMismatch_expectedCodePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedCodePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PathMismatch_expectedCodePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PathMismatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PathMismatch_actualCodePath(ctx context.Context, field graphql.CollectedField, obj *model.PathMismatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PathMismatch_actualCodePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActualCodePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PathMismatch_actualCodePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PathMismatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PathMismatch_expectedNamePath(ctx context.Context, field graphql.CollectedField, obj *model.PathMismatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PathMismatch_expectedNamePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedNamePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PathMismatch_expectedNamePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PathMismatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PathMismatch_actualNamePath(ctx context.Context, field graphql.CollectedField, obj *model.PathMismatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PathMismatch_actualNamePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActualNamePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PathMismatch_actualNamePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PathMismatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PathMismatch_severity(ctx context.Context, field graphql.CollectedField, obj *model.PathMismatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PathMismatch_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PathMismatch_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PathMismatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_code(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.PositionCode)
	fc.Result = res
	return ec.marshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_recordId(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_tenantId(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_title(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_jobProfileCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_jobProfileCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobProfileCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_jobProfileCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_jobProfileName(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_jobProfileName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobProfileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_jobProfileName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_jobFamilyGroupCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_jobFamilyGroupCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobFamilyGroupCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyGroupCode)
	fc.Result = res
	return ec.marshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_jobFamilyGroupCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyGroupCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_jobFamilyCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_jobFamilyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobFamilyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyCode)
	fc.Result = res
	return ec.marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_jobFamilyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_jobRoleCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_jobRoleCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobRoleCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobRoleCode)
	fc.Result = res
	return ec.marshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_jobRoleCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRoleCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_jobLevelCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_jobLevelCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobLevelCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobLevelCode)
	fc.Result = res
	return ec.marshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_jobLevelCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobLevelCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_organizationCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_organizationCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_organizationCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_organizationName(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_organizationName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_organizationName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_positionType(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_positionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionType)
	fc.Result = res
	return ec.marshalNPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_positionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_employmentType(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_employmentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmploymentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EmploymentType)
	fc.Result = res
	return ec.marshalNEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_employmentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EmploymentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_gradeLevel(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_gradeLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GradeLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_gradeLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_headcountCapacity(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_headcountCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadcountCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_headcountCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_headcountInUse(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_headcountInUse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadcountInUse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_headcountInUse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_availableHeadcount(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_availableHeadcount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableHeadcount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_availableHeadcount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_currentAssignment(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_currentAssignment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentAssignment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignment)
	fc.Result = res
	return ec.marshalOPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_currentAssignment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentId":
				return ec.fieldContext_PositionAssignment_assignmentId(ctx, field)
			case "positionCode":
				return ec.fieldContext_PositionAssignment_positionCode(ctx, field)
			case "positionRecordId":
				return ec.fieldContext_PositionAssignment_positionRecordId(ctx, field)
			case "employeeId":
				return ec.fieldContext_PositionAssignment_employeeId(ctx, field)
			case "employeeName":
				return ec.fieldContext_PositionAssignment_employeeName(ctx, field)
			case "employeeNumber":
				return ec.fieldContext_PositionAssignment_employeeNumber(ctx, field)
			case "assignmentType":
				return ec.fieldContext_PositionAssignment_assignmentType(ctx, field)
			case "assignmentStatus":
				return ec.fieldContext_PositionAssignment_assignmentStatus(ctx, field)
			case "fte":
				return ec.fieldContext_PositionAssignment_fte(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionAssignment_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_PositionAssignment_endDate(ctx, field)
			case "actingUntil":
				return ec.fieldContext_PositionAssignment_actingUntil(ctx, field)
			case "autoRevert":
				return ec.fieldContext_PositionAssignment_autoRevert(ctx, field)
			case "reminderSentAt":
				return ec.fieldContext_PositionAssignment_reminderSentAt(ctx, field)
			case "isCurrent":
				return ec.fieldContext_PositionAssignment_isCurrent(ctx, field)
			case "notes":
				return ec.fieldContext_PositionAssignment_notes(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionAssignment_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PositionAssignment_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_assignmentHistory(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_assignmentHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentHistory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionAssignment)
	fc.Result = res
	return ec.marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_assignmentHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentId":
				return ec.fieldContext_PositionAssignment_assignmentId(ctx, field)
			case "positionCode":
				return ec.fieldContext_PositionAssignment_positionCode(ctx, field)
			case "positionRecordId":
				return ec.fieldContext_PositionAssignment_positionRecordId(ctx, field)
			case "employeeId":
				return ec.fieldContext_PositionAssignment_employeeId(ctx, field)
			case "employeeName":
				return ec.fieldContext_PositionAssignment_employeeName(ctx, field)
			case "employeeNumber":
				return ec.fieldContext_PositionAssignment_employeeNumber(ctx, field)
			case "assignmentType":
				return ec.fieldContext_PositionAssignment_assignmentType(ctx, field)
			case "assignmentStatus":
				return ec.fieldContext_PositionAssignment_assignmentStatus(ctx, field)
			case "fte":
				return ec.fieldContext_PositionAssignment_fte(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionAssignment_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_PositionAssignment_endDate(ctx, field)
			case "actingUntil":
				return ec.fieldContext_PositionAssignment_actingUntil(ctx, field)
			case "autoRevert":
				return ec.fieldContext_PositionAssignment_autoRevert(ctx, field)
			case "reminderSentAt":
				return ec.fieldContext_PositionAssignment_reminderSentAt(ctx, field)
			case "isCurrent":
				return ec.fieldContext_PositionAssignment_isCurrent(ctx, field)
			case "notes":
				return ec.fieldContext_PositionAssignment_notes(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionAssignment_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PositionAssignment_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_reportsToPositionCode(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_reportsToPositionCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReportsToPositionCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.PositionCode)
	fc.Result = res
	return ec.marshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_reportsToPositionCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_status(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionStatus)
	fc.Result = res
	return ec.marshalNPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_endDate(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_isFuture(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_isFuture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsFuture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_isFuture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_assignmentId(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_assignmentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_assignmentId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_positionCode(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_positionCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.PositionCode)
	fc.Result = res
	return ec.marshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_positionCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_positionRecordId(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_positionRecordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionRecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_positionRecordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_employeeId(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_employeeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmployeeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_employeeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_employeeName(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_employeeName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmployeeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_employeeName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_employeeNumber(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_employeeNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmployeeNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_employeeNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_assignmentType(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_assignmentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionAssignmentType)
	fc.Result = res
	return ec.marshalNPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_assignmentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionAssignmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_assignmentStatus(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_assignmentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionAssignmentStatus)
	fc.Result = res
	return ec.marshalNPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_assignmentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionAssignmentStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_fte(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_fte(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fte, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_fte(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_endDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_actingUntil(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_actingUntil(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActingUntil, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_actingUntil(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_autoRevert(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_autoRevert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoRevert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_autoRevert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_reminderSentAt(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_reminderSentAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReminderSentAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.DateTime)
	fc.Result = res
	return ec.marshalODateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_reminderSentAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_notes(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_notes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_notes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignment_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignment_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignment_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_assignmentId(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_assignmentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_assignmentId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_eventType(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_endDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_actor(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_actor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_changes(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_changes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(dto.JSON)
	fc.Result = res
	return ec.marshalOJSON2cubecastleinternalorganizationdtoJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_changes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAudit_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAudit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAudit_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAudit_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAudit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAuditConnection_data(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAuditConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAuditConnection_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionAssignmentAudit)
	fc.Result = res
	return ec.marshalNPositionAssignmentAudit2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAudit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAuditConnection_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAuditConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentId":
				return ec.fieldContext_PositionAssignmentAudit_assignmentId(ctx, field)
			case "eventType":
				return ec.fieldContext_PositionAssignmentAudit_eventType(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionAssignmentAudit_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_PositionAssignmentAudit_endDate(ctx, field)
			case "actor":
				return ec.fieldContext_PositionAssignmentAudit_actor(ctx, field)
			case "changes":
				return ec.fieldContext_PositionAssignmentAudit_changes(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionAssignmentAudit_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignmentAudit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAuditConnection_pagination(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAuditConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAuditConnection_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PaginationInfo)
	fc.Result = res
	return ec.marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAuditConnection_pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAuditConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginationInfo_pageSize(ctx, field)
			case "hasNext":
				return ec.fieldContext_PaginationInfo_hasNext(ctx, field)
			case "hasPrevious":
				return ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentAuditConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentAuditConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentAuditConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentAuditConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentAuditConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionAssignmentEdge)
	fc.Result = res
	return ec.marshalNPositionAssignmentEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_PositionAssignmentEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_PositionAssignmentEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignmentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentConnection_pagination(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentConnection_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PaginationInfo)
	fc.Result = res
	return ec.marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentConnection_pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginationInfo_pageSize(ctx, field)
			case "hasNext":
				return ec.fieldContext_PaginationInfo_hasNext(ctx, field)
			case "hasPrevious":
				return ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentConnection_data(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentConnection_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionAssignment)
	fc.Result = res
	return ec.marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentConnection_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentId":
				return ec.fieldContext_PositionAssignment_assignmentId(ctx, field)
			case "positionCode":
				return ec.fieldContext_PositionAssignment_positionCode(ctx, field)
			case "positionRecordId":
				return ec.fieldContext_PositionAssignment_positionRecordId(ctx, field)
			case "employeeId":
				return ec.fieldContext_PositionAssignment_employeeId(ctx, field)
			case "employeeName":
				return ec.fieldContext_PositionAssignment_employeeName(ctx, field)
			case "employeeNumber":
				return ec.fieldContext_PositionAssignment_employeeNumber(ctx, field)
			case "assignmentType":
				return ec.fieldContext_PositionAssignment_assignmentType(ctx, field)
			case "assignmentStatus":
				return ec.fieldContext_PositionAssignment_assignmentStatus(ctx, field)
			case "fte":
				return ec.fieldContext_PositionAssignment_fte(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionAssignment_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_PositionAssignment_endDate(ctx, field)
			case "actingUntil":
				return ec.fieldContext_PositionAssignment_actingUntil(ctx, field)
			case "autoRevert":
				return ec.fieldContext_PositionAssignment_autoRevert(ctx, field)
			case "reminderSentAt":
				return ec.fieldContext_PositionAssignment_reminderSentAt(ctx, field)
			case "isCurrent":
				return ec.fieldContext_PositionAssignment_isCurrent(ctx, field)
			case "notes":
				return ec.fieldContext_PositionAssignment_notes(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionAssignment_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PositionAssignment_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionAssignmentEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.PositionAssignmentEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionAssignmentEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignment)
	fc.Result = res
	return ec.marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionAssignmentEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionAssignmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentId":
				return ec.fieldContext_PositionAssignment_assignmentId(ctx, field)
			case "positionCode":
				return ec.fieldContext_PositionAssignment_positionCode(ctx, field)
			case "positionRecordId":
				return ec.fieldContext_PositionAssignment_positionRecordId(ctx, field)
			case "employeeId":
				return ec.fieldContext_PositionAssignment_employeeId(ctx, field)
			case "employeeName":
				return ec.fieldContext_PositionAssignment_employeeName(ctx, field)
			case "employeeNumber":
				return ec.fieldContext_PositionAssignment_employeeNumber(ctx, field)
			case "assignmentType":
				return ec.fieldContext_PositionAssignment_assignmentType(ctx, field)
			case "assignmentStatus":
				return ec.fieldContext_PositionAssignment_assignmentStatus(ctx, field)
			case "fte":
				return ec.fieldContext_PositionAssignment_fte(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionAssignment_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_PositionAssignment_endDate(ctx, field)
			case "actingUntil":
				return ec.fieldContext_PositionAssignment_actingUntil(ctx, field)
			case "autoRevert":
				return ec.fieldContext_PositionAssignment_autoRevert(ctx, field)
			case "reminderSentAt":
				return ec.fieldContext_PositionAssignment_reminderSentAt(ctx, field)
			case "isCurrent":
				return ec.fieldContext_PositionAssignment_isCurrent(ctx, field)
			case "notes":
				return ec.fieldContext_PositionAssignment_notes(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionAssignment_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PositionAssignment_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.PositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionEdge)
	fc.Result = res
	return ec.marshalNPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_PositionEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_PositionEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionConnection_pagination(ctx context.Context, field graphql.CollectedField, obj *model.PositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionConnection_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PaginationInfo)
	fc.Result = res
	return ec.marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionConnection_pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginationInfo_pageSize(ctx, field)
			case "hasNext":
				return ec.fieldContext_PaginationInfo_hasNext(ctx, field)
			case "hasPrevious":
				return ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionConnection_data(ctx context.Context, field graphql.CollectedField, obj *model.PositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionConnection_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Position)
	fc.Result = res
	return ec.marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionConnection_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Position_code(ctx, field)
			case "recordId":
				return ec.fieldContext_Position_recordId(ctx, field)
			case "tenantId":
				return ec.fieldContext_Position_tenantId(ctx, field)
			case "title":
				return ec.fieldContext_Position_title(ctx, field)
			case "jobProfileCode":
				return ec.fieldContext_Position_jobProfileCode(ctx, field)
			case "jobProfileName":
				return ec.fieldContext_Position_jobProfileName(ctx, field)
			case "jobFamilyGroupCode":
				return ec.fieldContext_Position_jobFamilyGroupCode(ctx, field)
			case "jobFamilyCode":
				return ec.fieldContext_Position_jobFamilyCode(ctx, field)
			case "jobRoleCode":
				return ec.fieldContext_Position_jobRoleCode(ctx, field)
			case "jobLevelCode":
				return ec.fieldContext_Position_jobLevelCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_Position_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_Position_organizationName(ctx, field)
			case "positionType":
				return ec.fieldContext_Position_positionType(ctx, field)
			case "employmentType":
				return ec.fieldContext_Position_employmentType(ctx, field)
			case "gradeLevel":
				return ec.fieldContext_Position_gradeLevel(ctx, field)
			case "headcountCapacity":
				return ec.fieldContext_Position_headcountCapacity(ctx, field)
			case "headcountInUse":
				return ec.fieldContext_Position_headcountInUse(ctx, field)
			case "availableHeadcount":
				return ec.fieldContext_Position_availableHeadcount(ctx, field)
			case "currentAssignment":
				return ec.fieldContext_Position_currentAssignment(ctx, field)
			case "assignmentHistory":
				return ec.fieldContext_Position_assignmentHistory(ctx, field)
			case "reportsToPositionCode":
				return ec.fieldContext_Position_reportsToPositionCode(ctx, field)
			case "status":
				return ec.fieldContext_Position_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Position_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Position_endDate(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Position_isCurrent(ctx, field)
			case "isFuture":
				return ec.fieldContext_Position_isFuture(ctx, field)
			case "createdAt":
				return ec.fieldContext_Position_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Position_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.PositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PositionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.PositionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Position_code(ctx, field)
			case "recordId":
				return ec.fieldContext_Position_recordId(ctx, field)
			case "tenantId":
				return ec.fieldContext_Position_tenantId(ctx, field)
			case "title":
				return ec.fieldContext_Position_title(ctx, field)
			case "jobProfileCode":
				return ec.fieldContext_Position_jobProfileCode(ctx, field)
			case "jobProfileName":
				return ec.fieldContext_Position_jobProfileName(ctx, field)
			case "jobFamilyGroupCode":
				return ec.fieldContext_Position_jobFamilyGroupCode(ctx, field)
			case "jobFamilyCode":
				return ec.fieldContext_Position_jobFamilyCode(ctx, field)
			case "jobRoleCode":
				return ec.fieldContext_Position_jobRoleCode(ctx, field)
			case "jobLevelCode":
				return ec.fieldContext_Position_jobLevelCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_Position_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_Position_organizationName(ctx, field)
			case "positionType":
				return ec.fieldContext_Position_positionType(ctx, field)
			case "employmentType":
				return ec.fieldContext_Position_employmentType(ctx, field)
			case "gradeLevel":
				return ec.fieldContext_Position_gradeLevel(ctx, field)
			case "headcountCapacity":
				return ec.fieldContext_Position_headcountCapacity(ctx, field)
			case "headcountInUse":
				return ec.fieldContext_Position_headcountInUse(ctx, field)
			case "availableHeadcount":
				return ec.fieldContext_Position_availableHeadcount(ctx, field)
			case "currentAssignment":
				return ec.fieldContext_Position_currentAssignment(ctx, field)
			case "assignmentHistory":
				return ec.fieldContext_Position_assignmentHistory(ctx, field)
			case "reportsToPositionCode":
				return ec.fieldContext_Position_reportsToPositionCode(ctx, field)
			case "status":
				return ec.fieldContext_Position_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Position_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Position_endDate(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Position_isCurrent(ctx, field)
			case "isFuture":
				return ec.fieldContext_Position_isFuture(ctx, field)
			case "createdAt":
				return ec.fieldContext_Position_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Position_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_recordId(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_recordId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_recordId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_status(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionStatus)
	fc.Result = res
	return ec.marshalNPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_title(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_endDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.Date)
	fc.Result = res
	return ec.marshalODate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_changeReason(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_changeReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_changeReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_timelineCategory(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_timelineCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimelineCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionTimelineCategory)
	fc.Result = res
	return ec.marshalNPositionTimelineCategory2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_timelineCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionTimelineCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_assignmentType(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_assignmentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignmentType)
	fc.Result = res
	return ec.marshalOPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_assignmentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionAssignmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTimelineEntry_assignmentStatus(ctx context.Context, field graphql.CollectedField, obj *model.PositionTimelineEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTimelineEntry_assignmentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignmentStatus)
	fc.Result = res
	return ec.marshalOPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTimelineEntry_assignmentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTimelineEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionAssignmentStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_transferId(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_transferId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransferID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.UUID)
	fc.Result = res
	return ec.marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_transferId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_positionCode(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_positionCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.PositionCode)
	fc.Result = res
	return ec.marshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_positionCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_fromOrganizationCode(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_fromOrganizationCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromOrganizationCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_fromOrganizationCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_toOrganizationCode(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_toOrganizationCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToOrganizationCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_toOrganizationCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_effectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_effectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_initiatedBy(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_initiatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InitiatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OperatedBy)
	fc.Result = res
	return ec.marshalNOperatedBy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOperatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_initiatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OperatedBy_id(ctx, field)
			case "name":
				return ec.fieldContext_OperatedBy_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OperatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_operationReason(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_operationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_operationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransfer_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransfer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransfer_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.DateTime)
	fc.Result = res
	return ec.marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransfer_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransfer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransferConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransferConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionTransferEdge)
	fc.Result = res
	return ec.marshalNPositionTransferEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransferConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_PositionTransferEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_PositionTransferEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionTransferEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransferConnection_pagination(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransferConnection_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PaginationInfo)
	fc.Result = res
	return ec.marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransferConnection_pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginationInfo_pageSize(ctx, field)
			case "hasNext":
				return ec.fieldContext_PaginationInfo_hasNext(ctx, field)
			case "hasPrevious":
				return ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransferConnection_data(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransferConnection_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionTransfer)
	fc.Result = res
	return ec.marshalNPositionTransfer2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransfer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransferConnection_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "transferId":
				return ec.fieldContext_PositionTransfer_transferId(ctx, field)
			case "positionCode":
				return ec.fieldContext_PositionTransfer_positionCode(ctx, field)
			case "fromOrganizationCode":
				return ec.fieldContext_PositionTransfer_fromOrganizationCode(ctx, field)
			case "toOrganizationCode":
				return ec.fieldContext_PositionTransfer_toOrganizationCode(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionTransfer_effectiveDate(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_PositionTransfer_initiatedBy(ctx, field)
			case "operationReason":
				return ec.fieldContext_PositionTransfer_operationReason(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionTransfer_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionTransfer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransferConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransferConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransferConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransferEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransferEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransferEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransferEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransferEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PositionTransferEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.PositionTransferEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PositionTransferEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionTransfer)
	fc.Result = res
	return ec.marshalNPositionTransfer2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransfer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PositionTransferEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PositionTransferEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "transferId":
				return ec.fieldContext_PositionTransfer_transferId(ctx, field)
			case "positionCode":
				return ec.fieldContext_PositionTransfer_positionCode(ctx, field)
			case "fromOrganizationCode":
				return ec.fieldContext_PositionTransfer_fromOrganizationCode(ctx, field)
			case "toOrganizationCode":
				return ec.fieldContext_PositionTransfer_toOrganizationCode(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionTransfer_effectiveDate(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_PositionTransfer_initiatedBy(ctx, field)
			case "operationReason":
				return ec.fieldContext_PositionTransfer_operationReason(ctx, field)
			case "createdAt":
				return ec.fieldContext_PositionTransfer_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionTransfer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organizations(rctx, fc.Args["filter"].(*model.OrganizationFilter), fc.Args["pagination"].(*model.PaginationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OrganizationConnection)
	fc.Result = res
	return ec.marshalNOrganizationConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_OrganizationConnection_data(ctx, field)
			case "pagination":
				return ec.fieldContext_OrganizationConnection_pagination(ctx, field)
			case "temporal":
				return ec.fieldContext_OrganizationConnection_temporal(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organization(rctx, fc.Args["code"].(string), fc.Args["asOfDate"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalOOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Organization_code(ctx, field)
			case "parentCode":
				return ec.fieldContext_Organization_parentCode(ctx, field)
			case "tenantId":
				return ec.fieldContext_Organization_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "unitType":
				return ec.fieldContext_Organization_unitType(ctx, field)
			case "status":
				return ec.fieldContext_Organization_status(ctx, field)
			case "level":
				return ec.fieldContext_Organization_level(ctx, field)
			case "sortOrder":
				return ec.fieldContext_Organization_sortOrder(ctx, field)
			case "codePath":
				return ec.fieldContext_Organization_codePath(ctx, field)
			case "namePath":
				return ec.fieldContext_Organization_namePath(ctx, field)
			case "path":
				return ec.fieldContext_Organization_path(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "profile":
				return ec.fieldContext_Organization_profile(ctx, field)
			case "changeReason":
				return ec.fieldContext_Organization_changeReason(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Organization_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Organization_endDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "recordId":
				return ec.fieldContext_Organization_recordId(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Organization_isCurrent(ctx, field)
			case "isTemporal":
				return ec.fieldContext_Organization_isTemporal(ctx, field)
			case "isFuture":
				return ec.fieldContext_Organization_isFuture(ctx, field)
			case "hierarchyDepth":
				return ec.fieldContext_Organization_hierarchyDepth(ctx, field)
			case "childrenCount":
				return ec.fieldContext_Organization_childrenCount(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "deletionReason":
				return ec.fieldContext_Organization_deletionReason(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_Organization_suspendedAt(ctx, field)
			case "suspendedBy":
				return ec.fieldContext_Organization_suspendedBy(ctx, field)
			case "suspensionReason":
				return ec.fieldContext_Organization_suspensionReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizationStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizationStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OrganizationStats(rctx, fc.Args["asOfDate"].(*string), fc.Args["includeHistorical"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OrganizationStats)
	fc.Result = res
	return ec.marshalNOrganizationStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizationStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalCount":
				return ec.fieldContext_OrganizationStats_totalCount(ctx, field)
			case "activeCount":
				return ec.fieldContext_OrganizationStats_activeCount(ctx, field)
			case "inactiveCount":
				return ec.fieldContext_OrganizationStats_inactiveCount(ctx, field)
			case "plannedCount":
				return ec.fieldContext_OrganizationStats_plannedCount(ctx, field)
			case "deletedCount":
				return ec.fieldContext_OrganizationStats_deletedCount(ctx, field)
			case "byType":
				return ec.fieldContext_OrganizationStats_byType(ctx, field)
			case "byStatus":
				return ec.fieldContext_OrganizationStats_byStatus(ctx, field)
			case "byLevel":
				return ec.fieldContext_OrganizationStats_byLevel(ctx, field)
			case "temporalStats":
				return ec.fieldContext_OrganizationStats_temporalStats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizationStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizationHierarchy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizationHierarchy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OrganizationHierarchy(rctx, fc.Args["code"].(string), fc.Args["tenantId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OrganizationHierarchy)
	fc.Result = res
	return ec.marshalOOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizationHierarchy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_OrganizationHierarchy_code(ctx, field)
			case "name":
				return ec.fieldContext_OrganizationHierarchy_name(ctx, field)
			case "level":
				return ec.fieldContext_OrganizationHierarchy_level(ctx, field)
			case "hierarchyDepth":
				return ec.fieldContext_OrganizationHierarchy_hierarchyDepth(ctx, field)
			case "codePath":
				return ec.fieldContext_OrganizationHierarchy_codePath(ctx, field)
			case "namePath":
				return ec.fieldContext_OrganizationHierarchy_namePath(ctx, field)
			case "parentChain":
				return ec.fieldContext_OrganizationHierarchy_parentChain(ctx, field)
			case "childrenCount":
				return ec.fieldContext_OrganizationHierarchy_childrenCount(ctx, field)
			case "isRoot":
				return ec.fieldContext_OrganizationHierarchy_isRoot(ctx, field)
			case "isLeaf":
				return ec.fieldContext_OrganizationHierarchy_isLeaf(ctx, field)
			case "children":
				return ec.fieldContext_OrganizationHierarchy_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationHierarchy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizationHierarchy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizationSubtree(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizationSubtree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OrganizationSubtree(rctx, fc.Args["code"].(string), fc.Args["tenantId"].(string), fc.Args["maxDepth"].(*int), fc.Args["includeInactive"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.OrganizationHierarchy)
	fc.Result = res
	return ec.marshalNOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizationSubtree(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_OrganizationHierarchy_code(ctx, field)
			case "name":
				return ec.fieldContext_OrganizationHierarchy_name(ctx, field)
			case "level":
				return ec.fieldContext_OrganizationHierarchy_level(ctx, field)
			case "hierarchyDepth":
				return ec.fieldContext_OrganizationHierarchy_hierarchyDepth(ctx, field)
			case "codePath":
				return ec.fieldContext_OrganizationHierarchy_codePath(ctx, field)
			case "namePath":
				return ec.fieldContext_OrganizationHierarchy_namePath(ctx, field)
			case "parentChain":
				return ec.fieldContext_OrganizationHierarchy_parentChain(ctx, field)
			case "childrenCount":
				return ec.fieldContext_OrganizationHierarchy_childrenCount(ctx, field)
			case "isRoot":
				return ec.fieldContext_OrganizationHierarchy_isRoot(ctx, field)
			case "isLeaf":
				return ec.fieldContext_OrganizationHierarchy_isLeaf(ctx, field)
			case "children":
				return ec.fieldContext_OrganizationHierarchy_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationHierarchy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizationSubtree_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hierarchyStatistics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hierarchyStatistics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HierarchyStatistics(rctx, fc.Args["tenantId"].(string), fc.Args["includeIntegrityCheck"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HierarchyStatistics)
	fc.Result = res
	return ec.marshalNHierarchyStatistics2cubecastlecmdhrmsserverqueryinternalgraphqlmodelHierarchyStatistics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hierarchyStatistics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tenantId":
				return ec.fieldContext_HierarchyStatistics_tenantId(ctx, field)
			case "totalOrganizations":
				return ec.fieldContext_HierarchyStatistics_totalOrganizations(ctx, field)
			case "maxDepth":
				return ec.fieldContext_HierarchyStatistics_maxDepth(ctx, field)
			case "avgDepth":
				return ec.fieldContext_HierarchyStatistics_avgDepth(ctx, field)
			case "depthDistribution":
				return ec.fieldContext_HierarchyStatistics_depthDistribution(ctx, field)
			case "rootOrganizations":
				return ec.fieldContext_HierarchyStatistics_rootOrganizations(ctx, field)
			case "leafOrganizations":
				return ec.fieldContext_HierarchyStatistics_leafOrganizations(ctx, field)
			case "integrityIssues":
				return ec.fieldContext_HierarchyStatistics_integrityIssues(ctx, field)
			case "lastAnalyzed":
				return ec.fieldContext_HierarchyStatistics_lastAnalyzed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HierarchyStatistics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hierarchyStatistics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Positions(rctx, fc.Args["filter"].(*model.PositionFilterInput), fc.Args["pagination"].(*model.PaginationInput), fc.Args["sorting"].([]model.PositionSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionConnection)
	fc.Result = res
	return ec.marshalNPositionConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PositionConnection_edges(ctx, field)
			case "pagination":
				return ec.fieldContext_PositionConnection_pagination(ctx, field)
			case "data":
				return ec.fieldContext_PositionConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_PositionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_position(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Position(rctx, fc.Args["code"].(dto.PositionCode), fc.Args["asOfDate"].(*dto.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalOPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_position(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Position_code(ctx, field)
			case "recordId":
				return ec.fieldContext_Position_recordId(ctx, field)
			case "tenantId":
				return ec.fieldContext_Position_tenantId(ctx, field)
			case "title":
				return ec.fieldContext_Position_title(ctx, field)
			case "jobProfileCode":
				return ec.fieldContext_Position_jobProfileCode(ctx, field)
			case "jobProfileName":
				return ec.fieldContext_Position_jobProfileName(ctx, field)
			case "jobFamilyGroupCode":
				return ec.fieldContext_Position_jobFamilyGroupCode(ctx, field)
			case "jobFamilyCode":
				return ec.fieldContext_Position_jobFamilyCode(ctx, field)
			case "jobRoleCode":
				return ec.fieldContext_Position_jobRoleCode(ctx, field)
			case "jobLevelCode":
				return ec.fieldContext_Position_jobLevelCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_Position_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_Position_organizationName(ctx, field)
			case "positionType":
				return ec.fieldContext_Position_positionType(ctx, field)
			case "employmentType":
				return ec.fieldContext_Position_employmentType(ctx, field)
			case "gradeLevel":
				return ec.fieldContext_Position_gradeLevel(ctx, field)
			case "headcountCapacity":
				return ec.fieldContext_Position_headcountCapacity(ctx, field)
			case "headcountInUse":
				return ec.fieldContext_Position_headcountInUse(ctx, field)
			case "availableHeadcount":
				return ec.fieldContext_Position_availableHeadcount(ctx, field)
			case "currentAssignment":
				return ec.fieldContext_Position_currentAssignment(ctx, field)
			case "assignmentHistory":
				return ec.fieldContext_Position_assignmentHistory(ctx, field)
			case "reportsToPositionCode":
				return ec.fieldContext_Position_reportsToPositionCode(ctx, field)
			case "status":
				return ec.fieldContext_Position_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Position_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Position_endDate(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Position_isCurrent(ctx, field)
			case "isFuture":
				return ec.fieldContext_Position_isFuture(ctx, field)
			case "createdAt":
				return ec.fieldContext_Position_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Position_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_position_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positionTimeline(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positionTimeline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PositionTimeline(rctx, fc.Args["code"].(dto.PositionCode), fc.Args["startDate"].(*dto.Date), fc.Args["endDate"].(*dto.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.PositionTimelineEntry)
	fc.Result = res
	return ec.marshalNPositionTimelineEntry2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positionTimeline(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "recordId":
				return ec.fieldContext_PositionTimelineEntry_recordId(ctx, field)
			case "status":
				return ec.fieldContext_PositionTimelineEntry_status(ctx, field)
			case "title":
				return ec.fieldContext_PositionTimelineEntry_title(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_PositionTimelineEntry_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_PositionTimelineEntry_endDate(ctx, field)
			case "isCurrent":
				return ec.fieldContext_PositionTimelineEntry_isCurrent(ctx, field)
			case "changeReason":
				return ec.fieldContext_PositionTimelineEntry_changeReason(ctx, field)
			case "timelineCategory":
				return ec.fieldContext_PositionTimelineEntry_timelineCategory(ctx, field)
			case "assignmentType":
				return ec.fieldContext_PositionTimelineEntry_assignmentType(ctx, field)
			case "assignmentStatus":
				return ec.fieldContext_PositionTimelineEntry_assignmentStatus(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionTimelineEntry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positionTimeline_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positionVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positionVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PositionVersions(rctx, fc.Args["code"].(dto.PositionCode), fc.Args["includeDeleted"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Position)
	fc.Result = res
	return ec.marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positionVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Position_code(ctx, field)
			case "recordId":
				return ec.fieldContext_Position_recordId(ctx, field)
			case "tenantId":
				return ec.fieldContext_Position_tenantId(ctx, field)
			case "title":
				return ec.fieldContext_Position_title(ctx, field)
			case "jobProfileCode":
				return ec.fieldContext_Position_jobProfileCode(ctx, field)
			case "jobProfileName":
				return ec.fieldContext_Position_jobProfileName(ctx, field)
			case "jobFamilyGroupCode":
				return ec.fieldContext_Position_jobFamilyGroupCode(ctx, field)
			case "jobFamilyCode":
				return ec.fieldContext_Position_jobFamilyCode(ctx, field)
			case "jobRoleCode":
				return ec.fieldContext_Position_jobRoleCode(ctx, field)
			case "jobLevelCode":
				return ec.fieldContext_Position_jobLevelCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_Position_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_Position_organizationName(ctx, field)
			case "positionType":
				return ec.fieldContext_Position_positionType(ctx, field)
			case "employmentType":
				return ec.fieldContext_Position_employmentType(ctx, field)
			case "gradeLevel":
				return ec.fieldContext_Position_gradeLevel(ctx, field)
			case "headcountCapacity":
				return ec.fieldContext_Position_headcountCapacity(ctx, field)
			case "headcountInUse":
				return ec.fieldContext_Position_headcountInUse(ctx, field)
			case "availableHeadcount":
				return ec.fieldContext_Position_availableHeadcount(ctx, field)
			case "currentAssignment":
				return ec.fieldContext_Position_currentAssignment(ctx, field)
			case "assignmentHistory":
				return ec.fieldContext_Position_assignmentHistory(ctx, field)
			case "reportsToPositionCode":
				return ec.fieldContext_Position_reportsToPositionCode(ctx, field)
			case "status":
				return ec.fieldContext_Position_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Position_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Position_endDate(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Position_isCurrent(ctx, field)
			case "isFuture":
				return ec.fieldContext_Position_isFuture(ctx, field)
			case "createdAt":
				return ec.fieldContext_Position_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Position_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positionVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positionAssignments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positionAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PositionAssignments(rctx, fc.Args["positionCode"].(dto.PositionCode), fc.Args["filter"].(*model.PositionAssignmentFilterInput), fc.Args["pagination"].(*model.PaginationInput), fc.Args["sorting"].([]model.PositionAssignmentSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignmentConnection)
	fc.Result = res
	return ec.marshalNPositionAssignmentConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positionAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PositionAssignmentConnection_edges(ctx, field)
			case "pagination":
				return ec.fieldContext_PositionAssignmentConnection_pagination(ctx, field)
			case "data":
				return ec.fieldContext_PositionAssignmentConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_PositionAssignmentConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignmentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positionAssignments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positionAssignmentAudit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positionAssignmentAudit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PositionAssignmentAudit(rctx, fc.Args["positionCode"].(dto.PositionCode), fc.Args["assignmentId"].(*dto.UUID), fc.Args["dateRange"].(*model.DateRangeInput), fc.Args["pagination"].(*model.PaginationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignmentAuditConnection)
	fc.Result = res
	return ec.marshalNPositionAssignmentAuditConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAuditConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positionAssignmentAudit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_PositionAssignmentAuditConnection_data(ctx, field)
			case "pagination":
				return ec.fieldContext_PositionAssignmentAuditConnection_pagination(ctx, field)
			case "totalCount":
				return ec.fieldContext_PositionAssignmentAuditConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignmentAuditConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positionAssignmentAudit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_assignments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_assignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Assignments(rctx, fc.Args["organizationCode"].(*string), fc.Args["positionCode"].(*dto.PositionCode), fc.Args["filter"].(*model.PositionAssignmentFilterInput), fc.Args["pagination"].(*model.PaginationInput), fc.Args["sorting"].([]model.PositionAssignmentSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignmentConnection)
	fc.Result = res
	return ec.marshalNPositionAssignmentConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_assignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PositionAssignmentConnection_edges(ctx, field)
			case "pagination":
				return ec.fieldContext_PositionAssignmentConnection_pagination(ctx, field)
			case "data":
				return ec.fieldContext_PositionAssignmentConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_PositionAssignmentConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignmentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_assignments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_assignmentHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_assignmentHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AssignmentHistory(rctx, fc.Args["positionCode"].(dto.PositionCode), fc.Args["filter"].(*model.PositionAssignmentFilterInput), fc.Args["pagination"].(*model.PaginationInput), fc.Args["sorting"].([]model.PositionAssignmentSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionAssignmentConnection)
	fc.Result = res
	return ec.marshalNPositionAssignmentConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_assignmentHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PositionAssignmentConnection_edges(ctx, field)
			case "pagination":
				return ec.fieldContext_PositionAssignmentConnection_pagination(ctx, field)
			case "data":
				return ec.fieldContext_PositionAssignmentConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_PositionAssignmentConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionAssignmentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_assignmentHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_assignmentStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_assignmentStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AssignmentStats(rctx, fc.Args["organizationCode"].(*string), fc.Args["positionCode"].(*dto.PositionCode))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AssignmentStats)
	fc.Result = res
	return ec.marshalNAssignmentStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAssignmentStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_assignmentStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "positionCode":
				return ec.fieldContext_AssignmentStats_positionCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_AssignmentStats_organizationCode(ctx, field)
			case "totalAssignments":
				return ec.fieldContext_AssignmentStats_totalAssignments(ctx, field)
			case "activeAssignments":
				return ec.fieldContext_AssignmentStats_activeAssignments(ctx, field)
			case "pendingAssignments":
				return ec.fieldContext_AssignmentStats_pendingAssignments(ctx, field)
			case "endedAssignments":
				return ec.fieldContext_AssignmentStats_endedAssignments(ctx, field)
			case "primaryAssignments":
				return ec.fieldContext_AssignmentStats_primaryAssignments(ctx, field)
			case "secondaryAssignments":
				return ec.fieldContext_AssignmentStats_secondaryAssignments(ctx, field)
			case "actingAssignments":
				return ec.fieldContext_AssignmentStats_actingAssignments(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_AssignmentStats_lastUpdatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AssignmentStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_assignmentStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_vacantPositions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_vacantPositions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().VacantPositions(rctx, fc.Args["filter"].(*model.VacantPositionFilterInput), fc.Args["pagination"].(*model.PaginationInput), fc.Args["sorting"].([]model.VacantPositionSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VacantPositionConnection)
	fc.Result = res
	return ec.marshalNVacantPositionConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_vacantPositions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_VacantPositionConnection_edges(ctx, field)
			case "pagination":
				return ec.fieldContext_VacantPositionConnection_pagination(ctx, field)
			case "data":
				return ec.fieldContext_VacantPositionConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_VacantPositionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VacantPositionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_vacantPositions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positionTransfers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positionTransfers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PositionTransfers(rctx, fc.Args["positionCode"].(*dto.PositionCode), fc.Args["organizationCode"].(*string), fc.Args["pagination"].(*model.PaginationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PositionTransferConnection)
	fc.Result = res
	return ec.marshalNPositionTransferConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positionTransfers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PositionTransferConnection_edges(ctx, field)
			case "pagination":
				return ec.fieldContext_PositionTransferConnection_pagination(ctx, field)
			case "data":
				return ec.fieldContext_PositionTransferConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_PositionTransferConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PositionTransferConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positionTransfers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_positionHeadcountStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_positionHeadcountStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PositionHeadcountStats(rctx, fc.Args["organizationCode"].(string), fc.Args["includeSubordinates"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HeadcountStats)
	fc.Result = res
	return ec.marshalNHeadcountStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelHeadcountStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_positionHeadcountStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "organizationCode":
				return ec.fieldContext_HeadcountStats_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_HeadcountStats_organizationName(ctx, field)
			case "totalCapacity":
				return ec.fieldContext_HeadcountStats_totalCapacity(ctx, field)
			case "totalFilled":
				return ec.fieldContext_HeadcountStats_totalFilled(ctx, field)
			case "totalAvailable":
				return ec.fieldContext_HeadcountStats_totalAvailable(ctx, field)
			case "fillRate":
				return ec.fieldContext_HeadcountStats_fillRate(ctx, field)
			case "byLevel":
				return ec.fieldContext_HeadcountStats_byLevel(ctx, field)
			case "byType":
				return ec.fieldContext_HeadcountStats_byType(ctx, field)
			case "byFamily":
				return ec.fieldContext_HeadcountStats_byFamily(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HeadcountStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_positionHeadcountStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_auditHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_auditHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AuditHistory(rctx, fc.Args["recordId"].(string), fc.Args["startDate"].(*string), fc.Args["endDate"].(*string), fc.Args["operation"].(*model.OperationType), fc.Args["userId"].(*string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AuditLogDetail)
	fc.Result = res
	return ec.marshalNAuditLogDetail2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAuditLogDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_auditHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "auditId":
				return ec.fieldContext_AuditLogDetail_auditId(ctx, field)
			case "recordId":
				return ec.fieldContext_AuditLogDetail_recordId(ctx, field)
			case "operation":
				return ec.fieldContext_AuditLogDetail_operation(ctx, field)
			case "timestamp":
				return ec.fieldContext_AuditLogDetail_timestamp(ctx, field)
			case "operationReason":
				return ec.fieldContext_AuditLogDetail_operationReason(ctx, field)
			case "beforeData":
				return ec.fieldContext_AuditLogDetail_beforeData(ctx, field)
			case "afterData":
				return ec.fieldContext_AuditLogDetail_afterData(ctx, field)
			case "modifiedFields":
				return ec.fieldContext_AuditLogDetail_modifiedFields(ctx, field)
			case "changes":
				return ec.fieldContext_AuditLogDetail_changes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuditLogDetail", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_auditHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_auditLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_auditLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AuditLog(rctx, fc.Args["auditId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuditLogDetail)
	fc.Result = res
	return ec.marshalOAuditLogDetail2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAuditLogDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_auditLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "auditId":
				return ec.fieldContext_AuditLogDetail_auditId(ctx, field)
			case "recordId":
				return ec.fieldContext_AuditLogDetail_recordId(ctx, field)
			case "operation":
				return ec.fieldContext_AuditLogDetail_operation(ctx, field)
			case "timestamp":
				return ec.fieldContext_AuditLogDetail_timestamp(ctx, field)
			case "operationReason":
				return ec.fieldContext_AuditLogDetail_operationReason(ctx, field)
			case "beforeData":
				return ec.fieldContext_AuditLogDetail_beforeData(ctx, field)
			case "afterData":
				return ec.fieldContext_AuditLogDetail_afterData(ctx, field)
			case "modifiedFields":
				return ec.fieldContext_AuditLogDetail_modifiedFields(ctx, field)
			case "changes":
				return ec.fieldContext_AuditLogDetail_changes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuditLogDetail", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_auditLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizationVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizationVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OrganizationVersions(rctx, fc.Args["code"].(string), fc.Args["includeDeleted"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizationVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Organization_code(ctx, field)
			case "parentCode":
				return ec.fieldContext_Organization_parentCode(ctx, field)
			case "tenantId":
				return ec.fieldContext_Organization_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "unitType":
				return ec.fieldContext_Organization_unitType(ctx, field)
			case "status":
				return ec.fieldContext_Organization_status(ctx, field)
			case "level":
				return ec.fieldContext_Organization_level(ctx, field)
			case "sortOrder":
				return ec.fieldContext_Organization_sortOrder(ctx, field)
			case "codePath":
				return ec.fieldContext_Organization_codePath(ctx, field)
			case "namePath":
				return ec.fieldContext_Organization_namePath(ctx, field)
			case "path":
				return ec.fieldContext_Organization_path(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "profile":
				return ec.fieldContext_Organization_profile(ctx, field)
			case "changeReason":
				return ec.fieldContext_Organization_changeReason(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_Organization_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Organization_endDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "recordId":
				return ec.fieldContext_Organization_recordId(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Organization_isCurrent(ctx, field)
			case "isTemporal":
				return ec.fieldContext_Organization_isTemporal(ctx, field)
			case "isFuture":
				return ec.fieldContext_Organization_isFuture(ctx, field)
			case "hierarchyDepth":
				return ec.fieldContext_Organization_hierarchyDepth(ctx, field)
			case "childrenCount":
				return ec.fieldContext_Organization_childrenCount(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "deletionReason":
				return ec.fieldContext_Organization_deletionReason(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_Organization_suspendedAt(ctx, field)
			case "suspendedBy":
				return ec.fieldContext_Organization_suspendedBy(ctx, field)
			case "suspensionReason":
				return ec.fieldContext_Organization_suspensionReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizationVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_jobFamilyGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_jobFamilyGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().JobFamilyGroups(rctx, fc.Args["includeInactive"].(*bool), fc.Args["asOfDate"].(*dto.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.JobFamilyGroup)
	fc.Result = res
	return ec.marshalNJobFamilyGroup2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamilyGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_jobFamilyGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_JobFamilyGroup_code(ctx, field)
			case "recordId":
				return ec.fieldContext_JobFamilyGroup_recordId(ctx, field)
			case "name":
				return ec.fieldContext_JobFamilyGroup_name(ctx, field)
			case "status":
				return ec.fieldContext_JobFamilyGroup_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_JobFamilyGroup_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_JobFamilyGroup_endDate(ctx, field)
			case "description":
				return ec.fieldContext_JobFamilyGroup_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobFamilyGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_jobFamilyGroups_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_jobFamilies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_jobFamilies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().JobFamilies(rctx, fc.Args["groupCode"].(dto.JobFamilyGroupCode), fc.Args["includeInactive"].(*bool), fc.Args["asOfDate"].(*dto.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.JobFamily)
	fc.Result = res
	return ec.marshalNJobFamily2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamily(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_jobFamilies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_JobFamily_code(ctx, field)
			case "recordId":
				return ec.fieldContext_JobFamily_recordId(ctx, field)
			case "groupCode":
				return ec.fieldContext_JobFamily_groupCode(ctx, field)
			case "name":
				return ec.fieldContext_JobFamily_name(ctx, field)
			case "status":
				return ec.fieldContext_JobFamily_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_JobFamily_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_JobFamily_endDate(ctx, field)
			case "description":
				return ec.fieldContext_JobFamily_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobFamily", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_jobFamilies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_jobRoles(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_jobRoles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().JobRoles(rctx, fc.Args["familyCode"].(dto.JobFamilyCode), fc.Args["includeInactive"].(*bool), fc.Args["asOfDate"].(*dto.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.JobRole)
	fc.Result = res
	return ec.marshalNJobRole2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_jobRoles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_JobRole_code(ctx, field)
			case "recordId":
				return ec.fieldContext_JobRole_recordId(ctx, field)
			case "familyCode":
				return ec.fieldContext_JobRole_familyCode(ctx, field)
			case "name":
				return ec.fieldContext_JobRole_name(ctx, field)
			case "status":
				return ec.fieldContext_JobRole_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_JobRole_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_JobRole_endDate(ctx, field)
			case "description":
				return ec.fieldContext_JobRole_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobRole", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_jobRoles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_jobLevels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_jobLevels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().JobLevels(rctx, fc.Args["roleCode"].(dto.JobRoleCode), fc.Args["includeInactive"].(*bool), fc.Args["asOfDate"].(*dto.Date))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.JobLevel)
	fc.Result = res
	return ec.marshalNJobLevel2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_jobLevels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_JobLevel_code(ctx, field)
			case "recordId":
				return ec.fieldContext_JobLevel_recordId(ctx, field)
			case "roleCode":
				return ec.fieldContext_JobLevel_roleCode(ctx, field)
			case "name":
				return ec.fieldContext_JobLevel_name(ctx, field)
			case "status":
				return ec.fieldContext_JobLevel_status(ctx, field)
			case "effectiveDate":
				return ec.fieldContext_JobLevel_effectiveDate(ctx, field)
			case "endDate":
				return ec.fieldContext_JobLevel_endDate(ctx, field)
			case "levelRank":
				return ec.fieldContext_JobLevel_levelRank(ctx, field)
			case "description":
				return ec.fieldContext_JobLevel_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobLevel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_jobLevels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepairSuggestion_issueType(ctx context.Context, field graphql.CollectedField, obj *model.RepairSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepairSuggestion_issueType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepairSuggestion_issueType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepairSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepairSuggestion_affectedCodes(ctx context.Context, field graphql.CollectedField, obj *model.RepairSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepairSuggestion_affectedCodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedCodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepairSuggestion_affectedCodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepairSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepairSuggestion_suggestedAction(ctx context.Context, field graphql.CollectedField, obj *model.RepairSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepairSuggestion_suggestedAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepairSuggestion_suggestedAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepairSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepairSuggestion_automatable(ctx context.Context, field graphql.CollectedField, obj *model.RepairSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepairSuggestion_automatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Automatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepairSuggestion_automatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepairSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepairSuggestion_riskLevel(ctx context.Context, field graphql.CollectedField, obj *model.RepairSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepairSuggestion_riskLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiskLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepairSuggestion_riskLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepairSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusStatistic_status(ctx context.Context, field graphql.CollectedField, obj *model.StatusStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusStatistic_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Status)
	fc.Result = res
	return ec.marshalNStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusStatistic_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Status does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusStatistic_count(ctx context.Context, field graphql.CollectedField, obj *model.StatusStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusStatistic_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusStatistic_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalInfo_asOfDate(ctx context.Context, field graphql.CollectedField, obj *model.TemporalInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalInfo_asOfDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AsOfDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalInfo_asOfDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalInfo_currentCount(ctx context.Context, field graphql.CollectedField, obj *model.TemporalInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalInfo_currentCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalInfo_currentCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalInfo_futureCount(ctx context.Context, field graphql.CollectedField, obj *model.TemporalInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalInfo_futureCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FutureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalInfo_futureCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalInfo_historicalCount(ctx context.Context, field graphql.CollectedField, obj *model.TemporalInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalInfo_historicalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HistoricalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalInfo_historicalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalStatistics_totalVersions(ctx context.Context, field graphql.CollectedField, obj *model.TemporalStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalStatistics_totalVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalStatistics_totalVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalStatistics_averageVersionsPerOrg(ctx context.Context, field graphql.CollectedField, obj *model.TemporalStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalStatistics_averageVersionsPerOrg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AverageVersionsPerOrg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalStatistics_averageVersionsPerOrg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalStatistics_oldestEffectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.TemporalStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalStatistics_oldestEffectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestEffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalStatistics_oldestEffectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TemporalStatistics_newestEffectiveDate(ctx context.Context, field graphql.CollectedField, obj *model.TemporalStatistics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TemporalStatistics_newestEffectiveDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewestEffectiveDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TemporalStatistics_newestEffectiveDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TemporalStatistics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeHeadcount_positionType(ctx context.Context, field graphql.CollectedField, obj *model.TypeHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeHeadcount_positionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PositionType)
	fc.Result = res
	return ec.marshalNPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeHeadcount_positionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeHeadcount_capacity(ctx context.Context, field graphql.CollectedField, obj *model.TypeHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeHeadcount_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeHeadcount_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeHeadcount_filled(ctx context.Context, field graphql.CollectedField, obj *model.TypeHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeHeadcount_filled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeHeadcount_filled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeHeadcount_available(ctx context.Context, field graphql.CollectedField, obj *model.TypeHeadcount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeHeadcount_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeHeadcount_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeHeadcount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeStatistic_unitType(ctx context.Context, field graphql.CollectedField, obj *model.TypeStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeStatistic_unitType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnitType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UnitType)
	fc.Result = res
	return ec.marshalNUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeStatistic_unitType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UnitType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeStatistic_count(ctx context.Context, field graphql.CollectedField, obj *model.TypeStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeStatistic_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeStatistic_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserInfo_userId(ctx context.Context, field graphql.CollectedField, obj *model.UserInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserInfo_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserInfo_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserInfo_userName(ctx context.Context, field graphql.CollectedField, obj *model.UserInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserInfo_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserInfo_userName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserInfo_role(ctx context.Context, field graphql.CollectedField, obj *model.UserInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserInfo_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserInfo_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_positionCode(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_positionCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PositionCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.PositionCode)
	fc.Result = res
	return ec.marshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_positionCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PositionCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_organizationCode(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_organizationCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_organizationCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_organizationName(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_organizationName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_organizationName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_jobFamilyCode(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_jobFamilyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobFamilyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobFamilyCode)
	fc.Result = res
	return ec.marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_jobFamilyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobFamilyCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_jobRoleCode(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_jobRoleCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobRoleCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobRoleCode)
	fc.Result = res
	return ec.marshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_jobRoleCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobRoleCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_jobLevelCode(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_jobLevelCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobLevelCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.JobLevelCode)
	fc.Result = res
	return ec.marshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_jobLevelCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobLevelCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_vacantSince(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_vacantSince(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VacantSince, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(dto.Date)
	fc.Result = res
	return ec.marshalNDate2cubecastleinternalorganizationdtoDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_vacantSince(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_headcountCapacity(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_headcountCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadcountCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_headcountCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_headcountAvailable(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_headcountAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadcountAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_headcountAvailable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPosition_totalAssignments(ctx context.Context, field graphql.CollectedField, obj *model.VacantPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPosition_totalAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalAssignments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPosition_totalAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPositionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.VacantPositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPositionConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VacantPositionEdge)
	fc.Result = res
	return ec.marshalNVacantPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPositionConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_VacantPositionEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_VacantPositionEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VacantPositionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPositionConnection_pagination(ctx context.Context, field graphql.CollectedField, obj *model.VacantPositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPositionConnection_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PaginationInfo)
	fc.Result = res
	return ec.marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPositionConnection_pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PaginationInfo_total(ctx, field)
			case "page":
				return ec.fieldContext_PaginationInfo_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginationInfo_pageSize(ctx, field)
			case "hasNext":
				return ec.fieldContext_PaginationInfo_hasNext(ctx, field)
			case "hasPrevious":
				return ec.fieldContext_PaginationInfo_hasPrevious(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginationInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPositionConnection_data(ctx context.Context, field graphql.CollectedField, obj *model.VacantPositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPositionConnection_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VacantPosition)
	fc.Result = res
	return ec.marshalNVacantPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPositionConnection_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "positionCode":
				return ec.fieldContext_VacantPosition_positionCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_VacantPosition_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_VacantPosition_organizationName(ctx, field)
			case "jobFamilyCode":
				return ec.fieldContext_VacantPosition_jobFamilyCode(ctx, field)
			case "jobRoleCode":
				return ec.fieldContext_VacantPosition_jobRoleCode(ctx, field)
			case "jobLevelCode":
				return ec.fieldContext_VacantPosition_jobLevelCode(ctx, field)
			case "vacantSince":
				return ec.fieldContext_VacantPosition_vacantSince(ctx, field)
			case "headcountCapacity":
				return ec.fieldContext_VacantPosition_headcountCapacity(ctx, field)
			case "headcountAvailable":
				return ec.fieldContext_VacantPosition_headcountAvailable(ctx, field)
			case "totalAssignments":
				return ec.fieldContext_VacantPosition_totalAssignments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VacantPosition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPositionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.VacantPositionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPositionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPositionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPositionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPositionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.VacantPositionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPositionEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPositionEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPositionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VacantPositionEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.VacantPositionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VacantPositionEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VacantPosition)
	fc.Result = res
	return ec.marshalNVacantPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VacantPositionEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VacantPositionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "positionCode":
				return ec.fieldContext_VacantPosition_positionCode(ctx, field)
			case "organizationCode":
				return ec.fieldContext_VacantPosition_organizationCode(ctx, field)
			case "organizationName":
				return ec.fieldContext_VacantPosition_organizationName(ctx, field)
			case "jobFamilyCode":
				return ec.fieldContext_VacantPosition_jobFamilyCode(ctx, field)
			case "jobRoleCode":
				return ec.fieldContext_VacantPosition_jobRoleCode(ctx, field)
			case "jobLevelCode":
				return ec.fieldContext_VacantPosition_jobLevelCode(ctx, field)
			case "vacantSince":
				return ec.fieldContext_VacantPosition_vacantSince(ctx, field)
			case "headcountCapacity":
				return ec.fieldContext_VacantPosition_headcountCapacity(ctx, field)
			case "headcountAvailable":
				return ec.fieldContext_VacantPosition_headcountAvailable(ctx, field)
			case "totalAssignments":
				return ec.fieldContext_VacantPosition_totalAssignments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VacantPosition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputDateRangeInput(ctx context.Context, obj interface{}) (*model.DateRangeInput, error) {
	var it model.DateRangeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"from", "to"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "from":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.From = data
		case "to":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.To = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputOrganizationFilter(ctx context.Context, obj interface{}) (*model.OrganizationFilter, error) {
	var it model.OrganizationFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["includeFuture"]; !present {
		asMap["includeFuture"] = false
	}
	if _, present := asMap["onlyFuture"]; !present {
		asMap["onlyFuture"] = false
	}
	if _, present := asMap["includeDisabledAncestors"]; !present {
		asMap["includeDisabledAncestors"] = false
	}
	if _, present := asMap["rootsOnly"]; !present {
		asMap["rootsOnly"] = false
	}
	if _, present := asMap["leavesOnly"]; !present {
		asMap["leavesOnly"] = false
	}
	if _, present := asMap["searchFields"]; !present {
		asMap["searchFields"] = []interface{}{"NAME", "DESCRIPTION"}
	}

	fieldsInOrder := [...]string{"asOfDate", "includeFuture", "onlyFuture", "unitType", "status", "parentCode", "codes", "excludeCodes", "excludeDescendantsOf", "includeDisabledAncestors", "level", "minLevel", "maxLevel", "rootsOnly", "leavesOnly", "searchText", "searchFields", "hasChildren", "hasProfile", "profileContains", "operationType", "operatedBy", "operationDateRange"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "asOfDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.AsOfDate = data
		case "includeFuture":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeFuture"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.IncludeFuture = data
		case "onlyFuture":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlyFuture"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.OnlyFuture = data
		case "unitType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitType"))
			data, err := ec.unmarshalOUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx, v)
			if err != nil {
				return &it, err
			}
			it.UnitType = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Status = data
		case "parentCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentCode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.ParentCode = data
		case "codes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Codes = data
		case "excludeCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeCodes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.ExcludeCodes = data
		case "excludeDescendantsOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeDescendantsOf"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.ExcludeDescendantsOf = data
		case "includeDisabledAncestors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDisabledAncestors"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.IncludeDisabledAncestors = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Level = data
		case "minLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minLevel"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return &it, err
			}
			it.MinLevel = data
		case "maxLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLevel"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return &it, err
			}
			it.MaxLevel = data
		case "rootsOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootsOnly"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.RootsOnly = data
		case "leavesOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("leavesOnly"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.LeavesOnly = data
		case "searchText":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchText"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.SearchText = data
		case "searchFields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchFields"))
			data, err := ec.unmarshalOSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx, v)
			if err != nil {
				return &it, err
			}
			it.SearchFields = data
		case "hasChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildren"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.HasChildren = data
		case "hasProfile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProfile"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.HasProfile = data
		case "profileContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("profileContains"))
			data, err := ec.unmarshalOJSON2cubecastleinternalorganizationdtoJSON(ctx, v)
			if err != nil {
				return &it, err
			}
			it.ProfileContains = data
		case "operationType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationType"))
			data, err := ec.unmarshalOOperationType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOperationType(ctx, v)
			if err != nil {
				return &it, err
			}
			it.OperationType = data
		case "operatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.OperatedBy = data
		case "operationDateRange":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationDateRange"))
			data, err := ec.unmarshalODateRangeInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDateRangeInput(ctx, v)
			if err != nil {
				return &it, err
			}
			it.OperationDateRange = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputPaginationInput(ctx context.Context, obj interface{}) (*model.PaginationInput, error) {
	var it model.PaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["pageSize"]; !present {
		asMap["pageSize"] = 50
	}
	if _, present := asMap["sortBy"]; !present {
		asMap["sortBy"] = "code"
	}
	if _, present := asMap["sortOrder"]; !present {
		asMap["sortOrder"] = "asc"
	}

	fieldsInOrder := [...]string{"page", "pageSize", "sortBy", "sortOrder"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return &it, err
			}
			it.PageSize = data
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.SortBy = data
		case "sortOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortOrder"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.SortOrder = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputPositionAssignmentFilterInput(ctx context.Context, obj interface{}) (*model.PositionAssignmentFilterInput, error) {
	var it model.PositionAssignmentFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["includeHistorical"]; !present {
		asMap["includeHistorical"] = true
	}
	if _, present := asMap["includeActingOnly"]; !present {
		asMap["includeActingOnly"] = false
	}

	fieldsInOrder := [...]string{"employeeId", "status", "assignmentTypes", "dateRange", "asOfDate", "includeHistorical", "includeActingOnly"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "employeeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("employeeId"))
			data, err := ec.unmarshalOUUID2cubecastleinternalorganizationdtoUUID(ctx, v)
			if err != nil {
				return &it, err
			}
			it.EmployeeID = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Status = data
		case "assignmentTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assignmentTypes"))
			data, err := ec.unmarshalOPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx, v)
			if err != nil {
				return &it, err
			}
			it.AssignmentTypes = data
		case "dateRange":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateRange"))
			data, err := ec.unmarshalODateRangeInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDateRangeInput(ctx, v)
			if err != nil {
				return &it, err
			}
			it.DateRange = data
		case "asOfDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
			data, err := ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, v)
			if err != nil {
				return &it, err
			}
			it.AsOfDate = data
		case "includeHistorical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeHistorical"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.IncludeHistorical = data
		case "includeActingOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeActingOnly"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return &it, err
			}
			it.IncludeActingOnly = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputPositionAssignmentSortInput(ctx context.Context, obj interface{}) (*model.PositionAssignmentSortInput, error) {
	var it model.PositionAssignmentSortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "DESC"
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNPositionAssignmentSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortField(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalOSortOrder2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSortOrder(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Direction = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputPositionFilterInput(ctx context.Context, obj interface{}) (*model.PositionFilterInput, error) {
	var it model.PositionFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"organizationCode", "positionCodes", "status", "jobFamilyGroupCodes", "jobFamilyCodes", "jobRoleCodes", "jobLevelCodes", "positionTypes", "employmentTypes", "effectiveRange"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "organizationCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationCode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.OrganizationCode = data
		case "positionCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionCodes"))
			data, err := ec.unmarshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.PositionCodes = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Status = data
		case "jobFamilyGroupCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobFamilyGroupCodes"))
			data, err := ec.unmarshalOJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobFamilyGroupCodes = data
		case "jobFamilyCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobFamilyCodes"))
			data, err := ec.unmarshalOJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobFamilyCodes = data
		case "jobRoleCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobRoleCodes"))
			data, err := ec.unmarshalOJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobRoleCodes = data
		case "jobLevelCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobLevelCodes"))
			data, err := ec.unmarshalOJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobLevelCodes = data
		case "positionTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionTypes"))
			data, err := ec.unmarshalOPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx, v)
			if err != nil {
				return &it, err
			}
			it.PositionTypes = data
		case "employmentTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("employmentTypes"))
			data, err := ec.unmarshalOEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx, v)
			if err != nil {
				return &it, err
			}
			it.EmploymentTypes = data
		case "effectiveRange":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("effectiveRange"))
			data, err := ec.unmarshalODateRangeInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDateRangeInput(ctx, v)
			if err != nil {
				return &it, err
			}
			it.EffectiveRange = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputPositionSortInput(ctx context.Context, obj interface{}) (*model.PositionSortInput, error) {
	var it model.PositionSortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNPositionSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortField(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalOSortOrder2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSortOrder(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Direction = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputVacantPositionFilterInput(ctx context.Context, obj interface{}) (*model.VacantPositionFilterInput, error) {
	var it model.VacantPositionFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"organizationCodes", "jobFamilyCodes", "jobRoleCodes", "jobLevelCodes", "positionTypes", "minimumVacantDays", "asOfDate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "organizationCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationCodes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return &it, err
			}
			it.OrganizationCodes = data
		case "jobFamilyCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobFamilyCodes"))
			data, err := ec.unmarshalOJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobFamilyCodes = data
		case "jobRoleCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobRoleCodes"))
			data, err := ec.unmarshalOJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobRoleCodes = data
		case "jobLevelCodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobLevelCodes"))
			data, err := ec.unmarshalOJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, v)
			if err != nil {
				return &it, err
			}
			it.JobLevelCodes = data
		case "positionTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positionTypes"))
			data, err := ec.unmarshalOPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx, v)
			if err != nil {
				return &it, err
			}
			it.PositionTypes = data
		case "minimumVacantDays":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumVacantDays"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return &it, err
			}
			it.MinimumVacantDays = data
		case "asOfDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asOfDate"))
			data, err := ec.unmarshalODate2cubecastleinternalorganizationdtoDate(ctx, v)
			if err != nil {
				return &it, err
			}
			it.AsOfDate = data
		}
	}

	return &it, nil
}

func (ec *executionContext) unmarshalInputVacantPositionSortInput(ctx context.Context, obj interface{}) (*model.VacantPositionSortInput, error) {
	var it model.VacantPositionSortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "DESC"
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNVacantPositionSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortField(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalOSortOrder2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSortOrder(ctx, v)
			if err != nil {
				return &it, err
			}
			it.Direction = data
		}
	}

	return &it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var assignmentStatsImplementors = []string{"AssignmentStats"}

func (ec *executionContext) _AssignmentStats(ctx context.Context, sel ast.SelectionSet, obj *model.AssignmentStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assignmentStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssignmentStats")
		case "positionCode":
			out.Values[i] = ec._AssignmentStats_positionCode(ctx, field, obj)
		case "organizationCode":
			out.Values[i] = ec._AssignmentStats_organizationCode(ctx, field, obj)
		case "totalAssignments":
			out.Values[i] = ec._AssignmentStats_totalAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeAssignments":
			out.Values[i] = ec._AssignmentStats_activeAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pendingAssignments":
			out.Values[i] = ec._AssignmentStats_pendingAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endedAssignments":
			out.Values[i] = ec._AssignmentStats_endedAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "primaryAssignments":
			out.Values[i] = ec._AssignmentStats_primaryAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secondaryAssignments":
			out.Values[i] = ec._AssignmentStats_secondaryAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actingAssignments":
			out.Values[i] = ec._AssignmentStats_actingAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastUpdatedAt":
			out.Values[i] = ec._AssignmentStats_lastUpdatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var auditLogDetailImplementors = []string{"AuditLogDetail"}

func (ec *executionContext) _AuditLogDetail(ctx context.Context, sel ast.SelectionSet, obj *model.AuditLogDetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, auditLogDetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuditLogDetail")
		case "auditId":
			out.Values[i] = ec._AuditLogDetail_auditId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._AuditLogDetail_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operation":
			out.Values[i] = ec._AuditLogDetail_operation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._AuditLogDetail_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operationReason":
			out.Values[i] = ec._AuditLogDetail_operationReason(ctx, field, obj)
		case "beforeData":
			out.Values[i] = ec._AuditLogDetail_beforeData(ctx, field, obj)
		case "afterData":
			out.Values[i] = ec._AuditLogDetail_afterData(ctx, field, obj)
		case "modifiedFields":
			out.Values[i] = ec._AuditLogDetail_modifiedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changes":
			out.Values[i] = ec._AuditLogDetail_changes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cacheInconsistencyImplementors = []string{"CacheInconsistency"}

func (ec *executionContext) _CacheInconsistency(ctx context.Context, sel ast.SelectionSet, obj *model.CacheInconsistency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cacheInconsistencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CacheInconsistency")
		case "code":
			out.Values[i] = ec._CacheInconsistency_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fieldName":
			out.Values[i] = ec._CacheInconsistency_fieldName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cachedValue":
			out.Values[i] = ec._CacheInconsistency_cachedValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "calculatedValue":
			out.Values[i] = ec._CacheInconsistency_calculatedValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "impactLevel":
			out.Values[i] = ec._CacheInconsistency_impactLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var circularReferenceImplementors = []string{"CircularReference"}

func (ec *executionContext) _CircularReference(ctx context.Context, sel ast.SelectionSet, obj *model.CircularReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, circularReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CircularReference")
		case "affectedCodes":
			out.Values[i] = ec._CircularReference_affectedCodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "circularPath":
			out.Values[i] = ec._CircularReference_circularPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._CircularReference_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var consistencyFindingsImplementors = []string{"ConsistencyFindings"}

func (ec *executionContext) _ConsistencyFindings(ctx context.Context, sel ast.SelectionSet, obj *model.ConsistencyFindings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, consistencyFindingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConsistencyFindings")
		case "pathMismatches":
			out.Values[i] = ec._ConsistencyFindings_pathMismatches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "levelInconsistencies":
			out.Values[i] = ec._ConsistencyFindings_levelInconsistencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orphanedNodes":
			out.Values[i] = ec._ConsistencyFindings_orphanedNodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "circularReferences":
			out.Values[i] = ec._ConsistencyFindings_circularReferences(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "depthViolations":
			out.Values[i] = ec._ConsistencyFindings_depthViolations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cacheInconsistencies":
			out.Values[i] = ec._ConsistencyFindings_cacheInconsistencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataChangesImplementors = []string{"DataChanges"}

func (ec *executionContext) _DataChanges(ctx context.Context, sel ast.SelectionSet, obj *model.DataChanges) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataChangesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataChanges")
		case "beforeData":
			out.Values[i] = ec._DataChanges_beforeData(ctx, field, obj)
		case "afterData":
			out.Values[i] = ec._DataChanges_afterData(ctx, field, obj)
		case "modifiedFields":
			out.Values[i] = ec._DataChanges_modifiedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dateRangeImplementors = []string{"DateRange"}

func (ec *executionContext) _DateRange(ctx context.Context, sel ast.SelectionSet, obj *model.DateRange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dateRangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DateRange")
		case "earliest":
			out.Values[i] = ec._DateRange_earliest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latest":
			out.Values[i] = ec._DateRange_latest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var depthDistributionImplementors = []string{"DepthDistribution"}

func (ec *executionContext) _DepthDistribution(ctx context.Context, sel ast.SelectionSet, obj *model.DepthDistribution) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, depthDistributionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DepthDistribution")
		case "depth":
			out.Values[i] = ec._DepthDistribution_depth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._DepthDistribution_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var depthViolationImplementors = []string{"DepthViolation"}

func (ec *executionContext) _DepthViolation(ctx context.Context, sel ast.SelectionSet, obj *model.DepthViolation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, depthViolationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DepthViolation")
		case "code":
			out.Values[i] = ec._DepthViolation_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentDepth":
			out.Values[i] = ec._DepthViolation_currentDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxAllowedDepth":
			out.Values[i] = ec._DepthViolation_maxAllowedDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentChain":
			out.Values[i] = ec._DepthViolation_parentChain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var familyHeadcountImplementors = []string{"FamilyHeadcount"}

func (ec *executionContext) _FamilyHeadcount(ctx context.Context, sel ast.SelectionSet, obj *model.FamilyHeadcount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, familyHeadcountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FamilyHeadcount")
		case "jobFamilyCode":
			out.Values[i] = ec._FamilyHeadcount_jobFamilyCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobFamilyName":
			out.Values[i] = ec._FamilyHeadcount_jobFamilyName(ctx, field, obj)
		case "capacity":
			out.Values[i] = ec._FamilyHeadcount_capacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilized":
			out.Values[i] = ec._FamilyHeadcount_utilized(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "available":
			out.Values[i] = ec._FamilyHeadcount_available(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fieldChangeImplementors = []string{"FieldChange"}

func (ec *executionContext) _FieldChange(ctx context.Context, sel ast.SelectionSet, obj *model.FieldChange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fieldChangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FieldChange")
		case "field":
			out.Values[i] = ec._FieldChange_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._FieldChange_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._FieldChange_newValue(ctx, field, obj)
		case "dataType":
			out.Values[i] = ec._FieldChange_dataType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var headcountStatsImplementors = []string{"HeadcountStats"}

func (ec *executionContext) _HeadcountStats(ctx context.Context, sel ast.SelectionSet, obj *model.HeadcountStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, headcountStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HeadcountStats")
		case "organizationCode":
			out.Values[i] = ec._HeadcountStats_organizationCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organizationName":
			out.Values[i] = ec._HeadcountStats_organizationName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCapacity":
			out.Values[i] = ec._HeadcountStats_totalCapacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalFilled":
			out.Values[i] = ec._HeadcountStats_totalFilled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalAvailable":
			out.Values[i] = ec._HeadcountStats_totalAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fillRate":
			out.Values[i] = ec._HeadcountStats_fillRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "byLevel":
			out.Values[i] = ec._HeadcountStats_byLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "byType":
			out.Values[i] = ec._HeadcountStats_byType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "byFamily":
			out.Values[i] = ec._HeadcountStats_byFamily(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hierarchyConsistencyReportImplementors = []string{"HierarchyConsistencyReport"}

func (ec *executionContext) _HierarchyConsistencyReport(ctx context.Context, sel ast.SelectionSet, obj *model.HierarchyConsistencyReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hierarchyConsistencyReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HierarchyConsistencyReport")
		case "checkId":
			out.Values[i] = ec._HierarchyConsistencyReport_checkId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._HierarchyConsistencyReport_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executedAt":
			out.Values[i] = ec._HierarchyConsistencyReport_executedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executionTimeMs":
			out.Values[i] = ec._HierarchyConsistencyReport_executionTimeMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalChecked":
			out.Values[i] = ec._HierarchyConsistencyReport_totalChecked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issuesFound":
			out.Values[i] = ec._HierarchyConsistencyReport_issuesFound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkMode":
			out.Values[i] = ec._HierarchyConsistencyReport_checkMode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consistencyReport":
			out.Values[i] = ec._HierarchyConsistencyReport_consistencyReport(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repairSuggestions":
			out.Values[i] = ec._HierarchyConsistencyReport_repairSuggestions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "healthScore":
			out.Values[i] = ec._HierarchyConsistencyReport_healthScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recommendedActions":
			out.Values[i] = ec._HierarchyConsistencyReport_recommendedActions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hierarchyStatisticsImplementors = []string{"HierarchyStatistics"}

func (ec *executionContext) _HierarchyStatistics(ctx context.Context, sel ast.SelectionSet, obj *model.HierarchyStatistics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hierarchyStatisticsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HierarchyStatistics")
		case "tenantId":
			out.Values[i] = ec._HierarchyStatistics_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalOrganizations":
			out.Values[i] = ec._HierarchyStatistics_totalOrganizations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDepth":
			out.Values[i] = ec._HierarchyStatistics_maxDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "avgDepth":
			out.Values[i] = ec._HierarchyStatistics_avgDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "depthDistribution":
			out.Values[i] = ec._HierarchyStatistics_depthDistribution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rootOrganizations":
			out.Values[i] = ec._HierarchyStatistics_rootOrganizations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "leafOrganizations":
			out.Values[i] = ec._HierarchyStatistics_leafOrganizations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "integrityIssues":
			out.Values[i] = ec._HierarchyStatistics_integrityIssues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastAnalyzed":
			out.Values[i] = ec._HierarchyStatistics_lastAnalyzed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrityIssueImplementors = []string{"IntegrityIssue"}

func (ec *executionContext) _IntegrityIssue(ctx context.Context, sel ast.SelectionSet, obj *model.IntegrityIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrityIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrityIssue")
		case "type":
			out.Values[i] = ec._IntegrityIssue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._IntegrityIssue_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "affectedCodes":
			out.Values[i] = ec._IntegrityIssue_affectedCodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobFamilyImplementors = []string{"JobFamily"}

func (ec *executionContext) _JobFamily(ctx context.Context, sel ast.SelectionSet, obj *model.JobFamily) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobFamilyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobFamily")
		case "code":
			out.Values[i] = ec._JobFamily_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._JobFamily_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupCode":
			out.Values[i] = ec._JobFamily_groupCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JobFamily_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._JobFamily_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._JobFamily_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._JobFamily_endDate(ctx, field, obj)
		case "description":
			out.Values[i] = ec._JobFamily_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobFamilyGroupImplementors = []string{"JobFamilyGroup"}

func (ec *executionContext) _JobFamilyGroup(ctx context.Context, sel ast.SelectionSet, obj *model.JobFamilyGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobFamilyGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobFamilyGroup")
		case "code":
			out.Values[i] = ec._JobFamilyGroup_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._JobFamilyGroup_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JobFamilyGroup_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._JobFamilyGroup_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._JobFamilyGroup_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._JobFamilyGroup_endDate(ctx, field, obj)
		case "description":
			out.Values[i] = ec._JobFamilyGroup_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobLevelImplementors = []string{"JobLevel"}

func (ec *executionContext) _JobLevel(ctx context.Context, sel ast.SelectionSet, obj *model.JobLevel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobLevelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobLevel")
		case "code":
			out.Values[i] = ec._JobLevel_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._JobLevel_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roleCode":
			out.Values[i] = ec._JobLevel_roleCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JobLevel_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._JobLevel_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._JobLevel_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._JobLevel_endDate(ctx, field, obj)
		case "levelRank":
			out.Values[i] = ec._JobLevel_levelRank(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._JobLevel_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobRoleImplementors = []string{"JobRole"}

func (ec *executionContext) _JobRole(ctx context.Context, sel ast.SelectionSet, obj *model.JobRole) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobRoleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobRole")
		case "code":
			out.Values[i] = ec._JobRole_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._JobRole_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "familyCode":
			out.Values[i] = ec._JobRole_familyCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JobRole_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._JobRole_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._JobRole_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._JobRole_endDate(ctx, field, obj)
		case "description":
			out.Values[i] = ec._JobRole_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var levelHeadcountImplementors = []string{"LevelHeadcount"}

func (ec *executionContext) _LevelHeadcount(ctx context.Context, sel ast.SelectionSet, obj *model.LevelHeadcount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelHeadcountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LevelHeadcount")
		case "jobLevelCode":
			out.Values[i] = ec._LevelHeadcount_jobLevelCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capacity":
			out.Values[i] = ec._LevelHeadcount_capacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "utilized":
			out.Values[i] = ec._LevelHeadcount_utilized(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "available":
			out.Values[i] = ec._LevelHeadcount_available(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var levelInconsistencyImplementors = []string{"LevelInconsistency"}

func (ec *executionContext) _LevelInconsistency(ctx context.Context, sel ast.SelectionSet, obj *model.LevelInconsistency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelInconsistencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LevelInconsistency")
		case "code":
			out.Values[i] = ec._LevelInconsistency_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expectedLevel":
			out.Values[i] = ec._LevelInconsistency_expectedLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actualLevel":
			out.Values[i] = ec._LevelInconsistency_actualLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentCode":
			out.Values[i] = ec._LevelInconsistency_parentCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._LevelInconsistency_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var levelStatisticImplementors = []string{"LevelStatistic"}

func (ec *executionContext) _LevelStatistic(ctx context.Context, sel ast.SelectionSet, obj *model.LevelStatistic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelStatisticImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LevelStatistic")
		case "level":
			out.Values[i] = ec._LevelStatistic_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._LevelStatistic_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var operatedByImplementors = []string{"OperatedBy"}

func (ec *executionContext) _OperatedBy(ctx context.Context, sel ast.SelectionSet, obj *model.OperatedBy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatedByImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperatedBy")
		case "id":
			out.Values[i] = ec._OperatedBy_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._OperatedBy_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var operationsSummaryImplementors = []string{"OperationsSummary"}

func (ec *executionContext) _OperationsSummary(ctx context.Context, sel ast.SelectionSet, obj *model.OperationsSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operationsSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationsSummary")
		case "create":
			out.Values[i] = ec._OperationsSummary_create(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "update":
			out.Values[i] = ec._OperationsSummary_update(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suspend":
			out.Values[i] = ec._OperationsSummary_suspend(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reactivate":
			out.Values[i] = ec._OperationsSummary_reactivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "delete":
			out.Values[i] = ec._OperationsSummary_delete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *model.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "code":
			out.Values[i] = ec._Organization_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentCode":
			out.Values[i] = ec._Organization_parentCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Organization_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unitType":
			out.Values[i] = ec._Organization_unitType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Organization_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._Organization_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sortOrder":
			out.Values[i] = ec._Organization_sortOrder(ctx, field, obj)
		case "codePath":
			out.Values[i] = ec._Organization_codePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namePath":
			out.Values[i] = ec._Organization_namePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Organization_path(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Organization_description(ctx, field, obj)
		case "profile":
			out.Values[i] = ec._Organization_profile(ctx, field, obj)
		case "changeReason":
			out.Values[i] = ec._Organization_changeReason(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Organization_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._Organization_endDate(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Organization_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Organization_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._Organization_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isCurrent":
			out.Values[i] = ec._Organization_isCurrent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isTemporal":
			out.Values[i] = ec._Organization_isTemporal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isFuture":
			out.Values[i] = ec._Organization_isFuture(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hierarchyDepth":
			out.Values[i] = ec._Organization_hierarchyDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childrenCount":
			out.Values[i] = ec._Organization_childrenCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Organization_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._Organization_deletedBy(ctx, field, obj)
		case "deletionReason":
			out.Values[i] = ec._Organization_deletionReason(ctx, field, obj)
		case "suspendedAt":
			out.Values[i] = ec._Organization_suspendedAt(ctx, field, obj)
		case "suspendedBy":
			out.Values[i] = ec._Organization_suspendedBy(ctx, field, obj)
		case "suspensionReason":
			out.Values[i] = ec._Organization_suspensionReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationConnectionImplementors = []string{"OrganizationConnection"}

func (ec *executionContext) _OrganizationConnection(ctx context.Context, sel ast.SelectionSet, obj *model.OrganizationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationConnection")
		case "data":
			out.Values[i] = ec._OrganizationConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._OrganizationConnection_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "temporal":
			out.Values[i] = ec._OrganizationConnection_temporal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationHierarchyImplementors = []string{"OrganizationHierarchy"}

func (ec *executionContext) _OrganizationHierarchy(ctx context.Context, sel ast.SelectionSet, obj *model.OrganizationHierarchy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationHierarchyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationHierarchy")
		case "code":
			out.Values[i] = ec._OrganizationHierarchy_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._OrganizationHierarchy_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._OrganizationHierarchy_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hierarchyDepth":
			out.Values[i] = ec._OrganizationHierarchy_hierarchyDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "codePath":
			out.Values[i] = ec._OrganizationHierarchy_codePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namePath":
			out.Values[i] = ec._OrganizationHierarchy_namePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentChain":
			out.Values[i] = ec._OrganizationHierarchy_parentChain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childrenCount":
			out.Values[i] = ec._OrganizationHierarchy_childrenCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRoot":
			out.Values[i] = ec._OrganizationHierarchy_isRoot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isLeaf":
			out.Values[i] = ec._OrganizationHierarchy_isLeaf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._OrganizationHierarchy_children(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationStatsImplementors = []string{"OrganizationStats"}

func (ec *executionContext) _OrganizationStats(ctx context.Context, sel ast.SelectionSet, obj *model.OrganizationStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationStats")
		case "totalCount":
			out.Values[i] = ec._OrganizationStats_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeCount":
			out.Values[i] = ec._OrganizationStats_activeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inactiveCount":
			out.Values[i] = ec._OrganizationStats_inactiveCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "plannedCount":
			out.Values[i] = ec._OrganizationStats_plannedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedCount":
			out.Values[i] = ec._OrganizationStats_deletedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "byType":
			out.Values[i] = ec._OrganizationStats_byType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "byStatus":
			out.Values[i] = ec._OrganizationStats_byStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "byLevel":
			out.Values[i] = ec._OrganizationStats_byLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "temporalStats":
			out.Values[i] = ec._OrganizationStats_temporalStats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var orphanedNodeImplementors = []string{"OrphanedNode"}

func (ec *executionContext) _OrphanedNode(ctx context.Context, sel ast.SelectionSet, obj *model.OrphanedNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, orphanedNodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrphanedNode")
		case "code":
			out.Values[i] = ec._OrphanedNode_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._OrphanedNode_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentCode":
			out.Values[i] = ec._OrphanedNode_parentCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._OrphanedNode_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var paginationInfoImplementors = []string{"PaginationInfo"}

func (ec *executionContext) _PaginationInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PaginationInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginationInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginationInfo")
		case "total":
			out.Values[i] = ec._PaginationInfo_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "page":
			out.Values[i] = ec._PaginationInfo_page(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageSize":
			out.Values[i] = ec._PaginationInfo_pageSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNext":
			out.Values[i] = ec._PaginationInfo_hasNext(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPrevious":
			out.Values[i] = ec._PaginationInfo_hasPrevious(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pathMismatchImplementors = []string{"PathMismatch"}

func (ec *executionContext) _PathMismatch(ctx context.Context, sel ast.SelectionSet, obj *model.PathMismatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pathMismatchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PathMismatch")
		case "code":
			out.Values[i] = ec._PathMismatch_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expectedCodePath":
			out.Values[i] = ec._PathMismatch_expectedCodePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actualCodePath":
			out.Values[i] = ec._PathMismatch_actualCodePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expectedNamePath":
			out.Values[i] = ec._PathMismatch_expectedNamePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actualNamePath":
			out.Values[i] = ec._PathMismatch_actualNamePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._PathMismatch_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionImplementors = []string{"Position"}

func (ec *executionContext) _Position(ctx context.Context, sel ast.SelectionSet, obj *model.Position) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Position")
		case "code":
			out.Values[i] = ec._Position_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordId":
			out.Values[i] = ec._Position_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Position_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._Position_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobProfileCode":
			out.Values[i] = ec._Position_jobProfileCode(ctx, field, obj)
		case "jobProfileName":
			out.Values[i] = ec._Position_jobProfileName(ctx, field, obj)
		case "jobFamilyGroupCode":
			out.Values[i] = ec._Position_jobFamilyGroupCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobFamilyCode":
			out.Values[i] = ec._Position_jobFamilyCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobRoleCode":
			out.Values[i] = ec._Position_jobRoleCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobLevelCode":
			out.Values[i] = ec._Position_jobLevelCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organizationCode":
			out.Values[i] = ec._Position_organizationCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organizationName":
			out.Values[i] = ec._Position_organizationName(ctx, field, obj)
		case "positionType":
			out.Values[i] = ec._Position_positionType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "employmentType":
			out.Values[i] = ec._Position_employmentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gradeLevel":
			out.Values[i] = ec._Position_gradeLevel(ctx, field, obj)
		case "headcountCapacity":
			out.Values[i] = ec._Position_headcountCapacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headcountInUse":
			out.Values[i] = ec._Position_headcountInUse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "availableHeadcount":
			out.Values[i] = ec._Position_availableHeadcount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentAssignment":
			out.Values[i] = ec._Position_currentAssignment(ctx, field, obj)
		case "assignmentHistory":
			out.Values[i] = ec._Position_assignmentHistory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reportsToPositionCode":
			out.Values[i] = ec._Position_reportsToPositionCode(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Position_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._Position_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._Position_endDate(ctx, field, obj)
		case "isCurrent":
			out.Values[i] = ec._Position_isCurrent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isFuture":
			out.Values[i] = ec._Position_isFuture(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Position_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Position_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionAssignmentImplementors = []string{"PositionAssignment"}

func (ec *executionContext) _PositionAssignment(ctx context.Context, sel ast.SelectionSet, obj *model.PositionAssignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionAssignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionAssignment")
		case "assignmentId":
			out.Values[i] = ec._PositionAssignment_assignmentId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "positionCode":
			out.Values[i] = ec._PositionAssignment_positionCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "positionRecordId":
			out.Values[i] = ec._PositionAssignment_positionRecordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "employeeId":
			out.Values[i] = ec._PositionAssignment_employeeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "employeeName":
			out.Values[i] = ec._PositionAssignment_employeeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "employeeNumber":
			out.Values[i] = ec._PositionAssignment_employeeNumber(ctx, field, obj)
		case "assignmentType":
			out.Values[i] = ec._PositionAssignment_assignmentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignmentStatus":
			out.Values[i] = ec._PositionAssignment_assignmentStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fte":
			out.Values[i] = ec._PositionAssignment_fte(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._PositionAssignment_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._PositionAssignment_endDate(ctx, field, obj)
		case "actingUntil":
			out.Values[i] = ec._PositionAssignment_actingUntil(ctx, field, obj)
		case "autoRevert":
			out.Values[i] = ec._PositionAssignment_autoRevert(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reminderSentAt":
			out.Values[i] = ec._PositionAssignment_reminderSentAt(ctx, field, obj)
		case "isCurrent":
			out.Values[i] = ec._PositionAssignment_isCurrent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notes":
			out.Values[i] = ec._PositionAssignment_notes(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._PositionAssignment_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._PositionAssignment_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionAssignmentAuditImplementors = []string{"PositionAssignmentAudit"}

func (ec *executionContext) _PositionAssignmentAudit(ctx context.Context, sel ast.SelectionSet, obj *model.PositionAssignmentAudit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionAssignmentAuditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionAssignmentAudit")
		case "assignmentId":
			out.Values[i] = ec._PositionAssignmentAudit_assignmentId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._PositionAssignmentAudit_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._PositionAssignmentAudit_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._PositionAssignmentAudit_endDate(ctx, field, obj)
		case "actor":
			out.Values[i] = ec._PositionAssignmentAudit_actor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changes":
			out.Values[i] = ec._PositionAssignmentAudit_changes(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._PositionAssignmentAudit_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionAssignmentAuditConnectionImplementors = []string{"PositionAssignmentAuditConnection"}

func (ec *executionContext) _PositionAssignmentAuditConnection(ctx context.Context, sel ast.SelectionSet, obj *model.PositionAssignmentAuditConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionAssignmentAuditConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionAssignmentAuditConnection")
		case "data":
			out.Values[i] = ec._PositionAssignmentAuditConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._PositionAssignmentAuditConnection_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._PositionAssignmentAuditConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionAssignmentConnectionImplementors = []string{"PositionAssignmentConnection"}

func (ec *executionContext) _PositionAssignmentConnection(ctx context.Context, sel ast.SelectionSet, obj *model.PositionAssignmentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionAssignmentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionAssignmentConnection")
		case "edges":
			out.Values[i] = ec._PositionAssignmentConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._PositionAssignmentConnection_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PositionAssignmentConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._PositionAssignmentConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionAssignmentEdgeImplementors = []string{"PositionAssignmentEdge"}

func (ec *executionContext) _PositionAssignmentEdge(ctx context.Context, sel ast.SelectionSet, obj *model.PositionAssignmentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionAssignmentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionAssignmentEdge")
		case "cursor":
			out.Values[i] = ec._PositionAssignmentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._PositionAssignmentEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionConnectionImplementors = []string{"PositionConnection"}

func (ec *executionContext) _PositionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.PositionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionConnection")
		case "edges":
			out.Values[i] = ec._PositionConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._PositionConnection_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PositionConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._PositionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionEdgeImplementors = []string{"PositionEdge"}

func (ec *executionContext) _PositionEdge(ctx context.Context, sel ast.SelectionSet, obj *model.PositionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionEdge")
		case "cursor":
			out.Values[i] = ec._PositionEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._PositionEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionTimelineEntryImplementors = []string{"PositionTimelineEntry"}

func (ec *executionContext) _PositionTimelineEntry(ctx context.Context, sel ast.SelectionSet, obj *model.PositionTimelineEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionTimelineEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionTimelineEntry")
		case "recordId":
			out.Values[i] = ec._PositionTimelineEntry_recordId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._PositionTimelineEntry_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._PositionTimelineEntry_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._PositionTimelineEntry_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._PositionTimelineEntry_endDate(ctx, field, obj)
		case "isCurrent":
			out.Values[i] = ec._PositionTimelineEntry_isCurrent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changeReason":
			out.Values[i] = ec._PositionTimelineEntry_changeReason(ctx, field, obj)
		case "timelineCategory":
			out.Values[i] = ec._PositionTimelineEntry_timelineCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignmentType":
			out.Values[i] = ec._PositionTimelineEntry_assignmentType(ctx, field, obj)
		case "assignmentStatus":
			out.Values[i] = ec._PositionTimelineEntry_assignmentStatus(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionTransferImplementors = []string{"PositionTransfer"}

func (ec *executionContext) _PositionTransfer(ctx context.Context, sel ast.SelectionSet, obj *model.PositionTransfer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionTransferImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionTransfer")
		case "transferId":
			out.Values[i] = ec._PositionTransfer_transferId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "positionCode":
			out.Values[i] = ec._PositionTransfer_positionCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fromOrganizationCode":
			out.Values[i] = ec._PositionTransfer_fromOrganizationCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "toOrganizationCode":
			out.Values[i] = ec._PositionTransfer_toOrganizationCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "effectiveDate":
			out.Values[i] = ec._PositionTransfer_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "initiatedBy":
			out.Values[i] = ec._PositionTransfer_initiatedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operationReason":
			out.Values[i] = ec._PositionTransfer_operationReason(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._PositionTransfer_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionTransferConnectionImplementors = []string{"PositionTransferConnection"}

func (ec *executionContext) _PositionTransferConnection(ctx context.Context, sel ast.SelectionSet, obj *model.PositionTransferConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionTransferConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionTransferConnection")
		case "edges":
			out.Values[i] = ec._PositionTransferConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._PositionTransferConnection_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PositionTransferConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._PositionTransferConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionTransferEdgeImplementors = []string{"PositionTransferEdge"}

func (ec *executionContext) _PositionTransferEdge(ctx context.Context, sel ast.SelectionSet, obj *model.PositionTransferEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionTransferEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PositionTransferEdge")
		case "cursor":
			out.Values[i] = ec._PositionTransferEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._PositionTransferEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "organizations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organization(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizationStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizationStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizationHierarchy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizationHierarchy(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizationSubtree":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizationSubtree(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hierarchyStatistics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hierarchyStatistics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "position":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_position(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positionTimeline":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positionTimeline(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positionVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positionVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positionAssignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positionAssignments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positionAssignmentAudit":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positionAssignmentAudit(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "assignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assignments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "assignmentHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assignmentHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "assignmentStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assignmentStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "vacantPositions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_vacantPositions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positionTransfers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positionTransfers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "positionHeadcountStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_positionHeadcountStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "auditHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_auditHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "auditLog":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_auditLog(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizationVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizationVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "jobFamilyGroups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_jobFamilyGroups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "jobFamilies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_jobFamilies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "jobRoles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_jobRoles(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "jobLevels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_jobLevels(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repairSuggestionImplementors = []string{"RepairSuggestion"}

func (ec *executionContext) _RepairSuggestion(ctx context.Context, sel ast.SelectionSet, obj *model.RepairSuggestion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repairSuggestionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepairSuggestion")
		case "issueType":
			out.Values[i] = ec._RepairSuggestion_issueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "affectedCodes":
			out.Values[i] = ec._RepairSuggestion_affectedCodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestedAction":
			out.Values[i] = ec._RepairSuggestion_suggestedAction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "automatable":
			out.Values[i] = ec._RepairSuggestion_automatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "riskLevel":
			out.Values[i] = ec._RepairSuggestion_riskLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var statusStatisticImplementors = []string{"StatusStatistic"}

func (ec *executionContext) _StatusStatistic(ctx context.Context, sel ast.SelectionSet, obj *model.StatusStatistic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusStatisticImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusStatistic")
		case "status":
			out.Values[i] = ec._StatusStatistic_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._StatusStatistic_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var temporalInfoImplementors = []string{"TemporalInfo"}

func (ec *executionContext) _TemporalInfo(ctx context.Context, sel ast.SelectionSet, obj *model.TemporalInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, temporalInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TemporalInfo")
		case "asOfDate":
			out.Values[i] = ec._TemporalInfo_asOfDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentCount":
			out.Values[i] = ec._TemporalInfo_currentCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "futureCount":
			out.Values[i] = ec._TemporalInfo_futureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "historicalCount":
			out.Values[i] = ec._TemporalInfo_historicalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var temporalStatisticsImplementors = []string{"TemporalStatistics"}

func (ec *executionContext) _TemporalStatistics(ctx context.Context, sel ast.SelectionSet, obj *model.TemporalStatistics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, temporalStatisticsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TemporalStatistics")
		case "totalVersions":
			out.Values[i] = ec._TemporalStatistics_totalVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "averageVersionsPerOrg":
			out.Values[i] = ec._TemporalStatistics_averageVersionsPerOrg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldestEffectiveDate":
			out.Values[i] = ec._TemporalStatistics_oldestEffectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newestEffectiveDate":
			out.Values[i] = ec._TemporalStatistics_newestEffectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typeHeadcountImplementors = []string{"TypeHeadcount"}

func (ec *executionContext) _TypeHeadcount(ctx context.Context, sel ast.SelectionSet, obj *model.TypeHeadcount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeHeadcountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeHeadcount")
		case "positionType":
			out.Values[i] = ec._TypeHeadcount_positionType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capacity":
			out.Values[i] = ec._TypeHeadcount_capacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filled":
			out.Values[i] = ec._TypeHeadcount_filled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "available":
			out.Values[i] = ec._TypeHeadcount_available(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typeStatisticImplementors = []string{"TypeStatistic"}

func (ec *executionContext) _TypeStatistic(ctx context.Context, sel ast.SelectionSet, obj *model.TypeStatistic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeStatisticImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeStatistic")
		case "unitType":
			out.Values[i] = ec._TypeStatistic_unitType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._TypeStatistic_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userInfoImplementors = []string{"UserInfo"}

func (ec *executionContext) _UserInfo(ctx context.Context, sel ast.SelectionSet, obj *model.UserInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserInfo")
		case "userId":
			out.Values[i] = ec._UserInfo_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userName":
			out.Values[i] = ec._UserInfo_userName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "role":
			out.Values[i] = ec._UserInfo_role(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vacantPositionImplementors = []string{"VacantPosition"}

func (ec *executionContext) _VacantPosition(ctx context.Context, sel ast.SelectionSet, obj *model.VacantPosition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vacantPositionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VacantPosition")
		case "positionCode":
			out.Values[i] = ec._VacantPosition_positionCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organizationCode":
			out.Values[i] = ec._VacantPosition_organizationCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organizationName":
			out.Values[i] = ec._VacantPosition_organizationName(ctx, field, obj)
		case "jobFamilyCode":
			out.Values[i] = ec._VacantPosition_jobFamilyCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobRoleCode":
			out.Values[i] = ec._VacantPosition_jobRoleCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobLevelCode":
			out.Values[i] = ec._VacantPosition_jobLevelCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vacantSince":
			out.Values[i] = ec._VacantPosition_vacantSince(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headcountCapacity":
			out.Values[i] = ec._VacantPosition_headcountCapacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headcountAvailable":
			out.Values[i] = ec._VacantPosition_headcountAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalAssignments":
			out.Values[i] = ec._VacantPosition_totalAssignments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vacantPositionConnectionImplementors = []string{"VacantPositionConnection"}

func (ec *executionContext) _VacantPositionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.VacantPositionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vacantPositionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VacantPositionConnection")
		case "edges":
			out.Values[i] = ec._VacantPositionConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._VacantPositionConnection_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._VacantPositionConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._VacantPositionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vacantPositionEdgeImplementors = []string{"VacantPositionEdge"}

func (ec *executionContext) _VacantPositionEdge(ctx context.Context, sel ast.SelectionSet, obj *model.VacantPositionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vacantPositionEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VacantPositionEdge")
		case "cursor":
			out.Values[i] = ec._VacantPositionEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._VacantPositionEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAssignmentStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAssignmentStats(ctx context.Context, sel ast.SelectionSet, v model.AssignmentStats) graphql.Marshaler {
	return ec._AssignmentStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNAssignmentStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAssignmentStats(ctx context.Context, sel ast.SelectionSet, v *model.AssignmentStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AssignmentStats(ctx, sel, v)
}

func (ec *executionContext) marshalNAuditLogDetail2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAuditLogDetail(ctx context.Context, sel ast.SelectionSet, v model.AuditLogDetail) graphql.Marshaler {
	return ec._AuditLogDetail(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuditLogDetail2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAuditLogDetail(ctx context.Context, sel ast.SelectionSet, v []model.AuditLogDetail) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuditLogDetail2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAuditLogDetail(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCacheInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCacheInconsistency(ctx context.Context, sel ast.SelectionSet, v model.CacheInconsistency) graphql.Marshaler {
	return ec._CacheInconsistency(ctx, sel, &v)
}

func (ec *executionContext) marshalNCacheInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCacheInconsistency(ctx context.Context, sel ast.SelectionSet, v []model.CacheInconsistency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCacheInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCacheInconsistency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCircularReference2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCircularReference(ctx context.Context, sel ast.SelectionSet, v model.CircularReference) graphql.Marshaler {
	return ec._CircularReference(ctx, sel, &v)
}

func (ec *executionContext) marshalNCircularReference2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCircularReference(ctx context.Context, sel ast.SelectionSet, v []model.CircularReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCircularReference2cubecastlecmdhrmsserverqueryinternalgraphqlmodelCircularReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNConsistencyCheckMode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelConsistencyCheckMode(ctx context.Context, v interface{}) (model.ConsistencyCheckMode, error) {
	var res model.ConsistencyCheckMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConsistencyCheckMode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelConsistencyCheckMode(ctx context.Context, sel ast.SelectionSet, v model.ConsistencyCheckMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConsistencyFindings2cubecastlecmdhrmsserverqueryinternalgraphqlmodelConsistencyFindings(ctx context.Context, sel ast.SelectionSet, v *model.ConsistencyFindings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConsistencyFindings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDate2cubecastleinternalorganizationdtoDate(ctx context.Context, v interface{}) (dto.Date, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.Date(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2cubecastleinternalorganizationdtoDate(ctx context.Context, sel ast.SelectionSet, v dto.Date) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx context.Context, v interface{}) (dto.DateTime, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.DateTime(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2cubecastleinternalorganizationdtoDateTime(ctx context.Context, sel ast.SelectionSet, v dto.DateTime) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDepthDistribution2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthDistribution(ctx context.Context, sel ast.SelectionSet, v model.DepthDistribution) graphql.Marshaler {
	return ec._DepthDistribution(ctx, sel, &v)
}

func (ec *executionContext) marshalNDepthDistribution2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthDistribution(ctx context.Context, sel ast.SelectionSet, v []model.DepthDistribution) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDepthDistribution2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthDistribution(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDepthViolation2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthViolation(ctx context.Context, sel ast.SelectionSet, v model.DepthViolation) graphql.Marshaler {
	return ec._DepthViolation(ctx, sel, &v)
}

func (ec *executionContext) marshalNDepthViolation2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthViolation(ctx context.Context, sel ast.SelectionSet, v []model.DepthViolation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDepthViolation2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDepthViolation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx context.Context, v interface{}) (model.EmploymentType, error) {
	var res model.EmploymentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx context.Context, sel ast.SelectionSet, v model.EmploymentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFamilyHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFamilyHeadcount(ctx context.Context, sel ast.SelectionSet, v model.FamilyHeadcount) graphql.Marshaler {
	return ec._FamilyHeadcount(ctx, sel, &v)
}

func (ec *executionContext) marshalNFamilyHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFamilyHeadcount(ctx context.Context, sel ast.SelectionSet, v []model.FamilyHeadcount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFamilyHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFamilyHeadcount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFieldChange2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFieldChange(ctx context.Context, sel ast.SelectionSet, v model.FieldChange) graphql.Marshaler {
	return ec._FieldChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNFieldChange2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFieldChange(ctx context.Context, sel ast.SelectionSet, v []model.FieldChange) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFieldChange2cubecastlecmdhrmsserverqueryinternalgraphqlmodelFieldChange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNHeadcountStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelHeadcountStats(ctx context.Context, sel ast.SelectionSet, v model.HeadcountStats) graphql.Marshaler {
	return ec._HeadcountStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNHeadcountStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelHeadcountStats(ctx context.Context, sel ast.SelectionSet, v *model.HeadcountStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HeadcountStats(ctx, sel, v)
}

func (ec *executionContext) marshalNHierarchyStatistics2cubecastlecmdhrmsserverqueryinternalgraphqlmodelHierarchyStatistics(ctx context.Context, sel ast.SelectionSet, v model.HierarchyStatistics) graphql.Marshaler {
	return ec._HierarchyStatistics(ctx, sel, &v)
}

func (ec *executionContext) marshalNHierarchyStatistics2cubecastlecmdhrmsserverqueryinternalgraphqlmodelHierarchyStatistics(ctx context.Context, sel ast.SelectionSet, v *model.HierarchyStatistics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HierarchyStatistics(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIntegrityIssue2cubecastlecmdhrmsserverqueryinternalgraphqlmodelIntegrityIssue(ctx context.Context, sel ast.SelectionSet, v model.IntegrityIssue) graphql.Marshaler {
	return ec._IntegrityIssue(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrityIssue2cubecastlecmdhrmsserverqueryinternalgraphqlmodelIntegrityIssue(ctx context.Context, sel ast.SelectionSet, v []model.IntegrityIssue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntegrityIssue2cubecastlecmdhrmsserverqueryinternalgraphqlmodelIntegrityIssue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobCatalogStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobCatalogStatus(ctx context.Context, v interface{}) (model.JobCatalogStatus, error) {
	var res model.JobCatalogStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobCatalogStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobCatalogStatus(ctx context.Context, sel ast.SelectionSet, v model.JobCatalogStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNJobFamily2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamily(ctx context.Context, sel ast.SelectionSet, v model.JobFamily) graphql.Marshaler {
	return ec._JobFamily(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobFamily2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamily(ctx context.Context, sel ast.SelectionSet, v []model.JobFamily) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobFamily2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamily(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx context.Context, v interface{}) (dto.JobFamilyCode, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.JobFamilyCode(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx context.Context, sel ast.SelectionSet, v dto.JobFamilyCode) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNJobFamilyGroup2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamilyGroup(ctx context.Context, sel ast.SelectionSet, v model.JobFamilyGroup) graphql.Marshaler {
	return ec._JobFamilyGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobFamilyGroup2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamilyGroup(ctx context.Context, sel ast.SelectionSet, v []model.JobFamilyGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobFamilyGroup2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobFamilyGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx context.Context, v interface{}) (dto.JobFamilyGroupCode, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.JobFamilyGroupCode(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx context.Context, sel ast.SelectionSet, v dto.JobFamilyGroupCode) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNJobLevel2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobLevel(ctx context.Context, sel ast.SelectionSet, v model.JobLevel) graphql.Marshaler {
	return ec._JobLevel(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobLevel2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobLevel(ctx context.Context, sel ast.SelectionSet, v []model.JobLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobLevel2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx context.Context, v interface{}) (dto.JobLevelCode, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.JobLevelCode(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx context.Context, sel ast.SelectionSet, v dto.JobLevelCode) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNJobRole2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobRole(ctx context.Context, sel ast.SelectionSet, v model.JobRole) graphql.Marshaler {
	return ec._JobRole(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobRole2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobRole(ctx context.Context, sel ast.SelectionSet, v []model.JobRole) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobRole2cubecastlecmdhrmsserverqueryinternalgraphqlmodelJobRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx context.Context, v interface{}) (dto.JobRoleCode, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.JobRoleCode(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx context.Context, sel ast.SelectionSet, v dto.JobRoleCode) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLevelHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelHeadcount(ctx context.Context, sel ast.SelectionSet, v model.LevelHeadcount) graphql.Marshaler {
	return ec._LevelHeadcount(ctx, sel, &v)
}

func (ec *executionContext) marshalNLevelHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelHeadcount(ctx context.Context, sel ast.SelectionSet, v []model.LevelHeadcount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLevelHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelHeadcount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLevelInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelInconsistency(ctx context.Context, sel ast.SelectionSet, v model.LevelInconsistency) graphql.Marshaler {
	return ec._LevelInconsistency(ctx, sel, &v)
}

func (ec *executionContext) marshalNLevelInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelInconsistency(ctx context.Context, sel ast.SelectionSet, v []model.LevelInconsistency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLevelInconsistency2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelInconsistency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLevelStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelStatistic(ctx context.Context, sel ast.SelectionSet, v model.LevelStatistic) graphql.Marshaler {
	return ec._LevelStatistic(ctx, sel, &v)
}

func (ec *executionContext) marshalNLevelStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelStatistic(ctx context.Context, sel ast.SelectionSet, v []model.LevelStatistic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLevelStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelLevelStatistic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOperatedBy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOperatedBy(ctx context.Context, sel ast.SelectionSet, v *model.OperatedBy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OperatedBy(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx context.Context, sel ast.SelectionSet, v []model.Organization) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOrganizationConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationConnection(ctx context.Context, sel ast.SelectionSet, v model.OrganizationConnection) graphql.Marshaler {
	return ec._OrganizationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationConnection(ctx context.Context, sel ast.SelectionSet, v *model.OrganizationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx context.Context, sel ast.SelectionSet, v model.OrganizationHierarchy) graphql.Marshaler {
	return ec._OrganizationHierarchy(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx context.Context, sel ast.SelectionSet, v []model.OrganizationHierarchy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOrganizationStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationStats(ctx context.Context, sel ast.SelectionSet, v model.OrganizationStats) graphql.Marshaler {
	return ec._OrganizationStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationStats2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationStats(ctx context.Context, sel ast.SelectionSet, v *model.OrganizationStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationStats(ctx, sel, v)
}

func (ec *executionContext) marshalNOrphanedNode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrphanedNode(ctx context.Context, sel ast.SelectionSet, v model.OrphanedNode) graphql.Marshaler {
	return ec._OrphanedNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrphanedNode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrphanedNode(ctx context.Context, sel ast.SelectionSet, v []model.OrphanedNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrphanedNode2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrphanedNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPaginationInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInfo(ctx context.Context, sel ast.SelectionSet, v *model.PaginationInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PaginationInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNPathMismatch2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPathMismatch(ctx context.Context, sel ast.SelectionSet, v model.PathMismatch) graphql.Marshaler {
	return ec._PathMismatch(ctx, sel, &v)
}

func (ec *executionContext) marshalNPathMismatch2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPathMismatch(ctx context.Context, sel ast.SelectionSet, v []model.PathMismatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPathMismatch2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPathMismatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx context.Context, sel ast.SelectionSet, v model.Position) graphql.Marshaler {
	return ec._Position(ctx, sel, &v)
}

func (ec *executionContext) marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx context.Context, sel ast.SelectionSet, v []model.Position) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx context.Context, sel ast.SelectionSet, v *model.Position) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Position(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignment) graphql.Marshaler {
	return ec._PositionAssignment(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx context.Context, sel ast.SelectionSet, v []model.PositionAssignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx context.Context, sel ast.SelectionSet, v *model.PositionAssignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PositionAssignment(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionAssignmentAudit2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAudit(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentAudit) graphql.Marshaler {
	return ec._PositionAssignmentAudit(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionAssignmentAudit2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAudit(ctx context.Context, sel ast.SelectionSet, v []model.PositionAssignmentAudit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionAssignmentAudit2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAudit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPositionAssignmentAuditConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAuditConnection(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentAuditConnection) graphql.Marshaler {
	return ec._PositionAssignmentAuditConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionAssignmentAuditConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentAuditConnection(ctx context.Context, sel ast.SelectionSet, v *model.PositionAssignmentAuditConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PositionAssignmentAuditConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionAssignmentConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentConnection(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentConnection) graphql.Marshaler {
	return ec._PositionAssignmentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionAssignmentConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentConnection(ctx context.Context, sel ast.SelectionSet, v *model.PositionAssignmentConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PositionAssignmentConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionAssignmentEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentEdge(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentEdge) graphql.Marshaler {
	return ec._PositionAssignmentEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionAssignmentEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentEdge(ctx context.Context, sel ast.SelectionSet, v []model.PositionAssignmentEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionAssignmentEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPositionAssignmentSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortField(ctx context.Context, v interface{}) (model.PositionAssignmentSortField, error) {
	var res model.PositionAssignmentSortField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionAssignmentSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortField(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentSortField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPositionAssignmentSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortInput(ctx context.Context, v interface{}) (model.PositionAssignmentSortInput, error) {
	res, err := ec.unmarshalInputPositionAssignmentSortInput(ctx, v)
	return *res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx context.Context, v interface{}) (model.PositionAssignmentStatus, error) {
	var res model.PositionAssignmentStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx context.Context, v interface{}) (model.PositionAssignmentType, error) {
	var res model.PositionAssignmentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx context.Context, sel ast.SelectionSet, v model.PositionAssignmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx context.Context, v interface{}) (dto.PositionCode, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.PositionCode(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx context.Context, sel ast.SelectionSet, v dto.PositionCode) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPositionConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionConnection(ctx context.Context, sel ast.SelectionSet, v model.PositionConnection) graphql.Marshaler {
	return ec._PositionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionConnection(ctx context.Context, sel ast.SelectionSet, v *model.PositionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PositionConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionEdge(ctx context.Context, sel ast.SelectionSet, v model.PositionEdge) graphql.Marshaler {
	return ec._PositionEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionEdge(ctx context.Context, sel ast.SelectionSet, v []model.PositionEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPositionSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortField(ctx context.Context, v interface{}) (model.PositionSortField, error) {
	var res model.PositionSortField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortField(ctx context.Context, sel ast.SelectionSet, v model.PositionSortField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortInput(ctx context.Context, v interface{}) (model.PositionSortInput, error) {
	res, err := ec.unmarshalInputPositionSortInput(ctx, v)
	return *res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx context.Context, v interface{}) (model.PositionStatus, error) {
	var res model.PositionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx context.Context, sel ast.SelectionSet, v model.PositionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPositionTimelineCategory2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineCategory(ctx context.Context, v interface{}) (model.PositionTimelineCategory, error) {
	var res model.PositionTimelineCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionTimelineCategory2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineCategory(ctx context.Context, sel ast.SelectionSet, v model.PositionTimelineCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPositionTimelineEntry2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineEntry(ctx context.Context, sel ast.SelectionSet, v model.PositionTimelineEntry) graphql.Marshaler {
	return ec._PositionTimelineEntry(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionTimelineEntry2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineEntry(ctx context.Context, sel ast.SelectionSet, v []model.PositionTimelineEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionTimelineEntry2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTimelineEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPositionTransfer2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransfer(ctx context.Context, sel ast.SelectionSet, v model.PositionTransfer) graphql.Marshaler {
	return ec._PositionTransfer(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionTransfer2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransfer(ctx context.Context, sel ast.SelectionSet, v []model.PositionTransfer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionTransfer2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransfer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPositionTransfer2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransfer(ctx context.Context, sel ast.SelectionSet, v *model.PositionTransfer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PositionTransfer(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionTransferConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferConnection(ctx context.Context, sel ast.SelectionSet, v model.PositionTransferConnection) graphql.Marshaler {
	return ec._PositionTransferConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionTransferConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferConnection(ctx context.Context, sel ast.SelectionSet, v *model.PositionTransferConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PositionTransferConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNPositionTransferEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferEdge(ctx context.Context, sel ast.SelectionSet, v model.PositionTransferEdge) graphql.Marshaler {
	return ec._PositionTransferEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNPositionTransferEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferEdge(ctx context.Context, sel ast.SelectionSet, v []model.PositionTransferEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionTransferEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionTransferEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx context.Context, v interface{}) (model.PositionType, error) {
	var res model.PositionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx context.Context, sel ast.SelectionSet, v model.PositionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRepairSuggestion2cubecastlecmdhrmsserverqueryinternalgraphqlmodelRepairSuggestion(ctx context.Context, sel ast.SelectionSet, v model.RepairSuggestion) graphql.Marshaler {
	return ec._RepairSuggestion(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepairSuggestion2cubecastlecmdhrmsserverqueryinternalgraphqlmodelRepairSuggestion(ctx context.Context, sel ast.SelectionSet, v []model.RepairSuggestion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepairSuggestion2cubecastlecmdhrmsserverqueryinternalgraphqlmodelRepairSuggestion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx context.Context, v interface{}) (model.SearchField, error) {
	var res model.SearchField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx context.Context, sel ast.SelectionSet, v model.SearchField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx context.Context, v interface{}) (model.Status, error) {
	var res model.Status
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx context.Context, sel ast.SelectionSet, v model.Status) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStatusStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatusStatistic(ctx context.Context, sel ast.SelectionSet, v model.StatusStatistic) graphql.Marshaler {
	return ec._StatusStatistic(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatusStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatusStatistic(ctx context.Context, sel ast.SelectionSet, v []model.StatusStatistic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatusStatistic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTemporalInfo2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTemporalInfo(ctx context.Context, sel ast.SelectionSet, v *model.TemporalInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TemporalInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNTemporalStatistics2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTemporalStatistics(ctx context.Context, sel ast.SelectionSet, v *model.TemporalStatistics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TemporalStatistics(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeHeadcount(ctx context.Context, sel ast.SelectionSet, v model.TypeHeadcount) graphql.Marshaler {
	return ec._TypeHeadcount(ctx, sel, &v)
}

func (ec *executionContext) marshalNTypeHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeHeadcount(ctx context.Context, sel ast.SelectionSet, v []model.TypeHeadcount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeHeadcount2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeHeadcount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTypeStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeStatistic(ctx context.Context, sel ast.SelectionSet, v model.TypeStatistic) graphql.Marshaler {
	return ec._TypeStatistic(ctx, sel, &v)
}

func (ec *executionContext) marshalNTypeStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeStatistic(ctx context.Context, sel ast.SelectionSet, v []model.TypeStatistic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeStatistic2cubecastlecmdhrmsserverqueryinternalgraphqlmodelTypeStatistic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUUID2cubecastleinternalorganizationdtoUUID(ctx context.Context, v interface{}) (dto.UUID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := dto.UUID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUUID2cubecastleinternalorganizationdtoUUID(ctx context.Context, sel ast.SelectionSet, v dto.UUID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx context.Context, v interface{}) (model.UnitType, error) {
	var res model.UnitType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx context.Context, sel ast.SelectionSet, v model.UnitType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNVacantPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPosition(ctx context.Context, sel ast.SelectionSet, v model.VacantPosition) graphql.Marshaler {
	return ec._VacantPosition(ctx, sel, &v)
}

func (ec *executionContext) marshalNVacantPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPosition(ctx context.Context, sel ast.SelectionSet, v []model.VacantPosition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVacantPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPosition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVacantPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPosition(ctx context.Context, sel ast.SelectionSet, v *model.VacantPosition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VacantPosition(ctx, sel, v)
}

func (ec *executionContext) marshalNVacantPositionConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionConnection(ctx context.Context, sel ast.SelectionSet, v model.VacantPositionConnection) graphql.Marshaler {
	return ec._VacantPositionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNVacantPositionConnection2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionConnection(ctx context.Context, sel ast.SelectionSet, v *model.VacantPositionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VacantPositionConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNVacantPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionEdge(ctx context.Context, sel ast.SelectionSet, v model.VacantPositionEdge) graphql.Marshaler {
	return ec._VacantPositionEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalNVacantPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionEdge(ctx context.Context, sel ast.SelectionSet, v []model.VacantPositionEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVacantPositionEdge2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNVacantPositionSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortField(ctx context.Context, v interface{}) (model.VacantPositionSortField, error) {
	var res model.VacantPositionSortField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVacantPositionSortField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortField(ctx context.Context, sel ast.SelectionSet, v model.VacantPositionSortField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNVacantPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortInput(ctx context.Context, v interface{}) (model.VacantPositionSortInput, error) {
	res, err := ec.unmarshalInputVacantPositionSortInput(ctx, v)
	return *res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAuditLogDetail2cubecastlecmdhrmsserverqueryinternalgraphqlmodelAuditLogDetail(ctx context.Context, sel ast.SelectionSet, v *model.AuditLogDetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuditLogDetail(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODate2cubecastleinternalorganizationdtoDate(ctx context.Context, v interface{}) (*dto.Date, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := dto.Date(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2cubecastleinternalorganizationdtoDate(ctx context.Context, sel ast.SelectionSet, v *dto.Date) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalODateRangeInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelDateRangeInput(ctx context.Context, v interface{}) (*model.DateRangeInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDateRangeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODateTime2cubecastleinternalorganizationdtoDateTime(ctx context.Context, v interface{}) (*dto.DateTime, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := dto.DateTime(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2cubecastleinternalorganizationdtoDateTime(ctx context.Context, sel ast.SelectionSet, v *dto.DateTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalOEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx context.Context, v interface{}) ([]model.EmploymentType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.EmploymentType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx context.Context, sel ast.SelectionSet, v []model.EmploymentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEmploymentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelEmploymentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOJSON2cubecastleinternalorganizationdtoJSON(ctx context.Context, v interface{}) (dto.JSON, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJSON(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2cubecastleinternalorganizationdtoJSON(ctx context.Context, sel ast.SelectionSet, v dto.JSON) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JSON(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx context.Context, v interface{}) ([]dto.JobFamilyCode, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]dto.JobFamilyCode, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx context.Context, sel ast.SelectionSet, v []dto.JobFamilyCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNJobFamilyCode2cubecastleinternalorganizationdtoJobFamilyCode(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx context.Context, v interface{}) ([]dto.JobFamilyGroupCode, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]dto.JobFamilyGroupCode, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx context.Context, sel ast.SelectionSet, v []dto.JobFamilyGroupCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNJobFamilyGroupCode2cubecastleinternalorganizationdtoJobFamilyGroupCode(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx context.Context, v interface{}) ([]dto.JobLevelCode, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]dto.JobLevelCode, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx context.Context, sel ast.SelectionSet, v []dto.JobLevelCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNJobLevelCode2cubecastleinternalorganizationdtoJobLevelCode(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx context.Context, v interface{}) ([]dto.JobRoleCode, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]dto.JobRoleCode, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx context.Context, sel ast.SelectionSet, v []dto.JobRoleCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNJobRoleCode2cubecastleinternalorganizationdtoJobRoleCode(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOperationType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOperationType(ctx context.Context, v interface{}) (*model.OperationType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.OperationType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOperationType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOperationType(ctx context.Context, sel ast.SelectionSet, v *model.OperationType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOOrganization2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganization(ctx context.Context, sel ast.SelectionSet, v *model.Organization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOrganizationFilter2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationFilter(ctx context.Context, v interface{}) (*model.OrganizationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrganizationFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrganizationHierarchy2cubecastlecmdhrmsserverqueryinternalgraphqlmodelOrganizationHierarchy(ctx context.Context, sel ast.SelectionSet, v *model.OrganizationHierarchy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OrganizationHierarchy(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPaginationInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPaginationInput(ctx context.Context, v interface{}) (*model.PaginationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPaginationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPosition2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPosition(ctx context.Context, sel ast.SelectionSet, v *model.Position) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Position(ctx, sel, v)
}

func (ec *executionContext) marshalOPositionAssignment2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignment(ctx context.Context, sel ast.SelectionSet, v *model.PositionAssignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PositionAssignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPositionAssignmentFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentFilterInput(ctx context.Context, v interface{}) (*model.PositionAssignmentFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPositionAssignmentFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPositionAssignmentSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortInput(ctx context.Context, v interface{}) ([]model.PositionAssignmentSortInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.PositionAssignmentSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPositionAssignmentSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx context.Context, v interface{}) (*model.PositionAssignmentStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PositionAssignmentStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPositionAssignmentStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentStatus(ctx context.Context, sel ast.SelectionSet, v *model.PositionAssignmentStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx context.Context, v interface{}) ([]model.PositionAssignmentType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.PositionAssignmentType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx context.Context, sel ast.SelectionSet, v []model.PositionAssignmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx context.Context, v interface{}) (*model.PositionAssignmentType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PositionAssignmentType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPositionAssignmentType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionAssignmentType(ctx context.Context, sel ast.SelectionSet, v *model.PositionAssignmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx context.Context, v interface{}) ([]dto.PositionCode, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]dto.PositionCode, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx context.Context, sel ast.SelectionSet, v []dto.PositionCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx context.Context, v interface{}) (*dto.PositionCode, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := dto.PositionCode(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPositionCode2cubecastleinternalorganizationdtoPositionCode(ctx context.Context, sel ast.SelectionSet, v *dto.PositionCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalOPositionFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionFilterInput(ctx context.Context, v interface{}) (*model.PositionFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPositionFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortInput(ctx context.Context, v interface{}) ([]model.PositionSortInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.PositionSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx context.Context, v interface{}) (*model.PositionStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PositionStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPositionStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionStatus(ctx context.Context, sel ast.SelectionSet, v *model.PositionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx context.Context, v interface{}) ([]model.PositionType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.PositionType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx context.Context, sel ast.SelectionSet, v []model.PositionType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPositionType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelPositionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx context.Context, v interface{}) ([]model.SearchField, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.SearchField, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx context.Context, sel ast.SelectionSet, v []model.SearchField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchField2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSearchField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSortOrder2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSortOrder(ctx context.Context, v interface{}) (*model.SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.SortOrder)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortOrder2cubecastlecmdhrmsserverqueryinternalgraphqlmodelSortOrder(ctx context.Context, sel ast.SelectionSet, v *model.SortOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx context.Context, v interface{}) (*model.Status, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Status)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStatus2cubecastlecmdhrmsserverqueryinternalgraphqlmodelStatus(ctx context.Context, sel ast.SelectionSet, v *model.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOUUID2cubecastleinternalorganizationdtoUUID(ctx context.Context, v interface{}) (*dto.UUID, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := dto.UUID(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUUID2cubecastleinternalorganizationdtoUUID(ctx context.Context, sel ast.SelectionSet, v *dto.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalOUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx context.Context, v interface{}) (*model.UnitType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.UnitType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUnitType2cubecastlecmdhrmsserverqueryinternalgraphqlmodelUnitType(ctx context.Context, sel ast.SelectionSet, v *model.UnitType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVacantPositionFilterInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionFilterInput(ctx context.Context, v interface{}) (*model.VacantPositionFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVacantPositionFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOVacantPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortInput(ctx context.Context, v interface{}) ([]model.VacantPositionSortInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.VacantPositionSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVacantPositionSortInput2cubecastlecmdhrmsserverqueryinternalgraphqlmodelVacantPositionSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
