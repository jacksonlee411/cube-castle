// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"cube-castle/internal/organization/dto"
	"fmt"
	"io"
	"strconv"
)

type AssignmentStats struct {
	PositionCode         *dto.PositionCode `json:"positionCode,omitempty"`
	OrganizationCode     *string           `json:"organizationCode,omitempty"`
	TotalAssignments     int               `json:"totalAssignments"`
	ActiveAssignments    int               `json:"activeAssignments"`
	PendingAssignments   int               `json:"pendingAssignments"`
	EndedAssignments     int               `json:"endedAssignments"`
	PrimaryAssignments   int               `json:"primaryAssignments"`
	SecondaryAssignments int               `json:"secondaryAssignments"`
	ActingAssignments    int               `json:"actingAssignments"`
	LastUpdatedAt        dto.DateTime      `json:"lastUpdatedAt"`
}

// Comprehensive audit log entry with complete change tracking information.
// Each audit record tracks changes to a specific organization temporal version (recordId).
type AuditLogDetail struct {
	AuditID         string        `json:"auditId"`
	RecordID        string        `json:"recordId"`
	Operation       string        `json:"operation"`
	Timestamp       string        `json:"timestamp"`
	OperationReason *string       `json:"operationReason,omitempty"`
	BeforeData      *string       `json:"beforeData,omitempty"`
	AfterData       *string       `json:"afterData,omitempty"`
	ModifiedFields  []string      `json:"modifiedFields"`
	Changes         []FieldChange `json:"changes"`
}

// Cache inconsistency detection result.
type CacheInconsistency struct {
	Code            string `json:"code"`
	FieldName       string `json:"fieldName"`
	CachedValue     string `json:"cachedValue"`
	CalculatedValue string `json:"calculatedValue"`
	ImpactLevel     string `json:"impactLevel"`
}

// Circular reference detection result.
type CircularReference struct {
	AffectedCodes []string `json:"affectedCodes"`
	CircularPath  []string `json:"circularPath"`
	Severity      string   `json:"severity"`
}

// Consistency check findings with detailed issues.
type ConsistencyFindings struct {
	PathMismatches       []PathMismatch       `json:"pathMismatches"`
	LevelInconsistencies []LevelInconsistency `json:"levelInconsistencies"`
	OrphanedNodes        []OrphanedNode       `json:"orphanedNodes"`
	CircularReferences   []CircularReference  `json:"circularReferences"`
	DepthViolations      []DepthViolation     `json:"depthViolations"`
	CacheInconsistencies []CacheInconsistency `json:"cacheInconsistencies"`
}

// Simplified data changes with before/after comparison.
type DataChanges struct {
	BeforeData     dto.JSON `json:"beforeData,omitempty"`
	AfterData      dto.JSON `json:"afterData,omitempty"`
	ModifiedFields []string `json:"modifiedFields"`
}

// Date range specification.
type DateRange struct {
	Earliest dto.DateTime `json:"earliest"`
	Latest   dto.DateTime `json:"latest"`
}

// Date range input for filtering.
type DateRangeInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

// Hierarchy depth distribution analysis.
type DepthDistribution struct {
	Depth int `json:"depth"`
	Count int `json:"count"`
}

// Depth violation detection result.
type DepthViolation struct {
	Code            string   `json:"code"`
	CurrentDepth    int      `json:"currentDepth"`
	MaxAllowedDepth int      `json:"maxAllowedDepth"`
	ParentChain     []string `json:"parentChain"`
}

type FamilyHeadcount struct {
	JobFamilyCode dto.JobFamilyCode `json:"jobFamilyCode"`
	JobFamilyName *string           `json:"jobFamilyName,omitempty"`
	Capacity      float64           `json:"capacity"`
	Utilized      float64           `json:"utilized"`
	Available     float64           `json:"available"`
}

// Detailed field-level change information for audit tracking.
type FieldChange struct {
	Field    string  `json:"field"`
	OldValue *string `json:"oldValue,omitempty"`
	NewValue *string `json:"newValue,omitempty"`
	DataType string  `json:"dataType"`
}

type HeadcountStats struct {
	OrganizationCode string            `json:"organizationCode"`
	OrganizationName string            `json:"organizationName"`
	TotalCapacity    float64           `json:"totalCapacity"`
	TotalFilled      float64           `json:"totalFilled"`
	TotalAvailable   float64           `json:"totalAvailable"`
	FillRate         float64           `json:"fillRate"`
	ByLevel          []LevelHeadcount  `json:"byLevel"`
	ByType           []TypeHeadcount   `json:"byType"`
	ByFamily         []FamilyHeadcount `json:"byFamily"`
}

// Hierarchy consistency check report with detailed findings and repair suggestions.
type HierarchyConsistencyReport struct {
	CheckID            string               `json:"checkId"`
	TenantID           string               `json:"tenantId"`
	ExecutedAt         dto.DateTime         `json:"executedAt"`
	ExecutionTimeMs    int                  `json:"executionTimeMs"`
	TotalChecked       int                  `json:"totalChecked"`
	IssuesFound        int                  `json:"issuesFound"`
	CheckMode          ConsistencyCheckMode `json:"checkMode"`
	ConsistencyReport  *ConsistencyFindings `json:"consistencyReport"`
	RepairSuggestions  []RepairSuggestion   `json:"repairSuggestions"`
	HealthScore        float64              `json:"healthScore"`
	RecommendedActions []string             `json:"recommendedActions"`
}

// Hierarchy distribution statistics and integrity analysis.
type HierarchyStatistics struct {
	TenantID           string              `json:"tenantId"`
	TotalOrganizations int                 `json:"totalOrganizations"`
	MaxDepth           int                 `json:"maxDepth"`
	AvgDepth           float64             `json:"avgDepth"`
	DepthDistribution  []DepthDistribution `json:"depthDistribution"`
	RootOrganizations  int                 `json:"rootOrganizations"`
	LeafOrganizations  int                 `json:"leafOrganizations"`
	IntegrityIssues    []IntegrityIssue    `json:"integrityIssues"`
	LastAnalyzed       string              `json:"lastAnalyzed"`
}

// Hierarchy integrity issue detection.
type IntegrityIssue struct {
	Type          string   `json:"type"`
	Count         int      `json:"count"`
	AffectedCodes []string `json:"affectedCodes"`
}

type JobFamily struct {
	Code          dto.JobFamilyCode      `json:"code"`
	RecordID      dto.UUID               `json:"recordId"`
	GroupCode     dto.JobFamilyGroupCode `json:"groupCode"`
	Name          string                 `json:"name"`
	Status        JobCatalogStatus       `json:"status"`
	EffectiveDate dto.Date               `json:"effectiveDate"`
	EndDate       *dto.Date              `json:"endDate,omitempty"`
	Description   *string                `json:"description,omitempty"`
}

type JobFamilyGroup struct {
	Code          dto.JobFamilyGroupCode `json:"code"`
	RecordID      dto.UUID               `json:"recordId"`
	Name          string                 `json:"name"`
	Status        JobCatalogStatus       `json:"status"`
	EffectiveDate dto.Date               `json:"effectiveDate"`
	EndDate       *dto.Date              `json:"endDate,omitempty"`
	Description   *string                `json:"description,omitempty"`
}

type JobLevel struct {
	Code          dto.JobLevelCode `json:"code"`
	RecordID      dto.UUID         `json:"recordId"`
	RoleCode      dto.JobRoleCode  `json:"roleCode"`
	Name          string           `json:"name"`
	Status        JobCatalogStatus `json:"status"`
	EffectiveDate dto.Date         `json:"effectiveDate"`
	EndDate       *dto.Date        `json:"endDate,omitempty"`
	LevelRank     int              `json:"levelRank"`
	Description   *string          `json:"description,omitempty"`
}

type JobRole struct {
	Code          dto.JobRoleCode   `json:"code"`
	RecordID      dto.UUID          `json:"recordId"`
	FamilyCode    dto.JobFamilyCode `json:"familyCode"`
	Name          string            `json:"name"`
	Status        JobCatalogStatus  `json:"status"`
	EffectiveDate dto.Date          `json:"effectiveDate"`
	EndDate       *dto.Date         `json:"endDate,omitempty"`
	Description   *string           `json:"description,omitempty"`
}

type LevelHeadcount struct {
	JobLevelCode dto.JobLevelCode `json:"jobLevelCode"`
	Capacity     float64          `json:"capacity"`
	Utilized     float64          `json:"utilized"`
	Available    float64          `json:"available"`
}

// Level inconsistency detection result.
type LevelInconsistency struct {
	Code          string `json:"code"`
	ExpectedLevel int    `json:"expectedLevel"`
	ActualLevel   int    `json:"actualLevel"`
	ParentCode    string `json:"parentCode"`
	Reason        string `json:"reason"`
}

// Statistics by hierarchy level.
type LevelStatistic struct {
	Level int `json:"level"`
	Count int `json:"count"`
}

// Standard operator information with ID and display name.
type OperatedBy struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

// Operations summary statistics.
type OperationsSummary struct {
	Create     int `json:"create"`
	Update     int `json:"update"`
	Suspend    int `json:"suspend"`
	Reactivate int `json:"reactivate"`
	Delete     int `json:"delete"`
}

// Organization unit entity with complete temporal and audit information.
// Represents the current state based on asOfDate parameter or latest effective record.
type Organization struct {
	Code             string   `json:"code"`
	ParentCode       string   `json:"parentCode"`
	TenantID         string   `json:"tenantId"`
	Name             string   `json:"name"`
	UnitType         UnitType `json:"unitType"`
	Status           Status   `json:"status"`
	Level            int      `json:"level"`
	SortOrder        *int     `json:"sortOrder,omitempty"`
	CodePath         string   `json:"codePath"`
	NamePath         string   `json:"namePath"`
	Path             *string  `json:"path,omitempty"`
	Description      *string  `json:"description,omitempty"`
	Profile          *string  `json:"profile,omitempty"`
	ChangeReason     *string  `json:"changeReason,omitempty"`
	EffectiveDate    string   `json:"effectiveDate"`
	EndDate          *string  `json:"endDate,omitempty"`
	CreatedAt        string   `json:"createdAt"`
	UpdatedAt        string   `json:"updatedAt"`
	RecordID         string   `json:"recordId"`
	IsCurrent        bool     `json:"isCurrent"`
	IsTemporal       bool     `json:"isTemporal"`
	IsFuture         bool     `json:"isFuture"`
	HierarchyDepth   int      `json:"hierarchyDepth"`
	ChildrenCount    int      `json:"childrenCount"`
	DeletedAt        *string  `json:"deletedAt,omitempty"`
	DeletedBy        *string  `json:"deletedBy,omitempty"`
	DeletionReason   *string  `json:"deletionReason,omitempty"`
	SuspendedAt      *string  `json:"suspendedAt,omitempty"`
	SuspendedBy      *string  `json:"suspendedBy,omitempty"`
	SuspensionReason *string  `json:"suspensionReason,omitempty"`
}

// Connection type for paginated organization results with metadata.
type OrganizationConnection struct {
	Data       []Organization  `json:"data"`
	Pagination *PaginationInfo `json:"pagination"`
	Temporal   *TemporalInfo   `json:"temporal"`
}

// Comprehensive filter for organization queries with temporal support.
type OrganizationFilter struct {
	AsOfDate                 *string         `json:"asOfDate,omitempty"`
	IncludeFuture            *bool           `json:"includeFuture,omitempty"`
	OnlyFuture               *bool           `json:"onlyFuture,omitempty"`
	UnitType                 *UnitType       `json:"unitType,omitempty"`
	Status                   *Status         `json:"status,omitempty"`
	ParentCode               *string         `json:"parentCode,omitempty"`
	Codes                    []string        `json:"codes,omitempty"`
	ExcludeCodes             []string        `json:"excludeCodes,omitempty"`
	ExcludeDescendantsOf     *string         `json:"excludeDescendantsOf,omitempty"`
	IncludeDisabledAncestors *bool           `json:"includeDisabledAncestors,omitempty"`
	Level                    *int            `json:"level,omitempty"`
	MinLevel                 *int            `json:"minLevel,omitempty"`
	MaxLevel                 *int            `json:"maxLevel,omitempty"`
	RootsOnly                *bool           `json:"rootsOnly,omitempty"`
	LeavesOnly               *bool           `json:"leavesOnly,omitempty"`
	SearchText               *string         `json:"searchText,omitempty"`
	SearchFields             []SearchField   `json:"searchFields,omitempty"`
	HasChildren              *bool           `json:"hasChildren,omitempty"`
	HasProfile               *bool           `json:"hasProfile,omitempty"`
	ProfileContains          dto.JSON        `json:"profileContains,omitempty"`
	OperationType            *OperationType  `json:"operationType,omitempty"`
	OperatedBy               *string         `json:"operatedBy,omitempty"`
	OperationDateRange       *DateRangeInput `json:"operationDateRange,omitempty"`
}

// Hierarchy-specific organization information with relationship context.
type OrganizationHierarchy struct {
	Code           string                  `json:"code"`
	Name           string                  `json:"name"`
	Level          int                     `json:"level"`
	HierarchyDepth int                     `json:"hierarchyDepth"`
	CodePath       string                  `json:"codePath"`
	NamePath       string                  `json:"namePath"`
	ParentChain    []string                `json:"parentChain"`
	ChildrenCount  int                     `json:"childrenCount"`
	IsRoot         bool                    `json:"isRoot"`
	IsLeaf         bool                    `json:"isLeaf"`
	Children       []OrganizationHierarchy `json:"children"`
}

// Comprehensive organization statistics with temporal breakdown.
type OrganizationStats struct {
	TotalCount    int                 `json:"totalCount"`
	ActiveCount   int                 `json:"activeCount"`
	InactiveCount int                 `json:"inactiveCount"`
	PlannedCount  int                 `json:"plannedCount"`
	DeletedCount  int                 `json:"deletedCount"`
	ByType        []TypeStatistic     `json:"byType"`
	ByStatus      []StatusStatistic   `json:"byStatus"`
	ByLevel       []LevelStatistic    `json:"byLevel"`
	TemporalStats *TemporalStatistics `json:"temporalStats"`
}

// Orphaned node detection result.
type OrphanedNode struct {
	Code       string `json:"code"`
	Name       string `json:"name"`
	ParentCode string `json:"parentCode"`
	Reason     string `json:"reason"`
}

// Pagination information for connection types.
type PaginationInfo struct {
	Total       int  `json:"total"`
	Page        int  `json:"page"`
	PageSize    int  `json:"pageSize"`
	HasNext     bool `json:"hasNext"`
	HasPrevious bool `json:"hasPrevious"`
}

// Pagination configuration for result sets.
type PaginationInput struct {
	Page      *int    `json:"page,omitempty"`
	PageSize  *int    `json:"pageSize,omitempty"`
	SortBy    *string `json:"sortBy,omitempty"`
	SortOrder *string `json:"sortOrder,omitempty"`
}

// Path mismatch detection result.
type PathMismatch struct {
	Code             string `json:"code"`
	ExpectedCodePath string `json:"expectedCodePath"`
	ActualCodePath   string `json:"actualCodePath"`
	ExpectedNamePath string `json:"expectedNamePath"`
	ActualNamePath   string `json:"actualNamePath"`
	Severity         string `json:"severity"`
}

// Position resource exposed via GraphQL.
type Position struct {
	Code                  dto.PositionCode       `json:"code"`
	RecordID              dto.UUID               `json:"recordId"`
	TenantID              dto.UUID               `json:"tenantId"`
	Title                 string                 `json:"title"`
	JobProfileCode        *string                `json:"jobProfileCode,omitempty"`
	JobProfileName        *string                `json:"jobProfileName,omitempty"`
	JobFamilyGroupCode    dto.JobFamilyGroupCode `json:"jobFamilyGroupCode"`
	JobFamilyCode         dto.JobFamilyCode      `json:"jobFamilyCode"`
	JobRoleCode           dto.JobRoleCode        `json:"jobRoleCode"`
	JobLevelCode          dto.JobLevelCode       `json:"jobLevelCode"`
	OrganizationCode      string                 `json:"organizationCode"`
	OrganizationName      *string                `json:"organizationName,omitempty"`
	PositionType          PositionType           `json:"positionType"`
	EmploymentType        EmploymentType         `json:"employmentType"`
	GradeLevel            *string                `json:"gradeLevel,omitempty"`
	HeadcountCapacity     float64                `json:"headcountCapacity"`
	HeadcountInUse        float64                `json:"headcountInUse"`
	AvailableHeadcount    float64                `json:"availableHeadcount"`
	CurrentAssignment     *PositionAssignment    `json:"currentAssignment,omitempty"`
	AssignmentHistory     []PositionAssignment   `json:"assignmentHistory"`
	ReportsToPositionCode *dto.PositionCode      `json:"reportsToPositionCode,omitempty"`
	Status                PositionStatus         `json:"status"`
	EffectiveDate         dto.Date               `json:"effectiveDate"`
	EndDate               *dto.Date              `json:"endDate,omitempty"`
	IsCurrent             bool                   `json:"isCurrent"`
	IsFuture              bool                   `json:"isFuture"`
	CreatedAt             dto.DateTime           `json:"createdAt"`
	UpdatedAt             dto.DateTime           `json:"updatedAt"`
}

type PositionAssignment struct {
	AssignmentID     dto.UUID                 `json:"assignmentId"`
	PositionCode     dto.PositionCode         `json:"positionCode"`
	PositionRecordID dto.UUID                 `json:"positionRecordId"`
	EmployeeID       dto.UUID                 `json:"employeeId"`
	EmployeeName     string                   `json:"employeeName"`
	EmployeeNumber   *string                  `json:"employeeNumber,omitempty"`
	AssignmentType   PositionAssignmentType   `json:"assignmentType"`
	AssignmentStatus PositionAssignmentStatus `json:"assignmentStatus"`
	Fte              float64                  `json:"fte"`
	EffectiveDate    dto.Date                 `json:"effectiveDate"`
	EndDate          *dto.Date                `json:"endDate,omitempty"`
	ActingUntil      *dto.Date                `json:"actingUntil,omitempty"`
	AutoRevert       bool                     `json:"autoRevert"`
	ReminderSentAt   *dto.DateTime            `json:"reminderSentAt,omitempty"`
	IsCurrent        bool                     `json:"isCurrent"`
	Notes            *string                  `json:"notes,omitempty"`
	CreatedAt        dto.DateTime             `json:"createdAt"`
	UpdatedAt        dto.DateTime             `json:"updatedAt"`
}

type PositionAssignmentAudit struct {
	AssignmentID  dto.UUID     `json:"assignmentId"`
	EventType     string       `json:"eventType"`
	EffectiveDate dto.Date     `json:"effectiveDate"`
	EndDate       *dto.Date    `json:"endDate,omitempty"`
	Actor         string       `json:"actor"`
	Changes       dto.JSON     `json:"changes,omitempty"`
	CreatedAt     dto.DateTime `json:"createdAt"`
}

type PositionAssignmentAuditConnection struct {
	Data       []PositionAssignmentAudit `json:"data"`
	Pagination *PaginationInfo           `json:"pagination"`
	TotalCount int                       `json:"totalCount"`
}

type PositionAssignmentConnection struct {
	Edges      []PositionAssignmentEdge `json:"edges"`
	Pagination *PaginationInfo          `json:"pagination"`
	Data       []PositionAssignment     `json:"data"`
	TotalCount int                      `json:"totalCount"`
}

type PositionAssignmentEdge struct {
	Cursor string              `json:"cursor"`
	Node   *PositionAssignment `json:"node"`
}

// Filter options for position assignment queries.
type PositionAssignmentFilterInput struct {
	EmployeeID        *dto.UUID                 `json:"employeeId,omitempty"`
	Status            *PositionAssignmentStatus `json:"status,omitempty"`
	AssignmentTypes   []PositionAssignmentType  `json:"assignmentTypes,omitempty"`
	DateRange         *DateRangeInput           `json:"dateRange,omitempty"`
	AsOfDate          *dto.Date                 `json:"asOfDate,omitempty"`
	IncludeHistorical *bool                     `json:"includeHistorical,omitempty"`
	IncludeActingOnly *bool                     `json:"includeActingOnly,omitempty"`
}

// Sorting input for assignment queries.
type PositionAssignmentSortInput struct {
	Field     PositionAssignmentSortField `json:"field"`
	Direction *SortOrder                  `json:"direction,omitempty"`
}

type PositionConnection struct {
	Edges      []PositionEdge  `json:"edges"`
	Pagination *PaginationInfo `json:"pagination"`
	Data       []Position      `json:"data"`
	TotalCount int             `json:"totalCount"`
}

type PositionEdge struct {
	Cursor string    `json:"cursor"`
	Node   *Position `json:"node"`
}

// Filter options for position queries.
type PositionFilterInput struct {
	OrganizationCode    *string                  `json:"organizationCode,omitempty"`
	PositionCodes       []dto.PositionCode       `json:"positionCodes,omitempty"`
	Status              *PositionStatus          `json:"status,omitempty"`
	JobFamilyGroupCodes []dto.JobFamilyGroupCode `json:"jobFamilyGroupCodes,omitempty"`
	JobFamilyCodes      []dto.JobFamilyCode      `json:"jobFamilyCodes,omitempty"`
	JobRoleCodes        []dto.JobRoleCode        `json:"jobRoleCodes,omitempty"`
	JobLevelCodes       []dto.JobLevelCode       `json:"jobLevelCodes,omitempty"`
	PositionTypes       []PositionType           `json:"positionTypes,omitempty"`
	EmploymentTypes     []EmploymentType         `json:"employmentTypes,omitempty"`
	EffectiveRange      *DateRangeInput          `json:"effectiveRange,omitempty"`
}

// Sorting input for position queries.
type PositionSortInput struct {
	Field     PositionSortField `json:"field"`
	Direction *SortOrder        `json:"direction,omitempty"`
}

// Entry describing a specific temporal version of a position.
type PositionTimelineEntry struct {
	RecordID         dto.UUID                  `json:"recordId"`
	Status           PositionStatus            `json:"status"`
	Title            string                    `json:"title"`
	EffectiveDate    dto.Date                  `json:"effectiveDate"`
	EndDate          *dto.Date                 `json:"endDate,omitempty"`
	IsCurrent        bool                      `json:"isCurrent"`
	ChangeReason     *string                   `json:"changeReason,omitempty"`
	TimelineCategory PositionTimelineCategory  `json:"timelineCategory"`
	AssignmentType   *PositionAssignmentType   `json:"assignmentType,omitempty"`
	AssignmentStatus *PositionAssignmentStatus `json:"assignmentStatus,omitempty"`
}

type PositionTransfer struct {
	TransferID           dto.UUID         `json:"transferId"`
	PositionCode         dto.PositionCode `json:"positionCode"`
	FromOrganizationCode string           `json:"fromOrganizationCode"`
	ToOrganizationCode   string           `json:"toOrganizationCode"`
	EffectiveDate        dto.Date         `json:"effectiveDate"`
	InitiatedBy          *OperatedBy      `json:"initiatedBy"`
	OperationReason      *string          `json:"operationReason,omitempty"`
	CreatedAt            dto.DateTime     `json:"createdAt"`
}

type PositionTransferConnection struct {
	Edges      []PositionTransferEdge `json:"edges"`
	Pagination *PaginationInfo        `json:"pagination"`
	Data       []PositionTransfer     `json:"data"`
	TotalCount int                    `json:"totalCount"`
}

type PositionTransferEdge struct {
	Cursor string            `json:"cursor"`
	Node   *PositionTransfer `json:"node"`
}

// Root Query type providing all organization management query operations.
// All queries require appropriate OAuth 2.0 permissions and support multi-tenant isolation.
type Query struct {
}

// Repair suggestion with automation capability.
type RepairSuggestion struct {
	IssueType       string   `json:"issueType"`
	AffectedCodes   []string `json:"affectedCodes"`
	SuggestedAction string   `json:"suggestedAction"`
	Automatable     bool     `json:"automatable"`
	RiskLevel       string   `json:"riskLevel"`
}

// Statistics by organization status.
type StatusStatistic struct {
	Status Status `json:"status"`
	Count  int    `json:"count"`
}

// Temporal context information for queries.
type TemporalInfo struct {
	AsOfDate        string `json:"asOfDate"`
	CurrentCount    int    `json:"currentCount"`
	FutureCount     int    `json:"futureCount"`
	HistoricalCount int    `json:"historicalCount"`
}

// Temporal statistics breakdown.
type TemporalStatistics struct {
	TotalVersions         int     `json:"totalVersions"`
	AverageVersionsPerOrg float64 `json:"averageVersionsPerOrg"`
	OldestEffectiveDate   string  `json:"oldestEffectiveDate"`
	NewestEffectiveDate   string  `json:"newestEffectiveDate"`
}

type TypeHeadcount struct {
	PositionType PositionType `json:"positionType"`
	Capacity     float64      `json:"capacity"`
	Filled       float64      `json:"filled"`
	Available    float64      `json:"available"`
}

// Statistics by organization unit type.
type TypeStatistic struct {
	UnitType UnitType `json:"unitType"`
	Count    int      `json:"count"`
}

// User information for audit trails.
type UserInfo struct {
	UserID   string  `json:"userId"`
	UserName string  `json:"userName"`
	Role     *string `json:"role,omitempty"`
}

type VacantPosition struct {
	PositionCode       dto.PositionCode  `json:"positionCode"`
	OrganizationCode   string            `json:"organizationCode"`
	OrganizationName   *string           `json:"organizationName,omitempty"`
	JobFamilyCode      dto.JobFamilyCode `json:"jobFamilyCode"`
	JobRoleCode        dto.JobRoleCode   `json:"jobRoleCode"`
	JobLevelCode       dto.JobLevelCode  `json:"jobLevelCode"`
	VacantSince        dto.Date          `json:"vacantSince"`
	HeadcountCapacity  float64           `json:"headcountCapacity"`
	HeadcountAvailable float64           `json:"headcountAvailable"`
	TotalAssignments   int               `json:"totalAssignments"`
}

type VacantPositionConnection struct {
	Edges      []VacantPositionEdge `json:"edges"`
	Pagination *PaginationInfo      `json:"pagination"`
	Data       []VacantPosition     `json:"data"`
	TotalCount int                  `json:"totalCount"`
}

type VacantPositionEdge struct {
	Cursor string          `json:"cursor"`
	Node   *VacantPosition `json:"node"`
}

// Filter options for vacant position queries.
type VacantPositionFilterInput struct {
	OrganizationCodes []string            `json:"organizationCodes,omitempty"`
	JobFamilyCodes    []dto.JobFamilyCode `json:"jobFamilyCodes,omitempty"`
	JobRoleCodes      []dto.JobRoleCode   `json:"jobRoleCodes,omitempty"`
	JobLevelCodes     []dto.JobLevelCode  `json:"jobLevelCodes,omitempty"`
	PositionTypes     []PositionType      `json:"positionTypes,omitempty"`
	MinimumVacantDays *int                `json:"minimumVacantDays,omitempty"`
	AsOfDate          *dto.Date           `json:"asOfDate,omitempty"`
}

// Sorting input for vacant position queries.
type VacantPositionSortInput struct {
	Field     VacantPositionSortField `json:"field"`
	Direction *SortOrder              `json:"direction,omitempty"`
}

// Consistency check modes with different performance characteristics.
type ConsistencyCheckMode string

const (
	ConsistencyCheckModeFast     ConsistencyCheckMode = "FAST"
	ConsistencyCheckModeDeep     ConsistencyCheckMode = "DEEP"
	ConsistencyCheckModeTargeted ConsistencyCheckMode = "TARGETED"
)

var AllConsistencyCheckMode = []ConsistencyCheckMode{
	ConsistencyCheckModeFast,
	ConsistencyCheckModeDeep,
	ConsistencyCheckModeTargeted,
}

func (e ConsistencyCheckMode) IsValid() bool {
	switch e {
	case ConsistencyCheckModeFast, ConsistencyCheckModeDeep, ConsistencyCheckModeTargeted:
		return true
	}
	return false
}

func (e ConsistencyCheckMode) String() string {
	return string(e)
}

func (e *ConsistencyCheckMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConsistencyCheckMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConsistencyCheckMode", str)
	}
	return nil
}

func (e ConsistencyCheckMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Employment type for position assignments.
type EmploymentType string

const (
	EmploymentTypeFullTime EmploymentType = "FULL_TIME"
	EmploymentTypePartTime EmploymentType = "PART_TIME"
	EmploymentTypeIntern   EmploymentType = "INTERN"
)

var AllEmploymentType = []EmploymentType{
	EmploymentTypeFullTime,
	EmploymentTypePartTime,
	EmploymentTypeIntern,
}

func (e EmploymentType) IsValid() bool {
	switch e {
	case EmploymentTypeFullTime, EmploymentTypePartTime, EmploymentTypeIntern:
		return true
	}
	return false
}

func (e EmploymentType) String() string {
	return string(e)
}

func (e *EmploymentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmploymentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmploymentType", str)
	}
	return nil
}

func (e EmploymentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status for job catalog entries.
type JobCatalogStatus string

const (
	JobCatalogStatusActive   JobCatalogStatus = "ACTIVE"
	JobCatalogStatusInactive JobCatalogStatus = "INACTIVE"
)

var AllJobCatalogStatus = []JobCatalogStatus{
	JobCatalogStatusActive,
	JobCatalogStatusInactive,
}

func (e JobCatalogStatus) IsValid() bool {
	switch e {
	case JobCatalogStatusActive, JobCatalogStatusInactive:
		return true
	}
	return false
}

func (e JobCatalogStatus) String() string {
	return string(e)
}

func (e *JobCatalogStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobCatalogStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobCatalogStatus", str)
	}
	return nil
}

func (e JobCatalogStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Operation types for audit and temporal tracking.
type OperationType string

const (
	OperationTypeCreate     OperationType = "CREATE"
	OperationTypeUpdate     OperationType = "UPDATE"
	OperationTypeSuspend    OperationType = "SUSPEND"
	OperationTypeReactivate OperationType = "REACTIVATE"
	OperationTypeDeactivate OperationType = "DEACTIVATE"
	OperationTypeDelete     OperationType = "DELETE"
)

var AllOperationType = []OperationType{
	OperationTypeCreate,
	OperationTypeUpdate,
	OperationTypeSuspend,
	OperationTypeReactivate,
	OperationTypeDeactivate,
	OperationTypeDelete,
}

func (e OperationType) IsValid() bool {
	switch e {
	case OperationTypeCreate, OperationTypeUpdate, OperationTypeSuspend, OperationTypeReactivate, OperationTypeDeactivate, OperationTypeDelete:
		return true
	}
	return false
}

func (e OperationType) String() string {
	return string(e)
}

func (e *OperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationType", str)
	}
	return nil
}

func (e OperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported assignment sorting fields.
type PositionAssignmentSortField string

const (
	PositionAssignmentSortFieldEffectiveDate PositionAssignmentSortField = "EFFECTIVE_DATE"
	PositionAssignmentSortFieldEndDate       PositionAssignmentSortField = "END_DATE"
	PositionAssignmentSortFieldCreatedAt     PositionAssignmentSortField = "CREATED_AT"
)

var AllPositionAssignmentSortField = []PositionAssignmentSortField{
	PositionAssignmentSortFieldEffectiveDate,
	PositionAssignmentSortFieldEndDate,
	PositionAssignmentSortFieldCreatedAt,
}

func (e PositionAssignmentSortField) IsValid() bool {
	switch e {
	case PositionAssignmentSortFieldEffectiveDate, PositionAssignmentSortFieldEndDate, PositionAssignmentSortFieldCreatedAt:
		return true
	}
	return false
}

func (e PositionAssignmentSortField) String() string {
	return string(e)
}

func (e *PositionAssignmentSortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionAssignmentSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionAssignmentSortField", str)
	}
	return nil
}

func (e PositionAssignmentSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Lifecycle status for a position assignment.
type PositionAssignmentStatus string

const (
	PositionAssignmentStatusPending PositionAssignmentStatus = "PENDING"
	PositionAssignmentStatusActive  PositionAssignmentStatus = "ACTIVE"
	PositionAssignmentStatusEnded   PositionAssignmentStatus = "ENDED"
)

var AllPositionAssignmentStatus = []PositionAssignmentStatus{
	PositionAssignmentStatusPending,
	PositionAssignmentStatusActive,
	PositionAssignmentStatusEnded,
}

func (e PositionAssignmentStatus) IsValid() bool {
	switch e {
	case PositionAssignmentStatusPending, PositionAssignmentStatusActive, PositionAssignmentStatusEnded:
		return true
	}
	return false
}

func (e PositionAssignmentStatus) String() string {
	return string(e)
}

func (e *PositionAssignmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionAssignmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionAssignmentStatus", str)
	}
	return nil
}

func (e PositionAssignmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Assignment type within a position.
type PositionAssignmentType string

const (
	PositionAssignmentTypePrimary   PositionAssignmentType = "PRIMARY"
	PositionAssignmentTypeSecondary PositionAssignmentType = "SECONDARY"
	PositionAssignmentTypeActing    PositionAssignmentType = "ACTING"
)

var AllPositionAssignmentType = []PositionAssignmentType{
	PositionAssignmentTypePrimary,
	PositionAssignmentTypeSecondary,
	PositionAssignmentTypeActing,
}

func (e PositionAssignmentType) IsValid() bool {
	switch e {
	case PositionAssignmentTypePrimary, PositionAssignmentTypeSecondary, PositionAssignmentTypeActing:
		return true
	}
	return false
}

func (e PositionAssignmentType) String() string {
	return string(e)
}

func (e *PositionAssignmentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionAssignmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionAssignmentType", str)
	}
	return nil
}

func (e PositionAssignmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported position sorting fields.
type PositionSortField string

const (
	PositionSortFieldCode          PositionSortField = "CODE"
	PositionSortFieldTitle         PositionSortField = "TITLE"
	PositionSortFieldEffectiveDate PositionSortField = "EFFECTIVE_DATE"
	PositionSortFieldStatus        PositionSortField = "STATUS"
)

var AllPositionSortField = []PositionSortField{
	PositionSortFieldCode,
	PositionSortFieldTitle,
	PositionSortFieldEffectiveDate,
	PositionSortFieldStatus,
}

func (e PositionSortField) IsValid() bool {
	switch e {
	case PositionSortFieldCode, PositionSortFieldTitle, PositionSortFieldEffectiveDate, PositionSortFieldStatus:
		return true
	}
	return false
}

func (e PositionSortField) String() string {
	return string(e)
}

func (e *PositionSortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionSortField", str)
	}
	return nil
}

func (e PositionSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Lifecycle status for positions.
type PositionStatus string

const (
	PositionStatusPlanned  PositionStatus = "PLANNED"
	PositionStatusActive   PositionStatus = "ACTIVE"
	PositionStatusFilled   PositionStatus = "FILLED"
	PositionStatusVacant   PositionStatus = "VACANT"
	PositionStatusInactive PositionStatus = "INACTIVE"
	PositionStatusDeleted  PositionStatus = "DELETED"
)

var AllPositionStatus = []PositionStatus{
	PositionStatusPlanned,
	PositionStatusActive,
	PositionStatusFilled,
	PositionStatusVacant,
	PositionStatusInactive,
	PositionStatusDeleted,
}

func (e PositionStatus) IsValid() bool {
	switch e {
	case PositionStatusPlanned, PositionStatusActive, PositionStatusFilled, PositionStatusVacant, PositionStatusInactive, PositionStatusDeleted:
		return true
	}
	return false
}

func (e PositionStatus) String() string {
	return string(e)
}

func (e *PositionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionStatus", str)
	}
	return nil
}

func (e PositionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PositionTimelineCategory string

const (
	PositionTimelineCategoryPositionVersion    PositionTimelineCategory = "POSITION_VERSION"
	PositionTimelineCategoryPositionAssignment PositionTimelineCategory = "POSITION_ASSIGNMENT"
)

var AllPositionTimelineCategory = []PositionTimelineCategory{
	PositionTimelineCategoryPositionVersion,
	PositionTimelineCategoryPositionAssignment,
}

func (e PositionTimelineCategory) IsValid() bool {
	switch e {
	case PositionTimelineCategoryPositionVersion, PositionTimelineCategoryPositionAssignment:
		return true
	}
	return false
}

func (e PositionTimelineCategory) String() string {
	return string(e)
}

func (e *PositionTimelineCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionTimelineCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionTimelineCategory", str)
	}
	return nil
}

func (e PositionTimelineCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Contract type for positions.
type PositionType string

const (
	PositionTypeRegular    PositionType = "REGULAR"
	PositionTypeTemporary  PositionType = "TEMPORARY"
	PositionTypeContractor PositionType = "CONTRACTOR"
)

var AllPositionType = []PositionType{
	PositionTypeRegular,
	PositionTypeTemporary,
	PositionTypeContractor,
}

func (e PositionType) IsValid() bool {
	switch e {
	case PositionTypeRegular, PositionTypeTemporary, PositionTypeContractor:
		return true
	}
	return false
}

func (e PositionType) String() string {
	return string(e)
}

func (e *PositionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PositionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PositionType", str)
	}
	return nil
}

func (e PositionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search fields for text-based filtering.
type SearchField string

const (
	SearchFieldName        SearchField = "NAME"
	SearchFieldDescription SearchField = "DESCRIPTION"
	SearchFieldCodePath    SearchField = "CODE_PATH"
	SearchFieldNamePath    SearchField = "NAME_PATH"
)

var AllSearchField = []SearchField{
	SearchFieldName,
	SearchFieldDescription,
	SearchFieldCodePath,
	SearchFieldNamePath,
}

func (e SearchField) IsValid() bool {
	switch e {
	case SearchFieldName, SearchFieldDescription, SearchFieldCodePath, SearchFieldNamePath:
		return true
	}
	return false
}

func (e SearchField) String() string {
	return string(e)
}

func (e *SearchField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchField", str)
	}
	return nil
}

func (e SearchField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting field options.
type SortField string

const (
	SortFieldCode          SortField = "CODE"
	SortFieldName          SortField = "NAME"
	SortFieldCreatedAt     SortField = "CREATED_AT"
	SortFieldUpdatedAt     SortField = "UPDATED_AT"
	SortFieldEffectiveDate SortField = "EFFECTIVE_DATE"
	SortFieldLevel         SortField = "LEVEL"
	SortFieldSortOrder     SortField = "SORT_ORDER"
)

var AllSortField = []SortField{
	SortFieldCode,
	SortFieldName,
	SortFieldCreatedAt,
	SortFieldUpdatedAt,
	SortFieldEffectiveDate,
	SortFieldLevel,
	SortFieldSortOrder,
}

func (e SortField) IsValid() bool {
	switch e {
	case SortFieldCode, SortFieldName, SortFieldCreatedAt, SortFieldUpdatedAt, SortFieldEffectiveDate, SortFieldLevel, SortFieldSortOrder:
		return true
	}
	return false
}

func (e SortField) String() string {
	return string(e)
}

func (e *SortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortField", str)
	}
	return nil
}

func (e SortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting order options.
type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Organization business status (ADR-008: 一维业务状态模型).
type Status string

const (
	StatusActive   Status = "ACTIVE"
	StatusInactive Status = "INACTIVE"
	StatusPlanned  Status = "PLANNED"
	StatusDeleted  Status = "DELETED"
)

var AllStatus = []Status{
	StatusActive,
	StatusInactive,
	StatusPlanned,
	StatusDeleted,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusActive, StatusInactive, StatusPlanned, StatusDeleted:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Organization unit types with specific business semantics.
type UnitType string

const (
	UnitTypeDepartment       UnitType = "DEPARTMENT"
	UnitTypeOrganizationUnit UnitType = "ORGANIZATION_UNIT"
	UnitTypeCompany          UnitType = "COMPANY"
	UnitTypeProjectTeam      UnitType = "PROJECT_TEAM"
)

var AllUnitType = []UnitType{
	UnitTypeDepartment,
	UnitTypeOrganizationUnit,
	UnitTypeCompany,
	UnitTypeProjectTeam,
}

func (e UnitType) IsValid() bool {
	switch e {
	case UnitTypeDepartment, UnitTypeOrganizationUnit, UnitTypeCompany, UnitTypeProjectTeam:
		return true
	}
	return false
}

func (e UnitType) String() string {
	return string(e)
}

func (e *UnitType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitType", str)
	}
	return nil
}

func (e UnitType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported vacant position sorting fields.
type VacantPositionSortField string

const (
	VacantPositionSortFieldVacantSince        VacantPositionSortField = "VACANT_SINCE"
	VacantPositionSortFieldHeadcountAvailable VacantPositionSortField = "HEADCOUNT_AVAILABLE"
	VacantPositionSortFieldHeadcountCapacity  VacantPositionSortField = "HEADCOUNT_CAPACITY"
)

var AllVacantPositionSortField = []VacantPositionSortField{
	VacantPositionSortFieldVacantSince,
	VacantPositionSortFieldHeadcountAvailable,
	VacantPositionSortFieldHeadcountCapacity,
}

func (e VacantPositionSortField) IsValid() bool {
	switch e {
	case VacantPositionSortFieldVacantSince, VacantPositionSortFieldHeadcountAvailable, VacantPositionSortFieldHeadcountCapacity:
		return true
	}
	return false
}

func (e VacantPositionSortField) String() string {
	return string(e)
}

func (e *VacantPositionSortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VacantPositionSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VacantPositionSortField", str)
	}
	return nil
}

func (e VacantPositionSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
