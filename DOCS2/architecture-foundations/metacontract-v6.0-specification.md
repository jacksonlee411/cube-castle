# **元合约v6.0：城堡的宪法**

**版本**: v6.0  
**原始创建时间**: 2025年7月  
**迁移时间**: 2025年8月5日  
**迁移自**: docs/architecture/metacontract_v6.0_specification.md  
**文档状态**: 高级指导文档 - 项目最高技术宪章  
**重要性**: 最高级别 - 作为平台开发的唯一法律依据  
**维护团队**: 项目架构委员会  

## **序言：城堡哲学及其四大支柱**

### **引言**

本文档，《元合约v6.0》，是构建我们HR SaaS平台的最高技术宪章与唯一事实来源（Single Source of Truth）。它作为《城堡蓝图：构建雄伟、AI增强型单体的架构指南》的权威技术实现，正式宣告了平台架构的最终形态 1。本版本v6.0是所有先前版本与战略蓝图的最终综合与结晶，取代所有此前的规约，并作为指导未来所有开发、治理和演进工作的唯一法律依据 1。

本合约的核心论点是：对于一支精干的专家团队，一个纪律严明、模块化的单体架构——即"城堡"——由一部机器可读的"元合约"所治理，这并非对宏伟愿景的妥协，而是实现该愿景最智能、风险最低的实施路径 1。它将抽象的架构原则转化为可执行、可审计、可自动强制执行的技术规约，确保平台在演进过程中保持架构的一致性、设计的优雅性以及长期的可维护性。

### **"城堡模型"定义**

为了防止单体应用演变成不可维护的"大泥球"，平台架构必须采纳"城堡模型"——一个对边界清晰、高内聚、低耦合的模块化单体进行形式化定义的架构 1。该系统被构想为一个由多个独立但又无缝衔接的防御性结构组成的有机整体，旨在最大化开发速度，同时为未来的演进预设清晰的路径 1。

* **主堡 (The Keep)**：这是城堡最核心、防卫最森严的部分，象征着系统的核心业务领域。在我们的HR SaaS平台中，它对应着CoreHR模块，包含员工（Employee）、组织架构（OrganizationUnit）等最关键的实体和业务逻辑。它是整个系统的基石，所有其他模块都直接或间接地依赖于其提供的核心能力 1。  
* **塔楼 (The Towers)**：这些是独立的、功能明确的防御性建筑，各自承担着特定的职责。每一座"塔楼"都是代码库中一个明确的、独立的模块，拥有自己清晰的业务边界。例如：IdentityAccess（身份与访问管理）、IntelligenceGateway（智能网关）、TenancyManagement（租户管理）以及未来规划的Payroll（薪酬）等 1。  
* **城墙与门禁 (The Walls & Gates)**：正如城堡的城墙定义了防御边界，每个模块（无论是"主堡"还是"塔楼"）都必须拥有一个严格定义的、版本化的内部公共API。这是外界（即其他模块）与该模块交互的唯一合法通道。任何试图"翻墙"或"挖地道"（即直接调用模块内部私有函数或访问其数据表）的行为都将被架构和工具链所禁止。这直接满足了"所有数据交互都必须通过API方式进行"的核心要求，并为未来的架构演进（如"绞杀者无花果"模式）预设了清晰的"断裂带" 1。

#### **表格：城堡组件与元合约模块映射**

| 城堡组件 | 核心职责 | 关键所属实体 | 对应的元合约模块（命名空间） |
| :---- | :---- | :---- | :---- |
| 主堡 (The Keep) | 核心人力资源管理，是所有业务的基础。 | Employee, OrganizationUnit, Position | core-hr.keep |
| 身份塔楼 (Identity Tower) | 用户认证、授权、角色与权限管理。 | User, Role, Permission | identity-access.tower |
| 智能网关塔楼 (Intelligence Tower) | 处理自然语言输入，意图识别，与LLM交互。 | Intent, Entity, DialogueState | intelligence-gateway.tower |
| 租户管理塔楼 (Tenancy Tower) | 管理租户生命周期、配置、功能开关。 | TenantProfile, Subscription | tenancy-management.tower |
| 薪酬塔楼 (Payroll Tower) (未来) | 薪资计算、发放、税务处理。 | Payslip, SalaryRule | payroll.tower |

### **四大支柱：在城堡语境下的重塑**

平台成功的基石——可信赖（Trustworthy）、智能化（Intelligent）、可扩展（Scalable）和可治理（Governed）——其原则在城堡蓝图中被完整保留。然而，其实现方式根据单体架构的特性进行了务实的调整，以求达到简单性与效率的统一，极大地降低了运维复杂性和认知负荷 1。

* **可信赖 (Trustworthy)**：在单体架构中，数据一致性和安全上下文传播的实现方式远比分布式系统简洁。通过采用**进程内事务性发件箱**模式，平台可以在单个数据库事务中同时更新业务数据和待发布事件，从而以原子方式保证关系型数据库与图数据库之间的数据一致性。安全上下文（如用户身份和租户ID）可以直接在进程内的函数调用间传递，避免了在服务间通过网络传递JWT或Token所带来的复杂性和安全风险 1。  
* **智能化 (Intelligent)**：IntelligenceGateway塔楼作为AI交互的核心，可以直接在进程内调用其他业务模块（如CoreHR）的API。这种**低延迟的内部API调用**消除了网络开销，使得AI交互的响应速度得到极大提升，这对于提供流畅的对话式体验至关重要 1。  
* **可扩展 (Scalable)**：平台的初期扩展将优先采用**垂直扩展**，即增加单个实例的CPU和内存资源。当需要水平扩展时，将通过为不同的大型租户部署整个单体的多个副本来实现（即"专属筒仓"模式）。这种模式的管理复杂度远低于管理一个由数十个不同微服务组成的"舰队"，因为它只需要管理少数几个同构的服务实例 1。  
* **可治理 (Governed)**：平台将通过一个**嵌入到单体应用中的OPA库（SDK）**来实现"治理即代码"。这种方式提供了与v4.0蓝图（暗示采用独立的OPA守护进程）完全相同的逻辑分离和动态策略执行能力，但极大地降低了运维开销，因为它消除了部署、监控和维护一个独立服务的需要，实现了零延迟、零运维开销的动态策略执行 1。

#### **表格：四大支柱在单体语境下的实现**

| 支柱 | 核心价值 | 关键架构组件（单体语境实现） |
| :---- | :---- | :---- |
| **可信赖 (Trustworthy)** | 确保数据、安全和运营的绝对可靠性，是所有高级功能的基础。 | - **进程内事务性发件箱**：保证关系型与图数据库的一致性。 - **"交互即审计事件"**：确保所有AI操作都可追溯。 - **默认安全的授权模型**：通过enforce_tenant_boundary和数据库行级安全（RLS）防止数据泄露。 |
| **智能化 (Intelligent)** | 以对话式AI为核心，提供主动、协作式的用户体验。 | - **"灵活理解，刚性创建"**：连接自然语言与业务流程的核心模式。 - **图数据库 (Neo4j)**：作为"洞察系统"，提供深度上下文理解。 - **情境感知模型 (SAM)**：利用UI上下文提升意图识别准确率。 - **低延迟内部API调用**：智能网关与业务模块间无网络开销。 |
| **可扩展 (Scalable)** | 满足不同市场区隔的需求，并能高效地管理大规模部署。 | - **混合多租户模型**：通过RLS（逻辑隔离）和独立部署（物理隔离）实现。 - **垂直扩展优先**：通过增加单个实例的资源进行初期扩展。 - **基础设施即代码 (IaC)**：自动化专属租户的上线与生命周期管理。 |
| **可治理 (Governed)** | 建立清晰、可执行的规则体系，确保平台演进的可控性与安全性。 | - **统一的元合约**：作为平台的"宪法"和单一事实来源。 - **嵌入式OPA引擎**：将策略与业务逻辑解耦，实现零延迟、零运维开销的动态策略执行。 - **"活合约"治理框架**：通过CI/CD流程管理元合约自身的变更。 |

## **第一部分：王国法典 —— 元合约完整规约**

这份新规约是所有分析与建议的最终结晶，旨在成为HR SaaS平台开发工作的坚实基石。以下是元合约规范完整定义，以模块化表格形式呈现。每个属性的"说明/理由"列解释了其设计目的，并与前文的城堡蓝图分析相呼应 1。

### **1. 核心身份 (Core Identity)**

**目的**：提供API的唯一标识、分类和高级别上下文，是API目录、治理和映射到"城堡模型"组件的核心。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| specification_version | string | 是 | 元合约规范自身版本，固定为 "v6.0"。 |
| api_id | UUID | 是 | API的全局唯一、不可变标识符。用于API目录、监控、日志等系统的精确关联，不受API版本、路径变化影响 1。 |
| namespace | string | 是 | 业务域标识，强制遵循{module-name}.{castle-component}格式，如core-hr.keep或identity-access.tower。此规约将API直接与城堡模型的架构组件绑定 1。 |
| resource_name | string | 是 | 资源名称，在命名空间内唯一。强制要求集合资源使用小写复数名词，如 "employees" 1。 |
| version | semantic_version | 是 | API的语义化版本，如 "1.2.3"。遵循SemVer规范 1。 |
| label | string (Localized) | 是 | 用户友好的显示名称，用于UI展示。 |
| description | string | 是 | 对API所代表的业务概念的详细说明。 |
| resource_type | enum | 是 | 资源的核心类型： - ENTITY: 持久化业务实体，如 worker。 - PROCESS: 有状态、长周期的业务流程，如 hiring_process。 - BUSINESS_PROCESS_EVENT: 代表对 ENTITY 时间线的瞬时、带生效日期的变更事件，如 job_change_event。此分类是事件驱动架构的核心 1。 |
| abstraction_level | enum | 是 | API的抽象层级：PROCESS_ORIENTED (高度抽象的流程API)；DATA_ORIENTED (面向数据的专家级API)。用于支撑"受控抽象"战略 1。 |
| audience | enum | 是 | API的目标受众：INTERNAL_APP (内部前端或服务)；EXTERNAL_PARTNER (外部合作伙伴)。用于指导安全策略和文档生成 1。 |
| lifecycle_status | enum | 是 | API的生命周期状态：DRAFT, ACTIVE, DEPRECATED, RETIRED。 |
| owning_team | string | 是 | 负责该API的团队标识。 |
| last_updated | ISO8601 DateTime | 是 | 元合约最后修改时间。 |

### **2. 数据结构 (Data Structure)**

**目的**：提供一个健壮的、统一的模式定义框架，该框架不仅适用于业务实体，同样适用于作为一级公民的业务流程事件资源，并为"多语言持久化"策略提供声明式的治理依据。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| fields | Array | 是 | 资源所有数据字段的定义集合。 |
| primary_key | UUID | 是 | 唯一标识实例的主键字段名。强制使用UUID类型以保证分布式环境下的唯一性 1。 |
| data_classification | enum | 是 | 数据敏感度分类：PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED。 |
| polymorphism | Polymorphism_Definition | 否 | 定义资源的多态性。包含discriminator_property和mapping，用于实现"管理多态性"的API模式 1。 |
| data_lineage | Array | 否 | 数据来源和流转关系。 |
| quality_rules | Array | 否 | 数据质量验证规则。 |
| compliance_tags | Array | 否 | 法规遵循标签 (如 GDPR, SOX)。 |
| schema_registry_ref | Schema_Registry_Reference | 否 | 外部Schema注册中心（如Confluent Schema Registry）的引用。 |
| persistence_profile | Persistence_Profile (object) | 否 | **[城堡蓝图核心]** 定义资源的混合持久化策略。如果缺失，则默认为仅使用关系型数据库（记录系统）。此配置是驱动"进程内事务性发件箱"工作线程的权威数据源，实现了数据同步的自动化和声明式治理 1。 |

#### **2.1 子定义：Persistence_Profile 持久化配置**

**目的**：通过在元合约中引入persistence_profile，我们为数据同步服务提供了一个声明式的、权威的数据源。该服务在启动时，可以动态地读取整个平台所有API的元合约。对于每一个声明了混合存储策略的资源，同步服务可以自动地、无需人工干预地为其建立所需的数据管道和事件监听器，并根据graph_node_label等元数据，正确地在图数据库中创建节点和关系。最终，为一个新资源启用混合持久化能力，将从一个需要多团队协调的复杂工程任务，简化为一个开发团队在其元合约中进行声明式配置的"自服务"操作 1。

| 属性 | 类型 | 必需性 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| primary_store | enum | 是 | **记录系统声明**。显式声明该资源的"记录系统"（System of Record）是哪种存储。平台标准为RELATIONAL (PostgreSQL) 1。 |
| indexed_in | Array | 否 | **洞察系统声明**。声明该资源的数据被复制到了哪些用于分析和查询的二级存储中。平台标准可选值为GRAPH (Neo4j) 1。 |
| graph_node_label | string | 如果indexed_in包含GRAPH则必需 | **图元数据**。定义该资源在图数据库中作为节点（Node）时所使用的标签（Label）。这是图查询和数据同步服务的关键元数据 1。 |
| graph_edge_definitions | Array | 否 | 一个可选数组，通过引用**模块5**中定义的Relationship_Definition的rel_name，来声明该资源作为"源节点"时所拥有的全部图关系（边）。这为资源的图模型提供了一个内聚且可发现的视图 1。 |

### **3. 数据实例访问范式 (Data Instance Access Paradigms)**

**目的**：定义如何访问和查询资源的实例集合，并正式确立平台基于时间线和基于图谱的双重数据访问模型。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| instance_access_template | URI_Template | 是 | 获取单个实例的标准路径模板，如 /employees/{employee_id}。 |
| collection_access_path | URI | 是 | 获取实例集合的标准路径，如 /employees。 |
| pagination_policy | Pagination_Policy | 是 | 分页策略。强烈推荐使用CURSOR（游标）分页，以获得最佳性能和稳定性 1。 |
| sort_options | Array | 否 | 可用的排序字段和方向。 |
| filter_capabilities | Array | 否 | 支持的查询过滤器定义。 |
| timeline_query_parameters | Timeline_Query_Parameters | 否 | **[v2.0修订]** 定义对时态资源进行时间点查询的标准化参数。此属性是所有temporality_paradigm为EVENT_DRIVEN的ENTITY资源的**强制要求**，确保了全平台对于时间线查询的一致性 1。 |
| graph_query_capabilities | object | 是 | **[v5.1 修订]** 定义平台用于复杂关系查询的图查询能力。自本版本起，平台正式采用GraphQL作为唯一的图查询范式。详细规约见新增的模块3.6 1。 |
| query_cost_profile | enum | 是 | 一个预估的查询成本和复杂度的画像，用于触发相应的治理流程。可选值：LOW, MEDIUM, HIGH, REVIEW_REQUIRED 1。 |

#### **3.6 GraphQL查询范式与治理 (GraphQL Query Paradigm & Governance)**

**引言**: 为响应城堡蓝图对"洞察系统"的战略要求，并为AI应用提供丰富的上下文，平台采用GraphQL作为标准化、强类型的图数据查询接口。本部分定义了GraphQL服务的技术规约、安全与性能治理策略，以及开发者必须遵循的最佳实践 1。

| 属性 | 类型 | 是否必需 | 描述 |
| :---- | :---- | :---- | :---- |
| endpoint_url | string | 是 | 平台唯一的GraphQL服务访问入口，例如/api/graphql。所有图查询请求都应发送到此URL。 |
| schema_source_of_truth | string | 是 | 定义GraphQL Schema的唯一真实来源。Schema应基于**模块2（数据结构）**中定义的实体及其关系自动生成，确保API与核心数据模型始终保持一致。 |
| authentication_mechanism | string | 是 | GraphQL端点的认证机制。必须与平台其他API的认证标准保持一致，采用Bearer Token认证。 |
| authorization_model_ref | string | 是 | **[核心安全关联]** 声明GraphQL的授权逻辑**必须**遵循**模块8（安全模型）**的规约。解析器（Resolver）在返回任何字段前，必须通过嵌入式OPA引擎校验当前用户的权限是否满足该字段所需的安全约束。 |
| query_governance_policy | object | 是 | **[核心治理策略]** 定义为防止恶意或低效查询、保障服务稳定性的强制性策略，例如{ "max_depth": 7, "max_complexity": 200, "rate_limit_per_minute": 100 }。 |
| introspection_policy | string | 是 | 定义GraphQL内省（Introspection）功能的可用策略，以平衡开发体验和生产安全。有效值：ENABLED_IN_DEV_ONLY, DISABLED。 |

### **4. 时间行为模型 (Temporal Behavior Model)**

**目的**：定义资源在时间维度上的核心行为和能力，确保HR数据在整个生命周期中保持准确、合规和可审计。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| temporality_paradigm | enum | 是 | 资源所遵循的时态范式： - EVENT_DRIVEN: 资源状态由一系列带生效日期的、不可变的业务事件驱动。 - STATEFUL_SNAPSHOT: 遗留模型，适用于简单的、非事件驱动的配置类资源。 - NONE: 非时态资源 1。 |
| timeline_consistency_policy | Timeline_Consistency_Policy (枚举) | 如果temporality_paradigm为EVENT_DRIVEN则必需 | **[核心业务策略]** 定义EVENT_DRIVEN资源的时间线记录之间必须遵循的一致性策略。此策略直接映射并标准化了如SAP时间约束等复杂的业务规则 1。 |
| supports_future_dating | boolean | 如果temporality_paradigm为EVENT_DRIVEN则必需 | 是否允许提交"生效日期"在未来的业务事件。 |
| supports_retroactivity | boolean | 如果temporality_paradigm为EVENT_DRIVEN则必需 | 是否允许提交"生效日期"在过去的业务事件。 |
| retroactivity_triggers_recalculation | Array | 否 | 如果支持追溯处理，需在此列出由其自动触发的下游流程领域，如PAYROLL, ACCRUALS。这是实现自动化追溯处理的关键元数据 1。 |

### **5. 关联关系 (Relationships)**

**目的**：定义资源与其他资源之间的链接关系，并为图模型中的"边"提供明确的、可治理的定义。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| linkable_objects | Array | 否 | 可链接的其他业务对象列表。这些定义将作为HATEOAS生成_links的元数据来源 1。 |
| eager_loading_support | boolean | 否 | 是否支持通过查询参数（如?embed=...）预加载关联资源。 |
| referential_integrity | Referential_Integrity_Policy | 否 | 外键约束和验证规则。 |

#### **5.1 子定义: Relationship_Definition**

**目的**：对linkable_objects数组中的Relationship_Definition对象进行扩展，增加元数据属性，用以区分一个关系是简单的RESTful超链接，还是一个在图模型中拥有明确语义、可被遍历的一等公民"边" 1。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| rel | string | 是 | 关系类型，遵循IANA标准。 |
| href | URI_Template | 是 | 目标资源的链接模板。 |
| is_graph_edge | boolean | 是 | **[V4新增]** 标志此关系是否为图模型中的一条"边"。默认为false。这是区分简单链接和语义化图关系的关键 1。 |
| graph_edge_label | string | 如果is_graph_edge为true则必需 | **[V4新增]** 该关系作为图的"边"时的标签，如REPORTS_TO。此标签将用于图数据库查询 1。 |
| graph_edge_direction | enum | 如果is_graph_edge为true则必需 | **[V4新增]** 从源资源角度看，该关系在图中的方向：OUTGOING或INCOMING 1。 |

### **6. 状态变更管理 (State Transition Management)**

**目的**：定义所有改变资源状态的操作。这是实现"刚性创建"和"交互即审计事件"原则的技术核心。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| standard_mutations | Array | 否 | 定义对资源的Create, Update, Delete等标准HTTP方法操作。**强制约束**：如果temporality_paradigm为EVENT_DRIVEN，则此列表中不得包含UPDATE和DELETE 1。 |
| timeline_management_actions | Array | 否 | **[v2.0 核心新增]** 仅适用于EVENT_DRIVEN资源。定义用于管理事件时间线的精确业务动词（校正、取消、撤销），取代了传统的数据库DELETE操作 1。 |
| idempotency_policy | Idempotency_Policy | 是 | 定义所有变更操作的幂等性保证策略。 |
| concurrency_control | Concurrency_Control_Policy | 是 | 定义并发修改场景下的冲突检测和解决策略（如基于ETag的乐观锁）。 |
| state_transition_model | ENUM | 是 | 取值范围: EVENT_DRIVEN, DIRECT。**核心规约**: 对于resource_type为ENTITY的核心业务实体（例如Worker, Position），此值**必须**为EVENT_DRIVEN。这强制要求其生命周期中的任何状态变化，都必须由一个独立的、可审计的业务流程事件来触发和记录，是"刚性创建"原则的基石 1。 |
| allowed_actions | Array | 是 | 定义了允许在此资源上执行的、能引发状态转换的操作类型列表。这些操作通常映射到具体的业务流程事件，如HIRE, PROMOTE, TERMINATE。所有状态变更**必须**通过向相应的业务流程事件资源发送POST请求来发起，由**模块19**的EAC-005规约进行强制执行 1。 |

### **7. 业务流程事件 (Business Process Events)**

**目的**：本模块定义了平台用于记录并执行所有业务状态变更的唯一规范机制。每一个BUSINESS_PROCESS_EVENT既是一份业务活动的审计记录，也是触发后续业务逻辑的原子化指令。

| 规约ID | 规约名称 | 规约描述 | 强制级别 |
| :---- | :---- | :---- | :---- |
| BPE-001 | 事件结构 | 事件必须包含头部（header）和业务负载（payload）。头部必须包含event_id, timestamp, tenant_id等元数据。 | MUST |
| BPE-002 | 事件命名规范 | 事件名称应遵循Domain.Entity.Action的格式，例如HR.Employee.Hired。 | MUST |
| BPE-003 | 幂等性保障 | 事件消费者必须能处理重复事件。事件的event_id是实现幂等性消费的关键。 | MUST |
| BPE-004 | 状态变更的唯一来源 | 对任何核心业务实体的创建、更新或删除操作，**必须**通过发布一个对应的BUSINESS_PROCESS_EVENT来发起。该事件是后续数据库状态变更的唯一合法源头。 | MUST |

### **8. 安全模型 (Security Model)**

**目的**：定义资源的访问控制策略，确保数据安全和业务操作合规，并为城堡蓝图的"默认安全"和"混合多租户"模型提供宪法基础。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| authentication_methods | Array | 是 | 支持的认证机制。平台标准为OAuth 2.0。 |
| authorization_scheme | enum | 是 | 平台的授权基础架构。推荐ROLE_BASED (基于角色的访问控制 - RBAC) 作为基础。 |
| data_access_permissions | Array | 否 | (数据权限) 定义对资源数据字段的传统读取和写入权限。 |
| event_initiation_permissions | Array | 否 | **[v2.0 核心扩展]** (事件发起权限) 定义谁可以发起（创建）特定的业务流程事件。这是将权限从"写数据"提升到"发起业务"的关键 1。 |
| timeline_action_permissions | Array | 否 | **[v2.0 核心扩展]** (时间线管理权限) 定义谁可以执行敏感的时间线管理操作（校正、取消、撤销）。 |

#### **8.6 子定义: ConstraintRule**

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| rule_type | enum | 是 | 多态鉴别器。可选值：FIELD_COMPARISON，GRAPH_RELATIONSHIP。 |
| description | string | 是 | 对该规则的人类可读描述。 |
| enforce_tenant_boundary | boolean | 是 | **[城堡蓝图核心]** 默认值为true。当为true时，嵌入式OPA策略引擎**必须**强制确保此规则定义的所有数据访问或图遍历，都严格限制在当前操作者所属租户的边界之内。这是"默认安全"模型的基石，其行为由**模块19**的EAC-003规约强制保障 1。 |
| allow_cross_tenant_traversal | boolean | 是 | **[城堡蓝图核心]** 默认值为false。这是一个高特权标志，仅当明确设为true时，才允许此特定规则绕过enforce_tenant_boundary的检查。此标志的使用必须经过AI治理委员会的特别审批 1。 |
| security_query_cost_profile | enum | 否 | 为安全规则的计算成本提供一个静态分类，尤其针对计算开销可能很高的GRAPH_RELATIONSHIP类型。可选值: LOW, MEDIUM, HIGH 1。 |

#### **8.7 租户隔离强制执行 (Tenancy Isolation Enforcement)**

**引言**：为实现城堡蓝图中的"混合多租户模型"，本节对数据库层的行级安全（Row-Level Security, RLS）机制进行规约，作为"共享池（逻辑隔离）"模式的最终安全保障 1。

* **规约**：对于任何需要进行租户隔离的数据库查询，应用代码在执行查询之前，**必须**在当前数据库事务中执行SET LOCAL app.current_tenant_id = '...'语句，将当前请求的租户ID设置到会话变量中。  
* **理由**：使用SET LOCAL至关重要，它能确保该变量的生命周期仅限于当前事务，避免在连接池中发生租户上下文泄露的风险。数据库中所有受保护的表都将应用依赖此会话变量的RLS策略。一旦启用，数据库自身将成为数据隔离的最终防线，从根本上防止任何查询访问到不属于当前租户的数据行，从而将安全责任从"开发者必须记得添加WHERE tenant_id =..."转移到"架构默认提供且强制执行" 1。

### **9. 可观测性 (Observability)**

**目的**：定义平台的监控、日志和追踪策略，并强制要求所有指标和日志都具备租户维度，以支持城堡蓝图要求的精细化运营。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| logging_policy | LoggingPolicy | 是 | 定义API请求和系统错误的日志记录标准。**强制要求**：所有结构化日志**必须**包含tenant_id字段 1。 |
| metrics_policy | MetricsPolicy | 是 | 定义暴露给监控系统的技术性能指标。**强制要求**：所有指标**必须**包含tenant_id标签（维度） 1。 |
| tracing_policy | TracingPolicy | 是 | 定义分布式追踪的策略，遵循OpenTelemetry标准。 |
| business_process_monitoring | BusinessProcessMonitoring | 否 | **[v2.0 核心扩展]** (业务流程监控) 定义针对EVENT_DRIVEN资源的业务流程健康度和效率的监控要求 1。 |

#### **9.3 子定义: BusinessKPI (业务关键绩效指标)**

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| metric_name | string | 是 | 指标的标准化名称，例如hr_core.job_change.processing_duration_seconds。 |
| metric_type | enum | 是 | 指标类型：GAUGE, COUNTER, HISTOGRAM。 |
| description | string | 是 | 对该业务指标含义的清晰描述。 |
| required_dimensions | Array | 是 | 该指标必须包含的维度（标签），用于数据切分和筛选。**强制要求**：此列表**必须**包含tenant_id，以实现按租户对所有业务KPI进行切分和聚合，这是城堡蓝图可观测性策略的核心 1。 |

### **10. 集成契约 (Integration Contract)**

**目的**：定义本资源如何通过异步消息（事件）与其他系统进行集成，并正式将"进程内事务性发件箱"模式确立为实现可靠事件发布的唯一官方机制。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| data_subscriptions | Array | 否 | 定义本资源从其他系统订阅的数据或事件。 |
| event_publications | Array | 否 | (事件发布) 定义本资源在发生特定业务行为时，会对外发布的业务事件。**实现机制**：所有event_publications的生成**必须**通过城堡蓝图定义的"进程内事务性发件箱"模式来保证。此模式在提供高可靠性的同时，完全消除了对外部CDC/Kafka等复杂系统的依赖，是城堡哲学务实性的体现 1。 |

### **11-13. 巫师塔：AI与交互模型**

**引言**：本部分是AI集成的技术核心，详细阐述了旨在安全、可靠地连接非确定性的LLM世界与确定性的企业交易世界的架构。其核心范式为"灵活理解，刚性创建"，由情境感知模型（模块13）、对话式交互模型（模块12）和AI治理模型（模块11）协同实现 1。

* **灵活理解**：IntelligenceGateway塔楼借助LLM解析用户输入。前端应用根据**模块13（情境感知模型）**的UIState对象规约，将UI上下文随同用户话语一并发送。这使得LLM能更精确地理解用户意图 1。  
* **刚性创建**：一旦意图被理解，LLM的职责便结束。系统将利用现代LLM的**"函数调用"（Function Calling）**能力，强制其输出一个严格遵循**模块12（对话式交互模型）**中IntentDefinition和EntityDefinition所定义Schema的结构化JSON对象。IntelligenceGateway在收到此JSON后，但在调用任何业务API前，会调用嵌入式OPA引擎，依据**模块11（AI治理模型）**中的supported_intents_ref等规则进行最终授权检查。通过后，才会组装成一个标准的、对内部业务API的调用请求，并最终生成一个不可变的BUSINESS_PROCESS_EVENT 1。

#### **11. AI治理模型 (v3.0 新增)**

**目的**：将AI模型本身作为被管理对象，定义其生命周期、能力边界和风险控制策略，实现对AI代理行为的"治理即代码"。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| model_id | UUID | 是 | AI模型的全局唯一标识符。 |
| model_name | string | 是 | 用户友好的模型名称。 |
| model_version | semantic_version | 是 | 模型的语义化版本。 |
| model_type | enum | 是 | 模型的核心类型，如CLASSIFICATION, GENERATIVE_LLM, CONVERSATIONAL_AGENT。 |
| supported_intents_ref | Array | 否 | **[核心治理]** 指向模块12中已定义的、此模型版本被授权执行的意图ID列表。这是嵌入式OPA引擎控制其行为的核心依据。仅对CONVERSATIONAL_AGENT类型模型必需 1。 |
| human_escalation_policy | string | 否 | 定义AI必须将对话转接给人工的规则（如"连续两次意图识别失败时"）。 |
| training_data_lineage | Array | 是 | 用于训练该模型版本的数据源血缘关系，确保训练过程的可追溯性。 |

#### **12. 对话式交互模型 (v3.0 新增)**

**目的**：将意图、实体、对话流等对话核心构件资产化，使其可被治理和引用。这些定义将直接用于生成LLM函数调用的Schema。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| intent_id | string | 是 | 意图的唯一标识符，如CreateJobRequisition。 |
| description | string | 是 | 对该意图所代表的用户目标的详细描述。 |
| triggered_event_type | string | 是 | 该意图成功执行后，将触发发布的BUSINESS_PROCESS_EVENT类型（关联模块7）。 |
| required_entities | Array | 否 | 执行此意图所必需的实体（槽位）列表。 |
| entity_validation_schema | object | 是 | 一个强制性的验证模式，用于对required_entities中的每一个实体进行严格的格式、值和权限校验。此Schema是"刚性创建"的技术保障 1。 |

#### **13. 情境感知模型 (v3.0 新增)**

**目的**：定义前端UI与后端AI之间的协同契约，通过UI上下文提升交互准确率，是实现"灵活理解"的关键。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| page_id | string | 是 | 页面的全局唯一标识符，如TimeOffApprovalPage。 |
| data_context | object | 否 | 页面当前加载的数据上下文，如{employee_id: '12345', request_id: 'TOR-007'}。 |
| afforded_intents | Array | 是 | 在该上下文中被"赋能"的意图ID列表。这是SAM进行"理解"和消歧的核心逻辑依据 1。 |

### **14. 租户档案 (Tenancy Profile)**

**目的**：为将平台蓝图中关于租户管理的强制要求法典化，本模块正式定义租户的完整配置，作为管理"混合多租户模型"的唯一事实来源。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| profile_version | string | 是 | TenancyProfile规约自身的版本号，如 "1.0"。 |
| tenant_id | UUID | 是 | 租户的全局唯一、不可变标识符。是所有租户隔离策略的核心关联键。 |
| isolation_model | enum | 是 | **[核心业务策略]** 租户的隔离模型，直接映射城堡蓝图的混合隔离策略。可选值：LOGICAL_POOL (逻辑隔离共享池), DEDICATED_SILO (专属筒仓/物理隔离) 1。 |
| status | enum | 是 | 租户的生命周期状态，如ACTIVE, SUSPENDED, DEPROVISIONING。 |
| pricing_tier | string | 是 | 租户的商业定价层级，如STANDARD, ENTERPRISE。用于与策略引擎联动，实现动态功能授权 1。 |
| feature_flags | object | 否 | 为此租户动态开启或关闭特定功能的键值对映射。 |

### **19. 执行保障与合规性 (Execution Assurance & Compliance)**

**目的**：本模块不定义任何API资源，而是对支撑本合约所有模块得以强制执行的外部系统（即嵌入式OPA策略引擎）的行为进行规约。

| 规约ID | 规约名称 | 规约描述 | 强制级别 |
| :---- | :---- | :---- | :---- |
| EAC-001 | 策略执行点全覆盖 | 所有进入平台的数据访问请求，**必须**经过一个策略执行点（PEP）进行审查。在城堡架构中，此PEP通常是嵌入在单体应用内部的OPA库的调用点 1。 | MUST |
| EAC-002 | 元合约作为策略信息源 | 嵌入式OPA引擎**必须**能够实时、准确地获取并解析本元合约的最新版本，作为其决策所需的核心信息来源（PIP） 1。 | MUST |
| EAC-003 | 租户边界强制执行 | 对于元合约中enforce_tenant_boundary标记为true的任何资源，策略执行点**必须**拒绝任何未包含与当前认证主体tenant_id严格匹配的过滤条件的访问请求 1。 | MUST |
| EAC-005 | 禁止直接状态变更 | 平台的运行时环境**必须**阻止任何应用层服务直接对核心业务数据表执行INSERT, UPDATE, DELETE操作。数据变更的权限应仅限于消费BUSINESS_PROCESS_EVENT的"事件处理器"服务 1。 | MUST |

### **20. 元合约发现 (Meta-Contract Discovery)**

**目的**：定义如何发现和消费此元合约自身。

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| discovery_endpoint | URI | 是 | 获取此元合约文档的标准路径。 |
| caching_policy | Cache_Policy | 是 | 元合约的缓存配置。 |
| change_notification | Change_Notification_Policy | 是 | 元合约变更时的通知机制（如Webhook）。 |

## **第二部分：皇家铸造厂 —— 治理与开发工作流**

### **第一节：立法流程 —— 一部活的宪法**

平台的"宪法"——元合约，其自身的演进过程也必须被严格治理。这通过一个**"活合约"治理框架**来实现，该框架将元合约（OpenAPI YAML文件）视为一等公民源代码，并将其变更流程纳入CI/CD管道，确保其权威性与质量 1。

* **自动化规约校验 (Linting) 与 Spectral**：为自动强制执行API风格指南、检测破坏性变更，并确保所有对合约的修改都符合预定义的质量标准，CI流水线在每次提交拉取请求（Pull Request）时，都会使用Spectral这个灵活的JSON/YAML linter来自动校验元合约的变更 1。一个自定义的  
  .spectral.yaml规则集将被创建，它会扩展（extends）内置的spectral:oas规则集，并加入项目特有的规则，例如强制所有API路径都使用kebab-case命名法，或确保所有Schema都有描述信息。这个校验步骤将被集成到一个GitHub Action工作流中，任何"违宪"的修改都将导致构建失败 1。  
* **通过CODEOWNERS实现结构化审批**：自动化校验是基础，但对于宪法的关键部分（如安全模型、AI治理模型），还需要人工审批。通过利用Git的CODEOWNERS文件，平台建立了一个基于代码的审批机制 1。该文件位于  
  .github/目录下，使用类似/meta-contract/security/*.yaml @security-team这样的模式来为元合约的不同模块指定所有者。通过配置分支保护规则，强制要求任何对受保护路径的修改都必须获得其代码所有者的审查批准后才能合并，从而确保治理委员会对关键规则拥有技术上的否决权 1。

### **第二节：策略引擎 —— 皇家法令**

城堡蓝图全面采纳"治理即代码"并选择Open Policy Agent (OPA)作为核心技术。然而，为了契合"雄伟单体"削减运维复杂性的哲学，平台正式采纳**将OPA作为一个库（SDK）直接嵌入到单体应用进程中**的部署模式 1。

这种嵌入式方案提供了与独立的OPA守护进程完全相同的逻辑分离和动态策略执行能力，但其优势是压倒性的：决策延迟几乎为零（进程内函数调用），无任何额外运维开销，容错模型简单，资源占用更低，且开发工作流极为顺畅。这避免了引入不必要的网络开销和运维复杂性，是城堡哲学务实性的完美体现 1。

#### **表格：OPA部署模式对比**

| 评判标准 | 嵌入式库模型 | 独立服务/Sidecar模型 | "城堡蓝图"推荐 |
| :---- | :---- | :---- | :---- |
| **决策延迟** | 几乎为零（进程内函数调用）。 | 存在网络延迟（HTTP/gRPC调用）。 | **嵌入式库模型** |
| **运维复杂性** | 零额外开销。无需部署、监控、扩展或管理额外的服务。 | 高。需要管理OPA服务的生命周期、配置、高可用性。 | **嵌入式库模型** |
| **容错模型** | 简单。OPA与应用共存亡，失败模式单一。 | 复杂。引入了新的网络故障点，增加了系统的脆弱性。 | **嵌入式库模型** |
| **资源占用** | 更低。与主应用共享进程空间，内存占用更集约。 | 更高。需要为OPA服务单独分配CPU和内存资源。 | **嵌入式库模型** |
| **开发工作流** | 极其顺畅。开发者在本地运行和调试应用时，策略引擎天然可用。 | 略显复杂。本地开发可能需要运行OPA容器。 | **嵌入式库模型** |

### **第三节：皇家工匠 —— AI作为"力倍增器"**

一个由元合约治理的单体代码仓库——"城堡"——为AI编程助手（如GitHub Copilot）创造了理想的工作环境 1。AI编程助手的效能与其所能获取的上下文信息量直接相关。在传统的、分散的多仓库架构中，AI助手往往像是在"盲飞"，因为它无法看到项目不同部分之间的关联 1。

城堡架构通过提供最丰富的全局上下文，从根本上改变了这一局面。AI可以同时访问整个系统的所有部分：前端代码、后端API实现、数据库模型以及最重要的——作为"宪法"的元合约。这份元合约就像是提供给AI的一张详尽的架构"地图" 1。

其结果是，AI助手从一个简单的代码补全工具，转变为一个真正理解系统架构、能够提出高质量、合规代码建议的"架构师助理"。当开发者要求AI实现新功能时，AI不仅能理解当前的编码任务，还能查阅元合约来理解整个系统的"法律"，知道哪些数据模型是可用的，API应该如何设计，以及安全和租户规则是什么。它生成的代码建议不仅在语法上正确，更在架构上保持一致和合规。这种由"代理式AI"驱动的大规模、可靠的重构能力，也极大地缓解了传统单体仓库难以维护的痛点 1。在AI辅助开发的时代，最优的架构是能够最大化AI效能的架构。

## **第三部分：筑起城堡 —— 实施与演进**

### **第一节：垂直切片执行策略**

平台明确**废弃**"水平分层"式的路线图，因为它将所有关键的技术集成风险全部推迟到了项目后期。取而代之的，是基于垂直切片（Vertical Slice）的官方执行策略 1。该策略强调在项目初期优先交付一个贯穿整个技术栈的、功能极简但端到端可用的"最小可行AI"（Minimum Viable AI, MVAI），以此来优先解决最高风险的

进程内复杂集成问题 1。

#### **表格：实施路线图垂直切片**

| 切片 | 核心目标 | 关键任务（单体语境） | 预期成果与风险缓解 |
| :---- | :---- | :---- | :---- |
| **切片 0："心跳"切片** | 验证单体内部最核心、风险最高的集成链路。 | 1. 搭建包含CoreHR和IntelligenceGateway两个模块的单体骨架。 2. 实现**进程内事务性发件箱工作线程**，将CoreHR的一个字段变更同步到Neo4j。 3. 集成**嵌入式OPA库**，并在IntelligenceGateway中执行一次硬编码的策略检查。 4. 确保两个模块间通过元合约定义的API进行一次成功的内部调用。 | 证明了最棘手的内部集成（数据同步、策略检查、模块间调用）在单体架构下是可行的。项目最大的技术风险在第一周就被识别和缓解。 |
| **切片 1：第一个查询** | 端到端验证"灵活理解，刚性创建"的查询流程。 | 1. 扩展IntelligenceGateway以调用LLM解析"谁是我的经理？"意图。 2. CoreHR模块实现从Neo4j查询汇报链的逻辑。 3. 完整实现从自然语言输入到API响应输出的全链路。 | 验证了AI交互模型和多语言持久化架构的协同工作能力。 |
| **切片 2：第一个事务** | 端到端验证"交互即审计事件"的事务性流程。 | 1. 实现一个低风险的、需要写入数据的AI意图（如"更新我的电话号码"）。 2. 验证从意图识别到调用业务模块API，再到生成BUSINESS_PROCESS_EVENT并写入发件箱的完整流程。 | 平台的核心架构模式（刚性创建、事件溯源）得到完整验证，为引入高风险的交易型AI能力铺平了道路。 |
| **切片 3：第一个专属筒仓** | 验证并自动化物理隔离租户的生命周期管理。 | 1. 编写并测试Terraform脚本，用于自动化部署一个完整的专属租户环境。 2. 验证部署成功后，租户元数据注册表的自动更新。 3. 验证针对该租户的监控和数据库迁移流程。 | 平台已具备为大型企业客户提供服务的能力，商业模式得到验证。 |

### **第二节："绞杀者无花果"逃生舱口 —— 为未来而设计**

"绞杀者无花果"模式是本蓝图从设计之初就内置的演进路径。每个模块的公共API（"城墙与门禁"）天然地成为了未来实施绞杀策略时预设的"断裂带" 1。然而，启动"绞杀"一个模块的决策，不应是随意的，而应由明确的业务或技术驱动因素触发 1。

* **团队结构触发器（康威定律）**：当组织结构发生变化，为一个特定的业务领域（如Payroll）成立了一个独立的、自治的产品和工程团队时，就应该启动对该模块的"绞杀"流程。  
* **技术扩展性触发器**：当某个特定模块的负载（如数据库写入TPS或CPU消耗）与其他模块显著不同，导致对整个单体进行垂直扩展变得不再经济高效时，就应该将其剥离。  
* **业务需求触发器**：当出现新的、差异化的业务需求，而这些需求只有通过独立部署才能满足时（例如，一个欧洲客户要求其数据必须存储在欧盟境内以满足GDPR要求），就应该启动"绞杀"。

## **结论：一份务实雄心的蓝图**

本《元合约v6.0》并非对先前宏伟愿景的削减，而是为其量身定制的一条最智慧、最高效、风险最低的实现路径。它深刻地认识到，对于一支精干的团队，架构的成功不在于其理论上的先进性，而在于其在特定约束条件下的实践可行性 1。

通过将规约提升为一份"平台宪法"，本合约为项目提供了：

* **治理的基石**：一份机器可读的、作为唯一事实来源的元合约，将抽象的治理原则转化为可自动执行和审计的规则。  
* **AI的护城河**：一套精心设计的API模式和治理机制，为AI代理的行为划定了安全、可预测的边界，实现了"灵活理解，刚性创建"的平衡。  
* **架构的蓝图**：一个统一的规约，指导着从多语言持久化到多租户安全隔离等关键架构决策，确保系统各部分协调一致。  
* **开发的加速器**：一份精确的规约，不仅能通过代码生成工具消除大量样板代码，更能为AI编程助手提供最丰富的上下文，使其成为团队真正的"力倍增器"。

成功执行这份蓝图的关键，在于对核心原则的严格遵守和对实施路径的纪律性执行。其中，在项目初期（切片0）就果断地采用垂直切片方法，优先解决最核心的集成风险，是确保项目成功的首要战术决策。通过拥抱"规约即宪法"的理念，团队将有能力管理其宏伟愿景的复杂性，将风险降至最低，并最大限度地发挥人机协作的潜力，最终将蓝图变为现实 1。

#### **引用的著作**

1. 元合约