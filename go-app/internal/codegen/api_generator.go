// internal/codegen/api_generator.go
package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	
	"github.com/gaogu/cube-castle/go-app/internal/types"
)

// APIGenerator generates API route files from meta-contracts
type APIGenerator struct {
	templateEngine *template.Template
}

// NewAPIGenerator creates a new API generator
func NewAPIGenerator() *APIGenerator {
	return &APIGenerator{
		templateEngine: template.New("api-routes").Funcs(template.FuncMap{
			"title":      strings.Title,
			"lower":      strings.ToLower,
			"upper":      strings.ToUpper,
			"camelCase":  toCamelCase,
			"snakeCase":  toSnakeCase,
			"plural":     toPlural,
		}),
	}
}

// Generate creates API route files from a meta-contract
func (g *APIGenerator) Generate(contract *types.MetaContract, outputDir string) error {
	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	
	// Generate REST API handlers
	if err := g.generateRESTHandlers(contract, outputDir); err != nil {
		return fmt.Errorf("failed to generate REST handlers: %w", err)
	}
	
	// Generate GraphQL resolvers if enabled
	if contract.APIBehavior.GraphQLEnabled {
		if err := g.generateGraphQLResolvers(contract, outputDir); err != nil {
			return fmt.Errorf("failed to generate GraphQL resolvers: %w", err)
		}
	}
	
	// Generate middleware configurations
	if err := g.generateMiddleware(contract, outputDir); err != nil {
		return fmt.Errorf("failed to generate middleware: %w", err)
	}
	
	return nil
}

// generateRESTHandlers creates REST API handler files
func (g *APIGenerator) generateRESTHandlers(contract *types.MetaContract, outputDir string) error {
	tmplStr := `// Code generated by metacontract-compiler. DO NOT EDIT.
package api

import (
	"encoding/json"
	"net/http"
	"strconv"
	
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	
	"github.com/gaogu/cube-castle/go-app/internal/ent"
	"github.com/gaogu/cube-castle/go-app/internal/middleware"
)

// {{.ResourceName | title}}Handler handles HTTP requests for {{.ResourceName}}
type {{.ResourceName | title}}Handler struct {
	client *ent.Client
}

// New{{.ResourceName | title}}Handler creates a new handler instance
func New{{.ResourceName | title}}Handler(client *ent.Client) *{{.ResourceName | title}}Handler {
	return &{{.ResourceName | title}}Handler{
		client: client,
	}
}

// Routes registers all routes for {{.ResourceName}}
func (h *{{.ResourceName | title}}Handler) Routes() chi.Router {
	r := chi.NewRouter()
	
	// Apply middleware
	r.Use(middleware.TenantContext)
{{if eq .SecurityModel.AccessControl "RBAC"}}
	r.Use(middleware.RBACAuthorization)
{{end}}
{{if ne .SecurityModel.DataClassification "PUBLIC"}}
	r.Use(middleware.DataClassificationCheck("{{.SecurityModel.DataClassification}}"))
{{end}}
	
	// REST endpoints
	r.Post("/", h.Create{{.ResourceName | title}})
	r.Get("/", h.List{{.ResourceName | title | plural}})
	r.Get("/{id}", h.Get{{.ResourceName | title}})
	r.Put("/{id}", h.Update{{.ResourceName | title}})
	r.Delete("/{id}", h.Delete{{.ResourceName | title}})
	
{{if eq .TemporalBehavior.TemporalityParadigm "EVENT_DRIVEN"}}
	// Temporal endpoints
	r.Get("/{id}/history", h.Get{{.ResourceName | title}}History)
	r.Get("/{id}/at/{timestamp}", h.Get{{.ResourceName | title}}AtTime)
{{end}}
	
	return r
}

// Create{{.ResourceName | title}} creates a new {{.ResourceName}}
func (h *{{.ResourceName | title}}Handler) Create{{.ResourceName | title}}(w http.ResponseWriter, r *http.Request) {
	var req Create{{.ResourceName | title}}Request
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	
	tenantID := middleware.GetTenantID(r.Context())
	if tenantID == uuid.Nil {
		http.Error(w, "Tenant context required", http.StatusUnauthorized)
		return
	}
	
	// Create entity
	entity, err := h.client.{{.ResourceName | title}}.
		Create().
		SetTenantID(tenantID).
{{range .Fields}}
{{if ne .Name "id"}}
		Set{{.Name | title}}(req.{{.Name | title}}).
{{end}}
{{end}}
		Save(r.Context())
	
	if err != nil {
		http.Error(w, "Failed to create {{.ResourceName}}", http.StatusInternalServerError)
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(entity)
}

// List{{.ResourceName | title | plural}} lists all {{.ResourceName | plural}}
func (h *{{.ResourceName | title}}Handler) List{{.ResourceName | title | plural}}(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.GetTenantID(r.Context())
	if tenantID == uuid.Nil {
		http.Error(w, "Tenant context required", http.StatusUnauthorized)
		return
	}
	
	// Parse query parameters
	limit := 100 // default
	if l := r.URL.Query().Get("limit"); l != "" {
		if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 && parsed <= 1000 {
			limit = parsed
		}
	}
	
	offset := 0
	if o := r.URL.Query().Get("offset"); o != "" {
		if parsed, err := strconv.Atoi(o); err == nil && parsed >= 0 {
			offset = parsed
		}
	}
	
	// Query entities
	entities, err := h.client.{{.ResourceName | title}}.
		Query().
		Where({{.ResourceName | lower}}.TenantID(tenantID)).
		Limit(limit).
		Offset(offset).
		All(r.Context())
	
	if err != nil {
		http.Error(w, "Failed to list {{.ResourceName | plural}}", http.StatusInternalServerError)
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(entities)
}

// Get{{.ResourceName | title}} gets a specific {{.ResourceName}}
func (h *{{.ResourceName | title}}Handler) Get{{.ResourceName | title}}(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid ID format", http.StatusBadRequest)
		return
	}
	
	tenantID := middleware.GetTenantID(r.Context())
	if tenantID == uuid.Nil {
		http.Error(w, "Tenant context required", http.StatusUnauthorized)
		return
	}
	
	// Query entity
	entity, err := h.client.{{.ResourceName | title}}.
		Query().
		Where(
			{{.ResourceName | lower}}.ID(id),
			{{.ResourceName | lower}}.TenantID(tenantID),
		).
		Only(r.Context())
	
	if err != nil {
		if ent.IsNotFound(err) {
			http.Error(w, "{{.ResourceName | title}} not found", http.StatusNotFound)
		} else {
			http.Error(w, "Failed to get {{.ResourceName}}", http.StatusInternalServerError)
		}
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(entity)
}

// Update{{.ResourceName | title}} updates a specific {{.ResourceName}}
func (h *{{.ResourceName | title}}Handler) Update{{.ResourceName | title}}(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid ID format", http.StatusBadRequest)
		return
	}
	
	var req Update{{.ResourceName | title}}Request
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	
	tenantID := middleware.GetTenantID(r.Context())
	if tenantID == uuid.Nil {
		http.Error(w, "Tenant context required", http.StatusUnauthorized)
		return
	}
	
	// Update entity
	entity, err := h.client.{{.ResourceName | title}}.
		UpdateOneID(id).
		Where({{.ResourceName | lower}}.TenantID(tenantID)).
{{range .Fields}}
{{if and (ne .Name "id") (ne .Name "created_at") (ne .Name "tenant_id")}}
		Set{{.Name | title}}(req.{{.Name | title}}).
{{end}}
{{end}}
		Save(r.Context())
	
	if err != nil {
		if ent.IsNotFound(err) {
			http.Error(w, "{{.ResourceName | title}} not found", http.StatusNotFound)
		} else {
			http.Error(w, "Failed to update {{.ResourceName}}", http.StatusInternalServerError)
		}
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(entity)
}

// Delete{{.ResourceName | title}} deletes a specific {{.ResourceName}}
func (h *{{.ResourceName | title}}Handler) Delete{{.ResourceName | title}}(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid ID format", http.StatusBadRequest)
		return
	}
	
	tenantID := middleware.GetTenantID(r.Context())
	if tenantID == uuid.Nil {
		http.Error(w, "Tenant context required", http.StatusUnauthorized)
		return
	}
	
	// Delete entity
	err = h.client.{{.ResourceName | title}}.
		DeleteOneID(id).
		Where({{.ResourceName | lower}}.TenantID(tenantID)).
		Exec(r.Context())
	
	if err != nil {
		if ent.IsNotFound(err) {
			http.Error(w, "{{.ResourceName | title}} not found", http.StatusNotFound)
		} else {
			http.Error(w, "Failed to delete {{.ResourceName}}", http.StatusInternalServerError)
		}
		return
	}
	
	w.WriteHeader(http.StatusNoContent)
}

{{if eq .TemporalBehavior.TemporalityParadigm "EVENT_DRIVEN"}}
// Get{{.ResourceName | title}}History gets the history of a {{.ResourceName}}
func (h *{{.ResourceName | title}}Handler) Get{{.ResourceName | title}}History(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid ID format", http.StatusBadRequest)
		return
	}
	
	tenantID := middleware.GetTenantID(r.Context())
	if tenantID == uuid.Nil {
		http.Error(w, "Tenant context required", http.StatusUnauthorized)
		return
	}
	
	// Query history entities
	history, err := h.client.{{.ResourceName | title}}History.
		Query().
		Where(
			{{.ResourceName | lower}}history.EntityID(id),
			{{.ResourceName | lower}}history.TenantID(tenantID),
		).
		Order(ent.Desc({{.ResourceName | lower}}history.FieldEffectiveDate)).
		All(r.Context())
	
	if err != nil {
		http.Error(w, "Failed to get {{.ResourceName}} history", http.StatusInternalServerError)
		return
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(history)
}

// Get{{.ResourceName | title}}AtTime gets a {{.ResourceName}} at a specific time
func (h *{{.ResourceName | title}}Handler) Get{{.ResourceName | title}}AtTime(w http.ResponseWriter, r *http.Request) {
	idStr := chi.URLParam(r, "id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		http.Error(w, "Invalid ID format", http.StatusBadRequest)
		return
	}
	
	timestampStr := chi.URLParam(r, "timestamp")
	// Parse timestamp and implement temporal query logic
	// This would query the history table for the state at the specific time
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"message": "Temporal query not yet implemented",
		"id": idStr,
		"timestamp": timestampStr,
	})
}
{{end}}

// Request/Response types
type Create{{.ResourceName | title}}Request struct {
{{range .Fields}}
{{if and (ne .Name "id") (ne .Name "created_at") (ne .Name "updated_at") (ne .Name "tenant_id")}}
	{{.Name | title}} {{.GoType}} ` + "`" + `json:"{{.Name}}"` + "`" + `
{{end}}
{{end}}
}

type Update{{.ResourceName | title}}Request struct {
{{range .Fields}}
{{if and (ne .Name "id") (ne .Name "created_at") (ne .Name "updated_at") (ne .Name "tenant_id")}}
	{{.Name | title}} {{.GoType}} ` + "`" + `json:"{{.Name}}"` + "`" + `
{{end}}
{{end}}
}
`
	
	tmpl, err := g.templateEngine.Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}
	
	// Create template data
	data := &APITemplateData{
		MetaContract: contract,
		Fields:       g.convertAPIFields(contract.DataStructure.Fields),
	}
	
	// Generate the file
	filename := filepath.Join(outputDir, strings.ToLower(contract.ResourceName)+"_handler.go")
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create handler file: %w", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}
	
	return nil
}

// generateGraphQLResolvers creates GraphQL resolver files
func (g *APIGenerator) generateGraphQLResolvers(contract *types.MetaContract, outputDir string) error {
	// GraphQL resolver generation implementation
	// This would create resolver functions for GraphQL schema
	return nil
}

// generateMiddleware creates middleware configuration files
func (g *APIGenerator) generateMiddleware(contract *types.MetaContract, outputDir string) error {
	// Middleware generation implementation
	// This would create security and tenant context middleware
	return nil
}

// APITemplateData holds data for API template execution
type APITemplateData struct {
	*types.MetaContract
	Fields []APIFieldDefinition
}

// APIFieldDefinition represents a field with API-specific methods
type APIFieldDefinition struct {
	types.FieldDefinition
}

// GoType returns the Go type for the field
func (f APIFieldDefinition) GoType() string {
	switch f.Type {
	case "string":
		return "string"
	case "int":
		return "int"
	case "int64":
		return "int64"
	case "float64":
		return "float64"
	case "bool":
		return "bool"
	case "time":
		return "time.Time"
	case "uuid":
		return "uuid.UUID"
	case "json":
		return "interface{}"
	default:
		return "string"
	}
}

// convertAPIFields converts meta-contract fields to API template fields
func (g *APIGenerator) convertAPIFields(fields []types.FieldDefinition) []APIFieldDefinition {
	result := make([]APIFieldDefinition, len(fields))
	for i, field := range fields {
		result[i] = APIFieldDefinition{FieldDefinition: field}
	}
	return result
}

// Helper functions
func toPlural(s string) string {
	if strings.HasSuffix(s, "y") {
		return s[:len(s)-1] + "ies"
	}
	if strings.HasSuffix(s, "s") || strings.HasSuffix(s, "x") || strings.HasSuffix(s, "z") {
		return s + "es"
	}
	return s + "s"
}