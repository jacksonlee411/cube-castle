// internal/codegen/ent_generator.go
package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/gaogu/cube-castle/go-app/internal/types"
)

// EntGenerator generates Ent schema files from meta-contracts
type EntGenerator struct {
	templateEngine *template.Template
}

// NewEntGenerator creates a new Ent schema generator
func NewEntGenerator() *EntGenerator {
	return &EntGenerator{
		templateEngine: template.New("ent-schema").Funcs(template.FuncMap{
			"title":     strings.Title,
			"lower":     strings.ToLower,
			"upper":     strings.ToUpper,
			"camelCase": toCamelCase,
			"snakeCase": toSnakeCase,
		}),
	}
}

// Generate creates Ent schema files from a meta-contract
func (g *EntGenerator) Generate(contract *types.MetaContract, outputDir string) error {
	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate main entity schema
	if err := g.generateEntitySchema(contract, outputDir); err != nil {
		return fmt.Errorf("failed to generate entity schema: %w", err)
	}

	// Generate relationship schemas if defined
	if err := g.generateRelationships(contract, outputDir); err != nil {
		return fmt.Errorf("failed to generate relationships: %w", err)
	}

	// Generate history entities if temporal behavior is event-driven
	if contract.TemporalBehavior.TemporalityParadigm == "EVENT_DRIVEN" {
		if err := g.generateHistoryEntities(contract, outputDir); err != nil {
			return fmt.Errorf("failed to generate history entities: %w", err)
		}
	}

	return nil
}

// generateEntitySchema creates the main entity schema file
func (g *EntGenerator) generateEntitySchema(contract *types.MetaContract, outputDir string) error {
	tmplStr := `// Code generated by metacontract-compiler. DO NOT EDIT.
package schema

import (
	"time"
	
	"entgo.io/ent"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/index"
	"github.com/google/uuid"
	
	"github.com/gaogu/cube-castle/go-app/internal/ent/annotations"
)

// {{.ResourceName | title}} holds the schema definition for {{.ResourceName}}.
type {{.ResourceName | title}} struct {
	ent.Schema
}

// Fields of {{.ResourceName | title}}.
func ({{.ResourceName | title}}) Fields() []ent.Field {
	return []ent.Field{
{{range .Fields}}
		{{.GenerateField}},
{{end}}
	}
}

// Edges of {{.ResourceName | title}}.
func ({{.ResourceName | title}}) Edges() []ent.Edge {
	return []ent.Edge{
{{range .Relationships}}
		{{.GenerateEdge}},
{{end}}
	}
}

// Indexes of {{.ResourceName | title}}.
func ({{.ResourceName | title}}) Indexes() []ent.Index {
	return []ent.Index{
		// Tenant isolation index
		index.Fields("tenant_id"),
		
		// Time-based query optimization
{{if eq .TemporalBehavior.TemporalityParadigm "EVENT_DRIVEN"}}
		index.Fields("tenant_id", "effective_date"),
{{end}}
	}
}

// Annotations of {{.ResourceName | title}}.
func ({{.ResourceName | title}}) Annotations() []schema.Annotation {
	return []schema.Annotation{
		annotations.MetaContractAnnotation{
			DataClassification: "{{.DataStructure.DataClassification}}",
			ComplianceTags:     []string{
{{range .SecurityModel.ComplianceTags}}
				"{{.}}",
{{end}}
			},
{{if .DataStructure.PersistenceProfile}}
			PersistenceProfile: &annotations.PersistenceProfile{
				PrimaryStore:    "{{.DataStructure.PersistenceProfile.PrimaryStore}}",
				IndexedIn:       []string{
{{range .DataStructure.PersistenceProfile.IndexedIn}}
					"{{.}}",
{{end}}
				},
				GraphNodeLabel:  "{{.DataStructure.PersistenceProfile.GraphNodeLabel}}",
				GraphEdgeDefinitions: []string{
{{range .DataStructure.PersistenceProfile.GraphEdgeDefinitions}}
					"{{.}}",
{{end}}
				},
			},
{{end}}
		},
	}
}
`

	tmpl, err := g.templateEngine.Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create template data with methods
	data := &TemplateData{
		MetaContract:  contract,
		Fields:        g.convertFields(contract.DataStructure.Fields),
		Relationships: g.convertRelationships(contract.Relationships),
	}

	// Generate the file
	filename := filepath.Join(outputDir, strings.ToLower(contract.ResourceName)+".go")
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create schema file: %w", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// generateRelationships creates relationship-specific schema files
func (g *EntGenerator) generateRelationships(contract *types.MetaContract, outputDir string) error {
	// Implementation for relationship generation
	// This would create additional schema files for complex relationships
	return nil
}

// generateHistoryEntities creates history tracking entities for temporal models
func (g *EntGenerator) generateHistoryEntities(contract *types.MetaContract, outputDir string) error {
	// Implementation for history entity generation
	// This would create PositionHistory, CompensationHistory, etc.
	return nil
}

// TemplateData holds data for template execution
type TemplateData struct {
	*types.MetaContract
	Fields        []EntFieldDefinition
	Relationships []EntEdgeDefinition
}

// EntFieldDefinition represents an Ent field with generation methods
type EntFieldDefinition struct {
	types.FieldDefinition
}

// GenerateField generates the Ent field definition code
func (f EntFieldDefinition) GenerateField() string {
	var fieldType string
	switch f.Type {
	case "string":
		fieldType = "String"
	case "int":
		fieldType = "Int"
	case "int64":
		fieldType = "Int64"
	case "float64":
		fieldType = "Float64"
	case "bool":
		fieldType = "Bool"
	case "time":
		fieldType = "Time"
	case "uuid":
		fieldType = "UUID"
	case "json":
		fieldType = "JSON"
	default:
		fieldType = "String" // fallback
	}

	code := fmt.Sprintf("field.%s(\"%s\")", fieldType, f.Name)

	if f.Required {
		code += ".NotEmpty()"
	}

	if f.Unique {
		code += ".Unique()"
	}

	if f.DataClassification != "" {
		code += fmt.Sprintf(".Annotations(annotations.MetaContractAnnotation{DataClassification: \"%s\"})", f.DataClassification)
	}

	return code
}

// EntEdgeDefinition represents an Ent edge with generation methods
type EntEdgeDefinition struct {
	types.RelationshipDef
}

// GenerateEdge generates the Ent edge definition code
func (e EntEdgeDefinition) GenerateEdge() string {
	var edgeType string
	switch e.Type {
	case "one-to-one":
		edgeType = "To"
	case "one-to-many":
		edgeType = "To"
	case "many-to-many":
		edgeType = "To"
	default:
		edgeType = "To"
	}

	code := fmt.Sprintf("edge.%s(\"%s\", %s.Type)", edgeType, toSnakeCase(e.Name), strings.Title(e.TargetEntity))

	if e.Type == "one-to-one" {
		code += ".Unique()"
	}

	if !e.IsOptional {
		code += ".Required()"
	}

	return code
}

// convertFields converts meta-contract fields to template fields
func (g *EntGenerator) convertFields(fields []types.FieldDefinition) []EntFieldDefinition {
	result := make([]EntFieldDefinition, len(fields))
	for i, field := range fields {
		result[i] = EntFieldDefinition{FieldDefinition: field}
	}
	return result
}

// convertRelationships converts meta-contract relationships to template edges
func (g *EntGenerator) convertRelationships(relationships []types.RelationshipDef) []EntEdgeDefinition {
	result := make([]EntEdgeDefinition, len(relationships))
	for i, rel := range relationships {
		result[i] = EntEdgeDefinition{RelationshipDef: rel}
	}
	return result
}

// Helper functions
func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}
