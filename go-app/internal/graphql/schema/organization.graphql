# GraphQL schema for organizational structure and Neo4j integration
# internal/graphql/schema/organization.graphql

# Organization Chart Types
type OrganizationChart {
  department: String!
  employees: [EmployeeInChart!]!
  subDepartments: [SubDepartment!]!
  managerCount: Int!
  totalEmployees: Int!
}

type SubDepartment {
  department: String!
  employees: [EmployeeInChart!]!
  managerCount: Int!
  totalEmployees: Int!
}

type EmployeeInChart {
  id: ID!
  legalName: String!
  currentPosition: PositionInChart
}

type PositionInChart {
  positionTitle: String!
  jobLevel: String
}

# Reporting Path Types
type ReportingPath {
  fromEmployee: EmployeeInChart!
  toEmployee: EmployeeInChart!
  path: [PathStep!]!
  distance: Int!
  pathType: String!
}

type PathStep {
  employee: EmployeeInChart!
  relationship: String!
}

# Reporting Hierarchy Types
type ReportingHierarchy {
  manager: EmployeeInChart!
  directReports: [EmployeeInChart!]!
  allReports: [EmployeeInChart!]!
  depth: Int!
}

# Common Manager Type
type CommonManager {
  id: ID!
  legalName: String!
  currentPosition: PositionInChart
}

# Organization Metrics Types
type OrganizationMetrics {
  totalEmployees: Int!
  totalDepartments: Int!
  averageTeamSize: Float!
  maxReportingDepth: Int!
  spanOfControl: Float!
  departmentMetrics: [DepartmentMetric!]!
}

type DepartmentMetric {
  department: String!
  employeeCount: Int!
  managerCount: Int!
  averageSpan: Float!
  maxDepth: Int!
}

# Network Analysis Types
type EmployeeInfluence {
  employee: EmployeeInChart!
  influenceScore: Float!
  connectionsCount: Int!
  departments: [String!]!
  keyConnections: [EmployeeConnection!]!
}

type EmployeeConnection {
  employee: EmployeeInChart!
  connectionType: String!  # REPORTS_TO, MANAGES, COLLABORATES_WITH, PEER
  strength: Float!
}

type CollaborationNetwork {
  department: String!
  employees: [EmployeeInChart!]!
  connections: [Connection!]!
  networkDensity: Float!
  averagePathLength: Float!
}

type Connection {
  fromEmployee: EmployeeInChart!
  toEmployee: EmployeeInChart!
  connectionType: String!
  weight: Float!
}

# Team Structure Types
type TeamStructure {
  teamId: ID!
  teamName: String!
  manager: EmployeeInChart!
  members: [TeamMember!]!
  subTeams: [TeamStructure!]!
  teamMetrics: TeamMetrics!
}

type TeamMember {
  employee: EmployeeInChart!
  role: String!
  joinDate: Time!
  isCore: Boolean!
}

type TeamMetrics {
  memberCount: Int!
  averageTenure: Float!
  diversityIndex: Float!
  collaborationScore: Float!
}

# Queries
extend type Query {
  # Organization Chart Queries
  organizationChart(
    rootDepartment: String
    asOfDate: Time
    maxLevels: Int
  ): OrganizationChart

  # Reporting Structure Queries
  findReportingPath(
    fromEmployeeId: ID!
    toEmployeeId: ID!
  ): ReportingPath

  findCommonManager(
    employeeIds: [ID!]!
  ): CommonManager

  getReportingHierarchy(
    managerId: ID!
    maxDepth: Int
  ): ReportingHierarchy

  # Organization Analytics
  organizationMetrics(
    department: String
    asOfDate: Time
  ): OrganizationMetrics

  # Network Analysis
  getEmployeeInfluence(
    employeeId: ID!
    analysisDepth: Int
  ): EmployeeInfluence

  getCollaborationNetwork(
    department: String!
    includeExternal: Boolean
  ): CollaborationNetwork

  # Team Structure
  getTeamStructure(
    teamId: ID
    managerId: ID
    department: String
  ): TeamStructure

  # Department Queries
  getDepartmentHierarchy(
    rootDepartment: String
  ): [DepartmentNode!]!

  # Cross-department Analysis
  getCrossDepartmentConnections(
    fromDepartment: String!
    toDepartment: String!
    connectionType: String
  ): [Connection!]!

  # Succession Planning
  getSuccessionCandidates(
    positionId: ID!
    criteria: SuccessionCriteria
  ): [SuccessionCandidate!]!

  # Organizational Health
  getOrganizationalHealth(
    department: String
    timeRange: TimeRange
  ): OrganizationalHealth
}

# Department Structure Types
type DepartmentNode {
  id: ID!
  name: String!
  parentDepartment: DepartmentNode
  subDepartments: [DepartmentNode!]!
  manager: EmployeeInChart
  employees: [EmployeeInChart!]!
  level: Int!
}

# Succession Planning Types
input SuccessionCriteria {
  minExperience: Int
  requiredSkills: [String!]
  sameLocation: Boolean
  maxDistance: Int  # organizational distance
}

type SuccessionCandidate {
  employee: EmployeeInChart!
  readinessScore: Float!
  skillMatch: Float!
  experienceMatch: Float!
  riskFactors: [String!]!
  developmentNeeds: [String!]!
}

# Organizational Health Types
input TimeRange {
  startDate: Time!
  endDate: Time!
}

type OrganizationalHealth {
  overallScore: Float!
  turnoverRate: Float!
  promotionRate: Float!
  averageTenure: Float!
  spanOfControlHealth: Float!
  communicationHealth: Float!
  departmentHealthScores: [DepartmentHealth!]!
}

type DepartmentHealth {
  department: String!
  healthScore: Float!
  turnoverRate: Float!
  averageTenure: Float!
  managerEffectiveness: Float!
  teamCohesion: Float!
}

# Mutations for Graph Synchronization
extend type Mutation {
  # Sync operations to keep graph database updated
  syncEmployeeToGraph(employeeId: ID!): Boolean!
  syncPositionToGraph(positionId: ID!, employeeId: ID!): Boolean!
  syncDepartmentToGraph(departmentId: ID!): Boolean!
  
  # Relationship management
  createReportingRelationship(
    managerId: ID!
    reporteeId: ID!
  ): Boolean!
  
  removeReportingRelationship(
    managerId: ID!
    reporteeId: ID!
  ): Boolean!
  
  # Bulk sync operations
  fullGraphSync: GraphSyncResult!
  syncDepartment(department: String!): GraphSyncResult!
}

type GraphSyncResult {
  success: Boolean!
  syncedEmployees: Int!
  syncedPositions: Int!
  syncedRelationships: Int!
  errors: [String!]!
}

# Subscriptions for real-time organization updates
extend type Subscription {
  # Organization structure changes
  organizationStructureChanged(
    department: String
  ): OrganizationChangeEvent!
  
  # Reporting relationship changes
  reportingRelationshipChanged(
    employeeId: ID
  ): ReportingChangeEvent!
  
  # Team composition changes
  teamCompositionChanged(
    teamId: ID
    department: String
  ): TeamChangeEvent!
}

type OrganizationChangeEvent {
  type: String!  # DEPARTMENT_CREATED, DEPARTMENT_MOVED, MANAGER_CHANGED
  department: String!
  affectedEmployees: [ID!]!
  timestamp: Time!
}

type ReportingChangeEvent {
  type: String!  # MANAGER_CHANGED, REPORTS_ADDED, REPORTS_REMOVED
  employeeId: ID!
  oldManagerId: ID
  newManagerId: ID
  affectedReports: [ID!]!
  timestamp: Time!
}

type TeamChangeEvent {
  type: String!  # MEMBER_ADDED, MEMBER_REMOVED, ROLE_CHANGED
  teamId: ID!
  employeeId: ID!
  changeDetails: String!
  timestamp: Time!
}