// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/gaogu/cube-castle/go-app/ent/position"
	"github.com/gaogu/cube-castle/go-app/ent/positionoccupancyhistory"
	"github.com/google/uuid"
)

// PositionOccupancyHistory is the model entity for the PositionOccupancyHistory schema.
type PositionOccupancyHistory struct {
	config `json:"-"`
	// ID of the ent.
	// Unique identifier for this occupancy record
	ID uuid.UUID `json:"id,omitempty"`
	// Multi-tenant isolation foundation
	TenantID uuid.UUID `json:"tenant_id,omitempty"`
	// Reference to the position being occupied
	PositionID uuid.UUID `json:"position_id,omitempty"`
	// Reference to the employee occupying the position
	EmployeeID uuid.UUID `json:"employee_id,omitempty"`
	// When the employee started occupying this position
	StartDate time.Time `json:"start_date,omitempty"`
	// When the employee stopped occupying this position (null = current)
	EndDate *time.Time `json:"end_date,omitempty"`
	// Whether this occupancy relationship is currently active
	IsActive bool `json:"is_active,omitempty"`
	// Type of position assignment
	AssignmentType positionoccupancyhistory.AssignmentType `json:"assignment_type,omitempty"`
	// Business reason for this assignment
	AssignmentReason string `json:"assignment_reason,omitempty"`
	// Full-time equivalent percentage for this assignment
	FtePercentage float64 `json:"fte_percentage,omitempty"`
	// Work location arrangement for this assignment
	WorkArrangement positionoccupancyhistory.WorkArrangement `json:"work_arrangement,omitempty"`
	// Person who approved this assignment
	ApprovedBy *uuid.UUID `json:"approved_by,omitempty"`
	// When this assignment was approved
	ApprovalDate *time.Time `json:"approval_date,omitempty"`
	// Reference to approval document or process
	ApprovalReference string `json:"approval_reference,omitempty"`
	// Compensation details specific to this assignment
	CompensationData map[string]interface{} `json:"compensation_data,omitempty"`
	// Performance review cycle for this assignment
	PerformanceReviewCycle string `json:"performance_review_cycle,omitempty"`
	// Reference to the business event that caused this assignment
	SourceEventID *uuid.UUID `json:"source_event_id,omitempty"`
	// When this occupancy record was created
	CreatedAt time.Time `json:"created_at,omitempty"`
	// When this occupancy record was last updated
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the PositionOccupancyHistoryQuery when eager-loading is set.
	Edges        PositionOccupancyHistoryEdges `json:"edges"`
	selectValues sql.SelectValues
}

// PositionOccupancyHistoryEdges holds the relations/edges for other nodes in the graph.
type PositionOccupancyHistoryEdges struct {
	// The position this occupancy record belongs to
	Position *Position `json:"position,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// PositionOrErr returns the Position value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PositionOccupancyHistoryEdges) PositionOrErr() (*Position, error) {
	if e.Position != nil {
		return e.Position, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: position.Label}
	}
	return nil, &NotLoadedError{edge: "position"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*PositionOccupancyHistory) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case positionoccupancyhistory.FieldApprovedBy, positionoccupancyhistory.FieldSourceEventID:
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case positionoccupancyhistory.FieldCompensationData:
			values[i] = new([]byte)
		case positionoccupancyhistory.FieldIsActive:
			values[i] = new(sql.NullBool)
		case positionoccupancyhistory.FieldFtePercentage:
			values[i] = new(sql.NullFloat64)
		case positionoccupancyhistory.FieldAssignmentType, positionoccupancyhistory.FieldAssignmentReason, positionoccupancyhistory.FieldWorkArrangement, positionoccupancyhistory.FieldApprovalReference, positionoccupancyhistory.FieldPerformanceReviewCycle:
			values[i] = new(sql.NullString)
		case positionoccupancyhistory.FieldStartDate, positionoccupancyhistory.FieldEndDate, positionoccupancyhistory.FieldApprovalDate, positionoccupancyhistory.FieldCreatedAt, positionoccupancyhistory.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case positionoccupancyhistory.FieldID, positionoccupancyhistory.FieldTenantID, positionoccupancyhistory.FieldPositionID, positionoccupancyhistory.FieldEmployeeID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the PositionOccupancyHistory fields.
func (poh *PositionOccupancyHistory) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case positionoccupancyhistory.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				poh.ID = *value
			}
		case positionoccupancyhistory.FieldTenantID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value != nil {
				poh.TenantID = *value
			}
		case positionoccupancyhistory.FieldPositionID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field position_id", values[i])
			} else if value != nil {
				poh.PositionID = *value
			}
		case positionoccupancyhistory.FieldEmployeeID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field employee_id", values[i])
			} else if value != nil {
				poh.EmployeeID = *value
			}
		case positionoccupancyhistory.FieldStartDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field start_date", values[i])
			} else if value.Valid {
				poh.StartDate = value.Time
			}
		case positionoccupancyhistory.FieldEndDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field end_date", values[i])
			} else if value.Valid {
				poh.EndDate = new(time.Time)
				*poh.EndDate = value.Time
			}
		case positionoccupancyhistory.FieldIsActive:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_active", values[i])
			} else if value.Valid {
				poh.IsActive = value.Bool
			}
		case positionoccupancyhistory.FieldAssignmentType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field assignment_type", values[i])
			} else if value.Valid {
				poh.AssignmentType = positionoccupancyhistory.AssignmentType(value.String)
			}
		case positionoccupancyhistory.FieldAssignmentReason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field assignment_reason", values[i])
			} else if value.Valid {
				poh.AssignmentReason = value.String
			}
		case positionoccupancyhistory.FieldFtePercentage:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field fte_percentage", values[i])
			} else if value.Valid {
				poh.FtePercentage = value.Float64
			}
		case positionoccupancyhistory.FieldWorkArrangement:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field work_arrangement", values[i])
			} else if value.Valid {
				poh.WorkArrangement = positionoccupancyhistory.WorkArrangement(value.String)
			}
		case positionoccupancyhistory.FieldApprovedBy:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field approved_by", values[i])
			} else if value.Valid {
				poh.ApprovedBy = new(uuid.UUID)
				*poh.ApprovedBy = *value.S.(*uuid.UUID)
			}
		case positionoccupancyhistory.FieldApprovalDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field approval_date", values[i])
			} else if value.Valid {
				poh.ApprovalDate = new(time.Time)
				*poh.ApprovalDate = value.Time
			}
		case positionoccupancyhistory.FieldApprovalReference:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field approval_reference", values[i])
			} else if value.Valid {
				poh.ApprovalReference = value.String
			}
		case positionoccupancyhistory.FieldCompensationData:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field compensation_data", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &poh.CompensationData); err != nil {
					return fmt.Errorf("unmarshal field compensation_data: %w", err)
				}
			}
		case positionoccupancyhistory.FieldPerformanceReviewCycle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field performance_review_cycle", values[i])
			} else if value.Valid {
				poh.PerformanceReviewCycle = value.String
			}
		case positionoccupancyhistory.FieldSourceEventID:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field source_event_id", values[i])
			} else if value.Valid {
				poh.SourceEventID = new(uuid.UUID)
				*poh.SourceEventID = *value.S.(*uuid.UUID)
			}
		case positionoccupancyhistory.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				poh.CreatedAt = value.Time
			}
		case positionoccupancyhistory.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				poh.UpdatedAt = value.Time
			}
		default:
			poh.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the PositionOccupancyHistory.
// This includes values selected through modifiers, order, etc.
func (poh *PositionOccupancyHistory) Value(name string) (ent.Value, error) {
	return poh.selectValues.Get(name)
}

// QueryPosition queries the "position" edge of the PositionOccupancyHistory entity.
func (poh *PositionOccupancyHistory) QueryPosition() *PositionQuery {
	return NewPositionOccupancyHistoryClient(poh.config).QueryPosition(poh)
}

// Update returns a builder for updating this PositionOccupancyHistory.
// Note that you need to call PositionOccupancyHistory.Unwrap() before calling this method if this PositionOccupancyHistory
// was returned from a transaction, and the transaction was committed or rolled back.
func (poh *PositionOccupancyHistory) Update() *PositionOccupancyHistoryUpdateOne {
	return NewPositionOccupancyHistoryClient(poh.config).UpdateOne(poh)
}

// Unwrap unwraps the PositionOccupancyHistory entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (poh *PositionOccupancyHistory) Unwrap() *PositionOccupancyHistory {
	_tx, ok := poh.config.driver.(*txDriver)
	if !ok {
		panic("ent: PositionOccupancyHistory is not a transactional entity")
	}
	poh.config.driver = _tx.drv
	return poh
}

// String implements the fmt.Stringer.
func (poh *PositionOccupancyHistory) String() string {
	var builder strings.Builder
	builder.WriteString("PositionOccupancyHistory(")
	builder.WriteString(fmt.Sprintf("id=%v, ", poh.ID))
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", poh.TenantID))
	builder.WriteString(", ")
	builder.WriteString("position_id=")
	builder.WriteString(fmt.Sprintf("%v", poh.PositionID))
	builder.WriteString(", ")
	builder.WriteString("employee_id=")
	builder.WriteString(fmt.Sprintf("%v", poh.EmployeeID))
	builder.WriteString(", ")
	builder.WriteString("start_date=")
	builder.WriteString(poh.StartDate.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := poh.EndDate; v != nil {
		builder.WriteString("end_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("is_active=")
	builder.WriteString(fmt.Sprintf("%v", poh.IsActive))
	builder.WriteString(", ")
	builder.WriteString("assignment_type=")
	builder.WriteString(fmt.Sprintf("%v", poh.AssignmentType))
	builder.WriteString(", ")
	builder.WriteString("assignment_reason=")
	builder.WriteString(poh.AssignmentReason)
	builder.WriteString(", ")
	builder.WriteString("fte_percentage=")
	builder.WriteString(fmt.Sprintf("%v", poh.FtePercentage))
	builder.WriteString(", ")
	builder.WriteString("work_arrangement=")
	builder.WriteString(fmt.Sprintf("%v", poh.WorkArrangement))
	builder.WriteString(", ")
	if v := poh.ApprovedBy; v != nil {
		builder.WriteString("approved_by=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := poh.ApprovalDate; v != nil {
		builder.WriteString("approval_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("approval_reference=")
	builder.WriteString(poh.ApprovalReference)
	builder.WriteString(", ")
	builder.WriteString("compensation_data=")
	builder.WriteString(fmt.Sprintf("%v", poh.CompensationData))
	builder.WriteString(", ")
	builder.WriteString("performance_review_cycle=")
	builder.WriteString(poh.PerformanceReviewCycle)
	builder.WriteString(", ")
	if v := poh.SourceEventID; v != nil {
		builder.WriteString("source_event_id=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(poh.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(poh.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// PositionOccupancyHistories is a parsable slice of PositionOccupancyHistory.
type PositionOccupancyHistories []*PositionOccupancyHistory
