// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/gaogu/cube-castle/go-app/ent/assignmentdetails"
	"github.com/gaogu/cube-castle/go-app/ent/assignmenthistory"
	"github.com/gaogu/cube-castle/go-app/ent/employee"
	"github.com/gaogu/cube-castle/go-app/ent/organizationunit"
	"github.com/gaogu/cube-castle/go-app/ent/position"
	"github.com/gaogu/cube-castle/go-app/ent/positionassignment"
	"github.com/gaogu/cube-castle/go-app/ent/positionattributehistory"
	"github.com/gaogu/cube-castle/go-app/ent/positionhistory"
	"github.com/gaogu/cube-castle/go-app/ent/positionoccupancyhistory"
	"github.com/gaogu/cube-castle/go-app/ent/predicate"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAssignmentDetails        = "AssignmentDetails"
	TypeAssignmentHistory        = "AssignmentHistory"
	TypeEmployee                 = "Employee"
	TypeOrganizationUnit         = "OrganizationUnit"
	TypePosition                 = "Position"
	TypePositionAssignment       = "PositionAssignment"
	TypePositionAttributeHistory = "PositionAttributeHistory"
	TypePositionHistory          = "PositionHistory"
	TypePositionOccupancyHistory = "PositionOccupancyHistory"
)

// AssignmentDetailsMutation represents an operation that mutates the AssignmentDetails nodes in the graph.
type AssignmentDetailsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	tenant_id            *uuid.UUID
	pay_grade_id         *uuid.UUID
	compensation_plan_id *uuid.UUID
	work_location        *string
	work_arrangement     *assignmentdetails.WorkArrangement
	assignment_reason    *assignmentdetails.AssignmentReason
	change_reason        *string
	notes                *string
	approved_by          *uuid.UUID
	approved_at          *time.Time
	approval_status      *assignmentdetails.ApprovalStatus
	custom_fields        *map[string]interface{}
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	assignment           *uuid.UUID
	clearedassignment    bool
	done                 bool
	oldValue             func(context.Context) (*AssignmentDetails, error)
	predicates           []predicate.AssignmentDetails
}

var _ ent.Mutation = (*AssignmentDetailsMutation)(nil)

// assignmentdetailsOption allows management of the mutation configuration using functional options.
type assignmentdetailsOption func(*AssignmentDetailsMutation)

// newAssignmentDetailsMutation creates new mutation for the AssignmentDetails entity.
func newAssignmentDetailsMutation(c config, op Op, opts ...assignmentdetailsOption) *AssignmentDetailsMutation {
	m := &AssignmentDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignmentDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentDetailsID sets the ID field of the mutation.
func withAssignmentDetailsID(id uuid.UUID) assignmentdetailsOption {
	return func(m *AssignmentDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *AssignmentDetails
		)
		m.oldValue = func(ctx context.Context) (*AssignmentDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssignmentDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignmentDetails sets the old AssignmentDetails of the mutation.
func withAssignmentDetails(node *AssignmentDetails) assignmentdetailsOption {
	return func(m *AssignmentDetailsMutation) {
		m.oldValue = func(context.Context) (*AssignmentDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssignmentDetails entities.
func (m *AssignmentDetailsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentDetailsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssignmentDetailsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssignmentDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssignmentID sets the "assignment_id" field.
func (m *AssignmentDetailsMutation) SetAssignmentID(u uuid.UUID) {
	m.assignment = &u
}

// AssignmentID returns the value of the "assignment_id" field in the mutation.
func (m *AssignmentDetailsMutation) AssignmentID() (r uuid.UUID, exists bool) {
	v := m.assignment
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentID returns the old "assignment_id" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldAssignmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentID: %w", err)
	}
	return oldValue.AssignmentID, nil
}

// ResetAssignmentID resets all changes to the "assignment_id" field.
func (m *AssignmentDetailsMutation) ResetAssignmentID() {
	m.assignment = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *AssignmentDetailsMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AssignmentDetailsMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AssignmentDetailsMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetPayGradeID sets the "pay_grade_id" field.
func (m *AssignmentDetailsMutation) SetPayGradeID(u uuid.UUID) {
	m.pay_grade_id = &u
}

// PayGradeID returns the value of the "pay_grade_id" field in the mutation.
func (m *AssignmentDetailsMutation) PayGradeID() (r uuid.UUID, exists bool) {
	v := m.pay_grade_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPayGradeID returns the old "pay_grade_id" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldPayGradeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayGradeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayGradeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayGradeID: %w", err)
	}
	return oldValue.PayGradeID, nil
}

// ClearPayGradeID clears the value of the "pay_grade_id" field.
func (m *AssignmentDetailsMutation) ClearPayGradeID() {
	m.pay_grade_id = nil
	m.clearedFields[assignmentdetails.FieldPayGradeID] = struct{}{}
}

// PayGradeIDCleared returns if the "pay_grade_id" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) PayGradeIDCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldPayGradeID]
	return ok
}

// ResetPayGradeID resets all changes to the "pay_grade_id" field.
func (m *AssignmentDetailsMutation) ResetPayGradeID() {
	m.pay_grade_id = nil
	delete(m.clearedFields, assignmentdetails.FieldPayGradeID)
}

// SetCompensationPlanID sets the "compensation_plan_id" field.
func (m *AssignmentDetailsMutation) SetCompensationPlanID(u uuid.UUID) {
	m.compensation_plan_id = &u
}

// CompensationPlanID returns the value of the "compensation_plan_id" field in the mutation.
func (m *AssignmentDetailsMutation) CompensationPlanID() (r uuid.UUID, exists bool) {
	v := m.compensation_plan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompensationPlanID returns the old "compensation_plan_id" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldCompensationPlanID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompensationPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompensationPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompensationPlanID: %w", err)
	}
	return oldValue.CompensationPlanID, nil
}

// ClearCompensationPlanID clears the value of the "compensation_plan_id" field.
func (m *AssignmentDetailsMutation) ClearCompensationPlanID() {
	m.compensation_plan_id = nil
	m.clearedFields[assignmentdetails.FieldCompensationPlanID] = struct{}{}
}

// CompensationPlanIDCleared returns if the "compensation_plan_id" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) CompensationPlanIDCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldCompensationPlanID]
	return ok
}

// ResetCompensationPlanID resets all changes to the "compensation_plan_id" field.
func (m *AssignmentDetailsMutation) ResetCompensationPlanID() {
	m.compensation_plan_id = nil
	delete(m.clearedFields, assignmentdetails.FieldCompensationPlanID)
}

// SetWorkLocation sets the "work_location" field.
func (m *AssignmentDetailsMutation) SetWorkLocation(s string) {
	m.work_location = &s
}

// WorkLocation returns the value of the "work_location" field in the mutation.
func (m *AssignmentDetailsMutation) WorkLocation() (r string, exists bool) {
	v := m.work_location
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkLocation returns the old "work_location" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldWorkLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkLocation: %w", err)
	}
	return oldValue.WorkLocation, nil
}

// ClearWorkLocation clears the value of the "work_location" field.
func (m *AssignmentDetailsMutation) ClearWorkLocation() {
	m.work_location = nil
	m.clearedFields[assignmentdetails.FieldWorkLocation] = struct{}{}
}

// WorkLocationCleared returns if the "work_location" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) WorkLocationCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldWorkLocation]
	return ok
}

// ResetWorkLocation resets all changes to the "work_location" field.
func (m *AssignmentDetailsMutation) ResetWorkLocation() {
	m.work_location = nil
	delete(m.clearedFields, assignmentdetails.FieldWorkLocation)
}

// SetWorkArrangement sets the "work_arrangement" field.
func (m *AssignmentDetailsMutation) SetWorkArrangement(aa assignmentdetails.WorkArrangement) {
	m.work_arrangement = &aa
}

// WorkArrangement returns the value of the "work_arrangement" field in the mutation.
func (m *AssignmentDetailsMutation) WorkArrangement() (r assignmentdetails.WorkArrangement, exists bool) {
	v := m.work_arrangement
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkArrangement returns the old "work_arrangement" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldWorkArrangement(ctx context.Context) (v assignmentdetails.WorkArrangement, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkArrangement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkArrangement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkArrangement: %w", err)
	}
	return oldValue.WorkArrangement, nil
}

// ClearWorkArrangement clears the value of the "work_arrangement" field.
func (m *AssignmentDetailsMutation) ClearWorkArrangement() {
	m.work_arrangement = nil
	m.clearedFields[assignmentdetails.FieldWorkArrangement] = struct{}{}
}

// WorkArrangementCleared returns if the "work_arrangement" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) WorkArrangementCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldWorkArrangement]
	return ok
}

// ResetWorkArrangement resets all changes to the "work_arrangement" field.
func (m *AssignmentDetailsMutation) ResetWorkArrangement() {
	m.work_arrangement = nil
	delete(m.clearedFields, assignmentdetails.FieldWorkArrangement)
}

// SetAssignmentReason sets the "assignment_reason" field.
func (m *AssignmentDetailsMutation) SetAssignmentReason(ar assignmentdetails.AssignmentReason) {
	m.assignment_reason = &ar
}

// AssignmentReason returns the value of the "assignment_reason" field in the mutation.
func (m *AssignmentDetailsMutation) AssignmentReason() (r assignmentdetails.AssignmentReason, exists bool) {
	v := m.assignment_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentReason returns the old "assignment_reason" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldAssignmentReason(ctx context.Context) (v assignmentdetails.AssignmentReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentReason: %w", err)
	}
	return oldValue.AssignmentReason, nil
}

// ClearAssignmentReason clears the value of the "assignment_reason" field.
func (m *AssignmentDetailsMutation) ClearAssignmentReason() {
	m.assignment_reason = nil
	m.clearedFields[assignmentdetails.FieldAssignmentReason] = struct{}{}
}

// AssignmentReasonCleared returns if the "assignment_reason" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) AssignmentReasonCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldAssignmentReason]
	return ok
}

// ResetAssignmentReason resets all changes to the "assignment_reason" field.
func (m *AssignmentDetailsMutation) ResetAssignmentReason() {
	m.assignment_reason = nil
	delete(m.clearedFields, assignmentdetails.FieldAssignmentReason)
}

// SetChangeReason sets the "change_reason" field.
func (m *AssignmentDetailsMutation) SetChangeReason(s string) {
	m.change_reason = &s
}

// ChangeReason returns the value of the "change_reason" field in the mutation.
func (m *AssignmentDetailsMutation) ChangeReason() (r string, exists bool) {
	v := m.change_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeReason returns the old "change_reason" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldChangeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeReason: %w", err)
	}
	return oldValue.ChangeReason, nil
}

// ClearChangeReason clears the value of the "change_reason" field.
func (m *AssignmentDetailsMutation) ClearChangeReason() {
	m.change_reason = nil
	m.clearedFields[assignmentdetails.FieldChangeReason] = struct{}{}
}

// ChangeReasonCleared returns if the "change_reason" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) ChangeReasonCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldChangeReason]
	return ok
}

// ResetChangeReason resets all changes to the "change_reason" field.
func (m *AssignmentDetailsMutation) ResetChangeReason() {
	m.change_reason = nil
	delete(m.clearedFields, assignmentdetails.FieldChangeReason)
}

// SetNotes sets the "notes" field.
func (m *AssignmentDetailsMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *AssignmentDetailsMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *AssignmentDetailsMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[assignmentdetails.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) NotesCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *AssignmentDetailsMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, assignmentdetails.FieldNotes)
}

// SetApprovedBy sets the "approved_by" field.
func (m *AssignmentDetailsMutation) SetApprovedBy(u uuid.UUID) {
	m.approved_by = &u
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *AssignmentDetailsMutation) ApprovedBy() (r uuid.UUID, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldApprovedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *AssignmentDetailsMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[assignmentdetails.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *AssignmentDetailsMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, assignmentdetails.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *AssignmentDetailsMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *AssignmentDetailsMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *AssignmentDetailsMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[assignmentdetails.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *AssignmentDetailsMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, assignmentdetails.FieldApprovedAt)
}

// SetApprovalStatus sets the "approval_status" field.
func (m *AssignmentDetailsMutation) SetApprovalStatus(as assignmentdetails.ApprovalStatus) {
	m.approval_status = &as
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *AssignmentDetailsMutation) ApprovalStatus() (r assignmentdetails.ApprovalStatus, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldApprovalStatus(ctx context.Context) (v assignmentdetails.ApprovalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *AssignmentDetailsMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetCustomFields sets the "custom_fields" field.
func (m *AssignmentDetailsMutation) SetCustomFields(value map[string]interface{}) {
	m.custom_fields = &value
}

// CustomFields returns the value of the "custom_fields" field in the mutation.
func (m *AssignmentDetailsMutation) CustomFields() (r map[string]interface{}, exists bool) {
	v := m.custom_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomFields returns the old "custom_fields" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldCustomFields(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomFields: %w", err)
	}
	return oldValue.CustomFields, nil
}

// ClearCustomFields clears the value of the "custom_fields" field.
func (m *AssignmentDetailsMutation) ClearCustomFields() {
	m.custom_fields = nil
	m.clearedFields[assignmentdetails.FieldCustomFields] = struct{}{}
}

// CustomFieldsCleared returns if the "custom_fields" field was cleared in this mutation.
func (m *AssignmentDetailsMutation) CustomFieldsCleared() bool {
	_, ok := m.clearedFields[assignmentdetails.FieldCustomFields]
	return ok
}

// ResetCustomFields resets all changes to the "custom_fields" field.
func (m *AssignmentDetailsMutation) ResetCustomFields() {
	m.custom_fields = nil
	delete(m.clearedFields, assignmentdetails.FieldCustomFields)
}

// SetCreatedAt sets the "created_at" field.
func (m *AssignmentDetailsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssignmentDetailsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssignmentDetailsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssignmentDetailsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssignmentDetailsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssignmentDetails entity.
// If the AssignmentDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentDetailsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssignmentDetailsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearAssignment clears the "assignment" edge to the PositionAssignment entity.
func (m *AssignmentDetailsMutation) ClearAssignment() {
	m.clearedassignment = true
	m.clearedFields[assignmentdetails.FieldAssignmentID] = struct{}{}
}

// AssignmentCleared reports if the "assignment" edge to the PositionAssignment entity was cleared.
func (m *AssignmentDetailsMutation) AssignmentCleared() bool {
	return m.clearedassignment
}

// AssignmentIDs returns the "assignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignmentID instead. It exists only for internal usage by the builders.
func (m *AssignmentDetailsMutation) AssignmentIDs() (ids []uuid.UUID) {
	if id := m.assignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignment resets all changes to the "assignment" edge.
func (m *AssignmentDetailsMutation) ResetAssignment() {
	m.assignment = nil
	m.clearedassignment = false
}

// Where appends a list predicates to the AssignmentDetailsMutation builder.
func (m *AssignmentDetailsMutation) Where(ps ...predicate.AssignmentDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssignmentDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssignmentDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssignmentDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssignmentDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssignmentDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssignmentDetails).
func (m *AssignmentDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentDetailsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.assignment != nil {
		fields = append(fields, assignmentdetails.FieldAssignmentID)
	}
	if m.tenant_id != nil {
		fields = append(fields, assignmentdetails.FieldTenantID)
	}
	if m.pay_grade_id != nil {
		fields = append(fields, assignmentdetails.FieldPayGradeID)
	}
	if m.compensation_plan_id != nil {
		fields = append(fields, assignmentdetails.FieldCompensationPlanID)
	}
	if m.work_location != nil {
		fields = append(fields, assignmentdetails.FieldWorkLocation)
	}
	if m.work_arrangement != nil {
		fields = append(fields, assignmentdetails.FieldWorkArrangement)
	}
	if m.assignment_reason != nil {
		fields = append(fields, assignmentdetails.FieldAssignmentReason)
	}
	if m.change_reason != nil {
		fields = append(fields, assignmentdetails.FieldChangeReason)
	}
	if m.notes != nil {
		fields = append(fields, assignmentdetails.FieldNotes)
	}
	if m.approved_by != nil {
		fields = append(fields, assignmentdetails.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, assignmentdetails.FieldApprovedAt)
	}
	if m.approval_status != nil {
		fields = append(fields, assignmentdetails.FieldApprovalStatus)
	}
	if m.custom_fields != nil {
		fields = append(fields, assignmentdetails.FieldCustomFields)
	}
	if m.created_at != nil {
		fields = append(fields, assignmentdetails.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assignmentdetails.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignmentdetails.FieldAssignmentID:
		return m.AssignmentID()
	case assignmentdetails.FieldTenantID:
		return m.TenantID()
	case assignmentdetails.FieldPayGradeID:
		return m.PayGradeID()
	case assignmentdetails.FieldCompensationPlanID:
		return m.CompensationPlanID()
	case assignmentdetails.FieldWorkLocation:
		return m.WorkLocation()
	case assignmentdetails.FieldWorkArrangement:
		return m.WorkArrangement()
	case assignmentdetails.FieldAssignmentReason:
		return m.AssignmentReason()
	case assignmentdetails.FieldChangeReason:
		return m.ChangeReason()
	case assignmentdetails.FieldNotes:
		return m.Notes()
	case assignmentdetails.FieldApprovedBy:
		return m.ApprovedBy()
	case assignmentdetails.FieldApprovedAt:
		return m.ApprovedAt()
	case assignmentdetails.FieldApprovalStatus:
		return m.ApprovalStatus()
	case assignmentdetails.FieldCustomFields:
		return m.CustomFields()
	case assignmentdetails.FieldCreatedAt:
		return m.CreatedAt()
	case assignmentdetails.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignmentdetails.FieldAssignmentID:
		return m.OldAssignmentID(ctx)
	case assignmentdetails.FieldTenantID:
		return m.OldTenantID(ctx)
	case assignmentdetails.FieldPayGradeID:
		return m.OldPayGradeID(ctx)
	case assignmentdetails.FieldCompensationPlanID:
		return m.OldCompensationPlanID(ctx)
	case assignmentdetails.FieldWorkLocation:
		return m.OldWorkLocation(ctx)
	case assignmentdetails.FieldWorkArrangement:
		return m.OldWorkArrangement(ctx)
	case assignmentdetails.FieldAssignmentReason:
		return m.OldAssignmentReason(ctx)
	case assignmentdetails.FieldChangeReason:
		return m.OldChangeReason(ctx)
	case assignmentdetails.FieldNotes:
		return m.OldNotes(ctx)
	case assignmentdetails.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case assignmentdetails.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case assignmentdetails.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case assignmentdetails.FieldCustomFields:
		return m.OldCustomFields(ctx)
	case assignmentdetails.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assignmentdetails.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AssignmentDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignmentdetails.FieldAssignmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentID(v)
		return nil
	case assignmentdetails.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case assignmentdetails.FieldPayGradeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayGradeID(v)
		return nil
	case assignmentdetails.FieldCompensationPlanID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompensationPlanID(v)
		return nil
	case assignmentdetails.FieldWorkLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkLocation(v)
		return nil
	case assignmentdetails.FieldWorkArrangement:
		v, ok := value.(assignmentdetails.WorkArrangement)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkArrangement(v)
		return nil
	case assignmentdetails.FieldAssignmentReason:
		v, ok := value.(assignmentdetails.AssignmentReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentReason(v)
		return nil
	case assignmentdetails.FieldChangeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeReason(v)
		return nil
	case assignmentdetails.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case assignmentdetails.FieldApprovedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case assignmentdetails.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case assignmentdetails.FieldApprovalStatus:
		v, ok := value.(assignmentdetails.ApprovalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case assignmentdetails.FieldCustomFields:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomFields(v)
		return nil
	case assignmentdetails.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assignmentdetails.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AssignmentDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentDetailsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentDetailsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssignmentDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assignmentdetails.FieldPayGradeID) {
		fields = append(fields, assignmentdetails.FieldPayGradeID)
	}
	if m.FieldCleared(assignmentdetails.FieldCompensationPlanID) {
		fields = append(fields, assignmentdetails.FieldCompensationPlanID)
	}
	if m.FieldCleared(assignmentdetails.FieldWorkLocation) {
		fields = append(fields, assignmentdetails.FieldWorkLocation)
	}
	if m.FieldCleared(assignmentdetails.FieldWorkArrangement) {
		fields = append(fields, assignmentdetails.FieldWorkArrangement)
	}
	if m.FieldCleared(assignmentdetails.FieldAssignmentReason) {
		fields = append(fields, assignmentdetails.FieldAssignmentReason)
	}
	if m.FieldCleared(assignmentdetails.FieldChangeReason) {
		fields = append(fields, assignmentdetails.FieldChangeReason)
	}
	if m.FieldCleared(assignmentdetails.FieldNotes) {
		fields = append(fields, assignmentdetails.FieldNotes)
	}
	if m.FieldCleared(assignmentdetails.FieldApprovedBy) {
		fields = append(fields, assignmentdetails.FieldApprovedBy)
	}
	if m.FieldCleared(assignmentdetails.FieldApprovedAt) {
		fields = append(fields, assignmentdetails.FieldApprovedAt)
	}
	if m.FieldCleared(assignmentdetails.FieldCustomFields) {
		fields = append(fields, assignmentdetails.FieldCustomFields)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentDetailsMutation) ClearField(name string) error {
	switch name {
	case assignmentdetails.FieldPayGradeID:
		m.ClearPayGradeID()
		return nil
	case assignmentdetails.FieldCompensationPlanID:
		m.ClearCompensationPlanID()
		return nil
	case assignmentdetails.FieldWorkLocation:
		m.ClearWorkLocation()
		return nil
	case assignmentdetails.FieldWorkArrangement:
		m.ClearWorkArrangement()
		return nil
	case assignmentdetails.FieldAssignmentReason:
		m.ClearAssignmentReason()
		return nil
	case assignmentdetails.FieldChangeReason:
		m.ClearChangeReason()
		return nil
	case assignmentdetails.FieldNotes:
		m.ClearNotes()
		return nil
	case assignmentdetails.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case assignmentdetails.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case assignmentdetails.FieldCustomFields:
		m.ClearCustomFields()
		return nil
	}
	return fmt.Errorf("unknown AssignmentDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentDetailsMutation) ResetField(name string) error {
	switch name {
	case assignmentdetails.FieldAssignmentID:
		m.ResetAssignmentID()
		return nil
	case assignmentdetails.FieldTenantID:
		m.ResetTenantID()
		return nil
	case assignmentdetails.FieldPayGradeID:
		m.ResetPayGradeID()
		return nil
	case assignmentdetails.FieldCompensationPlanID:
		m.ResetCompensationPlanID()
		return nil
	case assignmentdetails.FieldWorkLocation:
		m.ResetWorkLocation()
		return nil
	case assignmentdetails.FieldWorkArrangement:
		m.ResetWorkArrangement()
		return nil
	case assignmentdetails.FieldAssignmentReason:
		m.ResetAssignmentReason()
		return nil
	case assignmentdetails.FieldChangeReason:
		m.ResetChangeReason()
		return nil
	case assignmentdetails.FieldNotes:
		m.ResetNotes()
		return nil
	case assignmentdetails.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case assignmentdetails.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case assignmentdetails.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case assignmentdetails.FieldCustomFields:
		m.ResetCustomFields()
		return nil
	case assignmentdetails.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assignmentdetails.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AssignmentDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assignment != nil {
		edges = append(edges, assignmentdetails.EdgeAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assignmentdetails.EdgeAssignment:
		if id := m.assignment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassignment {
		edges = append(edges, assignmentdetails.EdgeAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case assignmentdetails.EdgeAssignment:
		return m.clearedassignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentDetailsMutation) ClearEdge(name string) error {
	switch name {
	case assignmentdetails.EdgeAssignment:
		m.ClearAssignment()
		return nil
	}
	return fmt.Errorf("unknown AssignmentDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentDetailsMutation) ResetEdge(name string) error {
	switch name {
	case assignmentdetails.EdgeAssignment:
		m.ResetAssignment()
		return nil
	}
	return fmt.Errorf("unknown AssignmentDetails edge %s", name)
}

// AssignmentHistoryMutation represents an operation that mutates the AssignmentHistory nodes in the graph.
type AssignmentHistoryMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	tenant_id         *uuid.UUID
	event_type        *assignmenthistory.EventType
	event_date        *time.Time
	previous_values   *map[string]interface{}
	new_values        *map[string]interface{}
	reason            *string
	changed_by        *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	assignment        *uuid.UUID
	clearedassignment bool
	done              bool
	oldValue          func(context.Context) (*AssignmentHistory, error)
	predicates        []predicate.AssignmentHistory
}

var _ ent.Mutation = (*AssignmentHistoryMutation)(nil)

// assignmenthistoryOption allows management of the mutation configuration using functional options.
type assignmenthistoryOption func(*AssignmentHistoryMutation)

// newAssignmentHistoryMutation creates new mutation for the AssignmentHistory entity.
func newAssignmentHistoryMutation(c config, op Op, opts ...assignmenthistoryOption) *AssignmentHistoryMutation {
	m := &AssignmentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignmentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentHistoryID sets the ID field of the mutation.
func withAssignmentHistoryID(id uuid.UUID) assignmenthistoryOption {
	return func(m *AssignmentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AssignmentHistory
		)
		m.oldValue = func(ctx context.Context) (*AssignmentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssignmentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignmentHistory sets the old AssignmentHistory of the mutation.
func withAssignmentHistory(node *AssignmentHistory) assignmenthistoryOption {
	return func(m *AssignmentHistoryMutation) {
		m.oldValue = func(context.Context) (*AssignmentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssignmentHistory entities.
func (m *AssignmentHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssignmentHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssignmentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssignmentID sets the "assignment_id" field.
func (m *AssignmentHistoryMutation) SetAssignmentID(u uuid.UUID) {
	m.assignment = &u
}

// AssignmentID returns the value of the "assignment_id" field in the mutation.
func (m *AssignmentHistoryMutation) AssignmentID() (r uuid.UUID, exists bool) {
	v := m.assignment
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentID returns the old "assignment_id" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldAssignmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentID: %w", err)
	}
	return oldValue.AssignmentID, nil
}

// ResetAssignmentID resets all changes to the "assignment_id" field.
func (m *AssignmentHistoryMutation) ResetAssignmentID() {
	m.assignment = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *AssignmentHistoryMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AssignmentHistoryMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AssignmentHistoryMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetEventType sets the "event_type" field.
func (m *AssignmentHistoryMutation) SetEventType(at assignmenthistory.EventType) {
	m.event_type = &at
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AssignmentHistoryMutation) EventType() (r assignmenthistory.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldEventType(ctx context.Context) (v assignmenthistory.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AssignmentHistoryMutation) ResetEventType() {
	m.event_type = nil
}

// SetEventDate sets the "event_date" field.
func (m *AssignmentHistoryMutation) SetEventDate(t time.Time) {
	m.event_date = &t
}

// EventDate returns the value of the "event_date" field in the mutation.
func (m *AssignmentHistoryMutation) EventDate() (r time.Time, exists bool) {
	v := m.event_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEventDate returns the old "event_date" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldEventDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventDate: %w", err)
	}
	return oldValue.EventDate, nil
}

// ResetEventDate resets all changes to the "event_date" field.
func (m *AssignmentHistoryMutation) ResetEventDate() {
	m.event_date = nil
}

// SetPreviousValues sets the "previous_values" field.
func (m *AssignmentHistoryMutation) SetPreviousValues(value map[string]interface{}) {
	m.previous_values = &value
}

// PreviousValues returns the value of the "previous_values" field in the mutation.
func (m *AssignmentHistoryMutation) PreviousValues() (r map[string]interface{}, exists bool) {
	v := m.previous_values
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousValues returns the old "previous_values" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldPreviousValues(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousValues: %w", err)
	}
	return oldValue.PreviousValues, nil
}

// ClearPreviousValues clears the value of the "previous_values" field.
func (m *AssignmentHistoryMutation) ClearPreviousValues() {
	m.previous_values = nil
	m.clearedFields[assignmenthistory.FieldPreviousValues] = struct{}{}
}

// PreviousValuesCleared returns if the "previous_values" field was cleared in this mutation.
func (m *AssignmentHistoryMutation) PreviousValuesCleared() bool {
	_, ok := m.clearedFields[assignmenthistory.FieldPreviousValues]
	return ok
}

// ResetPreviousValues resets all changes to the "previous_values" field.
func (m *AssignmentHistoryMutation) ResetPreviousValues() {
	m.previous_values = nil
	delete(m.clearedFields, assignmenthistory.FieldPreviousValues)
}

// SetNewValues sets the "new_values" field.
func (m *AssignmentHistoryMutation) SetNewValues(value map[string]interface{}) {
	m.new_values = &value
}

// NewValues returns the value of the "new_values" field in the mutation.
func (m *AssignmentHistoryMutation) NewValues() (r map[string]interface{}, exists bool) {
	v := m.new_values
	if v == nil {
		return
	}
	return *v, true
}

// OldNewValues returns the old "new_values" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldNewValues(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewValues: %w", err)
	}
	return oldValue.NewValues, nil
}

// ClearNewValues clears the value of the "new_values" field.
func (m *AssignmentHistoryMutation) ClearNewValues() {
	m.new_values = nil
	m.clearedFields[assignmenthistory.FieldNewValues] = struct{}{}
}

// NewValuesCleared returns if the "new_values" field was cleared in this mutation.
func (m *AssignmentHistoryMutation) NewValuesCleared() bool {
	_, ok := m.clearedFields[assignmenthistory.FieldNewValues]
	return ok
}

// ResetNewValues resets all changes to the "new_values" field.
func (m *AssignmentHistoryMutation) ResetNewValues() {
	m.new_values = nil
	delete(m.clearedFields, assignmenthistory.FieldNewValues)
}

// SetReason sets the "reason" field.
func (m *AssignmentHistoryMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *AssignmentHistoryMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *AssignmentHistoryMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[assignmenthistory.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *AssignmentHistoryMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[assignmenthistory.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *AssignmentHistoryMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, assignmenthistory.FieldReason)
}

// SetChangedBy sets the "changed_by" field.
func (m *AssignmentHistoryMutation) SetChangedBy(u uuid.UUID) {
	m.changed_by = &u
}

// ChangedBy returns the value of the "changed_by" field in the mutation.
func (m *AssignmentHistoryMutation) ChangedBy() (r uuid.UUID, exists bool) {
	v := m.changed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldChangedBy returns the old "changed_by" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldChangedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangedBy: %w", err)
	}
	return oldValue.ChangedBy, nil
}

// ClearChangedBy clears the value of the "changed_by" field.
func (m *AssignmentHistoryMutation) ClearChangedBy() {
	m.changed_by = nil
	m.clearedFields[assignmenthistory.FieldChangedBy] = struct{}{}
}

// ChangedByCleared returns if the "changed_by" field was cleared in this mutation.
func (m *AssignmentHistoryMutation) ChangedByCleared() bool {
	_, ok := m.clearedFields[assignmenthistory.FieldChangedBy]
	return ok
}

// ResetChangedBy resets all changes to the "changed_by" field.
func (m *AssignmentHistoryMutation) ResetChangedBy() {
	m.changed_by = nil
	delete(m.clearedFields, assignmenthistory.FieldChangedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *AssignmentHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssignmentHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssignmentHistory entity.
// If the AssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssignmentHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAssignment clears the "assignment" edge to the PositionAssignment entity.
func (m *AssignmentHistoryMutation) ClearAssignment() {
	m.clearedassignment = true
	m.clearedFields[assignmenthistory.FieldAssignmentID] = struct{}{}
}

// AssignmentCleared reports if the "assignment" edge to the PositionAssignment entity was cleared.
func (m *AssignmentHistoryMutation) AssignmentCleared() bool {
	return m.clearedassignment
}

// AssignmentIDs returns the "assignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignmentID instead. It exists only for internal usage by the builders.
func (m *AssignmentHistoryMutation) AssignmentIDs() (ids []uuid.UUID) {
	if id := m.assignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignment resets all changes to the "assignment" edge.
func (m *AssignmentHistoryMutation) ResetAssignment() {
	m.assignment = nil
	m.clearedassignment = false
}

// Where appends a list predicates to the AssignmentHistoryMutation builder.
func (m *AssignmentHistoryMutation) Where(ps ...predicate.AssignmentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssignmentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssignmentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssignmentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssignmentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssignmentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssignmentHistory).
func (m *AssignmentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.assignment != nil {
		fields = append(fields, assignmenthistory.FieldAssignmentID)
	}
	if m.tenant_id != nil {
		fields = append(fields, assignmenthistory.FieldTenantID)
	}
	if m.event_type != nil {
		fields = append(fields, assignmenthistory.FieldEventType)
	}
	if m.event_date != nil {
		fields = append(fields, assignmenthistory.FieldEventDate)
	}
	if m.previous_values != nil {
		fields = append(fields, assignmenthistory.FieldPreviousValues)
	}
	if m.new_values != nil {
		fields = append(fields, assignmenthistory.FieldNewValues)
	}
	if m.reason != nil {
		fields = append(fields, assignmenthistory.FieldReason)
	}
	if m.changed_by != nil {
		fields = append(fields, assignmenthistory.FieldChangedBy)
	}
	if m.created_at != nil {
		fields = append(fields, assignmenthistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignmenthistory.FieldAssignmentID:
		return m.AssignmentID()
	case assignmenthistory.FieldTenantID:
		return m.TenantID()
	case assignmenthistory.FieldEventType:
		return m.EventType()
	case assignmenthistory.FieldEventDate:
		return m.EventDate()
	case assignmenthistory.FieldPreviousValues:
		return m.PreviousValues()
	case assignmenthistory.FieldNewValues:
		return m.NewValues()
	case assignmenthistory.FieldReason:
		return m.Reason()
	case assignmenthistory.FieldChangedBy:
		return m.ChangedBy()
	case assignmenthistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignmenthistory.FieldAssignmentID:
		return m.OldAssignmentID(ctx)
	case assignmenthistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case assignmenthistory.FieldEventType:
		return m.OldEventType(ctx)
	case assignmenthistory.FieldEventDate:
		return m.OldEventDate(ctx)
	case assignmenthistory.FieldPreviousValues:
		return m.OldPreviousValues(ctx)
	case assignmenthistory.FieldNewValues:
		return m.OldNewValues(ctx)
	case assignmenthistory.FieldReason:
		return m.OldReason(ctx)
	case assignmenthistory.FieldChangedBy:
		return m.OldChangedBy(ctx)
	case assignmenthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AssignmentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignmenthistory.FieldAssignmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentID(v)
		return nil
	case assignmenthistory.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case assignmenthistory.FieldEventType:
		v, ok := value.(assignmenthistory.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case assignmenthistory.FieldEventDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventDate(v)
		return nil
	case assignmenthistory.FieldPreviousValues:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousValues(v)
		return nil
	case assignmenthistory.FieldNewValues:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewValues(v)
		return nil
	case assignmenthistory.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case assignmenthistory.FieldChangedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangedBy(v)
		return nil
	case assignmenthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AssignmentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssignmentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assignmenthistory.FieldPreviousValues) {
		fields = append(fields, assignmenthistory.FieldPreviousValues)
	}
	if m.FieldCleared(assignmenthistory.FieldNewValues) {
		fields = append(fields, assignmenthistory.FieldNewValues)
	}
	if m.FieldCleared(assignmenthistory.FieldReason) {
		fields = append(fields, assignmenthistory.FieldReason)
	}
	if m.FieldCleared(assignmenthistory.FieldChangedBy) {
		fields = append(fields, assignmenthistory.FieldChangedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentHistoryMutation) ClearField(name string) error {
	switch name {
	case assignmenthistory.FieldPreviousValues:
		m.ClearPreviousValues()
		return nil
	case assignmenthistory.FieldNewValues:
		m.ClearNewValues()
		return nil
	case assignmenthistory.FieldReason:
		m.ClearReason()
		return nil
	case assignmenthistory.FieldChangedBy:
		m.ClearChangedBy()
		return nil
	}
	return fmt.Errorf("unknown AssignmentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentHistoryMutation) ResetField(name string) error {
	switch name {
	case assignmenthistory.FieldAssignmentID:
		m.ResetAssignmentID()
		return nil
	case assignmenthistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case assignmenthistory.FieldEventType:
		m.ResetEventType()
		return nil
	case assignmenthistory.FieldEventDate:
		m.ResetEventDate()
		return nil
	case assignmenthistory.FieldPreviousValues:
		m.ResetPreviousValues()
		return nil
	case assignmenthistory.FieldNewValues:
		m.ResetNewValues()
		return nil
	case assignmenthistory.FieldReason:
		m.ResetReason()
		return nil
	case assignmenthistory.FieldChangedBy:
		m.ResetChangedBy()
		return nil
	case assignmenthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AssignmentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assignment != nil {
		edges = append(edges, assignmenthistory.EdgeAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assignmenthistory.EdgeAssignment:
		if id := m.assignment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassignment {
		edges = append(edges, assignmenthistory.EdgeAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case assignmenthistory.EdgeAssignment:
		return m.clearedassignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentHistoryMutation) ClearEdge(name string) error {
	switch name {
	case assignmenthistory.EdgeAssignment:
		m.ClearAssignment()
		return nil
	}
	return fmt.Errorf("unknown AssignmentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentHistoryMutation) ResetEdge(name string) error {
	switch name {
	case assignmenthistory.EdgeAssignment:
		m.ResetAssignment()
		return nil
	}
	return fmt.Errorf("unknown AssignmentHistory edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	business_id             *string
	tenant_id               *uuid.UUID
	employee_type           *employee.EmployeeType
	employee_number         *string
	first_name              *string
	last_name               *string
	email                   *string
	personal_email          *string
	phone_number            *string
	employment_status       *employee.EmploymentStatus
	hire_date               *time.Time
	termination_date        *time.Time
	employee_details        *map[string]interface{}
	name                    *string
	position                *string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	current_position        *uuid.UUID
	clearedcurrent_position bool
	position_history        map[uuid.UUID]struct{}
	removedposition_history map[uuid.UUID]struct{}
	clearedposition_history bool
	assignments             map[uuid.UUID]struct{}
	removedassignments      map[uuid.UUID]struct{}
	clearedassignments      bool
	done                    bool
	oldValue                func(context.Context) (*Employee, error)
	predicates              []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id uuid.UUID) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Employee entities.
func (m *EmployeeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessID sets the "business_id" field.
func (m *EmployeeMutation) SetBusinessID(s string) {
	m.business_id = &s
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *EmployeeMutation) BusinessID() (r string, exists bool) {
	v := m.business_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldBusinessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *EmployeeMutation) ResetBusinessID() {
	m.business_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *EmployeeMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *EmployeeMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *EmployeeMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetEmployeeType sets the "employee_type" field.
func (m *EmployeeMutation) SetEmployeeType(et employee.EmployeeType) {
	m.employee_type = &et
}

// EmployeeType returns the value of the "employee_type" field in the mutation.
func (m *EmployeeMutation) EmployeeType() (r employee.EmployeeType, exists bool) {
	v := m.employee_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeType returns the old "employee_type" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeType(ctx context.Context) (v employee.EmployeeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeType: %w", err)
	}
	return oldValue.EmployeeType, nil
}

// ResetEmployeeType resets all changes to the "employee_type" field.
func (m *EmployeeMutation) ResetEmployeeType() {
	m.employee_type = nil
}

// SetEmployeeNumber sets the "employee_number" field.
func (m *EmployeeMutation) SetEmployeeNumber(s string) {
	m.employee_number = &s
}

// EmployeeNumber returns the value of the "employee_number" field in the mutation.
func (m *EmployeeMutation) EmployeeNumber() (r string, exists bool) {
	v := m.employee_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeNumber returns the old "employee_number" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeNumber: %w", err)
	}
	return oldValue.EmployeeNumber, nil
}

// ResetEmployeeNumber resets all changes to the "employee_number" field.
func (m *EmployeeMutation) ResetEmployeeNumber() {
	m.employee_number = nil
}

// SetFirstName sets the "first_name" field.
func (m *EmployeeMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *EmployeeMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *EmployeeMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *EmployeeMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *EmployeeMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *EmployeeMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
}

// SetPersonalEmail sets the "personal_email" field.
func (m *EmployeeMutation) SetPersonalEmail(s string) {
	m.personal_email = &s
}

// PersonalEmail returns the value of the "personal_email" field in the mutation.
func (m *EmployeeMutation) PersonalEmail() (r string, exists bool) {
	v := m.personal_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalEmail returns the old "personal_email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPersonalEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalEmail: %w", err)
	}
	return oldValue.PersonalEmail, nil
}

// ClearPersonalEmail clears the value of the "personal_email" field.
func (m *EmployeeMutation) ClearPersonalEmail() {
	m.personal_email = nil
	m.clearedFields[employee.FieldPersonalEmail] = struct{}{}
}

// PersonalEmailCleared returns if the "personal_email" field was cleared in this mutation.
func (m *EmployeeMutation) PersonalEmailCleared() bool {
	_, ok := m.clearedFields[employee.FieldPersonalEmail]
	return ok
}

// ResetPersonalEmail resets all changes to the "personal_email" field.
func (m *EmployeeMutation) ResetPersonalEmail() {
	m.personal_email = nil
	delete(m.clearedFields, employee.FieldPersonalEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *EmployeeMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *EmployeeMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *EmployeeMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[employee.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *EmployeeMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[employee.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *EmployeeMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, employee.FieldPhoneNumber)
}

// SetCurrentPositionID sets the "current_position_id" field.
func (m *EmployeeMutation) SetCurrentPositionID(u uuid.UUID) {
	m.current_position = &u
}

// CurrentPositionID returns the value of the "current_position_id" field in the mutation.
func (m *EmployeeMutation) CurrentPositionID() (r uuid.UUID, exists bool) {
	v := m.current_position
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPositionID returns the old "current_position_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCurrentPositionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPositionID: %w", err)
	}
	return oldValue.CurrentPositionID, nil
}

// ClearCurrentPositionID clears the value of the "current_position_id" field.
func (m *EmployeeMutation) ClearCurrentPositionID() {
	m.current_position = nil
	m.clearedFields[employee.FieldCurrentPositionID] = struct{}{}
}

// CurrentPositionIDCleared returns if the "current_position_id" field was cleared in this mutation.
func (m *EmployeeMutation) CurrentPositionIDCleared() bool {
	_, ok := m.clearedFields[employee.FieldCurrentPositionID]
	return ok
}

// ResetCurrentPositionID resets all changes to the "current_position_id" field.
func (m *EmployeeMutation) ResetCurrentPositionID() {
	m.current_position = nil
	delete(m.clearedFields, employee.FieldCurrentPositionID)
}

// SetEmploymentStatus sets the "employment_status" field.
func (m *EmployeeMutation) SetEmploymentStatus(es employee.EmploymentStatus) {
	m.employment_status = &es
}

// EmploymentStatus returns the value of the "employment_status" field in the mutation.
func (m *EmployeeMutation) EmploymentStatus() (r employee.EmploymentStatus, exists bool) {
	v := m.employment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEmploymentStatus returns the old "employment_status" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmploymentStatus(ctx context.Context) (v employee.EmploymentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmploymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmploymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmploymentStatus: %w", err)
	}
	return oldValue.EmploymentStatus, nil
}

// ResetEmploymentStatus resets all changes to the "employment_status" field.
func (m *EmployeeMutation) ResetEmploymentStatus() {
	m.employment_status = nil
}

// SetHireDate sets the "hire_date" field.
func (m *EmployeeMutation) SetHireDate(t time.Time) {
	m.hire_date = &t
}

// HireDate returns the value of the "hire_date" field in the mutation.
func (m *EmployeeMutation) HireDate() (r time.Time, exists bool) {
	v := m.hire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHireDate returns the old "hire_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldHireDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHireDate: %w", err)
	}
	return oldValue.HireDate, nil
}

// ResetHireDate resets all changes to the "hire_date" field.
func (m *EmployeeMutation) ResetHireDate() {
	m.hire_date = nil
}

// SetTerminationDate sets the "termination_date" field.
func (m *EmployeeMutation) SetTerminationDate(t time.Time) {
	m.termination_date = &t
}

// TerminationDate returns the value of the "termination_date" field in the mutation.
func (m *EmployeeMutation) TerminationDate() (r time.Time, exists bool) {
	v := m.termination_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminationDate returns the old "termination_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldTerminationDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminationDate: %w", err)
	}
	return oldValue.TerminationDate, nil
}

// ClearTerminationDate clears the value of the "termination_date" field.
func (m *EmployeeMutation) ClearTerminationDate() {
	m.termination_date = nil
	m.clearedFields[employee.FieldTerminationDate] = struct{}{}
}

// TerminationDateCleared returns if the "termination_date" field was cleared in this mutation.
func (m *EmployeeMutation) TerminationDateCleared() bool {
	_, ok := m.clearedFields[employee.FieldTerminationDate]
	return ok
}

// ResetTerminationDate resets all changes to the "termination_date" field.
func (m *EmployeeMutation) ResetTerminationDate() {
	m.termination_date = nil
	delete(m.clearedFields, employee.FieldTerminationDate)
}

// SetEmployeeDetails sets the "employee_details" field.
func (m *EmployeeMutation) SetEmployeeDetails(value map[string]interface{}) {
	m.employee_details = &value
}

// EmployeeDetails returns the value of the "employee_details" field in the mutation.
func (m *EmployeeMutation) EmployeeDetails() (r map[string]interface{}, exists bool) {
	v := m.employee_details
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDetails returns the old "employee_details" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDetails: %w", err)
	}
	return oldValue.EmployeeDetails, nil
}

// ClearEmployeeDetails clears the value of the "employee_details" field.
func (m *EmployeeMutation) ClearEmployeeDetails() {
	m.employee_details = nil
	m.clearedFields[employee.FieldEmployeeDetails] = struct{}{}
}

// EmployeeDetailsCleared returns if the "employee_details" field was cleared in this mutation.
func (m *EmployeeMutation) EmployeeDetailsCleared() bool {
	_, ok := m.clearedFields[employee.FieldEmployeeDetails]
	return ok
}

// ResetEmployeeDetails resets all changes to the "employee_details" field.
func (m *EmployeeMutation) ResetEmployeeDetails() {
	m.employee_details = nil
	delete(m.clearedFields, employee.FieldEmployeeDetails)
}

// SetName sets the "name" field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EmployeeMutation) ClearName() {
	m.name = nil
	m.clearedFields[employee.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EmployeeMutation) NameCleared() bool {
	_, ok := m.clearedFields[employee.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, employee.FieldName)
}

// SetPosition sets the "position" field.
func (m *EmployeeMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *EmployeeMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *EmployeeMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[employee.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *EmployeeMutation) PositionCleared() bool {
	_, ok := m.clearedFields[employee.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *EmployeeMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, employee.FieldPosition)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearCurrentPosition clears the "current_position" edge to the Position entity.
func (m *EmployeeMutation) ClearCurrentPosition() {
	m.clearedcurrent_position = true
	m.clearedFields[employee.FieldCurrentPositionID] = struct{}{}
}

// CurrentPositionCleared reports if the "current_position" edge to the Position entity was cleared.
func (m *EmployeeMutation) CurrentPositionCleared() bool {
	return m.CurrentPositionIDCleared() || m.clearedcurrent_position
}

// CurrentPositionIDs returns the "current_position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrentPositionID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CurrentPositionIDs() (ids []uuid.UUID) {
	if id := m.current_position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrentPosition resets all changes to the "current_position" edge.
func (m *EmployeeMutation) ResetCurrentPosition() {
	m.current_position = nil
	m.clearedcurrent_position = false
}

// AddPositionHistoryIDs adds the "position_history" edge to the PositionOccupancyHistory entity by ids.
func (m *EmployeeMutation) AddPositionHistoryIDs(ids ...uuid.UUID) {
	if m.position_history == nil {
		m.position_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.position_history[ids[i]] = struct{}{}
	}
}

// ClearPositionHistory clears the "position_history" edge to the PositionOccupancyHistory entity.
func (m *EmployeeMutation) ClearPositionHistory() {
	m.clearedposition_history = true
}

// PositionHistoryCleared reports if the "position_history" edge to the PositionOccupancyHistory entity was cleared.
func (m *EmployeeMutation) PositionHistoryCleared() bool {
	return m.clearedposition_history
}

// RemovePositionHistoryIDs removes the "position_history" edge to the PositionOccupancyHistory entity by IDs.
func (m *EmployeeMutation) RemovePositionHistoryIDs(ids ...uuid.UUID) {
	if m.removedposition_history == nil {
		m.removedposition_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.position_history, ids[i])
		m.removedposition_history[ids[i]] = struct{}{}
	}
}

// RemovedPositionHistory returns the removed IDs of the "position_history" edge to the PositionOccupancyHistory entity.
func (m *EmployeeMutation) RemovedPositionHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedposition_history {
		ids = append(ids, id)
	}
	return
}

// PositionHistoryIDs returns the "position_history" edge IDs in the mutation.
func (m *EmployeeMutation) PositionHistoryIDs() (ids []uuid.UUID) {
	for id := range m.position_history {
		ids = append(ids, id)
	}
	return
}

// ResetPositionHistory resets all changes to the "position_history" edge.
func (m *EmployeeMutation) ResetPositionHistory() {
	m.position_history = nil
	m.clearedposition_history = false
	m.removedposition_history = nil
}

// AddAssignmentIDs adds the "assignments" edge to the PositionAssignment entity by ids.
func (m *EmployeeMutation) AddAssignmentIDs(ids ...uuid.UUID) {
	if m.assignments == nil {
		m.assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the PositionAssignment entity.
func (m *EmployeeMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the PositionAssignment entity was cleared.
func (m *EmployeeMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the PositionAssignment entity by IDs.
func (m *EmployeeMutation) RemoveAssignmentIDs(ids ...uuid.UUID) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the PositionAssignment entity.
func (m *EmployeeMutation) RemovedAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *EmployeeMutation) AssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *EmployeeMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.business_id != nil {
		fields = append(fields, employee.FieldBusinessID)
	}
	if m.tenant_id != nil {
		fields = append(fields, employee.FieldTenantID)
	}
	if m.employee_type != nil {
		fields = append(fields, employee.FieldEmployeeType)
	}
	if m.employee_number != nil {
		fields = append(fields, employee.FieldEmployeeNumber)
	}
	if m.first_name != nil {
		fields = append(fields, employee.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, employee.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.personal_email != nil {
		fields = append(fields, employee.FieldPersonalEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, employee.FieldPhoneNumber)
	}
	if m.current_position != nil {
		fields = append(fields, employee.FieldCurrentPositionID)
	}
	if m.employment_status != nil {
		fields = append(fields, employee.FieldEmploymentStatus)
	}
	if m.hire_date != nil {
		fields = append(fields, employee.FieldHireDate)
	}
	if m.termination_date != nil {
		fields = append(fields, employee.FieldTerminationDate)
	}
	if m.employee_details != nil {
		fields = append(fields, employee.FieldEmployeeDetails)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.position != nil {
		fields = append(fields, employee.FieldPosition)
	}
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldBusinessID:
		return m.BusinessID()
	case employee.FieldTenantID:
		return m.TenantID()
	case employee.FieldEmployeeType:
		return m.EmployeeType()
	case employee.FieldEmployeeNumber:
		return m.EmployeeNumber()
	case employee.FieldFirstName:
		return m.FirstName()
	case employee.FieldLastName:
		return m.LastName()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPersonalEmail:
		return m.PersonalEmail()
	case employee.FieldPhoneNumber:
		return m.PhoneNumber()
	case employee.FieldCurrentPositionID:
		return m.CurrentPositionID()
	case employee.FieldEmploymentStatus:
		return m.EmploymentStatus()
	case employee.FieldHireDate:
		return m.HireDate()
	case employee.FieldTerminationDate:
		return m.TerminationDate()
	case employee.FieldEmployeeDetails:
		return m.EmployeeDetails()
	case employee.FieldName:
		return m.Name()
	case employee.FieldPosition:
		return m.Position()
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case employee.FieldTenantID:
		return m.OldTenantID(ctx)
	case employee.FieldEmployeeType:
		return m.OldEmployeeType(ctx)
	case employee.FieldEmployeeNumber:
		return m.OldEmployeeNumber(ctx)
	case employee.FieldFirstName:
		return m.OldFirstName(ctx)
	case employee.FieldLastName:
		return m.OldLastName(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPersonalEmail:
		return m.OldPersonalEmail(ctx)
	case employee.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case employee.FieldCurrentPositionID:
		return m.OldCurrentPositionID(ctx)
	case employee.FieldEmploymentStatus:
		return m.OldEmploymentStatus(ctx)
	case employee.FieldHireDate:
		return m.OldHireDate(ctx)
	case employee.FieldTerminationDate:
		return m.OldTerminationDate(ctx)
	case employee.FieldEmployeeDetails:
		return m.OldEmployeeDetails(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldPosition:
		return m.OldPosition(ctx)
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldBusinessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case employee.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case employee.FieldEmployeeType:
		v, ok := value.(employee.EmployeeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeType(v)
		return nil
	case employee.FieldEmployeeNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeNumber(v)
		return nil
	case employee.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case employee.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPersonalEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalEmail(v)
		return nil
	case employee.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case employee.FieldCurrentPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPositionID(v)
		return nil
	case employee.FieldEmploymentStatus:
		v, ok := value.(employee.EmploymentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmploymentStatus(v)
		return nil
	case employee.FieldHireDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHireDate(v)
		return nil
	case employee.FieldTerminationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminationDate(v)
		return nil
	case employee.FieldEmployeeDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDetails(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldPersonalEmail) {
		fields = append(fields, employee.FieldPersonalEmail)
	}
	if m.FieldCleared(employee.FieldPhoneNumber) {
		fields = append(fields, employee.FieldPhoneNumber)
	}
	if m.FieldCleared(employee.FieldCurrentPositionID) {
		fields = append(fields, employee.FieldCurrentPositionID)
	}
	if m.FieldCleared(employee.FieldTerminationDate) {
		fields = append(fields, employee.FieldTerminationDate)
	}
	if m.FieldCleared(employee.FieldEmployeeDetails) {
		fields = append(fields, employee.FieldEmployeeDetails)
	}
	if m.FieldCleared(employee.FieldName) {
		fields = append(fields, employee.FieldName)
	}
	if m.FieldCleared(employee.FieldPosition) {
		fields = append(fields, employee.FieldPosition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldPersonalEmail:
		m.ClearPersonalEmail()
		return nil
	case employee.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case employee.FieldCurrentPositionID:
		m.ClearCurrentPositionID()
		return nil
	case employee.FieldTerminationDate:
		m.ClearTerminationDate()
		return nil
	case employee.FieldEmployeeDetails:
		m.ClearEmployeeDetails()
		return nil
	case employee.FieldName:
		m.ClearName()
		return nil
	case employee.FieldPosition:
		m.ClearPosition()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case employee.FieldTenantID:
		m.ResetTenantID()
		return nil
	case employee.FieldEmployeeType:
		m.ResetEmployeeType()
		return nil
	case employee.FieldEmployeeNumber:
		m.ResetEmployeeNumber()
		return nil
	case employee.FieldFirstName:
		m.ResetFirstName()
		return nil
	case employee.FieldLastName:
		m.ResetLastName()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPersonalEmail:
		m.ResetPersonalEmail()
		return nil
	case employee.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case employee.FieldCurrentPositionID:
		m.ResetCurrentPositionID()
		return nil
	case employee.FieldEmploymentStatus:
		m.ResetEmploymentStatus()
		return nil
	case employee.FieldHireDate:
		m.ResetHireDate()
		return nil
	case employee.FieldTerminationDate:
		m.ResetTerminationDate()
		return nil
	case employee.FieldEmployeeDetails:
		m.ResetEmployeeDetails()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldPosition:
		m.ResetPosition()
		return nil
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.current_position != nil {
		edges = append(edges, employee.EdgeCurrentPosition)
	}
	if m.position_history != nil {
		edges = append(edges, employee.EdgePositionHistory)
	}
	if m.assignments != nil {
		edges = append(edges, employee.EdgeAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCurrentPosition:
		if id := m.current_position; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgePositionHistory:
		ids := make([]ent.Value, 0, len(m.position_history))
		for id := range m.position_history {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedposition_history != nil {
		edges = append(edges, employee.EdgePositionHistory)
	}
	if m.removedassignments != nil {
		edges = append(edges, employee.EdgeAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgePositionHistory:
		ids := make([]ent.Value, 0, len(m.removedposition_history))
		for id := range m.removedposition_history {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcurrent_position {
		edges = append(edges, employee.EdgeCurrentPosition)
	}
	if m.clearedposition_history {
		edges = append(edges, employee.EdgePositionHistory)
	}
	if m.clearedassignments {
		edges = append(edges, employee.EdgeAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCurrentPosition:
		return m.clearedcurrent_position
	case employee.EdgePositionHistory:
		return m.clearedposition_history
	case employee.EdgeAssignments:
		return m.clearedassignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCurrentPosition:
		m.ClearCurrentPosition()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCurrentPosition:
		m.ResetCurrentPosition()
		return nil
	case employee.EdgePositionHistory:
		m.ResetPositionHistory()
		return nil
	case employee.EdgeAssignments:
		m.ResetAssignments()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// OrganizationUnitMutation represents an operation that mutates the OrganizationUnit nodes in the graph.
type OrganizationUnitMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	business_id      *string
	tenant_id        *uuid.UUID
	unit_type        *organizationunit.UnitType
	name             *string
	description      *string
	level            *int
	addlevel         *int
	status           *organizationunit.Status
	profile          *map[string]interface{}
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	parent           *uuid.UUID
	clearedparent    bool
	children         map[uuid.UUID]struct{}
	removedchildren  map[uuid.UUID]struct{}
	clearedchildren  bool
	positions        map[uuid.UUID]struct{}
	removedpositions map[uuid.UUID]struct{}
	clearedpositions bool
	done             bool
	oldValue         func(context.Context) (*OrganizationUnit, error)
	predicates       []predicate.OrganizationUnit
}

var _ ent.Mutation = (*OrganizationUnitMutation)(nil)

// organizationunitOption allows management of the mutation configuration using functional options.
type organizationunitOption func(*OrganizationUnitMutation)

// newOrganizationUnitMutation creates new mutation for the OrganizationUnit entity.
func newOrganizationUnitMutation(c config, op Op, opts ...organizationunitOption) *OrganizationUnitMutation {
	m := &OrganizationUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationUnitID sets the ID field of the mutation.
func withOrganizationUnitID(id uuid.UUID) organizationunitOption {
	return func(m *OrganizationUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationUnit
		)
		m.oldValue = func(ctx context.Context) (*OrganizationUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationUnit sets the old OrganizationUnit of the mutation.
func withOrganizationUnit(node *OrganizationUnit) organizationunitOption {
	return func(m *OrganizationUnitMutation) {
		m.oldValue = func(context.Context) (*OrganizationUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationUnit entities.
func (m *OrganizationUnitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationUnitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationUnitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessID sets the "business_id" field.
func (m *OrganizationUnitMutation) SetBusinessID(s string) {
	m.business_id = &s
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *OrganizationUnitMutation) BusinessID() (r string, exists bool) {
	v := m.business_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldBusinessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *OrganizationUnitMutation) ResetBusinessID() {
	m.business_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *OrganizationUnitMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrganizationUnitMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrganizationUnitMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetUnitType sets the "unit_type" field.
func (m *OrganizationUnitMutation) SetUnitType(ot organizationunit.UnitType) {
	m.unit_type = &ot
}

// UnitType returns the value of the "unit_type" field in the mutation.
func (m *OrganizationUnitMutation) UnitType() (r organizationunit.UnitType, exists bool) {
	v := m.unit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitType returns the old "unit_type" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldUnitType(ctx context.Context) (v organizationunit.UnitType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitType: %w", err)
	}
	return oldValue.UnitType, nil
}

// ResetUnitType resets all changes to the "unit_type" field.
func (m *OrganizationUnitMutation) ResetUnitType() {
	m.unit_type = nil
}

// SetName sets the "name" field.
func (m *OrganizationUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationUnitMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationUnitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationUnitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationUnitMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organizationunit.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationUnitMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organizationunit.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationUnitMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organizationunit.FieldDescription)
}

// SetParentUnitID sets the "parent_unit_id" field.
func (m *OrganizationUnitMutation) SetParentUnitID(u uuid.UUID) {
	m.parent = &u
}

// ParentUnitID returns the value of the "parent_unit_id" field in the mutation.
func (m *OrganizationUnitMutation) ParentUnitID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentUnitID returns the old "parent_unit_id" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldParentUnitID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentUnitID: %w", err)
	}
	return oldValue.ParentUnitID, nil
}

// ClearParentUnitID clears the value of the "parent_unit_id" field.
func (m *OrganizationUnitMutation) ClearParentUnitID() {
	m.parent = nil
	m.clearedFields[organizationunit.FieldParentUnitID] = struct{}{}
}

// ParentUnitIDCleared returns if the "parent_unit_id" field was cleared in this mutation.
func (m *OrganizationUnitMutation) ParentUnitIDCleared() bool {
	_, ok := m.clearedFields[organizationunit.FieldParentUnitID]
	return ok
}

// ResetParentUnitID resets all changes to the "parent_unit_id" field.
func (m *OrganizationUnitMutation) ResetParentUnitID() {
	m.parent = nil
	delete(m.clearedFields, organizationunit.FieldParentUnitID)
}

// SetLevel sets the "level" field.
func (m *OrganizationUnitMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *OrganizationUnitMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *OrganizationUnitMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *OrganizationUnitMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *OrganizationUnitMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetStatus sets the "status" field.
func (m *OrganizationUnitMutation) SetStatus(o organizationunit.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationUnitMutation) Status() (r organizationunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldStatus(ctx context.Context) (v organizationunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationUnitMutation) ResetStatus() {
	m.status = nil
}

// SetProfile sets the "profile" field.
func (m *OrganizationUnitMutation) SetProfile(value map[string]interface{}) {
	m.profile = &value
}

// Profile returns the value of the "profile" field in the mutation.
func (m *OrganizationUnitMutation) Profile() (r map[string]interface{}, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldProfile(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *OrganizationUnitMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[organizationunit.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *OrganizationUnitMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[organizationunit.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *OrganizationUnitMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, organizationunit.FieldProfile)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationUnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationUnit entity.
// If the OrganizationUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetParentID sets the "parent" edge to the OrganizationUnit entity by id.
func (m *OrganizationUnitMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OrganizationUnit entity.
func (m *OrganizationUnitMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[organizationunit.FieldParentUnitID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the OrganizationUnit entity was cleared.
func (m *OrganizationUnitMutation) ParentCleared() bool {
	return m.ParentUnitIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OrganizationUnitMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrganizationUnitMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrganizationUnitMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the OrganizationUnit entity by ids.
func (m *OrganizationUnitMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the OrganizationUnit entity.
func (m *OrganizationUnitMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the OrganizationUnit entity was cleared.
func (m *OrganizationUnitMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the OrganizationUnit entity by IDs.
func (m *OrganizationUnitMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the OrganizationUnit entity.
func (m *OrganizationUnitMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrganizationUnitMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrganizationUnitMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddPositionIDs adds the "positions" edge to the Position entity by ids.
func (m *OrganizationUnitMutation) AddPositionIDs(ids ...uuid.UUID) {
	if m.positions == nil {
		m.positions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the Position entity.
func (m *OrganizationUnitMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the Position entity was cleared.
func (m *OrganizationUnitMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the Position entity by IDs.
func (m *OrganizationUnitMutation) RemovePositionIDs(ids ...uuid.UUID) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the Position entity.
func (m *OrganizationUnitMutation) RemovedPositionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *OrganizationUnitMutation) PositionsIDs() (ids []uuid.UUID) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *OrganizationUnitMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// Where appends a list predicates to the OrganizationUnitMutation builder.
func (m *OrganizationUnitMutation) Where(ps ...predicate.OrganizationUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationUnit).
func (m *OrganizationUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationUnitMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_id != nil {
		fields = append(fields, organizationunit.FieldBusinessID)
	}
	if m.tenant_id != nil {
		fields = append(fields, organizationunit.FieldTenantID)
	}
	if m.unit_type != nil {
		fields = append(fields, organizationunit.FieldUnitType)
	}
	if m.name != nil {
		fields = append(fields, organizationunit.FieldName)
	}
	if m.description != nil {
		fields = append(fields, organizationunit.FieldDescription)
	}
	if m.parent != nil {
		fields = append(fields, organizationunit.FieldParentUnitID)
	}
	if m.level != nil {
		fields = append(fields, organizationunit.FieldLevel)
	}
	if m.status != nil {
		fields = append(fields, organizationunit.FieldStatus)
	}
	if m.profile != nil {
		fields = append(fields, organizationunit.FieldProfile)
	}
	if m.created_at != nil {
		fields = append(fields, organizationunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationunit.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationunit.FieldBusinessID:
		return m.BusinessID()
	case organizationunit.FieldTenantID:
		return m.TenantID()
	case organizationunit.FieldUnitType:
		return m.UnitType()
	case organizationunit.FieldName:
		return m.Name()
	case organizationunit.FieldDescription:
		return m.Description()
	case organizationunit.FieldParentUnitID:
		return m.ParentUnitID()
	case organizationunit.FieldLevel:
		return m.Level()
	case organizationunit.FieldStatus:
		return m.Status()
	case organizationunit.FieldProfile:
		return m.Profile()
	case organizationunit.FieldCreatedAt:
		return m.CreatedAt()
	case organizationunit.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationunit.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case organizationunit.FieldTenantID:
		return m.OldTenantID(ctx)
	case organizationunit.FieldUnitType:
		return m.OldUnitType(ctx)
	case organizationunit.FieldName:
		return m.OldName(ctx)
	case organizationunit.FieldDescription:
		return m.OldDescription(ctx)
	case organizationunit.FieldParentUnitID:
		return m.OldParentUnitID(ctx)
	case organizationunit.FieldLevel:
		return m.OldLevel(ctx)
	case organizationunit.FieldStatus:
		return m.OldStatus(ctx)
	case organizationunit.FieldProfile:
		return m.OldProfile(ctx)
	case organizationunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationunit.FieldBusinessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case organizationunit.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case organizationunit.FieldUnitType:
		v, ok := value.(organizationunit.UnitType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitType(v)
		return nil
	case organizationunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationunit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organizationunit.FieldParentUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentUnitID(v)
		return nil
	case organizationunit.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case organizationunit.FieldStatus:
		v, ok := value.(organizationunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organizationunit.FieldProfile:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case organizationunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationUnitMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, organizationunit.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationunit.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationunit.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationunit.FieldDescription) {
		fields = append(fields, organizationunit.FieldDescription)
	}
	if m.FieldCleared(organizationunit.FieldParentUnitID) {
		fields = append(fields, organizationunit.FieldParentUnitID)
	}
	if m.FieldCleared(organizationunit.FieldProfile) {
		fields = append(fields, organizationunit.FieldProfile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationUnitMutation) ClearField(name string) error {
	switch name {
	case organizationunit.FieldDescription:
		m.ClearDescription()
		return nil
	case organizationunit.FieldParentUnitID:
		m.ClearParentUnitID()
		return nil
	case organizationunit.FieldProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationUnitMutation) ResetField(name string) error {
	switch name {
	case organizationunit.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case organizationunit.FieldTenantID:
		m.ResetTenantID()
		return nil
	case organizationunit.FieldUnitType:
		m.ResetUnitType()
		return nil
	case organizationunit.FieldName:
		m.ResetName()
		return nil
	case organizationunit.FieldDescription:
		m.ResetDescription()
		return nil
	case organizationunit.FieldParentUnitID:
		m.ResetParentUnitID()
		return nil
	case organizationunit.FieldLevel:
		m.ResetLevel()
		return nil
	case organizationunit.FieldStatus:
		m.ResetStatus()
		return nil
	case organizationunit.FieldProfile:
		m.ResetProfile()
		return nil
	case organizationunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, organizationunit.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, organizationunit.EdgeChildren)
	}
	if m.positions != nil {
		edges = append(edges, organizationunit.EdgePositions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationunit.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case organizationunit.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case organizationunit.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, organizationunit.EdgeChildren)
	}
	if m.removedpositions != nil {
		edges = append(edges, organizationunit.EdgePositions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationunit.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case organizationunit.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, organizationunit.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, organizationunit.EdgeChildren)
	}
	if m.clearedpositions {
		edges = append(edges, organizationunit.EdgePositions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationunit.EdgeParent:
		return m.clearedparent
	case organizationunit.EdgeChildren:
		return m.clearedchildren
	case organizationunit.EdgePositions:
		return m.clearedpositions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationUnitMutation) ClearEdge(name string) error {
	switch name {
	case organizationunit.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationUnitMutation) ResetEdge(name string) error {
	switch name {
	case organizationunit.EdgeParent:
		m.ResetParent()
		return nil
	case organizationunit.EdgeChildren:
		m.ResetChildren()
		return nil
	case organizationunit.EdgePositions:
		m.ResetPositions()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUnit edge %s", name)
}

// PositionMutation represents an operation that mutates the Position nodes in the graph.
type PositionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	tenant_id                 *uuid.UUID
	business_id               *string
	position_type             *position.PositionType
	job_profile_id            *uuid.UUID
	status                    *position.Status
	budgeted_fte              *float64
	addbudgeted_fte           *float64
	details                   *map[string]interface{}
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	manager                   *uuid.UUID
	clearedmanager            bool
	direct_reports            map[uuid.UUID]struct{}
	removeddirect_reports     map[uuid.UUID]struct{}
	cleareddirect_reports     bool
	department                *uuid.UUID
	cleareddepartment         bool
	current_incumbents        map[uuid.UUID]struct{}
	removedcurrent_incumbents map[uuid.UUID]struct{}
	clearedcurrent_incumbents bool
	occupancy_history         map[uuid.UUID]struct{}
	removedoccupancy_history  map[uuid.UUID]struct{}
	clearedoccupancy_history  bool
	attribute_history         map[uuid.UUID]struct{}
	removedattribute_history  map[uuid.UUID]struct{}
	clearedattribute_history  bool
	assignments               map[uuid.UUID]struct{}
	removedassignments        map[uuid.UUID]struct{}
	clearedassignments        bool
	done                      bool
	oldValue                  func(context.Context) (*Position, error)
	predicates                []predicate.Position
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows management of the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for the Position entity.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the ID field of the mutation.
func withPositionID(id uuid.UUID) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Position entities.
func (m *PositionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PositionMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PositionMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PositionMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetBusinessID sets the "business_id" field.
func (m *PositionMutation) SetBusinessID(s string) {
	m.business_id = &s
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *PositionMutation) BusinessID() (r string, exists bool) {
	v := m.business_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldBusinessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *PositionMutation) ResetBusinessID() {
	m.business_id = nil
}

// SetPositionType sets the "position_type" field.
func (m *PositionMutation) SetPositionType(pt position.PositionType) {
	m.position_type = &pt
}

// PositionType returns the value of the "position_type" field in the mutation.
func (m *PositionMutation) PositionType() (r position.PositionType, exists bool) {
	v := m.position_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionType returns the old "position_type" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldPositionType(ctx context.Context) (v position.PositionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionType: %w", err)
	}
	return oldValue.PositionType, nil
}

// ResetPositionType resets all changes to the "position_type" field.
func (m *PositionMutation) ResetPositionType() {
	m.position_type = nil
}

// SetJobProfileID sets the "job_profile_id" field.
func (m *PositionMutation) SetJobProfileID(u uuid.UUID) {
	m.job_profile_id = &u
}

// JobProfileID returns the value of the "job_profile_id" field in the mutation.
func (m *PositionMutation) JobProfileID() (r uuid.UUID, exists bool) {
	v := m.job_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobProfileID returns the old "job_profile_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldJobProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobProfileID: %w", err)
	}
	return oldValue.JobProfileID, nil
}

// ResetJobProfileID resets all changes to the "job_profile_id" field.
func (m *PositionMutation) ResetJobProfileID() {
	m.job_profile_id = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *PositionMutation) SetDepartmentID(u uuid.UUID) {
	m.department = &u
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *PositionMutation) DepartmentID() (r uuid.UUID, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDepartmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *PositionMutation) ResetDepartmentID() {
	m.department = nil
}

// SetManagerPositionID sets the "manager_position_id" field.
func (m *PositionMutation) SetManagerPositionID(u uuid.UUID) {
	m.manager = &u
}

// ManagerPositionID returns the value of the "manager_position_id" field in the mutation.
func (m *PositionMutation) ManagerPositionID() (r uuid.UUID, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerPositionID returns the old "manager_position_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldManagerPositionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerPositionID: %w", err)
	}
	return oldValue.ManagerPositionID, nil
}

// ClearManagerPositionID clears the value of the "manager_position_id" field.
func (m *PositionMutation) ClearManagerPositionID() {
	m.manager = nil
	m.clearedFields[position.FieldManagerPositionID] = struct{}{}
}

// ManagerPositionIDCleared returns if the "manager_position_id" field was cleared in this mutation.
func (m *PositionMutation) ManagerPositionIDCleared() bool {
	_, ok := m.clearedFields[position.FieldManagerPositionID]
	return ok
}

// ResetManagerPositionID resets all changes to the "manager_position_id" field.
func (m *PositionMutation) ResetManagerPositionID() {
	m.manager = nil
	delete(m.clearedFields, position.FieldManagerPositionID)
}

// SetStatus sets the "status" field.
func (m *PositionMutation) SetStatus(po position.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PositionMutation) Status() (r position.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldStatus(ctx context.Context) (v position.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PositionMutation) ResetStatus() {
	m.status = nil
}

// SetBudgetedFte sets the "budgeted_fte" field.
func (m *PositionMutation) SetBudgetedFte(f float64) {
	m.budgeted_fte = &f
	m.addbudgeted_fte = nil
}

// BudgetedFte returns the value of the "budgeted_fte" field in the mutation.
func (m *PositionMutation) BudgetedFte() (r float64, exists bool) {
	v := m.budgeted_fte
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetedFte returns the old "budgeted_fte" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldBudgetedFte(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetedFte is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetedFte requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetedFte: %w", err)
	}
	return oldValue.BudgetedFte, nil
}

// AddBudgetedFte adds f to the "budgeted_fte" field.
func (m *PositionMutation) AddBudgetedFte(f float64) {
	if m.addbudgeted_fte != nil {
		*m.addbudgeted_fte += f
	} else {
		m.addbudgeted_fte = &f
	}
}

// AddedBudgetedFte returns the value that was added to the "budgeted_fte" field in this mutation.
func (m *PositionMutation) AddedBudgetedFte() (r float64, exists bool) {
	v := m.addbudgeted_fte
	if v == nil {
		return
	}
	return *v, true
}

// ResetBudgetedFte resets all changes to the "budgeted_fte" field.
func (m *PositionMutation) ResetBudgetedFte() {
	m.budgeted_fte = nil
	m.addbudgeted_fte = nil
}

// SetDetails sets the "details" field.
func (m *PositionMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *PositionMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *PositionMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[position.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *PositionMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[position.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *PositionMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, position.FieldDetails)
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetManagerID sets the "manager" edge to the Position entity by id.
func (m *PositionMutation) SetManagerID(id uuid.UUID) {
	m.manager = &id
}

// ClearManager clears the "manager" edge to the Position entity.
func (m *PositionMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[position.FieldManagerPositionID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the Position entity was cleared.
func (m *PositionMutation) ManagerCleared() bool {
	return m.ManagerPositionIDCleared() || m.clearedmanager
}

// ManagerID returns the "manager" edge ID in the mutation.
func (m *PositionMutation) ManagerID() (id uuid.UUID, exists bool) {
	if m.manager != nil {
		return *m.manager, true
	}
	return
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *PositionMutation) ManagerIDs() (ids []uuid.UUID) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *PositionMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// AddDirectReportIDs adds the "direct_reports" edge to the Position entity by ids.
func (m *PositionMutation) AddDirectReportIDs(ids ...uuid.UUID) {
	if m.direct_reports == nil {
		m.direct_reports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.direct_reports[ids[i]] = struct{}{}
	}
}

// ClearDirectReports clears the "direct_reports" edge to the Position entity.
func (m *PositionMutation) ClearDirectReports() {
	m.cleareddirect_reports = true
}

// DirectReportsCleared reports if the "direct_reports" edge to the Position entity was cleared.
func (m *PositionMutation) DirectReportsCleared() bool {
	return m.cleareddirect_reports
}

// RemoveDirectReportIDs removes the "direct_reports" edge to the Position entity by IDs.
func (m *PositionMutation) RemoveDirectReportIDs(ids ...uuid.UUID) {
	if m.removeddirect_reports == nil {
		m.removeddirect_reports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.direct_reports, ids[i])
		m.removeddirect_reports[ids[i]] = struct{}{}
	}
}

// RemovedDirectReports returns the removed IDs of the "direct_reports" edge to the Position entity.
func (m *PositionMutation) RemovedDirectReportsIDs() (ids []uuid.UUID) {
	for id := range m.removeddirect_reports {
		ids = append(ids, id)
	}
	return
}

// DirectReportsIDs returns the "direct_reports" edge IDs in the mutation.
func (m *PositionMutation) DirectReportsIDs() (ids []uuid.UUID) {
	for id := range m.direct_reports {
		ids = append(ids, id)
	}
	return
}

// ResetDirectReports resets all changes to the "direct_reports" edge.
func (m *PositionMutation) ResetDirectReports() {
	m.direct_reports = nil
	m.cleareddirect_reports = false
	m.removeddirect_reports = nil
}

// ClearDepartment clears the "department" edge to the OrganizationUnit entity.
func (m *PositionMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[position.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the OrganizationUnit entity was cleared.
func (m *PositionMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *PositionMutation) DepartmentIDs() (ids []uuid.UUID) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *PositionMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddCurrentIncumbentIDs adds the "current_incumbents" edge to the Employee entity by ids.
func (m *PositionMutation) AddCurrentIncumbentIDs(ids ...uuid.UUID) {
	if m.current_incumbents == nil {
		m.current_incumbents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.current_incumbents[ids[i]] = struct{}{}
	}
}

// ClearCurrentIncumbents clears the "current_incumbents" edge to the Employee entity.
func (m *PositionMutation) ClearCurrentIncumbents() {
	m.clearedcurrent_incumbents = true
}

// CurrentIncumbentsCleared reports if the "current_incumbents" edge to the Employee entity was cleared.
func (m *PositionMutation) CurrentIncumbentsCleared() bool {
	return m.clearedcurrent_incumbents
}

// RemoveCurrentIncumbentIDs removes the "current_incumbents" edge to the Employee entity by IDs.
func (m *PositionMutation) RemoveCurrentIncumbentIDs(ids ...uuid.UUID) {
	if m.removedcurrent_incumbents == nil {
		m.removedcurrent_incumbents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.current_incumbents, ids[i])
		m.removedcurrent_incumbents[ids[i]] = struct{}{}
	}
}

// RemovedCurrentIncumbents returns the removed IDs of the "current_incumbents" edge to the Employee entity.
func (m *PositionMutation) RemovedCurrentIncumbentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcurrent_incumbents {
		ids = append(ids, id)
	}
	return
}

// CurrentIncumbentsIDs returns the "current_incumbents" edge IDs in the mutation.
func (m *PositionMutation) CurrentIncumbentsIDs() (ids []uuid.UUID) {
	for id := range m.current_incumbents {
		ids = append(ids, id)
	}
	return
}

// ResetCurrentIncumbents resets all changes to the "current_incumbents" edge.
func (m *PositionMutation) ResetCurrentIncumbents() {
	m.current_incumbents = nil
	m.clearedcurrent_incumbents = false
	m.removedcurrent_incumbents = nil
}

// AddOccupancyHistoryIDs adds the "occupancy_history" edge to the PositionOccupancyHistory entity by ids.
func (m *PositionMutation) AddOccupancyHistoryIDs(ids ...uuid.UUID) {
	if m.occupancy_history == nil {
		m.occupancy_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.occupancy_history[ids[i]] = struct{}{}
	}
}

// ClearOccupancyHistory clears the "occupancy_history" edge to the PositionOccupancyHistory entity.
func (m *PositionMutation) ClearOccupancyHistory() {
	m.clearedoccupancy_history = true
}

// OccupancyHistoryCleared reports if the "occupancy_history" edge to the PositionOccupancyHistory entity was cleared.
func (m *PositionMutation) OccupancyHistoryCleared() bool {
	return m.clearedoccupancy_history
}

// RemoveOccupancyHistoryIDs removes the "occupancy_history" edge to the PositionOccupancyHistory entity by IDs.
func (m *PositionMutation) RemoveOccupancyHistoryIDs(ids ...uuid.UUID) {
	if m.removedoccupancy_history == nil {
		m.removedoccupancy_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.occupancy_history, ids[i])
		m.removedoccupancy_history[ids[i]] = struct{}{}
	}
}

// RemovedOccupancyHistory returns the removed IDs of the "occupancy_history" edge to the PositionOccupancyHistory entity.
func (m *PositionMutation) RemovedOccupancyHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedoccupancy_history {
		ids = append(ids, id)
	}
	return
}

// OccupancyHistoryIDs returns the "occupancy_history" edge IDs in the mutation.
func (m *PositionMutation) OccupancyHistoryIDs() (ids []uuid.UUID) {
	for id := range m.occupancy_history {
		ids = append(ids, id)
	}
	return
}

// ResetOccupancyHistory resets all changes to the "occupancy_history" edge.
func (m *PositionMutation) ResetOccupancyHistory() {
	m.occupancy_history = nil
	m.clearedoccupancy_history = false
	m.removedoccupancy_history = nil
}

// AddAttributeHistoryIDs adds the "attribute_history" edge to the PositionAttributeHistory entity by ids.
func (m *PositionMutation) AddAttributeHistoryIDs(ids ...uuid.UUID) {
	if m.attribute_history == nil {
		m.attribute_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attribute_history[ids[i]] = struct{}{}
	}
}

// ClearAttributeHistory clears the "attribute_history" edge to the PositionAttributeHistory entity.
func (m *PositionMutation) ClearAttributeHistory() {
	m.clearedattribute_history = true
}

// AttributeHistoryCleared reports if the "attribute_history" edge to the PositionAttributeHistory entity was cleared.
func (m *PositionMutation) AttributeHistoryCleared() bool {
	return m.clearedattribute_history
}

// RemoveAttributeHistoryIDs removes the "attribute_history" edge to the PositionAttributeHistory entity by IDs.
func (m *PositionMutation) RemoveAttributeHistoryIDs(ids ...uuid.UUID) {
	if m.removedattribute_history == nil {
		m.removedattribute_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attribute_history, ids[i])
		m.removedattribute_history[ids[i]] = struct{}{}
	}
}

// RemovedAttributeHistory returns the removed IDs of the "attribute_history" edge to the PositionAttributeHistory entity.
func (m *PositionMutation) RemovedAttributeHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedattribute_history {
		ids = append(ids, id)
	}
	return
}

// AttributeHistoryIDs returns the "attribute_history" edge IDs in the mutation.
func (m *PositionMutation) AttributeHistoryIDs() (ids []uuid.UUID) {
	for id := range m.attribute_history {
		ids = append(ids, id)
	}
	return
}

// ResetAttributeHistory resets all changes to the "attribute_history" edge.
func (m *PositionMutation) ResetAttributeHistory() {
	m.attribute_history = nil
	m.clearedattribute_history = false
	m.removedattribute_history = nil
}

// AddAssignmentIDs adds the "assignments" edge to the PositionAssignment entity by ids.
func (m *PositionMutation) AddAssignmentIDs(ids ...uuid.UUID) {
	if m.assignments == nil {
		m.assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the PositionAssignment entity.
func (m *PositionMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the PositionAssignment entity was cleared.
func (m *PositionMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the PositionAssignment entity by IDs.
func (m *PositionMutation) RemoveAssignmentIDs(ids ...uuid.UUID) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the PositionAssignment entity.
func (m *PositionMutation) RemovedAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *PositionMutation) AssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *PositionMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// Where appends a list predicates to the PositionMutation builder.
func (m *PositionMutation) Where(ps ...predicate.Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant_id != nil {
		fields = append(fields, position.FieldTenantID)
	}
	if m.business_id != nil {
		fields = append(fields, position.FieldBusinessID)
	}
	if m.position_type != nil {
		fields = append(fields, position.FieldPositionType)
	}
	if m.job_profile_id != nil {
		fields = append(fields, position.FieldJobProfileID)
	}
	if m.department != nil {
		fields = append(fields, position.FieldDepartmentID)
	}
	if m.manager != nil {
		fields = append(fields, position.FieldManagerPositionID)
	}
	if m.status != nil {
		fields = append(fields, position.FieldStatus)
	}
	if m.budgeted_fte != nil {
		fields = append(fields, position.FieldBudgetedFte)
	}
	if m.details != nil {
		fields = append(fields, position.FieldDetails)
	}
	if m.created_at != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldTenantID:
		return m.TenantID()
	case position.FieldBusinessID:
		return m.BusinessID()
	case position.FieldPositionType:
		return m.PositionType()
	case position.FieldJobProfileID:
		return m.JobProfileID()
	case position.FieldDepartmentID:
		return m.DepartmentID()
	case position.FieldManagerPositionID:
		return m.ManagerPositionID()
	case position.FieldStatus:
		return m.Status()
	case position.FieldBudgetedFte:
		return m.BudgetedFte()
	case position.FieldDetails:
		return m.Details()
	case position.FieldCreatedAt:
		return m.CreatedAt()
	case position.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldTenantID:
		return m.OldTenantID(ctx)
	case position.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case position.FieldPositionType:
		return m.OldPositionType(ctx)
	case position.FieldJobProfileID:
		return m.OldJobProfileID(ctx)
	case position.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case position.FieldManagerPositionID:
		return m.OldManagerPositionID(ctx)
	case position.FieldStatus:
		return m.OldStatus(ctx)
	case position.FieldBudgetedFte:
		return m.OldBudgetedFte(ctx)
	case position.FieldDetails:
		return m.OldDetails(ctx)
	case position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case position.FieldBusinessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case position.FieldPositionType:
		v, ok := value.(position.PositionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionType(v)
		return nil
	case position.FieldJobProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobProfileID(v)
		return nil
	case position.FieldDepartmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case position.FieldManagerPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerPositionID(v)
		return nil
	case position.FieldStatus:
		v, ok := value.(position.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case position.FieldBudgetedFte:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetedFte(v)
		return nil
	case position.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case position.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionMutation) AddedFields() []string {
	var fields []string
	if m.addbudgeted_fte != nil {
		fields = append(fields, position.FieldBudgetedFte)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case position.FieldBudgetedFte:
		return m.AddedBudgetedFte()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case position.FieldBudgetedFte:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetedFte(v)
		return nil
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(position.FieldManagerPositionID) {
		fields = append(fields, position.FieldManagerPositionID)
	}
	if m.FieldCleared(position.FieldDetails) {
		fields = append(fields, position.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	switch name {
	case position.FieldManagerPositionID:
		m.ClearManagerPositionID()
		return nil
	case position.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldTenantID:
		m.ResetTenantID()
		return nil
	case position.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case position.FieldPositionType:
		m.ResetPositionType()
		return nil
	case position.FieldJobProfileID:
		m.ResetJobProfileID()
		return nil
	case position.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case position.FieldManagerPositionID:
		m.ResetManagerPositionID()
		return nil
	case position.FieldStatus:
		m.ResetStatus()
		return nil
	case position.FieldBudgetedFte:
		m.ResetBudgetedFte()
		return nil
	case position.FieldDetails:
		m.ResetDetails()
		return nil
	case position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.manager != nil {
		edges = append(edges, position.EdgeManager)
	}
	if m.direct_reports != nil {
		edges = append(edges, position.EdgeDirectReports)
	}
	if m.department != nil {
		edges = append(edges, position.EdgeDepartment)
	}
	if m.current_incumbents != nil {
		edges = append(edges, position.EdgeCurrentIncumbents)
	}
	if m.occupancy_history != nil {
		edges = append(edges, position.EdgeOccupancyHistory)
	}
	if m.attribute_history != nil {
		edges = append(edges, position.EdgeAttributeHistory)
	}
	if m.assignments != nil {
		edges = append(edges, position.EdgeAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case position.EdgeDirectReports:
		ids := make([]ent.Value, 0, len(m.direct_reports))
		for id := range m.direct_reports {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case position.EdgeCurrentIncumbents:
		ids := make([]ent.Value, 0, len(m.current_incumbents))
		for id := range m.current_incumbents {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeOccupancyHistory:
		ids := make([]ent.Value, 0, len(m.occupancy_history))
		for id := range m.occupancy_history {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeAttributeHistory:
		ids := make([]ent.Value, 0, len(m.attribute_history))
		for id := range m.attribute_history {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removeddirect_reports != nil {
		edges = append(edges, position.EdgeDirectReports)
	}
	if m.removedcurrent_incumbents != nil {
		edges = append(edges, position.EdgeCurrentIncumbents)
	}
	if m.removedoccupancy_history != nil {
		edges = append(edges, position.EdgeOccupancyHistory)
	}
	if m.removedattribute_history != nil {
		edges = append(edges, position.EdgeAttributeHistory)
	}
	if m.removedassignments != nil {
		edges = append(edges, position.EdgeAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeDirectReports:
		ids := make([]ent.Value, 0, len(m.removeddirect_reports))
		for id := range m.removeddirect_reports {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeCurrentIncumbents:
		ids := make([]ent.Value, 0, len(m.removedcurrent_incumbents))
		for id := range m.removedcurrent_incumbents {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeOccupancyHistory:
		ids := make([]ent.Value, 0, len(m.removedoccupancy_history))
		for id := range m.removedoccupancy_history {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeAttributeHistory:
		ids := make([]ent.Value, 0, len(m.removedattribute_history))
		for id := range m.removedattribute_history {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmanager {
		edges = append(edges, position.EdgeManager)
	}
	if m.cleareddirect_reports {
		edges = append(edges, position.EdgeDirectReports)
	}
	if m.cleareddepartment {
		edges = append(edges, position.EdgeDepartment)
	}
	if m.clearedcurrent_incumbents {
		edges = append(edges, position.EdgeCurrentIncumbents)
	}
	if m.clearedoccupancy_history {
		edges = append(edges, position.EdgeOccupancyHistory)
	}
	if m.clearedattribute_history {
		edges = append(edges, position.EdgeAttributeHistory)
	}
	if m.clearedassignments {
		edges = append(edges, position.EdgeAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	case position.EdgeManager:
		return m.clearedmanager
	case position.EdgeDirectReports:
		return m.cleareddirect_reports
	case position.EdgeDepartment:
		return m.cleareddepartment
	case position.EdgeCurrentIncumbents:
		return m.clearedcurrent_incumbents
	case position.EdgeOccupancyHistory:
		return m.clearedoccupancy_history
	case position.EdgeAttributeHistory:
		return m.clearedattribute_history
	case position.EdgeAssignments:
		return m.clearedassignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	case position.EdgeManager:
		m.ClearManager()
		return nil
	case position.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeManager:
		m.ResetManager()
		return nil
	case position.EdgeDirectReports:
		m.ResetDirectReports()
		return nil
	case position.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case position.EdgeCurrentIncumbents:
		m.ResetCurrentIncumbents()
		return nil
	case position.EdgeOccupancyHistory:
		m.ResetOccupancyHistory()
		return nil
	case position.EdgeAttributeHistory:
		m.ResetAttributeHistory()
		return nil
	case position.EdgeAssignments:
		m.ResetAssignments()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// PositionAssignmentMutation represents an operation that mutates the PositionAssignment nodes in the graph.
type PositionAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	tenant_id       *uuid.UUID
	start_date      *time.Time
	end_date        *time.Time
	is_current      *bool
	fte             *float64
	addfte          *float64
	assignment_type *positionassignment.AssignmentType
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	position        *uuid.UUID
	clearedposition bool
	employee        *uuid.UUID
	clearedemployee bool
	details         map[uuid.UUID]struct{}
	removeddetails  map[uuid.UUID]struct{}
	cleareddetails  bool
	history         map[uuid.UUID]struct{}
	removedhistory  map[uuid.UUID]struct{}
	clearedhistory  bool
	done            bool
	oldValue        func(context.Context) (*PositionAssignment, error)
	predicates      []predicate.PositionAssignment
}

var _ ent.Mutation = (*PositionAssignmentMutation)(nil)

// positionassignmentOption allows management of the mutation configuration using functional options.
type positionassignmentOption func(*PositionAssignmentMutation)

// newPositionAssignmentMutation creates new mutation for the PositionAssignment entity.
func newPositionAssignmentMutation(c config, op Op, opts ...positionassignmentOption) *PositionAssignmentMutation {
	m := &PositionAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypePositionAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionAssignmentID sets the ID field of the mutation.
func withPositionAssignmentID(id uuid.UUID) positionassignmentOption {
	return func(m *PositionAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionAssignment
		)
		m.oldValue = func(ctx context.Context) (*PositionAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionAssignment sets the old PositionAssignment of the mutation.
func withPositionAssignment(node *PositionAssignment) positionassignmentOption {
	return func(m *PositionAssignmentMutation) {
		m.oldValue = func(context.Context) (*PositionAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PositionAssignment entities.
func (m *PositionAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PositionAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PositionAssignmentMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PositionAssignmentMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PositionAssignmentMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *PositionAssignmentMutation) SetPositionID(u uuid.UUID) {
	m.position = &u
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *PositionAssignmentMutation) PositionID() (r uuid.UUID, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldPositionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *PositionAssignmentMutation) ResetPositionID() {
	m.position = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *PositionAssignmentMutation) SetEmployeeID(u uuid.UUID) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *PositionAssignmentMutation) EmployeeID() (r uuid.UUID, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldEmployeeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *PositionAssignmentMutation) ResetEmployeeID() {
	m.employee = nil
}

// SetStartDate sets the "start_date" field.
func (m *PositionAssignmentMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *PositionAssignmentMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *PositionAssignmentMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *PositionAssignmentMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PositionAssignmentMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PositionAssignmentMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[positionassignment.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PositionAssignmentMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[positionassignment.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PositionAssignmentMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, positionassignment.FieldEndDate)
}

// SetIsCurrent sets the "is_current" field.
func (m *PositionAssignmentMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *PositionAssignmentMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *PositionAssignmentMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetFte sets the "fte" field.
func (m *PositionAssignmentMutation) SetFte(f float64) {
	m.fte = &f
	m.addfte = nil
}

// Fte returns the value of the "fte" field in the mutation.
func (m *PositionAssignmentMutation) Fte() (r float64, exists bool) {
	v := m.fte
	if v == nil {
		return
	}
	return *v, true
}

// OldFte returns the old "fte" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldFte(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFte is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFte requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFte: %w", err)
	}
	return oldValue.Fte, nil
}

// AddFte adds f to the "fte" field.
func (m *PositionAssignmentMutation) AddFte(f float64) {
	if m.addfte != nil {
		*m.addfte += f
	} else {
		m.addfte = &f
	}
}

// AddedFte returns the value that was added to the "fte" field in this mutation.
func (m *PositionAssignmentMutation) AddedFte() (r float64, exists bool) {
	v := m.addfte
	if v == nil {
		return
	}
	return *v, true
}

// ResetFte resets all changes to the "fte" field.
func (m *PositionAssignmentMutation) ResetFte() {
	m.fte = nil
	m.addfte = nil
}

// SetAssignmentType sets the "assignment_type" field.
func (m *PositionAssignmentMutation) SetAssignmentType(pt positionassignment.AssignmentType) {
	m.assignment_type = &pt
}

// AssignmentType returns the value of the "assignment_type" field in the mutation.
func (m *PositionAssignmentMutation) AssignmentType() (r positionassignment.AssignmentType, exists bool) {
	v := m.assignment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentType returns the old "assignment_type" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldAssignmentType(ctx context.Context) (v positionassignment.AssignmentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentType: %w", err)
	}
	return oldValue.AssignmentType, nil
}

// ResetAssignmentType resets all changes to the "assignment_type" field.
func (m *PositionAssignmentMutation) ResetAssignmentType() {
	m.assignment_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PositionAssignment entity.
// If the PositionAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearPosition clears the "position" edge to the Position entity.
func (m *PositionAssignmentMutation) ClearPosition() {
	m.clearedposition = true
	m.clearedFields[positionassignment.FieldPositionID] = struct{}{}
}

// PositionCleared reports if the "position" edge to the Position entity was cleared.
func (m *PositionAssignmentMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionIDs returns the "position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *PositionAssignmentMutation) PositionIDs() (ids []uuid.UUID) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition resets all changes to the "position" edge.
func (m *PositionAssignmentMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *PositionAssignmentMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[positionassignment.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *PositionAssignmentMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PositionAssignmentMutation) EmployeeIDs() (ids []uuid.UUID) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *PositionAssignmentMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddDetailIDs adds the "details" edge to the AssignmentDetails entity by ids.
func (m *PositionAssignmentMutation) AddDetailIDs(ids ...uuid.UUID) {
	if m.details == nil {
		m.details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the AssignmentDetails entity.
func (m *PositionAssignmentMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the AssignmentDetails entity was cleared.
func (m *PositionAssignmentMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the AssignmentDetails entity by IDs.
func (m *PositionAssignmentMutation) RemoveDetailIDs(ids ...uuid.UUID) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the AssignmentDetails entity.
func (m *PositionAssignmentMutation) RemovedDetailsIDs() (ids []uuid.UUID) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *PositionAssignmentMutation) DetailsIDs() (ids []uuid.UUID) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *PositionAssignmentMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// AddHistoryIDs adds the "history" edge to the AssignmentHistory entity by ids.
func (m *PositionAssignmentMutation) AddHistoryIDs(ids ...uuid.UUID) {
	if m.history == nil {
		m.history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.history[ids[i]] = struct{}{}
	}
}

// ClearHistory clears the "history" edge to the AssignmentHistory entity.
func (m *PositionAssignmentMutation) ClearHistory() {
	m.clearedhistory = true
}

// HistoryCleared reports if the "history" edge to the AssignmentHistory entity was cleared.
func (m *PositionAssignmentMutation) HistoryCleared() bool {
	return m.clearedhistory
}

// RemoveHistoryIDs removes the "history" edge to the AssignmentHistory entity by IDs.
func (m *PositionAssignmentMutation) RemoveHistoryIDs(ids ...uuid.UUID) {
	if m.removedhistory == nil {
		m.removedhistory = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.history, ids[i])
		m.removedhistory[ids[i]] = struct{}{}
	}
}

// RemovedHistory returns the removed IDs of the "history" edge to the AssignmentHistory entity.
func (m *PositionAssignmentMutation) RemovedHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedhistory {
		ids = append(ids, id)
	}
	return
}

// HistoryIDs returns the "history" edge IDs in the mutation.
func (m *PositionAssignmentMutation) HistoryIDs() (ids []uuid.UUID) {
	for id := range m.history {
		ids = append(ids, id)
	}
	return
}

// ResetHistory resets all changes to the "history" edge.
func (m *PositionAssignmentMutation) ResetHistory() {
	m.history = nil
	m.clearedhistory = false
	m.removedhistory = nil
}

// Where appends a list predicates to the PositionAssignmentMutation builder.
func (m *PositionAssignmentMutation) Where(ps ...predicate.PositionAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PositionAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PositionAssignment).
func (m *PositionAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.tenant_id != nil {
		fields = append(fields, positionassignment.FieldTenantID)
	}
	if m.position != nil {
		fields = append(fields, positionassignment.FieldPositionID)
	}
	if m.employee != nil {
		fields = append(fields, positionassignment.FieldEmployeeID)
	}
	if m.start_date != nil {
		fields = append(fields, positionassignment.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, positionassignment.FieldEndDate)
	}
	if m.is_current != nil {
		fields = append(fields, positionassignment.FieldIsCurrent)
	}
	if m.fte != nil {
		fields = append(fields, positionassignment.FieldFte)
	}
	if m.assignment_type != nil {
		fields = append(fields, positionassignment.FieldAssignmentType)
	}
	if m.created_at != nil {
		fields = append(fields, positionassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, positionassignment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case positionassignment.FieldTenantID:
		return m.TenantID()
	case positionassignment.FieldPositionID:
		return m.PositionID()
	case positionassignment.FieldEmployeeID:
		return m.EmployeeID()
	case positionassignment.FieldStartDate:
		return m.StartDate()
	case positionassignment.FieldEndDate:
		return m.EndDate()
	case positionassignment.FieldIsCurrent:
		return m.IsCurrent()
	case positionassignment.FieldFte:
		return m.Fte()
	case positionassignment.FieldAssignmentType:
		return m.AssignmentType()
	case positionassignment.FieldCreatedAt:
		return m.CreatedAt()
	case positionassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case positionassignment.FieldTenantID:
		return m.OldTenantID(ctx)
	case positionassignment.FieldPositionID:
		return m.OldPositionID(ctx)
	case positionassignment.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case positionassignment.FieldStartDate:
		return m.OldStartDate(ctx)
	case positionassignment.FieldEndDate:
		return m.OldEndDate(ctx)
	case positionassignment.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case positionassignment.FieldFte:
		return m.OldFte(ctx)
	case positionassignment.FieldAssignmentType:
		return m.OldAssignmentType(ctx)
	case positionassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case positionassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PositionAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case positionassignment.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case positionassignment.FieldPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case positionassignment.FieldEmployeeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case positionassignment.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case positionassignment.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case positionassignment.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case positionassignment.FieldFte:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFte(v)
		return nil
	case positionassignment.FieldAssignmentType:
		v, ok := value.(positionassignment.AssignmentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentType(v)
		return nil
	case positionassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case positionassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PositionAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionAssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addfte != nil {
		fields = append(fields, positionassignment.FieldFte)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case positionassignment.FieldFte:
		return m.AddedFte()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case positionassignment.FieldFte:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFte(v)
		return nil
	}
	return fmt.Errorf("unknown PositionAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(positionassignment.FieldEndDate) {
		fields = append(fields, positionassignment.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionAssignmentMutation) ClearField(name string) error {
	switch name {
	case positionassignment.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown PositionAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionAssignmentMutation) ResetField(name string) error {
	switch name {
	case positionassignment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case positionassignment.FieldPositionID:
		m.ResetPositionID()
		return nil
	case positionassignment.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case positionassignment.FieldStartDate:
		m.ResetStartDate()
		return nil
	case positionassignment.FieldEndDate:
		m.ResetEndDate()
		return nil
	case positionassignment.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case positionassignment.FieldFte:
		m.ResetFte()
		return nil
	case positionassignment.FieldAssignmentType:
		m.ResetAssignmentType()
		return nil
	case positionassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case positionassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PositionAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.position != nil {
		edges = append(edges, positionassignment.EdgePosition)
	}
	if m.employee != nil {
		edges = append(edges, positionassignment.EdgeEmployee)
	}
	if m.details != nil {
		edges = append(edges, positionassignment.EdgeDetails)
	}
	if m.history != nil {
		edges = append(edges, positionassignment.EdgeHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case positionassignment.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case positionassignment.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case positionassignment.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	case positionassignment.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.history))
		for id := range m.history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddetails != nil {
		edges = append(edges, positionassignment.EdgeDetails)
	}
	if m.removedhistory != nil {
		edges = append(edges, positionassignment.EdgeHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionAssignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case positionassignment.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	case positionassignment.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.removedhistory))
		for id := range m.removedhistory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedposition {
		edges = append(edges, positionassignment.EdgePosition)
	}
	if m.clearedemployee {
		edges = append(edges, positionassignment.EdgeEmployee)
	}
	if m.cleareddetails {
		edges = append(edges, positionassignment.EdgeDetails)
	}
	if m.clearedhistory {
		edges = append(edges, positionassignment.EdgeHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case positionassignment.EdgePosition:
		return m.clearedposition
	case positionassignment.EdgeEmployee:
		return m.clearedemployee
	case positionassignment.EdgeDetails:
		return m.cleareddetails
	case positionassignment.EdgeHistory:
		return m.clearedhistory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case positionassignment.EdgePosition:
		m.ClearPosition()
		return nil
	case positionassignment.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown PositionAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case positionassignment.EdgePosition:
		m.ResetPosition()
		return nil
	case positionassignment.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case positionassignment.EdgeDetails:
		m.ResetDetails()
		return nil
	case positionassignment.EdgeHistory:
		m.ResetHistory()
		return nil
	}
	return fmt.Errorf("unknown PositionAssignment edge %s", name)
}

// PositionAttributeHistoryMutation represents an operation that mutates the PositionAttributeHistory nodes in the graph.
type PositionAttributeHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	tenant_id           *uuid.UUID
	position_type       *string
	job_profile_id      *uuid.UUID
	department_id       *uuid.UUID
	manager_position_id *uuid.UUID
	status              *string
	budgeted_fte        *float64
	addbudgeted_fte     *float64
	details             *map[string]interface{}
	effective_date      *time.Time
	end_date            *time.Time
	change_reason       *string
	changed_by          *uuid.UUID
	change_type         *string
	source_event_id     *uuid.UUID
	created_at          *time.Time
	clearedFields       map[string]struct{}
	position            *uuid.UUID
	clearedposition     bool
	done                bool
	oldValue            func(context.Context) (*PositionAttributeHistory, error)
	predicates          []predicate.PositionAttributeHistory
}

var _ ent.Mutation = (*PositionAttributeHistoryMutation)(nil)

// positionattributehistoryOption allows management of the mutation configuration using functional options.
type positionattributehistoryOption func(*PositionAttributeHistoryMutation)

// newPositionAttributeHistoryMutation creates new mutation for the PositionAttributeHistory entity.
func newPositionAttributeHistoryMutation(c config, op Op, opts ...positionattributehistoryOption) *PositionAttributeHistoryMutation {
	m := &PositionAttributeHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePositionAttributeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionAttributeHistoryID sets the ID field of the mutation.
func withPositionAttributeHistoryID(id uuid.UUID) positionattributehistoryOption {
	return func(m *PositionAttributeHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionAttributeHistory
		)
		m.oldValue = func(ctx context.Context) (*PositionAttributeHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionAttributeHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionAttributeHistory sets the old PositionAttributeHistory of the mutation.
func withPositionAttributeHistory(node *PositionAttributeHistory) positionattributehistoryOption {
	return func(m *PositionAttributeHistoryMutation) {
		m.oldValue = func(context.Context) (*PositionAttributeHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionAttributeHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionAttributeHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PositionAttributeHistory entities.
func (m *PositionAttributeHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionAttributeHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionAttributeHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PositionAttributeHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PositionAttributeHistoryMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PositionAttributeHistoryMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PositionAttributeHistoryMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *PositionAttributeHistoryMutation) SetPositionID(u uuid.UUID) {
	m.position = &u
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *PositionAttributeHistoryMutation) PositionID() (r uuid.UUID, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldPositionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *PositionAttributeHistoryMutation) ResetPositionID() {
	m.position = nil
}

// SetPositionType sets the "position_type" field.
func (m *PositionAttributeHistoryMutation) SetPositionType(s string) {
	m.position_type = &s
}

// PositionType returns the value of the "position_type" field in the mutation.
func (m *PositionAttributeHistoryMutation) PositionType() (r string, exists bool) {
	v := m.position_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionType returns the old "position_type" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldPositionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionType: %w", err)
	}
	return oldValue.PositionType, nil
}

// ResetPositionType resets all changes to the "position_type" field.
func (m *PositionAttributeHistoryMutation) ResetPositionType() {
	m.position_type = nil
}

// SetJobProfileID sets the "job_profile_id" field.
func (m *PositionAttributeHistoryMutation) SetJobProfileID(u uuid.UUID) {
	m.job_profile_id = &u
}

// JobProfileID returns the value of the "job_profile_id" field in the mutation.
func (m *PositionAttributeHistoryMutation) JobProfileID() (r uuid.UUID, exists bool) {
	v := m.job_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobProfileID returns the old "job_profile_id" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldJobProfileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobProfileID: %w", err)
	}
	return oldValue.JobProfileID, nil
}

// ResetJobProfileID resets all changes to the "job_profile_id" field.
func (m *PositionAttributeHistoryMutation) ResetJobProfileID() {
	m.job_profile_id = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *PositionAttributeHistoryMutation) SetDepartmentID(u uuid.UUID) {
	m.department_id = &u
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *PositionAttributeHistoryMutation) DepartmentID() (r uuid.UUID, exists bool) {
	v := m.department_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldDepartmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *PositionAttributeHistoryMutation) ResetDepartmentID() {
	m.department_id = nil
}

// SetManagerPositionID sets the "manager_position_id" field.
func (m *PositionAttributeHistoryMutation) SetManagerPositionID(u uuid.UUID) {
	m.manager_position_id = &u
}

// ManagerPositionID returns the value of the "manager_position_id" field in the mutation.
func (m *PositionAttributeHistoryMutation) ManagerPositionID() (r uuid.UUID, exists bool) {
	v := m.manager_position_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerPositionID returns the old "manager_position_id" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldManagerPositionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerPositionID: %w", err)
	}
	return oldValue.ManagerPositionID, nil
}

// ClearManagerPositionID clears the value of the "manager_position_id" field.
func (m *PositionAttributeHistoryMutation) ClearManagerPositionID() {
	m.manager_position_id = nil
	m.clearedFields[positionattributehistory.FieldManagerPositionID] = struct{}{}
}

// ManagerPositionIDCleared returns if the "manager_position_id" field was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) ManagerPositionIDCleared() bool {
	_, ok := m.clearedFields[positionattributehistory.FieldManagerPositionID]
	return ok
}

// ResetManagerPositionID resets all changes to the "manager_position_id" field.
func (m *PositionAttributeHistoryMutation) ResetManagerPositionID() {
	m.manager_position_id = nil
	delete(m.clearedFields, positionattributehistory.FieldManagerPositionID)
}

// SetStatus sets the "status" field.
func (m *PositionAttributeHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PositionAttributeHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PositionAttributeHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetBudgetedFte sets the "budgeted_fte" field.
func (m *PositionAttributeHistoryMutation) SetBudgetedFte(f float64) {
	m.budgeted_fte = &f
	m.addbudgeted_fte = nil
}

// BudgetedFte returns the value of the "budgeted_fte" field in the mutation.
func (m *PositionAttributeHistoryMutation) BudgetedFte() (r float64, exists bool) {
	v := m.budgeted_fte
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetedFte returns the old "budgeted_fte" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldBudgetedFte(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetedFte is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetedFte requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetedFte: %w", err)
	}
	return oldValue.BudgetedFte, nil
}

// AddBudgetedFte adds f to the "budgeted_fte" field.
func (m *PositionAttributeHistoryMutation) AddBudgetedFte(f float64) {
	if m.addbudgeted_fte != nil {
		*m.addbudgeted_fte += f
	} else {
		m.addbudgeted_fte = &f
	}
}

// AddedBudgetedFte returns the value that was added to the "budgeted_fte" field in this mutation.
func (m *PositionAttributeHistoryMutation) AddedBudgetedFte() (r float64, exists bool) {
	v := m.addbudgeted_fte
	if v == nil {
		return
	}
	return *v, true
}

// ResetBudgetedFte resets all changes to the "budgeted_fte" field.
func (m *PositionAttributeHistoryMutation) ResetBudgetedFte() {
	m.budgeted_fte = nil
	m.addbudgeted_fte = nil
}

// SetDetails sets the "details" field.
func (m *PositionAttributeHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *PositionAttributeHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *PositionAttributeHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[positionattributehistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[positionattributehistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *PositionAttributeHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, positionattributehistory.FieldDetails)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *PositionAttributeHistoryMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *PositionAttributeHistoryMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *PositionAttributeHistoryMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *PositionAttributeHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PositionAttributeHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PositionAttributeHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[positionattributehistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[positionattributehistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PositionAttributeHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, positionattributehistory.FieldEndDate)
}

// SetChangeReason sets the "change_reason" field.
func (m *PositionAttributeHistoryMutation) SetChangeReason(s string) {
	m.change_reason = &s
}

// ChangeReason returns the value of the "change_reason" field in the mutation.
func (m *PositionAttributeHistoryMutation) ChangeReason() (r string, exists bool) {
	v := m.change_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeReason returns the old "change_reason" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldChangeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeReason: %w", err)
	}
	return oldValue.ChangeReason, nil
}

// ClearChangeReason clears the value of the "change_reason" field.
func (m *PositionAttributeHistoryMutation) ClearChangeReason() {
	m.change_reason = nil
	m.clearedFields[positionattributehistory.FieldChangeReason] = struct{}{}
}

// ChangeReasonCleared returns if the "change_reason" field was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) ChangeReasonCleared() bool {
	_, ok := m.clearedFields[positionattributehistory.FieldChangeReason]
	return ok
}

// ResetChangeReason resets all changes to the "change_reason" field.
func (m *PositionAttributeHistoryMutation) ResetChangeReason() {
	m.change_reason = nil
	delete(m.clearedFields, positionattributehistory.FieldChangeReason)
}

// SetChangedBy sets the "changed_by" field.
func (m *PositionAttributeHistoryMutation) SetChangedBy(u uuid.UUID) {
	m.changed_by = &u
}

// ChangedBy returns the value of the "changed_by" field in the mutation.
func (m *PositionAttributeHistoryMutation) ChangedBy() (r uuid.UUID, exists bool) {
	v := m.changed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldChangedBy returns the old "changed_by" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldChangedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangedBy: %w", err)
	}
	return oldValue.ChangedBy, nil
}

// ResetChangedBy resets all changes to the "changed_by" field.
func (m *PositionAttributeHistoryMutation) ResetChangedBy() {
	m.changed_by = nil
}

// SetChangeType sets the "change_type" field.
func (m *PositionAttributeHistoryMutation) SetChangeType(s string) {
	m.change_type = &s
}

// ChangeType returns the value of the "change_type" field in the mutation.
func (m *PositionAttributeHistoryMutation) ChangeType() (r string, exists bool) {
	v := m.change_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeType returns the old "change_type" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldChangeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeType: %w", err)
	}
	return oldValue.ChangeType, nil
}

// ClearChangeType clears the value of the "change_type" field.
func (m *PositionAttributeHistoryMutation) ClearChangeType() {
	m.change_type = nil
	m.clearedFields[positionattributehistory.FieldChangeType] = struct{}{}
}

// ChangeTypeCleared returns if the "change_type" field was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) ChangeTypeCleared() bool {
	_, ok := m.clearedFields[positionattributehistory.FieldChangeType]
	return ok
}

// ResetChangeType resets all changes to the "change_type" field.
func (m *PositionAttributeHistoryMutation) ResetChangeType() {
	m.change_type = nil
	delete(m.clearedFields, positionattributehistory.FieldChangeType)
}

// SetSourceEventID sets the "source_event_id" field.
func (m *PositionAttributeHistoryMutation) SetSourceEventID(u uuid.UUID) {
	m.source_event_id = &u
}

// SourceEventID returns the value of the "source_event_id" field in the mutation.
func (m *PositionAttributeHistoryMutation) SourceEventID() (r uuid.UUID, exists bool) {
	v := m.source_event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceEventID returns the old "source_event_id" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldSourceEventID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceEventID: %w", err)
	}
	return oldValue.SourceEventID, nil
}

// ClearSourceEventID clears the value of the "source_event_id" field.
func (m *PositionAttributeHistoryMutation) ClearSourceEventID() {
	m.source_event_id = nil
	m.clearedFields[positionattributehistory.FieldSourceEventID] = struct{}{}
}

// SourceEventIDCleared returns if the "source_event_id" field was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) SourceEventIDCleared() bool {
	_, ok := m.clearedFields[positionattributehistory.FieldSourceEventID]
	return ok
}

// ResetSourceEventID resets all changes to the "source_event_id" field.
func (m *PositionAttributeHistoryMutation) ResetSourceEventID() {
	m.source_event_id = nil
	delete(m.clearedFields, positionattributehistory.FieldSourceEventID)
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionAttributeHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionAttributeHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PositionAttributeHistory entity.
// If the PositionAttributeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionAttributeHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionAttributeHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearPosition clears the "position" edge to the Position entity.
func (m *PositionAttributeHistoryMutation) ClearPosition() {
	m.clearedposition = true
	m.clearedFields[positionattributehistory.FieldPositionID] = struct{}{}
}

// PositionCleared reports if the "position" edge to the Position entity was cleared.
func (m *PositionAttributeHistoryMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionIDs returns the "position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *PositionAttributeHistoryMutation) PositionIDs() (ids []uuid.UUID) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition resets all changes to the "position" edge.
func (m *PositionAttributeHistoryMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// Where appends a list predicates to the PositionAttributeHistoryMutation builder.
func (m *PositionAttributeHistoryMutation) Where(ps ...predicate.PositionAttributeHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionAttributeHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionAttributeHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PositionAttributeHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionAttributeHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionAttributeHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PositionAttributeHistory).
func (m *PositionAttributeHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionAttributeHistoryMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.tenant_id != nil {
		fields = append(fields, positionattributehistory.FieldTenantID)
	}
	if m.position != nil {
		fields = append(fields, positionattributehistory.FieldPositionID)
	}
	if m.position_type != nil {
		fields = append(fields, positionattributehistory.FieldPositionType)
	}
	if m.job_profile_id != nil {
		fields = append(fields, positionattributehistory.FieldJobProfileID)
	}
	if m.department_id != nil {
		fields = append(fields, positionattributehistory.FieldDepartmentID)
	}
	if m.manager_position_id != nil {
		fields = append(fields, positionattributehistory.FieldManagerPositionID)
	}
	if m.status != nil {
		fields = append(fields, positionattributehistory.FieldStatus)
	}
	if m.budgeted_fte != nil {
		fields = append(fields, positionattributehistory.FieldBudgetedFte)
	}
	if m.details != nil {
		fields = append(fields, positionattributehistory.FieldDetails)
	}
	if m.effective_date != nil {
		fields = append(fields, positionattributehistory.FieldEffectiveDate)
	}
	if m.end_date != nil {
		fields = append(fields, positionattributehistory.FieldEndDate)
	}
	if m.change_reason != nil {
		fields = append(fields, positionattributehistory.FieldChangeReason)
	}
	if m.changed_by != nil {
		fields = append(fields, positionattributehistory.FieldChangedBy)
	}
	if m.change_type != nil {
		fields = append(fields, positionattributehistory.FieldChangeType)
	}
	if m.source_event_id != nil {
		fields = append(fields, positionattributehistory.FieldSourceEventID)
	}
	if m.created_at != nil {
		fields = append(fields, positionattributehistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionAttributeHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case positionattributehistory.FieldTenantID:
		return m.TenantID()
	case positionattributehistory.FieldPositionID:
		return m.PositionID()
	case positionattributehistory.FieldPositionType:
		return m.PositionType()
	case positionattributehistory.FieldJobProfileID:
		return m.JobProfileID()
	case positionattributehistory.FieldDepartmentID:
		return m.DepartmentID()
	case positionattributehistory.FieldManagerPositionID:
		return m.ManagerPositionID()
	case positionattributehistory.FieldStatus:
		return m.Status()
	case positionattributehistory.FieldBudgetedFte:
		return m.BudgetedFte()
	case positionattributehistory.FieldDetails:
		return m.Details()
	case positionattributehistory.FieldEffectiveDate:
		return m.EffectiveDate()
	case positionattributehistory.FieldEndDate:
		return m.EndDate()
	case positionattributehistory.FieldChangeReason:
		return m.ChangeReason()
	case positionattributehistory.FieldChangedBy:
		return m.ChangedBy()
	case positionattributehistory.FieldChangeType:
		return m.ChangeType()
	case positionattributehistory.FieldSourceEventID:
		return m.SourceEventID()
	case positionattributehistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionAttributeHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case positionattributehistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case positionattributehistory.FieldPositionID:
		return m.OldPositionID(ctx)
	case positionattributehistory.FieldPositionType:
		return m.OldPositionType(ctx)
	case positionattributehistory.FieldJobProfileID:
		return m.OldJobProfileID(ctx)
	case positionattributehistory.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case positionattributehistory.FieldManagerPositionID:
		return m.OldManagerPositionID(ctx)
	case positionattributehistory.FieldStatus:
		return m.OldStatus(ctx)
	case positionattributehistory.FieldBudgetedFte:
		return m.OldBudgetedFte(ctx)
	case positionattributehistory.FieldDetails:
		return m.OldDetails(ctx)
	case positionattributehistory.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case positionattributehistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case positionattributehistory.FieldChangeReason:
		return m.OldChangeReason(ctx)
	case positionattributehistory.FieldChangedBy:
		return m.OldChangedBy(ctx)
	case positionattributehistory.FieldChangeType:
		return m.OldChangeType(ctx)
	case positionattributehistory.FieldSourceEventID:
		return m.OldSourceEventID(ctx)
	case positionattributehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PositionAttributeHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionAttributeHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case positionattributehistory.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case positionattributehistory.FieldPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case positionattributehistory.FieldPositionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionType(v)
		return nil
	case positionattributehistory.FieldJobProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobProfileID(v)
		return nil
	case positionattributehistory.FieldDepartmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case positionattributehistory.FieldManagerPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerPositionID(v)
		return nil
	case positionattributehistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case positionattributehistory.FieldBudgetedFte:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetedFte(v)
		return nil
	case positionattributehistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case positionattributehistory.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case positionattributehistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case positionattributehistory.FieldChangeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeReason(v)
		return nil
	case positionattributehistory.FieldChangedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangedBy(v)
		return nil
	case positionattributehistory.FieldChangeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeType(v)
		return nil
	case positionattributehistory.FieldSourceEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceEventID(v)
		return nil
	case positionattributehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PositionAttributeHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionAttributeHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addbudgeted_fte != nil {
		fields = append(fields, positionattributehistory.FieldBudgetedFte)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionAttributeHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case positionattributehistory.FieldBudgetedFte:
		return m.AddedBudgetedFte()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionAttributeHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case positionattributehistory.FieldBudgetedFte:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetedFte(v)
		return nil
	}
	return fmt.Errorf("unknown PositionAttributeHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionAttributeHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(positionattributehistory.FieldManagerPositionID) {
		fields = append(fields, positionattributehistory.FieldManagerPositionID)
	}
	if m.FieldCleared(positionattributehistory.FieldDetails) {
		fields = append(fields, positionattributehistory.FieldDetails)
	}
	if m.FieldCleared(positionattributehistory.FieldEndDate) {
		fields = append(fields, positionattributehistory.FieldEndDate)
	}
	if m.FieldCleared(positionattributehistory.FieldChangeReason) {
		fields = append(fields, positionattributehistory.FieldChangeReason)
	}
	if m.FieldCleared(positionattributehistory.FieldChangeType) {
		fields = append(fields, positionattributehistory.FieldChangeType)
	}
	if m.FieldCleared(positionattributehistory.FieldSourceEventID) {
		fields = append(fields, positionattributehistory.FieldSourceEventID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionAttributeHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionAttributeHistoryMutation) ClearField(name string) error {
	switch name {
	case positionattributehistory.FieldManagerPositionID:
		m.ClearManagerPositionID()
		return nil
	case positionattributehistory.FieldDetails:
		m.ClearDetails()
		return nil
	case positionattributehistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	case positionattributehistory.FieldChangeReason:
		m.ClearChangeReason()
		return nil
	case positionattributehistory.FieldChangeType:
		m.ClearChangeType()
		return nil
	case positionattributehistory.FieldSourceEventID:
		m.ClearSourceEventID()
		return nil
	}
	return fmt.Errorf("unknown PositionAttributeHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionAttributeHistoryMutation) ResetField(name string) error {
	switch name {
	case positionattributehistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case positionattributehistory.FieldPositionID:
		m.ResetPositionID()
		return nil
	case positionattributehistory.FieldPositionType:
		m.ResetPositionType()
		return nil
	case positionattributehistory.FieldJobProfileID:
		m.ResetJobProfileID()
		return nil
	case positionattributehistory.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case positionattributehistory.FieldManagerPositionID:
		m.ResetManagerPositionID()
		return nil
	case positionattributehistory.FieldStatus:
		m.ResetStatus()
		return nil
	case positionattributehistory.FieldBudgetedFte:
		m.ResetBudgetedFte()
		return nil
	case positionattributehistory.FieldDetails:
		m.ResetDetails()
		return nil
	case positionattributehistory.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case positionattributehistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case positionattributehistory.FieldChangeReason:
		m.ResetChangeReason()
		return nil
	case positionattributehistory.FieldChangedBy:
		m.ResetChangedBy()
		return nil
	case positionattributehistory.FieldChangeType:
		m.ResetChangeType()
		return nil
	case positionattributehistory.FieldSourceEventID:
		m.ResetSourceEventID()
		return nil
	case positionattributehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PositionAttributeHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionAttributeHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.position != nil {
		edges = append(edges, positionattributehistory.EdgePosition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionAttributeHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case positionattributehistory.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionAttributeHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionAttributeHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionAttributeHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposition {
		edges = append(edges, positionattributehistory.EdgePosition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionAttributeHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case positionattributehistory.EdgePosition:
		return m.clearedposition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionAttributeHistoryMutation) ClearEdge(name string) error {
	switch name {
	case positionattributehistory.EdgePosition:
		m.ClearPosition()
		return nil
	}
	return fmt.Errorf("unknown PositionAttributeHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionAttributeHistoryMutation) ResetEdge(name string) error {
	switch name {
	case positionattributehistory.EdgePosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown PositionAttributeHistory edge %s", name)
}

// PositionHistoryMutation represents an operation that mutates the PositionHistory nodes in the graph.
type PositionHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	employee_id     *string
	organization_id *string
	position_title  *string
	department      *string
	effective_date  *time.Time
	end_date        *time.Time
	is_active       *bool
	is_retroactive  *bool
	salary_data     *map[string]interface{}
	change_reason   *string
	approval_status *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PositionHistory, error)
	predicates      []predicate.PositionHistory
}

var _ ent.Mutation = (*PositionHistoryMutation)(nil)

// positionhistoryOption allows management of the mutation configuration using functional options.
type positionhistoryOption func(*PositionHistoryMutation)

// newPositionHistoryMutation creates new mutation for the PositionHistory entity.
func newPositionHistoryMutation(c config, op Op, opts ...positionhistoryOption) *PositionHistoryMutation {
	m := &PositionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePositionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionHistoryID sets the ID field of the mutation.
func withPositionHistoryID(id string) positionhistoryOption {
	return func(m *PositionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionHistory
		)
		m.oldValue = func(ctx context.Context) (*PositionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionHistory sets the old PositionHistory of the mutation.
func withPositionHistory(node *PositionHistory) positionhistoryOption {
	return func(m *PositionHistoryMutation) {
		m.oldValue = func(context.Context) (*PositionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PositionHistory entities.
func (m *PositionHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PositionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *PositionHistoryMutation) SetEmployeeID(s string) {
	m.employee_id = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *PositionHistoryMutation) EmployeeID() (r string, exists bool) {
	v := m.employee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *PositionHistoryMutation) ResetEmployeeID() {
	m.employee_id = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *PositionHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *PositionHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *PositionHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetPositionTitle sets the "position_title" field.
func (m *PositionHistoryMutation) SetPositionTitle(s string) {
	m.position_title = &s
}

// PositionTitle returns the value of the "position_title" field in the mutation.
func (m *PositionHistoryMutation) PositionTitle() (r string, exists bool) {
	v := m.position_title
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionTitle returns the old "position_title" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldPositionTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionTitle: %w", err)
	}
	return oldValue.PositionTitle, nil
}

// ResetPositionTitle resets all changes to the "position_title" field.
func (m *PositionHistoryMutation) ResetPositionTitle() {
	m.position_title = nil
}

// SetDepartment sets the "department" field.
func (m *PositionHistoryMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *PositionHistoryMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ResetDepartment resets all changes to the "department" field.
func (m *PositionHistoryMutation) ResetDepartment() {
	m.department = nil
}

// SetEffectiveDate sets the "effective_date" field.
func (m *PositionHistoryMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *PositionHistoryMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *PositionHistoryMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *PositionHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PositionHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PositionHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[positionhistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PositionHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[positionhistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PositionHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, positionhistory.FieldEndDate)
}

// SetIsActive sets the "is_active" field.
func (m *PositionHistoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PositionHistoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PositionHistoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsRetroactive sets the "is_retroactive" field.
func (m *PositionHistoryMutation) SetIsRetroactive(b bool) {
	m.is_retroactive = &b
}

// IsRetroactive returns the value of the "is_retroactive" field in the mutation.
func (m *PositionHistoryMutation) IsRetroactive() (r bool, exists bool) {
	v := m.is_retroactive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRetroactive returns the old "is_retroactive" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldIsRetroactive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRetroactive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRetroactive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRetroactive: %w", err)
	}
	return oldValue.IsRetroactive, nil
}

// ResetIsRetroactive resets all changes to the "is_retroactive" field.
func (m *PositionHistoryMutation) ResetIsRetroactive() {
	m.is_retroactive = nil
}

// SetSalaryData sets the "salary_data" field.
func (m *PositionHistoryMutation) SetSalaryData(value map[string]interface{}) {
	m.salary_data = &value
}

// SalaryData returns the value of the "salary_data" field in the mutation.
func (m *PositionHistoryMutation) SalaryData() (r map[string]interface{}, exists bool) {
	v := m.salary_data
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryData returns the old "salary_data" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldSalaryData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryData: %w", err)
	}
	return oldValue.SalaryData, nil
}

// ClearSalaryData clears the value of the "salary_data" field.
func (m *PositionHistoryMutation) ClearSalaryData() {
	m.salary_data = nil
	m.clearedFields[positionhistory.FieldSalaryData] = struct{}{}
}

// SalaryDataCleared returns if the "salary_data" field was cleared in this mutation.
func (m *PositionHistoryMutation) SalaryDataCleared() bool {
	_, ok := m.clearedFields[positionhistory.FieldSalaryData]
	return ok
}

// ResetSalaryData resets all changes to the "salary_data" field.
func (m *PositionHistoryMutation) ResetSalaryData() {
	m.salary_data = nil
	delete(m.clearedFields, positionhistory.FieldSalaryData)
}

// SetChangeReason sets the "change_reason" field.
func (m *PositionHistoryMutation) SetChangeReason(s string) {
	m.change_reason = &s
}

// ChangeReason returns the value of the "change_reason" field in the mutation.
func (m *PositionHistoryMutation) ChangeReason() (r string, exists bool) {
	v := m.change_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeReason returns the old "change_reason" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldChangeReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeReason: %w", err)
	}
	return oldValue.ChangeReason, nil
}

// ClearChangeReason clears the value of the "change_reason" field.
func (m *PositionHistoryMutation) ClearChangeReason() {
	m.change_reason = nil
	m.clearedFields[positionhistory.FieldChangeReason] = struct{}{}
}

// ChangeReasonCleared returns if the "change_reason" field was cleared in this mutation.
func (m *PositionHistoryMutation) ChangeReasonCleared() bool {
	_, ok := m.clearedFields[positionhistory.FieldChangeReason]
	return ok
}

// ResetChangeReason resets all changes to the "change_reason" field.
func (m *PositionHistoryMutation) ResetChangeReason() {
	m.change_reason = nil
	delete(m.clearedFields, positionhistory.FieldChangeReason)
}

// SetApprovalStatus sets the "approval_status" field.
func (m *PositionHistoryMutation) SetApprovalStatus(s string) {
	m.approval_status = &s
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *PositionHistoryMutation) ApprovalStatus() (r string, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldApprovalStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *PositionHistoryMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PositionHistory entity.
// If the PositionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the PositionHistoryMutation builder.
func (m *PositionHistoryMutation) Where(ps ...predicate.PositionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PositionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PositionHistory).
func (m *PositionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.employee_id != nil {
		fields = append(fields, positionhistory.FieldEmployeeID)
	}
	if m.organization_id != nil {
		fields = append(fields, positionhistory.FieldOrganizationID)
	}
	if m.position_title != nil {
		fields = append(fields, positionhistory.FieldPositionTitle)
	}
	if m.department != nil {
		fields = append(fields, positionhistory.FieldDepartment)
	}
	if m.effective_date != nil {
		fields = append(fields, positionhistory.FieldEffectiveDate)
	}
	if m.end_date != nil {
		fields = append(fields, positionhistory.FieldEndDate)
	}
	if m.is_active != nil {
		fields = append(fields, positionhistory.FieldIsActive)
	}
	if m.is_retroactive != nil {
		fields = append(fields, positionhistory.FieldIsRetroactive)
	}
	if m.salary_data != nil {
		fields = append(fields, positionhistory.FieldSalaryData)
	}
	if m.change_reason != nil {
		fields = append(fields, positionhistory.FieldChangeReason)
	}
	if m.approval_status != nil {
		fields = append(fields, positionhistory.FieldApprovalStatus)
	}
	if m.created_at != nil {
		fields = append(fields, positionhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, positionhistory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case positionhistory.FieldEmployeeID:
		return m.EmployeeID()
	case positionhistory.FieldOrganizationID:
		return m.OrganizationID()
	case positionhistory.FieldPositionTitle:
		return m.PositionTitle()
	case positionhistory.FieldDepartment:
		return m.Department()
	case positionhistory.FieldEffectiveDate:
		return m.EffectiveDate()
	case positionhistory.FieldEndDate:
		return m.EndDate()
	case positionhistory.FieldIsActive:
		return m.IsActive()
	case positionhistory.FieldIsRetroactive:
		return m.IsRetroactive()
	case positionhistory.FieldSalaryData:
		return m.SalaryData()
	case positionhistory.FieldChangeReason:
		return m.ChangeReason()
	case positionhistory.FieldApprovalStatus:
		return m.ApprovalStatus()
	case positionhistory.FieldCreatedAt:
		return m.CreatedAt()
	case positionhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case positionhistory.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case positionhistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case positionhistory.FieldPositionTitle:
		return m.OldPositionTitle(ctx)
	case positionhistory.FieldDepartment:
		return m.OldDepartment(ctx)
	case positionhistory.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case positionhistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case positionhistory.FieldIsActive:
		return m.OldIsActive(ctx)
	case positionhistory.FieldIsRetroactive:
		return m.OldIsRetroactive(ctx)
	case positionhistory.FieldSalaryData:
		return m.OldSalaryData(ctx)
	case positionhistory.FieldChangeReason:
		return m.OldChangeReason(ctx)
	case positionhistory.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case positionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case positionhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PositionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case positionhistory.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case positionhistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case positionhistory.FieldPositionTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionTitle(v)
		return nil
	case positionhistory.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case positionhistory.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case positionhistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case positionhistory.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case positionhistory.FieldIsRetroactive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRetroactive(v)
		return nil
	case positionhistory.FieldSalaryData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryData(v)
		return nil
	case positionhistory.FieldChangeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeReason(v)
		return nil
	case positionhistory.FieldApprovalStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case positionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case positionhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PositionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PositionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(positionhistory.FieldEndDate) {
		fields = append(fields, positionhistory.FieldEndDate)
	}
	if m.FieldCleared(positionhistory.FieldSalaryData) {
		fields = append(fields, positionhistory.FieldSalaryData)
	}
	if m.FieldCleared(positionhistory.FieldChangeReason) {
		fields = append(fields, positionhistory.FieldChangeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionHistoryMutation) ClearField(name string) error {
	switch name {
	case positionhistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	case positionhistory.FieldSalaryData:
		m.ClearSalaryData()
		return nil
	case positionhistory.FieldChangeReason:
		m.ClearChangeReason()
		return nil
	}
	return fmt.Errorf("unknown PositionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionHistoryMutation) ResetField(name string) error {
	switch name {
	case positionhistory.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case positionhistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case positionhistory.FieldPositionTitle:
		m.ResetPositionTitle()
		return nil
	case positionhistory.FieldDepartment:
		m.ResetDepartment()
		return nil
	case positionhistory.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case positionhistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case positionhistory.FieldIsActive:
		m.ResetIsActive()
		return nil
	case positionhistory.FieldIsRetroactive:
		m.ResetIsRetroactive()
		return nil
	case positionhistory.FieldSalaryData:
		m.ResetSalaryData()
		return nil
	case positionhistory.FieldChangeReason:
		m.ResetChangeReason()
		return nil
	case positionhistory.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case positionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case positionhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PositionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PositionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PositionHistory edge %s", name)
}

// PositionOccupancyHistoryMutation represents an operation that mutates the PositionOccupancyHistory nodes in the graph.
type PositionOccupancyHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	tenant_id                *uuid.UUID
	start_date               *time.Time
	end_date                 *time.Time
	is_active                *bool
	assignment_type          *positionoccupancyhistory.AssignmentType
	assignment_reason        *string
	fte_percentage           *float64
	addfte_percentage        *float64
	work_arrangement         *positionoccupancyhistory.WorkArrangement
	approved_by              *uuid.UUID
	approval_date            *time.Time
	approval_reference       *string
	compensation_data        *map[string]interface{}
	performance_review_cycle *string
	source_event_id          *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	position                 *uuid.UUID
	clearedposition          bool
	employee                 *uuid.UUID
	clearedemployee          bool
	done                     bool
	oldValue                 func(context.Context) (*PositionOccupancyHistory, error)
	predicates               []predicate.PositionOccupancyHistory
}

var _ ent.Mutation = (*PositionOccupancyHistoryMutation)(nil)

// positionoccupancyhistoryOption allows management of the mutation configuration using functional options.
type positionoccupancyhistoryOption func(*PositionOccupancyHistoryMutation)

// newPositionOccupancyHistoryMutation creates new mutation for the PositionOccupancyHistory entity.
func newPositionOccupancyHistoryMutation(c config, op Op, opts ...positionoccupancyhistoryOption) *PositionOccupancyHistoryMutation {
	m := &PositionOccupancyHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePositionOccupancyHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionOccupancyHistoryID sets the ID field of the mutation.
func withPositionOccupancyHistoryID(id uuid.UUID) positionoccupancyhistoryOption {
	return func(m *PositionOccupancyHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionOccupancyHistory
		)
		m.oldValue = func(ctx context.Context) (*PositionOccupancyHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionOccupancyHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionOccupancyHistory sets the old PositionOccupancyHistory of the mutation.
func withPositionOccupancyHistory(node *PositionOccupancyHistory) positionoccupancyhistoryOption {
	return func(m *PositionOccupancyHistoryMutation) {
		m.oldValue = func(context.Context) (*PositionOccupancyHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionOccupancyHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionOccupancyHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PositionOccupancyHistory entities.
func (m *PositionOccupancyHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionOccupancyHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionOccupancyHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PositionOccupancyHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PositionOccupancyHistoryMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PositionOccupancyHistoryMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PositionOccupancyHistoryMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetPositionID sets the "position_id" field.
func (m *PositionOccupancyHistoryMutation) SetPositionID(u uuid.UUID) {
	m.position = &u
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *PositionOccupancyHistoryMutation) PositionID() (r uuid.UUID, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldPositionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *PositionOccupancyHistoryMutation) ResetPositionID() {
	m.position = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *PositionOccupancyHistoryMutation) SetEmployeeID(u uuid.UUID) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *PositionOccupancyHistoryMutation) EmployeeID() (r uuid.UUID, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldEmployeeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *PositionOccupancyHistoryMutation) ResetEmployeeID() {
	m.employee = nil
}

// SetStartDate sets the "start_date" field.
func (m *PositionOccupancyHistoryMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *PositionOccupancyHistoryMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *PositionOccupancyHistoryMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *PositionOccupancyHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PositionOccupancyHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PositionOccupancyHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[positionoccupancyhistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PositionOccupancyHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldEndDate)
}

// SetIsActive sets the "is_active" field.
func (m *PositionOccupancyHistoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PositionOccupancyHistoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PositionOccupancyHistoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetAssignmentType sets the "assignment_type" field.
func (m *PositionOccupancyHistoryMutation) SetAssignmentType(pt positionoccupancyhistory.AssignmentType) {
	m.assignment_type = &pt
}

// AssignmentType returns the value of the "assignment_type" field in the mutation.
func (m *PositionOccupancyHistoryMutation) AssignmentType() (r positionoccupancyhistory.AssignmentType, exists bool) {
	v := m.assignment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentType returns the old "assignment_type" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldAssignmentType(ctx context.Context) (v positionoccupancyhistory.AssignmentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentType: %w", err)
	}
	return oldValue.AssignmentType, nil
}

// ResetAssignmentType resets all changes to the "assignment_type" field.
func (m *PositionOccupancyHistoryMutation) ResetAssignmentType() {
	m.assignment_type = nil
}

// SetAssignmentReason sets the "assignment_reason" field.
func (m *PositionOccupancyHistoryMutation) SetAssignmentReason(s string) {
	m.assignment_reason = &s
}

// AssignmentReason returns the value of the "assignment_reason" field in the mutation.
func (m *PositionOccupancyHistoryMutation) AssignmentReason() (r string, exists bool) {
	v := m.assignment_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentReason returns the old "assignment_reason" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldAssignmentReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentReason: %w", err)
	}
	return oldValue.AssignmentReason, nil
}

// ClearAssignmentReason clears the value of the "assignment_reason" field.
func (m *PositionOccupancyHistoryMutation) ClearAssignmentReason() {
	m.assignment_reason = nil
	m.clearedFields[positionoccupancyhistory.FieldAssignmentReason] = struct{}{}
}

// AssignmentReasonCleared returns if the "assignment_reason" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) AssignmentReasonCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldAssignmentReason]
	return ok
}

// ResetAssignmentReason resets all changes to the "assignment_reason" field.
func (m *PositionOccupancyHistoryMutation) ResetAssignmentReason() {
	m.assignment_reason = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldAssignmentReason)
}

// SetFtePercentage sets the "fte_percentage" field.
func (m *PositionOccupancyHistoryMutation) SetFtePercentage(f float64) {
	m.fte_percentage = &f
	m.addfte_percentage = nil
}

// FtePercentage returns the value of the "fte_percentage" field in the mutation.
func (m *PositionOccupancyHistoryMutation) FtePercentage() (r float64, exists bool) {
	v := m.fte_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldFtePercentage returns the old "fte_percentage" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldFtePercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFtePercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFtePercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFtePercentage: %w", err)
	}
	return oldValue.FtePercentage, nil
}

// AddFtePercentage adds f to the "fte_percentage" field.
func (m *PositionOccupancyHistoryMutation) AddFtePercentage(f float64) {
	if m.addfte_percentage != nil {
		*m.addfte_percentage += f
	} else {
		m.addfte_percentage = &f
	}
}

// AddedFtePercentage returns the value that was added to the "fte_percentage" field in this mutation.
func (m *PositionOccupancyHistoryMutation) AddedFtePercentage() (r float64, exists bool) {
	v := m.addfte_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetFtePercentage resets all changes to the "fte_percentage" field.
func (m *PositionOccupancyHistoryMutation) ResetFtePercentage() {
	m.fte_percentage = nil
	m.addfte_percentage = nil
}

// SetWorkArrangement sets the "work_arrangement" field.
func (m *PositionOccupancyHistoryMutation) SetWorkArrangement(pa positionoccupancyhistory.WorkArrangement) {
	m.work_arrangement = &pa
}

// WorkArrangement returns the value of the "work_arrangement" field in the mutation.
func (m *PositionOccupancyHistoryMutation) WorkArrangement() (r positionoccupancyhistory.WorkArrangement, exists bool) {
	v := m.work_arrangement
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkArrangement returns the old "work_arrangement" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldWorkArrangement(ctx context.Context) (v positionoccupancyhistory.WorkArrangement, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkArrangement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkArrangement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkArrangement: %w", err)
	}
	return oldValue.WorkArrangement, nil
}

// ClearWorkArrangement clears the value of the "work_arrangement" field.
func (m *PositionOccupancyHistoryMutation) ClearWorkArrangement() {
	m.work_arrangement = nil
	m.clearedFields[positionoccupancyhistory.FieldWorkArrangement] = struct{}{}
}

// WorkArrangementCleared returns if the "work_arrangement" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) WorkArrangementCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldWorkArrangement]
	return ok
}

// ResetWorkArrangement resets all changes to the "work_arrangement" field.
func (m *PositionOccupancyHistoryMutation) ResetWorkArrangement() {
	m.work_arrangement = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldWorkArrangement)
}

// SetApprovedBy sets the "approved_by" field.
func (m *PositionOccupancyHistoryMutation) SetApprovedBy(u uuid.UUID) {
	m.approved_by = &u
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *PositionOccupancyHistoryMutation) ApprovedBy() (r uuid.UUID, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldApprovedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *PositionOccupancyHistoryMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[positionoccupancyhistory.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *PositionOccupancyHistoryMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldApprovedBy)
}

// SetApprovalDate sets the "approval_date" field.
func (m *PositionOccupancyHistoryMutation) SetApprovalDate(t time.Time) {
	m.approval_date = &t
}

// ApprovalDate returns the value of the "approval_date" field in the mutation.
func (m *PositionOccupancyHistoryMutation) ApprovalDate() (r time.Time, exists bool) {
	v := m.approval_date
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalDate returns the old "approval_date" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldApprovalDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalDate: %w", err)
	}
	return oldValue.ApprovalDate, nil
}

// ClearApprovalDate clears the value of the "approval_date" field.
func (m *PositionOccupancyHistoryMutation) ClearApprovalDate() {
	m.approval_date = nil
	m.clearedFields[positionoccupancyhistory.FieldApprovalDate] = struct{}{}
}

// ApprovalDateCleared returns if the "approval_date" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) ApprovalDateCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldApprovalDate]
	return ok
}

// ResetApprovalDate resets all changes to the "approval_date" field.
func (m *PositionOccupancyHistoryMutation) ResetApprovalDate() {
	m.approval_date = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldApprovalDate)
}

// SetApprovalReference sets the "approval_reference" field.
func (m *PositionOccupancyHistoryMutation) SetApprovalReference(s string) {
	m.approval_reference = &s
}

// ApprovalReference returns the value of the "approval_reference" field in the mutation.
func (m *PositionOccupancyHistoryMutation) ApprovalReference() (r string, exists bool) {
	v := m.approval_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalReference returns the old "approval_reference" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldApprovalReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalReference: %w", err)
	}
	return oldValue.ApprovalReference, nil
}

// ClearApprovalReference clears the value of the "approval_reference" field.
func (m *PositionOccupancyHistoryMutation) ClearApprovalReference() {
	m.approval_reference = nil
	m.clearedFields[positionoccupancyhistory.FieldApprovalReference] = struct{}{}
}

// ApprovalReferenceCleared returns if the "approval_reference" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) ApprovalReferenceCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldApprovalReference]
	return ok
}

// ResetApprovalReference resets all changes to the "approval_reference" field.
func (m *PositionOccupancyHistoryMutation) ResetApprovalReference() {
	m.approval_reference = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldApprovalReference)
}

// SetCompensationData sets the "compensation_data" field.
func (m *PositionOccupancyHistoryMutation) SetCompensationData(value map[string]interface{}) {
	m.compensation_data = &value
}

// CompensationData returns the value of the "compensation_data" field in the mutation.
func (m *PositionOccupancyHistoryMutation) CompensationData() (r map[string]interface{}, exists bool) {
	v := m.compensation_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCompensationData returns the old "compensation_data" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldCompensationData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompensationData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompensationData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompensationData: %w", err)
	}
	return oldValue.CompensationData, nil
}

// ClearCompensationData clears the value of the "compensation_data" field.
func (m *PositionOccupancyHistoryMutation) ClearCompensationData() {
	m.compensation_data = nil
	m.clearedFields[positionoccupancyhistory.FieldCompensationData] = struct{}{}
}

// CompensationDataCleared returns if the "compensation_data" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) CompensationDataCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldCompensationData]
	return ok
}

// ResetCompensationData resets all changes to the "compensation_data" field.
func (m *PositionOccupancyHistoryMutation) ResetCompensationData() {
	m.compensation_data = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldCompensationData)
}

// SetPerformanceReviewCycle sets the "performance_review_cycle" field.
func (m *PositionOccupancyHistoryMutation) SetPerformanceReviewCycle(s string) {
	m.performance_review_cycle = &s
}

// PerformanceReviewCycle returns the value of the "performance_review_cycle" field in the mutation.
func (m *PositionOccupancyHistoryMutation) PerformanceReviewCycle() (r string, exists bool) {
	v := m.performance_review_cycle
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformanceReviewCycle returns the old "performance_review_cycle" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldPerformanceReviewCycle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformanceReviewCycle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformanceReviewCycle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformanceReviewCycle: %w", err)
	}
	return oldValue.PerformanceReviewCycle, nil
}

// ClearPerformanceReviewCycle clears the value of the "performance_review_cycle" field.
func (m *PositionOccupancyHistoryMutation) ClearPerformanceReviewCycle() {
	m.performance_review_cycle = nil
	m.clearedFields[positionoccupancyhistory.FieldPerformanceReviewCycle] = struct{}{}
}

// PerformanceReviewCycleCleared returns if the "performance_review_cycle" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) PerformanceReviewCycleCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldPerformanceReviewCycle]
	return ok
}

// ResetPerformanceReviewCycle resets all changes to the "performance_review_cycle" field.
func (m *PositionOccupancyHistoryMutation) ResetPerformanceReviewCycle() {
	m.performance_review_cycle = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldPerformanceReviewCycle)
}

// SetSourceEventID sets the "source_event_id" field.
func (m *PositionOccupancyHistoryMutation) SetSourceEventID(u uuid.UUID) {
	m.source_event_id = &u
}

// SourceEventID returns the value of the "source_event_id" field in the mutation.
func (m *PositionOccupancyHistoryMutation) SourceEventID() (r uuid.UUID, exists bool) {
	v := m.source_event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceEventID returns the old "source_event_id" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldSourceEventID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceEventID: %w", err)
	}
	return oldValue.SourceEventID, nil
}

// ClearSourceEventID clears the value of the "source_event_id" field.
func (m *PositionOccupancyHistoryMutation) ClearSourceEventID() {
	m.source_event_id = nil
	m.clearedFields[positionoccupancyhistory.FieldSourceEventID] = struct{}{}
}

// SourceEventIDCleared returns if the "source_event_id" field was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) SourceEventIDCleared() bool {
	_, ok := m.clearedFields[positionoccupancyhistory.FieldSourceEventID]
	return ok
}

// ResetSourceEventID resets all changes to the "source_event_id" field.
func (m *PositionOccupancyHistoryMutation) ResetSourceEventID() {
	m.source_event_id = nil
	delete(m.clearedFields, positionoccupancyhistory.FieldSourceEventID)
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionOccupancyHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionOccupancyHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionOccupancyHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionOccupancyHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionOccupancyHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PositionOccupancyHistory entity.
// If the PositionOccupancyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionOccupancyHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionOccupancyHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearPosition clears the "position" edge to the Position entity.
func (m *PositionOccupancyHistoryMutation) ClearPosition() {
	m.clearedposition = true
	m.clearedFields[positionoccupancyhistory.FieldPositionID] = struct{}{}
}

// PositionCleared reports if the "position" edge to the Position entity was cleared.
func (m *PositionOccupancyHistoryMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionIDs returns the "position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *PositionOccupancyHistoryMutation) PositionIDs() (ids []uuid.UUID) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition resets all changes to the "position" edge.
func (m *PositionOccupancyHistoryMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *PositionOccupancyHistoryMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[positionoccupancyhistory.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *PositionOccupancyHistoryMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PositionOccupancyHistoryMutation) EmployeeIDs() (ids []uuid.UUID) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *PositionOccupancyHistoryMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the PositionOccupancyHistoryMutation builder.
func (m *PositionOccupancyHistoryMutation) Where(ps ...predicate.PositionOccupancyHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionOccupancyHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionOccupancyHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PositionOccupancyHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionOccupancyHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionOccupancyHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PositionOccupancyHistory).
func (m *PositionOccupancyHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionOccupancyHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.tenant_id != nil {
		fields = append(fields, positionoccupancyhistory.FieldTenantID)
	}
	if m.position != nil {
		fields = append(fields, positionoccupancyhistory.FieldPositionID)
	}
	if m.employee != nil {
		fields = append(fields, positionoccupancyhistory.FieldEmployeeID)
	}
	if m.start_date != nil {
		fields = append(fields, positionoccupancyhistory.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, positionoccupancyhistory.FieldEndDate)
	}
	if m.is_active != nil {
		fields = append(fields, positionoccupancyhistory.FieldIsActive)
	}
	if m.assignment_type != nil {
		fields = append(fields, positionoccupancyhistory.FieldAssignmentType)
	}
	if m.assignment_reason != nil {
		fields = append(fields, positionoccupancyhistory.FieldAssignmentReason)
	}
	if m.fte_percentage != nil {
		fields = append(fields, positionoccupancyhistory.FieldFtePercentage)
	}
	if m.work_arrangement != nil {
		fields = append(fields, positionoccupancyhistory.FieldWorkArrangement)
	}
	if m.approved_by != nil {
		fields = append(fields, positionoccupancyhistory.FieldApprovedBy)
	}
	if m.approval_date != nil {
		fields = append(fields, positionoccupancyhistory.FieldApprovalDate)
	}
	if m.approval_reference != nil {
		fields = append(fields, positionoccupancyhistory.FieldApprovalReference)
	}
	if m.compensation_data != nil {
		fields = append(fields, positionoccupancyhistory.FieldCompensationData)
	}
	if m.performance_review_cycle != nil {
		fields = append(fields, positionoccupancyhistory.FieldPerformanceReviewCycle)
	}
	if m.source_event_id != nil {
		fields = append(fields, positionoccupancyhistory.FieldSourceEventID)
	}
	if m.created_at != nil {
		fields = append(fields, positionoccupancyhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, positionoccupancyhistory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionOccupancyHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case positionoccupancyhistory.FieldTenantID:
		return m.TenantID()
	case positionoccupancyhistory.FieldPositionID:
		return m.PositionID()
	case positionoccupancyhistory.FieldEmployeeID:
		return m.EmployeeID()
	case positionoccupancyhistory.FieldStartDate:
		return m.StartDate()
	case positionoccupancyhistory.FieldEndDate:
		return m.EndDate()
	case positionoccupancyhistory.FieldIsActive:
		return m.IsActive()
	case positionoccupancyhistory.FieldAssignmentType:
		return m.AssignmentType()
	case positionoccupancyhistory.FieldAssignmentReason:
		return m.AssignmentReason()
	case positionoccupancyhistory.FieldFtePercentage:
		return m.FtePercentage()
	case positionoccupancyhistory.FieldWorkArrangement:
		return m.WorkArrangement()
	case positionoccupancyhistory.FieldApprovedBy:
		return m.ApprovedBy()
	case positionoccupancyhistory.FieldApprovalDate:
		return m.ApprovalDate()
	case positionoccupancyhistory.FieldApprovalReference:
		return m.ApprovalReference()
	case positionoccupancyhistory.FieldCompensationData:
		return m.CompensationData()
	case positionoccupancyhistory.FieldPerformanceReviewCycle:
		return m.PerformanceReviewCycle()
	case positionoccupancyhistory.FieldSourceEventID:
		return m.SourceEventID()
	case positionoccupancyhistory.FieldCreatedAt:
		return m.CreatedAt()
	case positionoccupancyhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionOccupancyHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case positionoccupancyhistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case positionoccupancyhistory.FieldPositionID:
		return m.OldPositionID(ctx)
	case positionoccupancyhistory.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case positionoccupancyhistory.FieldStartDate:
		return m.OldStartDate(ctx)
	case positionoccupancyhistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case positionoccupancyhistory.FieldIsActive:
		return m.OldIsActive(ctx)
	case positionoccupancyhistory.FieldAssignmentType:
		return m.OldAssignmentType(ctx)
	case positionoccupancyhistory.FieldAssignmentReason:
		return m.OldAssignmentReason(ctx)
	case positionoccupancyhistory.FieldFtePercentage:
		return m.OldFtePercentage(ctx)
	case positionoccupancyhistory.FieldWorkArrangement:
		return m.OldWorkArrangement(ctx)
	case positionoccupancyhistory.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case positionoccupancyhistory.FieldApprovalDate:
		return m.OldApprovalDate(ctx)
	case positionoccupancyhistory.FieldApprovalReference:
		return m.OldApprovalReference(ctx)
	case positionoccupancyhistory.FieldCompensationData:
		return m.OldCompensationData(ctx)
	case positionoccupancyhistory.FieldPerformanceReviewCycle:
		return m.OldPerformanceReviewCycle(ctx)
	case positionoccupancyhistory.FieldSourceEventID:
		return m.OldSourceEventID(ctx)
	case positionoccupancyhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case positionoccupancyhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PositionOccupancyHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionOccupancyHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case positionoccupancyhistory.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case positionoccupancyhistory.FieldPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	case positionoccupancyhistory.FieldEmployeeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case positionoccupancyhistory.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case positionoccupancyhistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case positionoccupancyhistory.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case positionoccupancyhistory.FieldAssignmentType:
		v, ok := value.(positionoccupancyhistory.AssignmentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentType(v)
		return nil
	case positionoccupancyhistory.FieldAssignmentReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentReason(v)
		return nil
	case positionoccupancyhistory.FieldFtePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFtePercentage(v)
		return nil
	case positionoccupancyhistory.FieldWorkArrangement:
		v, ok := value.(positionoccupancyhistory.WorkArrangement)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkArrangement(v)
		return nil
	case positionoccupancyhistory.FieldApprovedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case positionoccupancyhistory.FieldApprovalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalDate(v)
		return nil
	case positionoccupancyhistory.FieldApprovalReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalReference(v)
		return nil
	case positionoccupancyhistory.FieldCompensationData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompensationData(v)
		return nil
	case positionoccupancyhistory.FieldPerformanceReviewCycle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformanceReviewCycle(v)
		return nil
	case positionoccupancyhistory.FieldSourceEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceEventID(v)
		return nil
	case positionoccupancyhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case positionoccupancyhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PositionOccupancyHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionOccupancyHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addfte_percentage != nil {
		fields = append(fields, positionoccupancyhistory.FieldFtePercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionOccupancyHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case positionoccupancyhistory.FieldFtePercentage:
		return m.AddedFtePercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionOccupancyHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case positionoccupancyhistory.FieldFtePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFtePercentage(v)
		return nil
	}
	return fmt.Errorf("unknown PositionOccupancyHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionOccupancyHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(positionoccupancyhistory.FieldEndDate) {
		fields = append(fields, positionoccupancyhistory.FieldEndDate)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldAssignmentReason) {
		fields = append(fields, positionoccupancyhistory.FieldAssignmentReason)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldWorkArrangement) {
		fields = append(fields, positionoccupancyhistory.FieldWorkArrangement)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldApprovedBy) {
		fields = append(fields, positionoccupancyhistory.FieldApprovedBy)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldApprovalDate) {
		fields = append(fields, positionoccupancyhistory.FieldApprovalDate)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldApprovalReference) {
		fields = append(fields, positionoccupancyhistory.FieldApprovalReference)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldCompensationData) {
		fields = append(fields, positionoccupancyhistory.FieldCompensationData)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldPerformanceReviewCycle) {
		fields = append(fields, positionoccupancyhistory.FieldPerformanceReviewCycle)
	}
	if m.FieldCleared(positionoccupancyhistory.FieldSourceEventID) {
		fields = append(fields, positionoccupancyhistory.FieldSourceEventID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionOccupancyHistoryMutation) ClearField(name string) error {
	switch name {
	case positionoccupancyhistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	case positionoccupancyhistory.FieldAssignmentReason:
		m.ClearAssignmentReason()
		return nil
	case positionoccupancyhistory.FieldWorkArrangement:
		m.ClearWorkArrangement()
		return nil
	case positionoccupancyhistory.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case positionoccupancyhistory.FieldApprovalDate:
		m.ClearApprovalDate()
		return nil
	case positionoccupancyhistory.FieldApprovalReference:
		m.ClearApprovalReference()
		return nil
	case positionoccupancyhistory.FieldCompensationData:
		m.ClearCompensationData()
		return nil
	case positionoccupancyhistory.FieldPerformanceReviewCycle:
		m.ClearPerformanceReviewCycle()
		return nil
	case positionoccupancyhistory.FieldSourceEventID:
		m.ClearSourceEventID()
		return nil
	}
	return fmt.Errorf("unknown PositionOccupancyHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionOccupancyHistoryMutation) ResetField(name string) error {
	switch name {
	case positionoccupancyhistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case positionoccupancyhistory.FieldPositionID:
		m.ResetPositionID()
		return nil
	case positionoccupancyhistory.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case positionoccupancyhistory.FieldStartDate:
		m.ResetStartDate()
		return nil
	case positionoccupancyhistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case positionoccupancyhistory.FieldIsActive:
		m.ResetIsActive()
		return nil
	case positionoccupancyhistory.FieldAssignmentType:
		m.ResetAssignmentType()
		return nil
	case positionoccupancyhistory.FieldAssignmentReason:
		m.ResetAssignmentReason()
		return nil
	case positionoccupancyhistory.FieldFtePercentage:
		m.ResetFtePercentage()
		return nil
	case positionoccupancyhistory.FieldWorkArrangement:
		m.ResetWorkArrangement()
		return nil
	case positionoccupancyhistory.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case positionoccupancyhistory.FieldApprovalDate:
		m.ResetApprovalDate()
		return nil
	case positionoccupancyhistory.FieldApprovalReference:
		m.ResetApprovalReference()
		return nil
	case positionoccupancyhistory.FieldCompensationData:
		m.ResetCompensationData()
		return nil
	case positionoccupancyhistory.FieldPerformanceReviewCycle:
		m.ResetPerformanceReviewCycle()
		return nil
	case positionoccupancyhistory.FieldSourceEventID:
		m.ResetSourceEventID()
		return nil
	case positionoccupancyhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case positionoccupancyhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PositionOccupancyHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionOccupancyHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.position != nil {
		edges = append(edges, positionoccupancyhistory.EdgePosition)
	}
	if m.employee != nil {
		edges = append(edges, positionoccupancyhistory.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionOccupancyHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case positionoccupancyhistory.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case positionoccupancyhistory.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionOccupancyHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionOccupancyHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedposition {
		edges = append(edges, positionoccupancyhistory.EdgePosition)
	}
	if m.clearedemployee {
		edges = append(edges, positionoccupancyhistory.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionOccupancyHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case positionoccupancyhistory.EdgePosition:
		return m.clearedposition
	case positionoccupancyhistory.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionOccupancyHistoryMutation) ClearEdge(name string) error {
	switch name {
	case positionoccupancyhistory.EdgePosition:
		m.ClearPosition()
		return nil
	case positionoccupancyhistory.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown PositionOccupancyHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionOccupancyHistoryMutation) ResetEdge(name string) error {
	switch name {
	case positionoccupancyhistory.EdgePosition:
		m.ResetPosition()
		return nil
	case positionoccupancyhistory.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown PositionOccupancyHistory edge %s", name)
}
