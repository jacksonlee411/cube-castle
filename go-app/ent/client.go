// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/gaogu/cube-castle/go-app/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/gaogu/cube-castle/go-app/ent/assignmentdetails"
	"github.com/gaogu/cube-castle/go-app/ent/assignmenthistory"
	"github.com/gaogu/cube-castle/go-app/ent/employee"
	"github.com/gaogu/cube-castle/go-app/ent/organizationunit"
	"github.com/gaogu/cube-castle/go-app/ent/position"
	"github.com/gaogu/cube-castle/go-app/ent/positionassignment"
	"github.com/gaogu/cube-castle/go-app/ent/positionattributehistory"
	"github.com/gaogu/cube-castle/go-app/ent/positionhistory"
	"github.com/gaogu/cube-castle/go-app/ent/positionoccupancyhistory"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AssignmentDetails is the client for interacting with the AssignmentDetails builders.
	AssignmentDetails *AssignmentDetailsClient
	// AssignmentHistory is the client for interacting with the AssignmentHistory builders.
	AssignmentHistory *AssignmentHistoryClient
	// Employee is the client for interacting with the Employee builders.
	Employee *EmployeeClient
	// OrganizationUnit is the client for interacting with the OrganizationUnit builders.
	OrganizationUnit *OrganizationUnitClient
	// Position is the client for interacting with the Position builders.
	Position *PositionClient
	// PositionAssignment is the client for interacting with the PositionAssignment builders.
	PositionAssignment *PositionAssignmentClient
	// PositionAttributeHistory is the client for interacting with the PositionAttributeHistory builders.
	PositionAttributeHistory *PositionAttributeHistoryClient
	// PositionHistory is the client for interacting with the PositionHistory builders.
	PositionHistory *PositionHistoryClient
	// PositionOccupancyHistory is the client for interacting with the PositionOccupancyHistory builders.
	PositionOccupancyHistory *PositionOccupancyHistoryClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AssignmentDetails = NewAssignmentDetailsClient(c.config)
	c.AssignmentHistory = NewAssignmentHistoryClient(c.config)
	c.Employee = NewEmployeeClient(c.config)
	c.OrganizationUnit = NewOrganizationUnitClient(c.config)
	c.Position = NewPositionClient(c.config)
	c.PositionAssignment = NewPositionAssignmentClient(c.config)
	c.PositionAttributeHistory = NewPositionAttributeHistoryClient(c.config)
	c.PositionHistory = NewPositionHistoryClient(c.config)
	c.PositionOccupancyHistory = NewPositionOccupancyHistoryClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		AssignmentDetails:        NewAssignmentDetailsClient(cfg),
		AssignmentHistory:        NewAssignmentHistoryClient(cfg),
		Employee:                 NewEmployeeClient(cfg),
		OrganizationUnit:         NewOrganizationUnitClient(cfg),
		Position:                 NewPositionClient(cfg),
		PositionAssignment:       NewPositionAssignmentClient(cfg),
		PositionAttributeHistory: NewPositionAttributeHistoryClient(cfg),
		PositionHistory:          NewPositionHistoryClient(cfg),
		PositionOccupancyHistory: NewPositionOccupancyHistoryClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		AssignmentDetails:        NewAssignmentDetailsClient(cfg),
		AssignmentHistory:        NewAssignmentHistoryClient(cfg),
		Employee:                 NewEmployeeClient(cfg),
		OrganizationUnit:         NewOrganizationUnitClient(cfg),
		Position:                 NewPositionClient(cfg),
		PositionAssignment:       NewPositionAssignmentClient(cfg),
		PositionAttributeHistory: NewPositionAttributeHistoryClient(cfg),
		PositionHistory:          NewPositionHistoryClient(cfg),
		PositionOccupancyHistory: NewPositionOccupancyHistoryClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AssignmentDetails.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AssignmentDetails, c.AssignmentHistory, c.Employee, c.OrganizationUnit,
		c.Position, c.PositionAssignment, c.PositionAttributeHistory,
		c.PositionHistory, c.PositionOccupancyHistory,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AssignmentDetails, c.AssignmentHistory, c.Employee, c.OrganizationUnit,
		c.Position, c.PositionAssignment, c.PositionAttributeHistory,
		c.PositionHistory, c.PositionOccupancyHistory,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AssignmentDetailsMutation:
		return c.AssignmentDetails.mutate(ctx, m)
	case *AssignmentHistoryMutation:
		return c.AssignmentHistory.mutate(ctx, m)
	case *EmployeeMutation:
		return c.Employee.mutate(ctx, m)
	case *OrganizationUnitMutation:
		return c.OrganizationUnit.mutate(ctx, m)
	case *PositionMutation:
		return c.Position.mutate(ctx, m)
	case *PositionAssignmentMutation:
		return c.PositionAssignment.mutate(ctx, m)
	case *PositionAttributeHistoryMutation:
		return c.PositionAttributeHistory.mutate(ctx, m)
	case *PositionHistoryMutation:
		return c.PositionHistory.mutate(ctx, m)
	case *PositionOccupancyHistoryMutation:
		return c.PositionOccupancyHistory.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AssignmentDetailsClient is a client for the AssignmentDetails schema.
type AssignmentDetailsClient struct {
	config
}

// NewAssignmentDetailsClient returns a client for the AssignmentDetails from the given config.
func NewAssignmentDetailsClient(c config) *AssignmentDetailsClient {
	return &AssignmentDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assignmentdetails.Hooks(f(g(h())))`.
func (c *AssignmentDetailsClient) Use(hooks ...Hook) {
	c.hooks.AssignmentDetails = append(c.hooks.AssignmentDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assignmentdetails.Intercept(f(g(h())))`.
func (c *AssignmentDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssignmentDetails = append(c.inters.AssignmentDetails, interceptors...)
}

// Create returns a builder for creating a AssignmentDetails entity.
func (c *AssignmentDetailsClient) Create() *AssignmentDetailsCreate {
	mutation := newAssignmentDetailsMutation(c.config, OpCreate)
	return &AssignmentDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssignmentDetails entities.
func (c *AssignmentDetailsClient) CreateBulk(builders ...*AssignmentDetailsCreate) *AssignmentDetailsCreateBulk {
	return &AssignmentDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssignmentDetailsClient) MapCreateBulk(slice any, setFunc func(*AssignmentDetailsCreate, int)) *AssignmentDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssignmentDetailsCreateBulk{err: fmt.Errorf("calling to AssignmentDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssignmentDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssignmentDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssignmentDetails.
func (c *AssignmentDetailsClient) Update() *AssignmentDetailsUpdate {
	mutation := newAssignmentDetailsMutation(c.config, OpUpdate)
	return &AssignmentDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssignmentDetailsClient) UpdateOne(ad *AssignmentDetails) *AssignmentDetailsUpdateOne {
	mutation := newAssignmentDetailsMutation(c.config, OpUpdateOne, withAssignmentDetails(ad))
	return &AssignmentDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssignmentDetailsClient) UpdateOneID(id uuid.UUID) *AssignmentDetailsUpdateOne {
	mutation := newAssignmentDetailsMutation(c.config, OpUpdateOne, withAssignmentDetailsID(id))
	return &AssignmentDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssignmentDetails.
func (c *AssignmentDetailsClient) Delete() *AssignmentDetailsDelete {
	mutation := newAssignmentDetailsMutation(c.config, OpDelete)
	return &AssignmentDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssignmentDetailsClient) DeleteOne(ad *AssignmentDetails) *AssignmentDetailsDeleteOne {
	return c.DeleteOneID(ad.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssignmentDetailsClient) DeleteOneID(id uuid.UUID) *AssignmentDetailsDeleteOne {
	builder := c.Delete().Where(assignmentdetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssignmentDetailsDeleteOne{builder}
}

// Query returns a query builder for AssignmentDetails.
func (c *AssignmentDetailsClient) Query() *AssignmentDetailsQuery {
	return &AssignmentDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssignmentDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a AssignmentDetails entity by its id.
func (c *AssignmentDetailsClient) Get(ctx context.Context, id uuid.UUID) (*AssignmentDetails, error) {
	return c.Query().Where(assignmentdetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssignmentDetailsClient) GetX(ctx context.Context, id uuid.UUID) *AssignmentDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssignment queries the assignment edge of a AssignmentDetails.
func (c *AssignmentDetailsClient) QueryAssignment(ad *AssignmentDetails) *PositionAssignmentQuery {
	query := (&PositionAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ad.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignmentdetails.Table, assignmentdetails.FieldID, id),
			sqlgraph.To(positionassignment.Table, positionassignment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignmentdetails.AssignmentTable, assignmentdetails.AssignmentColumn),
		)
		fromV = sqlgraph.Neighbors(ad.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssignmentDetailsClient) Hooks() []Hook {
	return c.hooks.AssignmentDetails
}

// Interceptors returns the client interceptors.
func (c *AssignmentDetailsClient) Interceptors() []Interceptor {
	return c.inters.AssignmentDetails
}

func (c *AssignmentDetailsClient) mutate(ctx context.Context, m *AssignmentDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssignmentDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssignmentDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssignmentDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssignmentDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssignmentDetails mutation op: %q", m.Op())
	}
}

// AssignmentHistoryClient is a client for the AssignmentHistory schema.
type AssignmentHistoryClient struct {
	config
}

// NewAssignmentHistoryClient returns a client for the AssignmentHistory from the given config.
func NewAssignmentHistoryClient(c config) *AssignmentHistoryClient {
	return &AssignmentHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assignmenthistory.Hooks(f(g(h())))`.
func (c *AssignmentHistoryClient) Use(hooks ...Hook) {
	c.hooks.AssignmentHistory = append(c.hooks.AssignmentHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assignmenthistory.Intercept(f(g(h())))`.
func (c *AssignmentHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssignmentHistory = append(c.inters.AssignmentHistory, interceptors...)
}

// Create returns a builder for creating a AssignmentHistory entity.
func (c *AssignmentHistoryClient) Create() *AssignmentHistoryCreate {
	mutation := newAssignmentHistoryMutation(c.config, OpCreate)
	return &AssignmentHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssignmentHistory entities.
func (c *AssignmentHistoryClient) CreateBulk(builders ...*AssignmentHistoryCreate) *AssignmentHistoryCreateBulk {
	return &AssignmentHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssignmentHistoryClient) MapCreateBulk(slice any, setFunc func(*AssignmentHistoryCreate, int)) *AssignmentHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssignmentHistoryCreateBulk{err: fmt.Errorf("calling to AssignmentHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssignmentHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssignmentHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssignmentHistory.
func (c *AssignmentHistoryClient) Update() *AssignmentHistoryUpdate {
	mutation := newAssignmentHistoryMutation(c.config, OpUpdate)
	return &AssignmentHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssignmentHistoryClient) UpdateOne(ah *AssignmentHistory) *AssignmentHistoryUpdateOne {
	mutation := newAssignmentHistoryMutation(c.config, OpUpdateOne, withAssignmentHistory(ah))
	return &AssignmentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssignmentHistoryClient) UpdateOneID(id uuid.UUID) *AssignmentHistoryUpdateOne {
	mutation := newAssignmentHistoryMutation(c.config, OpUpdateOne, withAssignmentHistoryID(id))
	return &AssignmentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssignmentHistory.
func (c *AssignmentHistoryClient) Delete() *AssignmentHistoryDelete {
	mutation := newAssignmentHistoryMutation(c.config, OpDelete)
	return &AssignmentHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssignmentHistoryClient) DeleteOne(ah *AssignmentHistory) *AssignmentHistoryDeleteOne {
	return c.DeleteOneID(ah.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssignmentHistoryClient) DeleteOneID(id uuid.UUID) *AssignmentHistoryDeleteOne {
	builder := c.Delete().Where(assignmenthistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssignmentHistoryDeleteOne{builder}
}

// Query returns a query builder for AssignmentHistory.
func (c *AssignmentHistoryClient) Query() *AssignmentHistoryQuery {
	return &AssignmentHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssignmentHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a AssignmentHistory entity by its id.
func (c *AssignmentHistoryClient) Get(ctx context.Context, id uuid.UUID) (*AssignmentHistory, error) {
	return c.Query().Where(assignmenthistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssignmentHistoryClient) GetX(ctx context.Context, id uuid.UUID) *AssignmentHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssignment queries the assignment edge of a AssignmentHistory.
func (c *AssignmentHistoryClient) QueryAssignment(ah *AssignmentHistory) *PositionAssignmentQuery {
	query := (&PositionAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ah.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignmenthistory.Table, assignmenthistory.FieldID, id),
			sqlgraph.To(positionassignment.Table, positionassignment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignmenthistory.AssignmentTable, assignmenthistory.AssignmentColumn),
		)
		fromV = sqlgraph.Neighbors(ah.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssignmentHistoryClient) Hooks() []Hook {
	return c.hooks.AssignmentHistory
}

// Interceptors returns the client interceptors.
func (c *AssignmentHistoryClient) Interceptors() []Interceptor {
	return c.inters.AssignmentHistory
}

func (c *AssignmentHistoryClient) mutate(ctx context.Context, m *AssignmentHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssignmentHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssignmentHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssignmentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssignmentHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssignmentHistory mutation op: %q", m.Op())
	}
}

// EmployeeClient is a client for the Employee schema.
type EmployeeClient struct {
	config
}

// NewEmployeeClient returns a client for the Employee from the given config.
func NewEmployeeClient(c config) *EmployeeClient {
	return &EmployeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employee.Hooks(f(g(h())))`.
func (c *EmployeeClient) Use(hooks ...Hook) {
	c.hooks.Employee = append(c.hooks.Employee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employee.Intercept(f(g(h())))`.
func (c *EmployeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Employee = append(c.inters.Employee, interceptors...)
}

// Create returns a builder for creating a Employee entity.
func (c *EmployeeClient) Create() *EmployeeCreate {
	mutation := newEmployeeMutation(c.config, OpCreate)
	return &EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Employee entities.
func (c *EmployeeClient) CreateBulk(builders ...*EmployeeCreate) *EmployeeCreateBulk {
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmployeeClient) MapCreateBulk(slice any, setFunc func(*EmployeeCreate, int)) *EmployeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmployeeCreateBulk{err: fmt.Errorf("calling to EmployeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmployeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Employee.
func (c *EmployeeClient) Update() *EmployeeUpdate {
	mutation := newEmployeeMutation(c.config, OpUpdate)
	return &EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeClient) UpdateOne(e *Employee) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployee(e))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeClient) UpdateOneID(id uuid.UUID) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployeeID(id))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Employee.
func (c *EmployeeClient) Delete() *EmployeeDelete {
	mutation := newEmployeeMutation(c.config, OpDelete)
	return &EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeClient) DeleteOne(e *Employee) *EmployeeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeClient) DeleteOneID(id uuid.UUID) *EmployeeDeleteOne {
	builder := c.Delete().Where(employee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeDeleteOne{builder}
}

// Query returns a query builder for Employee.
func (c *EmployeeClient) Query() *EmployeeQuery {
	return &EmployeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployee},
		inters: c.Interceptors(),
	}
}

// Get returns a Employee entity by its id.
func (c *EmployeeClient) Get(ctx context.Context, id uuid.UUID) (*Employee, error) {
	return c.Query().Where(employee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeClient) GetX(ctx context.Context, id uuid.UUID) *Employee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCurrentPosition queries the current_position edge of a Employee.
func (c *EmployeeClient) QueryCurrentPosition(e *Employee) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.CurrentPositionTable, employee.CurrentPositionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartment queries the department edge of a Employee.
func (c *EmployeeClient) QueryDepartment(e *Employee) *OrganizationUnitQuery {
	query := (&OrganizationUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(organizationunit.Table, organizationunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.DepartmentTable, employee.DepartmentColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPositionHistory queries the position_history edge of a Employee.
func (c *EmployeeClient) QueryPositionHistory(e *Employee) *PositionOccupancyHistoryQuery {
	query := (&PositionOccupancyHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(positionoccupancyhistory.Table, positionoccupancyhistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.PositionHistoryTable, employee.PositionHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a Employee.
func (c *EmployeeClient) QueryAssignments(e *Employee) *PositionAssignmentQuery {
	query := (&PositionAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(positionassignment.Table, positionassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.AssignmentsTable, employee.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmployeeClient) Hooks() []Hook {
	return c.hooks.Employee
}

// Interceptors returns the client interceptors.
func (c *EmployeeClient) Interceptors() []Interceptor {
	return c.inters.Employee
}

func (c *EmployeeClient) mutate(ctx context.Context, m *EmployeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Employee mutation op: %q", m.Op())
	}
}

// OrganizationUnitClient is a client for the OrganizationUnit schema.
type OrganizationUnitClient struct {
	config
}

// NewOrganizationUnitClient returns a client for the OrganizationUnit from the given config.
func NewOrganizationUnitClient(c config) *OrganizationUnitClient {
	return &OrganizationUnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationunit.Hooks(f(g(h())))`.
func (c *OrganizationUnitClient) Use(hooks ...Hook) {
	c.hooks.OrganizationUnit = append(c.hooks.OrganizationUnit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationunit.Intercept(f(g(h())))`.
func (c *OrganizationUnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationUnit = append(c.inters.OrganizationUnit, interceptors...)
}

// Create returns a builder for creating a OrganizationUnit entity.
func (c *OrganizationUnitClient) Create() *OrganizationUnitCreate {
	mutation := newOrganizationUnitMutation(c.config, OpCreate)
	return &OrganizationUnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationUnit entities.
func (c *OrganizationUnitClient) CreateBulk(builders ...*OrganizationUnitCreate) *OrganizationUnitCreateBulk {
	return &OrganizationUnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationUnitClient) MapCreateBulk(slice any, setFunc func(*OrganizationUnitCreate, int)) *OrganizationUnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationUnitCreateBulk{err: fmt.Errorf("calling to OrganizationUnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationUnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationUnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationUnit.
func (c *OrganizationUnitClient) Update() *OrganizationUnitUpdate {
	mutation := newOrganizationUnitMutation(c.config, OpUpdate)
	return &OrganizationUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationUnitClient) UpdateOne(ou *OrganizationUnit) *OrganizationUnitUpdateOne {
	mutation := newOrganizationUnitMutation(c.config, OpUpdateOne, withOrganizationUnit(ou))
	return &OrganizationUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationUnitClient) UpdateOneID(id uuid.UUID) *OrganizationUnitUpdateOne {
	mutation := newOrganizationUnitMutation(c.config, OpUpdateOne, withOrganizationUnitID(id))
	return &OrganizationUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationUnit.
func (c *OrganizationUnitClient) Delete() *OrganizationUnitDelete {
	mutation := newOrganizationUnitMutation(c.config, OpDelete)
	return &OrganizationUnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationUnitClient) DeleteOne(ou *OrganizationUnit) *OrganizationUnitDeleteOne {
	return c.DeleteOneID(ou.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationUnitClient) DeleteOneID(id uuid.UUID) *OrganizationUnitDeleteOne {
	builder := c.Delete().Where(organizationunit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationUnitDeleteOne{builder}
}

// Query returns a query builder for OrganizationUnit.
func (c *OrganizationUnitClient) Query() *OrganizationUnitQuery {
	return &OrganizationUnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationUnit entity by its id.
func (c *OrganizationUnitClient) Get(ctx context.Context, id uuid.UUID) (*OrganizationUnit, error) {
	return c.Query().Where(organizationunit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationUnitClient) GetX(ctx context.Context, id uuid.UUID) *OrganizationUnit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a OrganizationUnit.
func (c *OrganizationUnitClient) QueryParent(ou *OrganizationUnit) *OrganizationUnitQuery {
	query := (&OrganizationUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationunit.Table, organizationunit.FieldID, id),
			sqlgraph.To(organizationunit.Table, organizationunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationunit.ParentTable, organizationunit.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a OrganizationUnit.
func (c *OrganizationUnitClient) QueryChildren(ou *OrganizationUnit) *OrganizationUnitQuery {
	query := (&OrganizationUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationunit.Table, organizationunit.FieldID, id),
			sqlgraph.To(organizationunit.Table, organizationunit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organizationunit.ChildrenTable, organizationunit.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPositions queries the positions edge of a OrganizationUnit.
func (c *OrganizationUnitClient) QueryPositions(ou *OrganizationUnit) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationunit.Table, organizationunit.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organizationunit.PositionsTable, organizationunit.PositionsColumn),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployees queries the employees edge of a OrganizationUnit.
func (c *OrganizationUnitClient) QueryEmployees(ou *OrganizationUnit) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationunit.Table, organizationunit.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organizationunit.EmployeesTable, organizationunit.EmployeesColumn),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationUnitClient) Hooks() []Hook {
	return c.hooks.OrganizationUnit
}

// Interceptors returns the client interceptors.
func (c *OrganizationUnitClient) Interceptors() []Interceptor {
	return c.inters.OrganizationUnit
}

func (c *OrganizationUnitClient) mutate(ctx context.Context, m *OrganizationUnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationUnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationUnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrganizationUnit mutation op: %q", m.Op())
	}
}

// PositionClient is a client for the Position schema.
type PositionClient struct {
	config
}

// NewPositionClient returns a client for the Position from the given config.
func NewPositionClient(c config) *PositionClient {
	return &PositionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `position.Hooks(f(g(h())))`.
func (c *PositionClient) Use(hooks ...Hook) {
	c.hooks.Position = append(c.hooks.Position, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `position.Intercept(f(g(h())))`.
func (c *PositionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Position = append(c.inters.Position, interceptors...)
}

// Create returns a builder for creating a Position entity.
func (c *PositionClient) Create() *PositionCreate {
	mutation := newPositionMutation(c.config, OpCreate)
	return &PositionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Position entities.
func (c *PositionClient) CreateBulk(builders ...*PositionCreate) *PositionCreateBulk {
	return &PositionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PositionClient) MapCreateBulk(slice any, setFunc func(*PositionCreate, int)) *PositionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PositionCreateBulk{err: fmt.Errorf("calling to PositionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PositionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PositionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Position.
func (c *PositionClient) Update() *PositionUpdate {
	mutation := newPositionMutation(c.config, OpUpdate)
	return &PositionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PositionClient) UpdateOne(po *Position) *PositionUpdateOne {
	mutation := newPositionMutation(c.config, OpUpdateOne, withPosition(po))
	return &PositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PositionClient) UpdateOneID(id uuid.UUID) *PositionUpdateOne {
	mutation := newPositionMutation(c.config, OpUpdateOne, withPositionID(id))
	return &PositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Position.
func (c *PositionClient) Delete() *PositionDelete {
	mutation := newPositionMutation(c.config, OpDelete)
	return &PositionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PositionClient) DeleteOne(po *Position) *PositionDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PositionClient) DeleteOneID(id uuid.UUID) *PositionDeleteOne {
	builder := c.Delete().Where(position.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PositionDeleteOne{builder}
}

// Query returns a query builder for Position.
func (c *PositionClient) Query() *PositionQuery {
	return &PositionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePosition},
		inters: c.Interceptors(),
	}
}

// Get returns a Position entity by its id.
func (c *PositionClient) Get(ctx context.Context, id uuid.UUID) (*Position, error) {
	return c.Query().Where(position.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PositionClient) GetX(ctx context.Context, id uuid.UUID) *Position {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryManager queries the manager edge of a Position.
func (c *PositionClient) QueryManager(po *Position) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, position.ManagerTable, position.ManagerColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDirectReports queries the direct_reports edge of a Position.
func (c *PositionClient) QueryDirectReports(po *Position) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, position.DirectReportsTable, position.DirectReportsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartment queries the department edge of a Position.
func (c *PositionClient) QueryDepartment(po *Position) *OrganizationUnitQuery {
	query := (&OrganizationUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(organizationunit.Table, organizationunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, position.DepartmentTable, position.DepartmentColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCurrentIncumbents queries the current_incumbents edge of a Position.
func (c *PositionClient) QueryCurrentIncumbents(po *Position) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, position.CurrentIncumbentsTable, position.CurrentIncumbentsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccupancyHistory queries the occupancy_history edge of a Position.
func (c *PositionClient) QueryOccupancyHistory(po *Position) *PositionOccupancyHistoryQuery {
	query := (&PositionOccupancyHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(positionoccupancyhistory.Table, positionoccupancyhistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, position.OccupancyHistoryTable, position.OccupancyHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributeHistory queries the attribute_history edge of a Position.
func (c *PositionClient) QueryAttributeHistory(po *Position) *PositionAttributeHistoryQuery {
	query := (&PositionAttributeHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(positionattributehistory.Table, positionattributehistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, position.AttributeHistoryTable, position.AttributeHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a Position.
func (c *PositionClient) QueryAssignments(po *Position) *PositionAssignmentQuery {
	query := (&PositionAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(positionassignment.Table, positionassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, position.AssignmentsTable, position.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PositionClient) Hooks() []Hook {
	return c.hooks.Position
}

// Interceptors returns the client interceptors.
func (c *PositionClient) Interceptors() []Interceptor {
	return c.inters.Position
}

func (c *PositionClient) mutate(ctx context.Context, m *PositionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PositionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PositionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PositionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Position mutation op: %q", m.Op())
	}
}

// PositionAssignmentClient is a client for the PositionAssignment schema.
type PositionAssignmentClient struct {
	config
}

// NewPositionAssignmentClient returns a client for the PositionAssignment from the given config.
func NewPositionAssignmentClient(c config) *PositionAssignmentClient {
	return &PositionAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `positionassignment.Hooks(f(g(h())))`.
func (c *PositionAssignmentClient) Use(hooks ...Hook) {
	c.hooks.PositionAssignment = append(c.hooks.PositionAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `positionassignment.Intercept(f(g(h())))`.
func (c *PositionAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.PositionAssignment = append(c.inters.PositionAssignment, interceptors...)
}

// Create returns a builder for creating a PositionAssignment entity.
func (c *PositionAssignmentClient) Create() *PositionAssignmentCreate {
	mutation := newPositionAssignmentMutation(c.config, OpCreate)
	return &PositionAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PositionAssignment entities.
func (c *PositionAssignmentClient) CreateBulk(builders ...*PositionAssignmentCreate) *PositionAssignmentCreateBulk {
	return &PositionAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PositionAssignmentClient) MapCreateBulk(slice any, setFunc func(*PositionAssignmentCreate, int)) *PositionAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PositionAssignmentCreateBulk{err: fmt.Errorf("calling to PositionAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PositionAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PositionAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PositionAssignment.
func (c *PositionAssignmentClient) Update() *PositionAssignmentUpdate {
	mutation := newPositionAssignmentMutation(c.config, OpUpdate)
	return &PositionAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PositionAssignmentClient) UpdateOne(pa *PositionAssignment) *PositionAssignmentUpdateOne {
	mutation := newPositionAssignmentMutation(c.config, OpUpdateOne, withPositionAssignment(pa))
	return &PositionAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PositionAssignmentClient) UpdateOneID(id uuid.UUID) *PositionAssignmentUpdateOne {
	mutation := newPositionAssignmentMutation(c.config, OpUpdateOne, withPositionAssignmentID(id))
	return &PositionAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PositionAssignment.
func (c *PositionAssignmentClient) Delete() *PositionAssignmentDelete {
	mutation := newPositionAssignmentMutation(c.config, OpDelete)
	return &PositionAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PositionAssignmentClient) DeleteOne(pa *PositionAssignment) *PositionAssignmentDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PositionAssignmentClient) DeleteOneID(id uuid.UUID) *PositionAssignmentDeleteOne {
	builder := c.Delete().Where(positionassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PositionAssignmentDeleteOne{builder}
}

// Query returns a query builder for PositionAssignment.
func (c *PositionAssignmentClient) Query() *PositionAssignmentQuery {
	return &PositionAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePositionAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a PositionAssignment entity by its id.
func (c *PositionAssignmentClient) Get(ctx context.Context, id uuid.UUID) (*PositionAssignment, error) {
	return c.Query().Where(positionassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PositionAssignmentClient) GetX(ctx context.Context, id uuid.UUID) *PositionAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosition queries the position edge of a PositionAssignment.
func (c *PositionAssignmentClient) QueryPosition(pa *PositionAssignment) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionassignment.Table, positionassignment.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, positionassignment.PositionTable, positionassignment.PositionColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a PositionAssignment.
func (c *PositionAssignmentClient) QueryEmployee(pa *PositionAssignment) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionassignment.Table, positionassignment.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, positionassignment.EmployeeTable, positionassignment.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDetails queries the details edge of a PositionAssignment.
func (c *PositionAssignmentClient) QueryDetails(pa *PositionAssignment) *AssignmentDetailsQuery {
	query := (&AssignmentDetailsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionassignment.Table, positionassignment.FieldID, id),
			sqlgraph.To(assignmentdetails.Table, assignmentdetails.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, positionassignment.DetailsTable, positionassignment.DetailsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHistory queries the history edge of a PositionAssignment.
func (c *PositionAssignmentClient) QueryHistory(pa *PositionAssignment) *AssignmentHistoryQuery {
	query := (&AssignmentHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionassignment.Table, positionassignment.FieldID, id),
			sqlgraph.To(assignmenthistory.Table, assignmenthistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, positionassignment.HistoryTable, positionassignment.HistoryColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PositionAssignmentClient) Hooks() []Hook {
	return c.hooks.PositionAssignment
}

// Interceptors returns the client interceptors.
func (c *PositionAssignmentClient) Interceptors() []Interceptor {
	return c.inters.PositionAssignment
}

func (c *PositionAssignmentClient) mutate(ctx context.Context, m *PositionAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PositionAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PositionAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PositionAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PositionAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PositionAssignment mutation op: %q", m.Op())
	}
}

// PositionAttributeHistoryClient is a client for the PositionAttributeHistory schema.
type PositionAttributeHistoryClient struct {
	config
}

// NewPositionAttributeHistoryClient returns a client for the PositionAttributeHistory from the given config.
func NewPositionAttributeHistoryClient(c config) *PositionAttributeHistoryClient {
	return &PositionAttributeHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `positionattributehistory.Hooks(f(g(h())))`.
func (c *PositionAttributeHistoryClient) Use(hooks ...Hook) {
	c.hooks.PositionAttributeHistory = append(c.hooks.PositionAttributeHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `positionattributehistory.Intercept(f(g(h())))`.
func (c *PositionAttributeHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PositionAttributeHistory = append(c.inters.PositionAttributeHistory, interceptors...)
}

// Create returns a builder for creating a PositionAttributeHistory entity.
func (c *PositionAttributeHistoryClient) Create() *PositionAttributeHistoryCreate {
	mutation := newPositionAttributeHistoryMutation(c.config, OpCreate)
	return &PositionAttributeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PositionAttributeHistory entities.
func (c *PositionAttributeHistoryClient) CreateBulk(builders ...*PositionAttributeHistoryCreate) *PositionAttributeHistoryCreateBulk {
	return &PositionAttributeHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PositionAttributeHistoryClient) MapCreateBulk(slice any, setFunc func(*PositionAttributeHistoryCreate, int)) *PositionAttributeHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PositionAttributeHistoryCreateBulk{err: fmt.Errorf("calling to PositionAttributeHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PositionAttributeHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PositionAttributeHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PositionAttributeHistory.
func (c *PositionAttributeHistoryClient) Update() *PositionAttributeHistoryUpdate {
	mutation := newPositionAttributeHistoryMutation(c.config, OpUpdate)
	return &PositionAttributeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PositionAttributeHistoryClient) UpdateOne(pah *PositionAttributeHistory) *PositionAttributeHistoryUpdateOne {
	mutation := newPositionAttributeHistoryMutation(c.config, OpUpdateOne, withPositionAttributeHistory(pah))
	return &PositionAttributeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PositionAttributeHistoryClient) UpdateOneID(id uuid.UUID) *PositionAttributeHistoryUpdateOne {
	mutation := newPositionAttributeHistoryMutation(c.config, OpUpdateOne, withPositionAttributeHistoryID(id))
	return &PositionAttributeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PositionAttributeHistory.
func (c *PositionAttributeHistoryClient) Delete() *PositionAttributeHistoryDelete {
	mutation := newPositionAttributeHistoryMutation(c.config, OpDelete)
	return &PositionAttributeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PositionAttributeHistoryClient) DeleteOne(pah *PositionAttributeHistory) *PositionAttributeHistoryDeleteOne {
	return c.DeleteOneID(pah.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PositionAttributeHistoryClient) DeleteOneID(id uuid.UUID) *PositionAttributeHistoryDeleteOne {
	builder := c.Delete().Where(positionattributehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PositionAttributeHistoryDeleteOne{builder}
}

// Query returns a query builder for PositionAttributeHistory.
func (c *PositionAttributeHistoryClient) Query() *PositionAttributeHistoryQuery {
	return &PositionAttributeHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePositionAttributeHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a PositionAttributeHistory entity by its id.
func (c *PositionAttributeHistoryClient) Get(ctx context.Context, id uuid.UUID) (*PositionAttributeHistory, error) {
	return c.Query().Where(positionattributehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PositionAttributeHistoryClient) GetX(ctx context.Context, id uuid.UUID) *PositionAttributeHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosition queries the position edge of a PositionAttributeHistory.
func (c *PositionAttributeHistoryClient) QueryPosition(pah *PositionAttributeHistory) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pah.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionattributehistory.Table, positionattributehistory.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, positionattributehistory.PositionTable, positionattributehistory.PositionColumn),
		)
		fromV = sqlgraph.Neighbors(pah.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PositionAttributeHistoryClient) Hooks() []Hook {
	return c.hooks.PositionAttributeHistory
}

// Interceptors returns the client interceptors.
func (c *PositionAttributeHistoryClient) Interceptors() []Interceptor {
	return c.inters.PositionAttributeHistory
}

func (c *PositionAttributeHistoryClient) mutate(ctx context.Context, m *PositionAttributeHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PositionAttributeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PositionAttributeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PositionAttributeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PositionAttributeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PositionAttributeHistory mutation op: %q", m.Op())
	}
}

// PositionHistoryClient is a client for the PositionHistory schema.
type PositionHistoryClient struct {
	config
}

// NewPositionHistoryClient returns a client for the PositionHistory from the given config.
func NewPositionHistoryClient(c config) *PositionHistoryClient {
	return &PositionHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `positionhistory.Hooks(f(g(h())))`.
func (c *PositionHistoryClient) Use(hooks ...Hook) {
	c.hooks.PositionHistory = append(c.hooks.PositionHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `positionhistory.Intercept(f(g(h())))`.
func (c *PositionHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PositionHistory = append(c.inters.PositionHistory, interceptors...)
}

// Create returns a builder for creating a PositionHistory entity.
func (c *PositionHistoryClient) Create() *PositionHistoryCreate {
	mutation := newPositionHistoryMutation(c.config, OpCreate)
	return &PositionHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PositionHistory entities.
func (c *PositionHistoryClient) CreateBulk(builders ...*PositionHistoryCreate) *PositionHistoryCreateBulk {
	return &PositionHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PositionHistoryClient) MapCreateBulk(slice any, setFunc func(*PositionHistoryCreate, int)) *PositionHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PositionHistoryCreateBulk{err: fmt.Errorf("calling to PositionHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PositionHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PositionHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PositionHistory.
func (c *PositionHistoryClient) Update() *PositionHistoryUpdate {
	mutation := newPositionHistoryMutation(c.config, OpUpdate)
	return &PositionHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PositionHistoryClient) UpdateOne(ph *PositionHistory) *PositionHistoryUpdateOne {
	mutation := newPositionHistoryMutation(c.config, OpUpdateOne, withPositionHistory(ph))
	return &PositionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PositionHistoryClient) UpdateOneID(id string) *PositionHistoryUpdateOne {
	mutation := newPositionHistoryMutation(c.config, OpUpdateOne, withPositionHistoryID(id))
	return &PositionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PositionHistory.
func (c *PositionHistoryClient) Delete() *PositionHistoryDelete {
	mutation := newPositionHistoryMutation(c.config, OpDelete)
	return &PositionHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PositionHistoryClient) DeleteOne(ph *PositionHistory) *PositionHistoryDeleteOne {
	return c.DeleteOneID(ph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PositionHistoryClient) DeleteOneID(id string) *PositionHistoryDeleteOne {
	builder := c.Delete().Where(positionhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PositionHistoryDeleteOne{builder}
}

// Query returns a query builder for PositionHistory.
func (c *PositionHistoryClient) Query() *PositionHistoryQuery {
	return &PositionHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePositionHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a PositionHistory entity by its id.
func (c *PositionHistoryClient) Get(ctx context.Context, id string) (*PositionHistory, error) {
	return c.Query().Where(positionhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PositionHistoryClient) GetX(ctx context.Context, id string) *PositionHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PositionHistoryClient) Hooks() []Hook {
	return c.hooks.PositionHistory
}

// Interceptors returns the client interceptors.
func (c *PositionHistoryClient) Interceptors() []Interceptor {
	return c.inters.PositionHistory
}

func (c *PositionHistoryClient) mutate(ctx context.Context, m *PositionHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PositionHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PositionHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PositionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PositionHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PositionHistory mutation op: %q", m.Op())
	}
}

// PositionOccupancyHistoryClient is a client for the PositionOccupancyHistory schema.
type PositionOccupancyHistoryClient struct {
	config
}

// NewPositionOccupancyHistoryClient returns a client for the PositionOccupancyHistory from the given config.
func NewPositionOccupancyHistoryClient(c config) *PositionOccupancyHistoryClient {
	return &PositionOccupancyHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `positionoccupancyhistory.Hooks(f(g(h())))`.
func (c *PositionOccupancyHistoryClient) Use(hooks ...Hook) {
	c.hooks.PositionOccupancyHistory = append(c.hooks.PositionOccupancyHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `positionoccupancyhistory.Intercept(f(g(h())))`.
func (c *PositionOccupancyHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PositionOccupancyHistory = append(c.inters.PositionOccupancyHistory, interceptors...)
}

// Create returns a builder for creating a PositionOccupancyHistory entity.
func (c *PositionOccupancyHistoryClient) Create() *PositionOccupancyHistoryCreate {
	mutation := newPositionOccupancyHistoryMutation(c.config, OpCreate)
	return &PositionOccupancyHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PositionOccupancyHistory entities.
func (c *PositionOccupancyHistoryClient) CreateBulk(builders ...*PositionOccupancyHistoryCreate) *PositionOccupancyHistoryCreateBulk {
	return &PositionOccupancyHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PositionOccupancyHistoryClient) MapCreateBulk(slice any, setFunc func(*PositionOccupancyHistoryCreate, int)) *PositionOccupancyHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PositionOccupancyHistoryCreateBulk{err: fmt.Errorf("calling to PositionOccupancyHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PositionOccupancyHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PositionOccupancyHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PositionOccupancyHistory.
func (c *PositionOccupancyHistoryClient) Update() *PositionOccupancyHistoryUpdate {
	mutation := newPositionOccupancyHistoryMutation(c.config, OpUpdate)
	return &PositionOccupancyHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PositionOccupancyHistoryClient) UpdateOne(poh *PositionOccupancyHistory) *PositionOccupancyHistoryUpdateOne {
	mutation := newPositionOccupancyHistoryMutation(c.config, OpUpdateOne, withPositionOccupancyHistory(poh))
	return &PositionOccupancyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PositionOccupancyHistoryClient) UpdateOneID(id uuid.UUID) *PositionOccupancyHistoryUpdateOne {
	mutation := newPositionOccupancyHistoryMutation(c.config, OpUpdateOne, withPositionOccupancyHistoryID(id))
	return &PositionOccupancyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PositionOccupancyHistory.
func (c *PositionOccupancyHistoryClient) Delete() *PositionOccupancyHistoryDelete {
	mutation := newPositionOccupancyHistoryMutation(c.config, OpDelete)
	return &PositionOccupancyHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PositionOccupancyHistoryClient) DeleteOne(poh *PositionOccupancyHistory) *PositionOccupancyHistoryDeleteOne {
	return c.DeleteOneID(poh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PositionOccupancyHistoryClient) DeleteOneID(id uuid.UUID) *PositionOccupancyHistoryDeleteOne {
	builder := c.Delete().Where(positionoccupancyhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PositionOccupancyHistoryDeleteOne{builder}
}

// Query returns a query builder for PositionOccupancyHistory.
func (c *PositionOccupancyHistoryClient) Query() *PositionOccupancyHistoryQuery {
	return &PositionOccupancyHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePositionOccupancyHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a PositionOccupancyHistory entity by its id.
func (c *PositionOccupancyHistoryClient) Get(ctx context.Context, id uuid.UUID) (*PositionOccupancyHistory, error) {
	return c.Query().Where(positionoccupancyhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PositionOccupancyHistoryClient) GetX(ctx context.Context, id uuid.UUID) *PositionOccupancyHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosition queries the position edge of a PositionOccupancyHistory.
func (c *PositionOccupancyHistoryClient) QueryPosition(poh *PositionOccupancyHistory) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := poh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionoccupancyhistory.Table, positionoccupancyhistory.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, positionoccupancyhistory.PositionTable, positionoccupancyhistory.PositionColumn),
		)
		fromV = sqlgraph.Neighbors(poh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a PositionOccupancyHistory.
func (c *PositionOccupancyHistoryClient) QueryEmployee(poh *PositionOccupancyHistory) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := poh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(positionoccupancyhistory.Table, positionoccupancyhistory.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, positionoccupancyhistory.EmployeeTable, positionoccupancyhistory.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(poh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PositionOccupancyHistoryClient) Hooks() []Hook {
	return c.hooks.PositionOccupancyHistory
}

// Interceptors returns the client interceptors.
func (c *PositionOccupancyHistoryClient) Interceptors() []Interceptor {
	return c.inters.PositionOccupancyHistory
}

func (c *PositionOccupancyHistoryClient) mutate(ctx context.Context, m *PositionOccupancyHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PositionOccupancyHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PositionOccupancyHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PositionOccupancyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PositionOccupancyHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PositionOccupancyHistory mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AssignmentDetails, AssignmentHistory, Employee, OrganizationUnit, Position,
		PositionAssignment, PositionAttributeHistory, PositionHistory,
		PositionOccupancyHistory []ent.Hook
	}
	inters struct {
		AssignmentDetails, AssignmentHistory, Employee, OrganizationUnit, Position,
		PositionAssignment, PositionAttributeHistory, PositionHistory,
		PositionOccupancyHistory []ent.Interceptor
	}
)
