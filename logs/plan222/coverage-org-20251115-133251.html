
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>organization: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cube-castle/internal/organization/api.go (83.0%)</option>
				
				<option value="file1">cube-castle/internal/organization/audit/logger.go (43.6%)</option>
				
				<option value="file2">cube-castle/internal/organization/dto/models.go (42.7%)</option>
				
				<option value="file3">cube-castle/internal/organization/dto/scalars.go (0.0%)</option>
				
				<option value="file4">cube-castle/internal/organization/events/outbox.go (0.0%)</option>
				
				<option value="file5">cube-castle/internal/organization/handler/common_utils.go (88.5%)</option>
				
				<option value="file6">cube-castle/internal/organization/handler/devtools.go (0.0%)</option>
				
				<option value="file7">cube-castle/internal/organization/handler/job_catalog_handler.go (9.3%)</option>
				
				<option value="file8">cube-castle/internal/organization/handler/logger_helper.go (92.3%)</option>
				
				<option value="file9">cube-castle/internal/organization/handler/operational.go (0.0%)</option>
				
				<option value="file10">cube-castle/internal/organization/handler/organization_base.go (0.0%)</option>
				
				<option value="file11">cube-castle/internal/organization/handler/organization_create.go (0.0%)</option>
				
				<option value="file12">cube-castle/internal/organization/handler/organization_events.go (0.0%)</option>
				
				<option value="file13">cube-castle/internal/organization/handler/organization_helpers.go (5.1%)</option>
				
				<option value="file14">cube-castle/internal/organization/handler/organization_history.go (0.0%)</option>
				
				<option value="file15">cube-castle/internal/organization/handler/organization_routes.go (0.0%)</option>
				
				<option value="file16">cube-castle/internal/organization/handler/organization_update.go (0.0%)</option>
				
				<option value="file17">cube-castle/internal/organization/handler/position_handler.go (43.3%)</option>
				
				<option value="file18">cube-castle/internal/organization/middleware/logger_helper.go (72.7%)</option>
				
				<option value="file19">cube-castle/internal/organization/middleware/performance.go (42.7%)</option>
				
				<option value="file20">cube-castle/internal/organization/middleware/ratelimit.go (47.0%)</option>
				
				<option value="file21">cube-castle/internal/organization/middleware/request.go (91.7%)</option>
				
				<option value="file22">cube-castle/internal/organization/query_facade.go (86.5%)</option>
				
				<option value="file23">cube-castle/internal/organization/repository/hierarchy.go (0.0%)</option>
				
				<option value="file24">cube-castle/internal/organization/repository/job_catalog_repository.go (15.7%)</option>
				
				<option value="file25">cube-castle/internal/organization/repository/logger_helper.go (90.0%)</option>
				
				<option value="file26">cube-castle/internal/organization/repository/organization_create.go (7.2%)</option>
				
				<option value="file27">cube-castle/internal/organization/repository/organization_hierarchy.go (48.3%)</option>
				
				<option value="file28">cube-castle/internal/organization/repository/organization_query.go (49.2%)</option>
				
				<option value="file29">cube-castle/internal/organization/repository/organization_repository.go (25.0%)</option>
				
				<option value="file30">cube-castle/internal/organization/repository/organization_status.go (32.8%)</option>
				
				<option value="file31">cube-castle/internal/organization/repository/organization_update.go (0.0%)</option>
				
				<option value="file32">cube-castle/internal/organization/repository/position_assignment_repository.go (0.0%)</option>
				
				<option value="file33">cube-castle/internal/organization/repository/position_repository.go (0.0%)</option>
				
				<option value="file34">cube-castle/internal/organization/repository/postgres_assignment_repository.go (56.8%)</option>
				
				<option value="file35">cube-castle/internal/organization/repository/postgres_audit.go (45.1%)</option>
				
				<option value="file36">cube-castle/internal/organization/repository/postgres_base.go (100.0%)</option>
				
				<option value="file37">cube-castle/internal/organization/repository/postgres_job_catalog.go (0.0%)</option>
				
				<option value="file38">cube-castle/internal/organization/repository/postgres_organization_details.go (0.0%)</option>
				
				<option value="file39">cube-castle/internal/organization/repository/postgres_organization_hierarchy.go (72.3%)</option>
				
				<option value="file40">cube-castle/internal/organization/repository/postgres_organizations_list.go (43.2%)</option>
				
				<option value="file41">cube-castle/internal/organization/repository/postgres_positions.go (13.6%)</option>
				
				<option value="file42">cube-castle/internal/organization/repository/temporal_timeline_delete.go (0.0%)</option>
				
				<option value="file43">cube-castle/internal/organization/repository/temporal_timeline_insert.go (0.0%)</option>
				
				<option value="file44">cube-castle/internal/organization/repository/temporal_timeline_manager.go (0.0%)</option>
				
				<option value="file45">cube-castle/internal/organization/repository/temporal_timeline_status.go (0.0%)</option>
				
				<option value="file46">cube-castle/internal/organization/repository/temporal_timeline_update.go (0.0%)</option>
				
				<option value="file47">cube-castle/internal/organization/resolver/resolver.go (41.2%)</option>
				
				<option value="file48">cube-castle/internal/organization/scheduler/logger_helper.go (66.7%)</option>
				
				<option value="file49">cube-castle/internal/organization/scheduler/operational_scheduler.go (37.9%)</option>
				
				<option value="file50">cube-castle/internal/organization/scheduler/organization_temporal_service.go (0.0%)</option>
				
				<option value="file51">cube-castle/internal/organization/scheduler/service.go (0.0%)</option>
				
				<option value="file52">cube-castle/internal/organization/scheduler/temporal_monitor.go (63.5%)</option>
				
				<option value="file53">cube-castle/internal/organization/scheduler/temporal_service.go (0.0%)</option>
				
				<option value="file54">cube-castle/internal/organization/service/cascade.go (0.0%)</option>
				
				<option value="file55">cube-castle/internal/organization/service/job_catalog_service.go (9.9%)</option>
				
				<option value="file56">cube-castle/internal/organization/service/logger_helper.go (0.0%)</option>
				
				<option value="file57">cube-castle/internal/organization/service/position_service.go (5.1%)</option>
				
				<option value="file58">cube-castle/internal/organization/utils/metrics.go (0.0%)</option>
				
				<option value="file59">cube-castle/internal/organization/utils/parent_code.go (100.0%)</option>
				
				<option value="file60">cube-castle/internal/organization/utils/response.go (73.2%)</option>
				
				<option value="file61">cube-castle/internal/organization/utils/validation.go (60.3%)</option>
				
				<option value="file62">cube-castle/internal/organization/validator/business.go (90.6%)</option>
				
				<option value="file63">cube-castle/internal/organization/validator/core.go (89.3%)</option>
				
				<option value="file64">cube-castle/internal/organization/validator/errors.go (90.0%)</option>
				
				<option value="file65">cube-castle/internal/organization/validator/job_catalog_validation.go (90.2%)</option>
				
				<option value="file66">cube-castle/internal/organization/validator/metrics.go (85.0%)</option>
				
				<option value="file67">cube-castle/internal/organization/validator/organization_rules.go (78.6%)</option>
				
				<option value="file68">cube-castle/internal/organization/validator/position_assignment_stub.go (100.0%)</option>
				
				<option value="file69">cube-castle/internal/organization/validator/position_assignment_validation.go (79.0%)</option>
				
				<option value="file70">cube-castle/internal/organization/validator/testing_stubs.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package organization

import (
        "context"
        "database/sql"
        "errors"
        "net/http"
        "time"

        auth "cube-castle/internal/auth"
        configpkg "cube-castle/internal/config"
        auditpkg "cube-castle/internal/organization/audit"
        dto "cube-castle/internal/organization/dto"
        handlerpkg "cube-castle/internal/organization/handler"
        middlewarepkg "cube-castle/internal/organization/middleware"
        repositorypkg "cube-castle/internal/organization/repository"
        "cube-castle/internal/organization/resolver"
        schedulerpkg "cube-castle/internal/organization/scheduler"
        servicepkg "cube-castle/internal/organization/service"
        utilspkg "cube-castle/internal/organization/utils"
        validatorpkg "cube-castle/internal/organization/validator"
        "cube-castle/pkg/database"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"
)

type CommandModuleDeps struct {
        DB              *sql.DB
        Logger          pkglogger.Logger
        CascadeMaxDepth int
        SchedulerConfig *configpkg.SchedulerConfig
        OutboxRepo      database.OutboxRepository
}

type OrganizationHandler = handlerpkg.OrganizationHandler
type PositionHandler = handlerpkg.PositionHandler
type JobCatalogHandler = handlerpkg.JobCatalogHandler
type OperationalHandler = handlerpkg.OperationalHandler
type DevToolsHandler = handlerpkg.DevToolsHandler
type AuditLogger = auditpkg.AuditLogger
type AuditHistoryConfig = repositorypkg.AuditHistoryConfig
type QueryRepository = repositorypkg.PostgreSQLRepository
type QueryRepositoryInterface = resolver.QueryRepository
type QueryResolver = resolver.Resolver
type QueryPermissionChecker = resolver.PermissionChecker
type AssignmentFacade interface {
        GetAssignments(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentHistory(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentStats(ctx context.Context, tenantID uuid.UUID, positionCode string, organizationCode string) (*dto.AssignmentStats, error)
        RefreshPositionCache(ctx context.Context, tenantID uuid.UUID, positionCode string) error
}

type CommandModule struct {
        DB           *sql.DB
        Logger       pkglogger.Logger
        Repositories CommandRepositories
        Services     CommandServices
        Validator    *validatorpkg.BusinessRuleValidator
        AuditLogger  *auditpkg.AuditLogger
}

type CommandRepositories struct {
        Organization       *repositorypkg.OrganizationRepository
        JobCatalog         *repositorypkg.JobCatalogRepository
        Position           *repositorypkg.PositionRepository
        PositionAssignment *repositorypkg.PositionAssignmentRepository
        Hierarchy          *repositorypkg.HierarchyRepository
        TemporalTimeline   *repositorypkg.TemporalTimelineManager
}

type CommandServices struct {
        Cascade    *servicepkg.CascadeUpdateService
        Scheduler  *schedulerpkg.Service
        Position   *servicepkg.PositionService
        JobCatalog *servicepkg.JobCatalogService
}

type CommandHandlers struct {
        Organization *handlerpkg.OrganizationHandler
        Position     *handlerpkg.PositionHandler
        JobCatalog   *handlerpkg.JobCatalogHandler
        Operational  *handlerpkg.OperationalHandler
        DevTools     *handlerpkg.DevToolsHandler
}

type CommandHandlerDeps struct {
        JWTMiddleware       *auth.JWTMiddleware
        RateLimitMiddleware *middlewarepkg.RateLimitMiddleware
        Logger              pkglogger.Logger
        DevMode             bool
}

type CommandMiddlewares struct {
        Performance *middlewarepkg.PerformanceMiddleware
        RateLimit   *middlewarepkg.RateLimitMiddleware
}

func NewCommandModule(deps CommandModuleDeps) (*CommandModule, error) <span class="cov8" title="1">{
        if deps.DB == nil </span><span class="cov0" title="0">{
                return nil, ErrMissingDatabase
        }</span>
        <span class="cov8" title="1">logger := deps.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">cascadeDepth := deps.CascadeMaxDepth
        if cascadeDepth &lt;= 0 </span><span class="cov8" title="1">{
                cascadeDepth = 4
        }</span>

        <span class="cov8" title="1">orgRepo := repositorypkg.NewOrganizationRepository(deps.DB, logger)
        jobCatalogRepo := repositorypkg.NewJobCatalogRepository(deps.DB, logger)
        positionRepo := repositorypkg.NewPositionRepository(deps.DB, logger)
        positionAssignmentRepo := repositorypkg.NewPositionAssignmentRepository(deps.DB, logger)
        hierarchyRepo := repositorypkg.NewHierarchyRepository(deps.DB, logger)
        timelineManager := repositorypkg.NewTemporalTimelineManager(deps.DB, logger)

        auditLogger := auditpkg.NewAuditLogger(deps.DB, logger)
        cascadeService := servicepkg.NewCascadeUpdateService(hierarchyRepo, cascadeDepth, logger)
        positionValidator, assignmentValidator := validatorpkg.NewPositionAssignmentValidationService(
                orgRepo,
                jobCatalogRepo,
                positionRepo,
                positionAssignmentRepo,
                logger,
        )
        positionService := servicepkg.NewPositionService(positionRepo, positionAssignmentRepo, jobCatalogRepo, orgRepo, positionValidator, assignmentValidator, auditLogger, logger, deps.OutboxRepo)
        jobCatalogValidator := validatorpkg.NewJobCatalogValidationService(jobCatalogRepo, logger)
        jobCatalogService := servicepkg.NewJobCatalogService(jobCatalogRepo, jobCatalogValidator, auditLogger, logger, deps.OutboxRepo)
        schedulerService := schedulerpkg.NewService(schedulerpkg.Dependencies{
                DB:                     deps.DB,
                Logger:                 logger,
                OrganizationRepository: orgRepo,
                PositionService:        positionService,
                Config:                 deps.SchedulerConfig,
        })

        validator := validatorpkg.NewBusinessRuleValidator(hierarchyRepo, orgRepo, logger)

        module := &amp;CommandModule{
                DB:     deps.DB,
                Logger: logger,
                Repositories: CommandRepositories{
                        Organization:       orgRepo,
                        JobCatalog:         jobCatalogRepo,
                        Position:           positionRepo,
                        PositionAssignment: positionAssignmentRepo,
                        Hierarchy:          hierarchyRepo,
                        TemporalTimeline:   timelineManager,
                },
                Services: CommandServices{
                        Cascade:    cascadeService,
                        Scheduler:  schedulerService,
                        Position:   positionService,
                        JobCatalog: jobCatalogService,
                },
                Validator:   validator,
                AuditLogger: auditLogger,
        }

        return module, nil</span>
}

func (m *CommandModule) NewHandlers(deps CommandHandlerDeps) CommandHandlers <span class="cov8" title="1">{
        logger := deps.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = m.Logger
        }</span>
        <span class="cov8" title="1">schedulerService := m.Services.Scheduler
        orgHandler := handlerpkg.NewOrganizationHandler(
                m.Repositories.Organization,
                schedulerService.Temporal(),
                m.AuditLogger,
                logger,
                m.Repositories.TemporalTimeline,
                m.Repositories.Hierarchy,
                m.Validator,
        )
        positionHandler := handlerpkg.NewPositionHandler(m.Services.Position, m.AuditLogger, logger)
        jobCatalogHandler := handlerpkg.NewJobCatalogHandler(m.Services.JobCatalog, logger)
        operationalHandler := handlerpkg.NewOperationalHandler(schedulerService.Monitor(), schedulerService.Operational(), deps.RateLimitMiddleware, logger)
        devToolsHandler := handlerpkg.NewDevToolsHandler(deps.JWTMiddleware, logger, deps.DevMode, m.DB)

        return CommandHandlers{
                Organization: orgHandler,
                Position:     positionHandler,
                JobCatalog:   jobCatalogHandler,
                Operational:  operationalHandler,
                DevTools:     devToolsHandler,
        }</span>
}

func NewCommandMiddlewares(logger pkglogger.Logger) CommandMiddlewares <span class="cov8" title="1">{
        rateLimit := middlewarepkg.NewRateLimitMiddleware(middlewarepkg.DefaultRateLimitConfig, logger)
        performance := middlewarepkg.NewPerformanceMiddleware(logger)
        return CommandMiddlewares{
                Performance: performance,
                RateLimit:   rateLimit,
        }
}</span>

var ErrMissingDatabase = errors.New("organization command module requires a database connection")

func RecordHTTPRequest(method, path string, status int) <span class="cov0" title="0">{
        utilspkg.RecordHTTPRequest(method, path, status)
}</span>

func NewDevToolsHandler(db *sql.DB, jwt *auth.JWTMiddleware, logger pkglogger.Logger, devMode bool) *handlerpkg.DevToolsHandler <span class="cov0" title="0">{
        return handlerpkg.NewDevToolsHandler(jwt, logger, devMode, db)
}</span>

func NewQueryRepository(db *sql.DB, redisClient *redis.Client, logger pkglogger.Logger, auditConfig AuditHistoryConfig) *repositorypkg.PostgreSQLRepository <span class="cov0" title="0">{
        return repositorypkg.NewPostgreSQLRepository(db, redisClient, logger, auditConfig)
}</span>

func NewQueryResolver(repo QueryRepositoryInterface, assignments resolver.AssignmentProvider, logger pkglogger.Logger, permissions QueryPermissionChecker) *resolver.Resolver <span class="cov0" title="0">{
        if assignments != nil </span><span class="cov0" title="0">{
                return resolver.NewResolverWithAssignments(repo, assignments, logger, permissions)
        }</span>
        <span class="cov0" title="0">return resolver.NewResolver(repo, logger, permissions)</span>
}

func NewAssignmentFacade(repo *repositorypkg.PostgreSQLRepository, redisClient *redis.Client, logger pkglogger.Logger, cacheTTL time.Duration) *AssignmentQueryFacade <span class="cov0" title="0">{
        return NewAssignmentQueryFacade(repo, redisClient, logger, cacheTTL)
}</span>

func DefaultAuditHistoryConfig() AuditHistoryConfig <span class="cov8" title="1">{
        return AuditHistoryConfig{
                StrictValidation:        true,
                AllowFallback:           true,
                CircuitBreakerThreshold: 25,
                LegacyMode:              false,
        }
}</span>

func RequestIDMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return middlewarepkg.RequestIDMiddleware(next)
}</span>

func GetRequestID(ctx context.Context) string <span class="cov8" title="1">{
        return middlewarepkg.GetRequestID(ctx)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package audit

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// AuditLogger 结构化审计日志记录器
type AuditLogger struct {
        db     *sql.DB
        logger pkglogger.Logger
}

// AuditEvent 简化的审计事件 (v4.3.0 - 移除过度设计的技术细节追踪)
type AuditEvent struct {
        ID                uuid.UUID              `json:"id"`
        TenantID          uuid.UUID              `json:"tenantId"`
        EventType         string                 `json:"eventType"`
        ResourceType      string                 `json:"resourceType"`
        ResourceID        string                 `json:"resourceId"`
        RecordID          uuid.UUID              `json:"recordId,omitempty"`
        ActorID           string                 `json:"actorId"`
        ActorType         string                 `json:"actorType"`
        ActorName         string                 `json:"actorName,omitempty"`
        ActionName        string                 `json:"actionName"`
        RequestID         string                 `json:"requestId"`
        CorrelationID     string                 `json:"correlationId,omitempty"`
        SourceCorrelation string                 `json:"sourceCorrelation,omitempty"`
        EntityCode        string                 `json:"entityCode,omitempty"`
        OperationReason   string                 `json:"operationReason,omitempty"`
        Timestamp         time.Time              `json:"timestamp"`
        Success           bool                   `json:"success"`
        ErrorCode         string                 `json:"errorCode,omitempty"`
        ErrorMessage      string                 `json:"errorMessage,omitempty"`
        BeforeData        map[string]interface{} `json:"beforeData,omitempty"`
        AfterData         map[string]interface{} `json:"afterData,omitempty"`
        ModifiedFields    []string               `json:"modifiedFields,omitempty"`
        Changes           []FieldChange          `json:"changes,omitempty"`
        BusinessContext   map[string]interface{} `json:"businessContext,omitempty"`
        ContextPayload    map[string]interface{} `json:"contextPayload,omitempty"`
}

// FieldChange 字段变更记录 - 保留关键审计功能
type FieldChange struct {
        Field    string      `json:"field"`
        OldValue interface{} `json:"oldValue"`
        NewValue interface{} `json:"newValue"`
        DataType string      `json:"dataType"`
}

// 审计事件类型常量
const (
        EventTypeCreate     = "CREATE"
        EventTypeUpdate     = "UPDATE"
        EventTypeDelete     = "DELETE"
        EventTypeSuspend    = "SUSPEND"
        EventTypeActivate   = "ACTIVATE"
        EventTypeQuery      = "QUERY"
        EventTypeValidation = "VALIDATION"
        EventTypeAuth       = "AUTHENTICATION"
        EventTypeError      = "ERROR"
)

// 资源类型常量
const (
        ResourceTypeOrganization = "ORGANIZATION"
        ResourceTypeHierarchy    = "HIERARCHY"
        ResourceTypeJobCatalog   = "JOB_CATALOG"
        ResourceTypePosition     = "POSITION"
        ResourceTypeUser         = "USER"
        ResourceTypeSystem       = "SYSTEM"
)

// 操作者类型常量
const (
        ActorTypeUser    = "USER"
        ActorTypeSystem  = "SYSTEM"
        ActorTypeService = "SERVICE"
)

func NewAuditLogger(db *sql.DB, baseLogger pkglogger.Logger) *AuditLogger <span class="cov8" title="1">{
        return &amp;AuditLogger{
                db: db,
                logger: baseLogger.WithFields(pkglogger.Fields{
                        "component": "audit",
                        "module":    "command",
                }),
        }
}</span>

// LogEvent 记录审计事件（自动处理默认值与 JSON 序列化）
func (a *AuditLogger) LogEvent(ctx context.Context, event *AuditEvent) error <span class="cov8" title="1">{
        return a.logEvent(ctx, a.db, event)
}</span>

// LogEventInTransaction 允许在现有事务中写入审计记录
func (a *AuditLogger) LogEventInTransaction(ctx context.Context, tx *sql.Tx, event *AuditEvent) error <span class="cov8" title="1">{
        if tx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("nil transaction provided for audit logging")
        }</span>
        <span class="cov8" title="1">return a.logEvent(ctx, tx, event)</span>
}

type dbExecutor interface {
        ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
        QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

func (a *AuditLogger) logEvent(ctx context.Context, exec dbExecutor, event *AuditEvent) error <span class="cov8" title="1">{
        if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("audit event is nil")
        }</span>

        <span class="cov8" title="1">a.applyDefaults(ctx, exec, event)

        beforeJSON := a.marshalOrDefault(event.BeforeData, "{}", "request_data")
        afterJSON := a.marshalOrDefault(event.AfterData, "{}", "response_data")
        modifiedJSON := a.marshalOrDefault(event.ModifiedFields, "[]", "modified_fields")
        changesJSON := a.marshalOrDefault(event.Changes, "[]", "changes")
        businessJSON := a.marshalOrDefault(event.BusinessContext, "{}", "business_context")

        query := `
        INSERT INTO audit_logs (
            id, tenant_id, event_type, resource_type, resource_id,
            actor_id, actor_type, action_name, request_id, operation_reason,
            timestamp, success, error_code, error_message,
            request_data, response_data, modified_fields, changes,
            record_id, business_context
        ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
            $11, $12, $13, $14, $15::jsonb, $16::jsonb, $17::jsonb, $18::jsonb,
            $19, $20::jsonb
        )`

        var recordIDParam interface{}
        if event.RecordID != uuid.Nil </span><span class="cov8" title="1">{
                recordIDParam = event.RecordID
        }</span>

        <span class="cov8" title="1">_, err := exec.ExecContext(ctx, query,
                event.ID, event.TenantID, event.EventType, event.ResourceType, event.ResourceID,
                event.ActorID, event.ActorType, event.ActionName, event.RequestID, event.OperationReason,
                event.Timestamp, event.Success, event.ErrorCode, event.ErrorMessage,
                beforeJSON, afterJSON, modifiedJSON, changesJSON,
                recordIDParam, businessJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                a.logger.Errorf("审计日志记录失败: %v", err)
                return fmt.Errorf("failed to log audit event: %w", err)
        }</span>

        <span class="cov8" title="1">a.logger.Infof("审计事件已记录: %s/%s/%s (ID: %s)",
                event.EventType, event.ResourceType, event.ActionName, event.ID.String())

        return nil</span>
}

func (a *AuditLogger) applyDefaults(ctx context.Context, exec dbExecutor, event *AuditEvent) <span class="cov8" title="1">{
        if event.ID == uuid.Nil </span><span class="cov8" title="1">{
                event.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">if event.Timestamp.IsZero() </span><span class="cov8" title="1">{
                event.Timestamp = time.Now().UTC()
        }</span>
        <span class="cov8" title="1">if event.ActorType == "" </span><span class="cov0" title="0">{
                event.ActorType = ActorTypeUser
        }</span>
        <span class="cov8" title="1">if event.BusinessContext == nil </span><span class="cov8" title="1">{
                event.BusinessContext = map[string]interface{}{}
        }</span>

        // 默认将 correlationId 写入 business_context；若缺失则使用 requestId
        <span class="cov8" title="1">if event.CorrelationID == "" &amp;&amp; event.RequestID != "" </span><span class="cov8" title="1">{
                event.CorrelationID = event.RequestID
        }</span>

        <span class="cov8" title="1">if event.CorrelationID != "" </span><span class="cov8" title="1">{
                event.BusinessContext["correlationId"] = event.CorrelationID
        }</span>
        <span class="cov8" title="1">if event.SourceCorrelation != "" </span><span class="cov0" title="0">{
                event.BusinessContext["sourceCorrelation"] = event.SourceCorrelation
        }</span>

        <span class="cov8" title="1">if event.ActorName != "" </span><span class="cov0" title="0">{
                event.BusinessContext["actorName"] = event.ActorName
        }</span>
        <span class="cov8" title="1">if event.ActorID != "" </span><span class="cov8" title="1">{
                event.BusinessContext["actorId"] = event.ActorID
        }</span>
        <span class="cov8" title="1">if event.ActorType != "" </span><span class="cov8" title="1">{
                event.BusinessContext["actorType"] = event.ActorType
        }</span>
        <span class="cov8" title="1">if event.OperationReason != "" </span><span class="cov8" title="1">{
                if _, ok := event.BusinessContext["operationReason"]; !ok </span><span class="cov8" title="1">{
                        event.BusinessContext["operationReason"] = event.OperationReason
                }</span>
        }

        <span class="cov8" title="1">if len(event.ContextPayload) &gt; 0 </span><span class="cov8" title="1">{
                event.BusinessContext["payload"] = cloneMap(event.ContextPayload)
        }</span>

        // 默认使用 AfterData/BeforeData 兜底 payload
        <span class="cov8" title="1">if _, ok := event.BusinessContext["payload"]; !ok </span><span class="cov8" title="1">{
                if event.Success &amp;&amp; len(event.AfterData) &gt; 0 </span><span class="cov8" title="1">{
                        event.BusinessContext["payload"] = cloneMap(event.AfterData)
                }</span> else<span class="cov8" title="1"> if !event.Success &amp;&amp; len(event.BeforeData) &gt; 0 </span><span class="cov0" title="0">{
                        event.BusinessContext["payload"] = cloneMap(event.BeforeData)
                }</span>
        }

        // 解析/回填 recordId, resourceId, entityCode
        <span class="cov8" title="1">a.resolveIdentifiers(ctx, exec, event)</span>
}

func (a *AuditLogger) resolveIdentifiers(ctx context.Context, exec dbExecutor, event *AuditEvent) <span class="cov8" title="1">{
        if event.ResourceID != "" &amp;&amp; event.RecordID == uuid.Nil </span><span class="cov8" title="1">{
                if rid, err := uuid.Parse(event.ResourceID); err == nil </span><span class="cov0" title="0">{
                        event.RecordID = rid
                }</span>
        }

        <span class="cov8" title="1">if event.RecordID != uuid.Nil &amp;&amp; event.ResourceID == "" </span><span class="cov0" title="0">{
                event.ResourceID = event.RecordID.String()
        }</span>

        <span class="cov8" title="1">if event.EntityCode != "" </span><span class="cov8" title="1">{
                event.BusinessContext["entityCode"] = event.EntityCode
        }</span>

        <span class="cov8" title="1">if event.EntityCode == "" </span><span class="cov8" title="1">{
                if code := firstNonEmpty(
                        extractCode(event.BusinessContext),
                        extractCode(event.AfterData),
                        extractCode(event.BeforeData),
                ); code != "" </span><span class="cov8" title="1">{
                        event.EntityCode = code
                }</span>
        }

        <span class="cov8" title="1">if event.RecordID == uuid.Nil &amp;&amp; event.ResourceType == ResourceTypeOrganization &amp;&amp; event.TenantID != uuid.Nil </span><span class="cov0" title="0">{
                code := firstNonEmpty(event.EntityCode, extractCode(event.BusinessContext), extractCode(event.AfterData), extractCode(event.BeforeData))
                if code != "" </span><span class="cov0" title="0">{
                        var rid uuid.UUID
                        err := exec.QueryRowContext(ctx,
                                `SELECT record_id FROM organization_units WHERE tenant_id = $1 AND code = $2 AND is_current = true LIMIT 1`,
                                event.TenantID, code,
                        ).Scan(&amp;rid)
                        if err == nil </span><span class="cov0" title="0">{
                                event.RecordID = rid
                                event.EntityCode = code
                                event.BusinessContext["entityCode"] = code
                        }</span>
                }
        }

        <span class="cov8" title="1">if event.RecordID != uuid.Nil &amp;&amp; event.ResourceID == "" </span><span class="cov0" title="0">{
                event.ResourceID = event.RecordID.String()
        }</span>

        <span class="cov8" title="1">if event.EntityCode == "" </span><span class="cov8" title="1">{
                event.EntityCode = extractCode(event.BusinessContext)
        }</span>

        <span class="cov8" title="1">if event.EntityCode != "" </span><span class="cov8" title="1">{
                if _, ok := event.BusinessContext["entityCode"]; !ok </span><span class="cov8" title="1">{
                        event.BusinessContext["entityCode"] = event.EntityCode
                }</span>
        }

        <span class="cov8" title="1">if event.ResourceID == "" </span><span class="cov8" title="1">{
                if event.EntityCode != "" </span><span class="cov0" title="0">{
                        event.ResourceID = event.EntityCode
                }</span> else<span class="cov8" title="1"> {
                        event.ResourceID = fmt.Sprintf("%s_%s_%s",
                                firstNonEmpty(event.EventType, "UNKNOWN"),
                                firstNonEmpty(event.ResourceType, "RESOURCE"),
                                firstNonEmpty(event.ActionName, "ACTION"),
                        )
                }</span>
        }
}

func (a *AuditLogger) marshalOrDefault(value interface{}, empty, field string) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return empty
        }</span>
        <span class="cov8" title="1">data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Warnf("审计字段 %s 序列化失败: %v", field, err)
                return empty
        }</span>
        <span class="cov8" title="1">if string(data) == "null" </span><span class="cov8" title="1">{
                return empty
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

func cloneMap(input map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">cloned := make(map[string]interface{}, len(input))
        for k, v := range input </span><span class="cov8" title="1">{
                cloned[k] = v
        }</span>
        <span class="cov8" title="1">return cloned</span>
}

func extractCode(source interface{}) string <span class="cov8" title="1">{
        switch typed := source.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                if v, ok := typed["code"].(string); ok &amp;&amp; strings.TrimSpace(v) != "" </span><span class="cov8" title="1">{
                        return strings.TrimSpace(v)
                }</span>
                <span class="cov8" title="1">if v, ok := typed["entityCode"].(string); ok &amp;&amp; strings.TrimSpace(v) != "" </span><span class="cov0" title="0">{
                        return strings.TrimSpace(v)
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func firstNonEmpty(values ...string) string <span class="cov8" title="1">{
        for _, v := range values </span><span class="cov8" title="1">{
                if strings.TrimSpace(v) != "" </span><span class="cov8" title="1">{
                        return strings.TrimSpace(v)
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func valueOrNil(ptr *string) interface{} <span class="cov8" title="1">{
        if ptr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">val := strings.TrimSpace(*ptr)
        if val == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return val</span>
}

// LogOrganizationCreate 记录组织创建事件 (v4.3.0 - 简化审计信息)
func (a *AuditLogger) LogOrganizationCreate(ctx context.Context, req *types.CreateOrganizationRequest, result *types.Organization, actorID, requestID, operationReason string) error <span class="cov8" title="1">{
        tenantID, _ := uuid.Parse(result.TenantID)
        // 计算创建时的“新增字段”列表（使用实际值作为 newValue）
        createdFields := []FieldChange{
                {Field: "code", DataType: "string", OldValue: nil, NewValue: result.Code},
                {Field: "name", DataType: "string", OldValue: nil, NewValue: result.Name},
                {Field: "unitType", DataType: "string", OldValue: nil, NewValue: result.UnitType},
                {Field: "parentCode", DataType: "string", OldValue: nil, NewValue: valueOrNil(result.ParentCode)},
                {Field: "status", DataType: "string", OldValue: nil, NewValue: result.Status},
                {Field: "level", DataType: "int", OldValue: nil, NewValue: result.Level},
        }
        modifiedFields := []string{"code", "name", "unitType", "parentCode", "status", "level"}

        if result.EffectiveDate != nil </span><span class="cov0" title="0">{
                createdFields = append(createdFields, FieldChange{
                        Field:    "effectiveDate",
                        OldValue: nil,
                        NewValue: result.EffectiveDate.String(),
                        DataType: "date",
                })
                modifiedFields = append(modifiedFields, "effectiveDate")
        }</span>
        <span class="cov8" title="1">if result.EndDate != nil </span><span class="cov0" title="0">{
                createdFields = append(createdFields, FieldChange{
                        Field:    "endDate",
                        OldValue: nil,
                        NewValue: result.EndDate.String(),
                        DataType: "date",
                })
                modifiedFields = append(modifiedFields, "endDate")
        }</span>

        <span class="cov8" title="1">recordID, _ := uuid.Parse(result.RecordID)
        afterData := map[string]interface{}{
                "code":       result.Code,
                "name":       result.Name,
                "unitType":   result.UnitType,
                "parentCode": result.ParentCode,
                "status":     result.Status,
                "level":      result.Level,
        }

        event := &amp;AuditEvent{
                TenantID:        tenantID,
                EventType:       EventTypeCreate,
                ResourceType:    ResourceTypeOrganization,
                ResourceID:      result.RecordID,
                RecordID:        recordID,
                EntityCode:      result.Code,
                ActorID:         actorID,
                ActorType:       ActorTypeUser,
                ActionName:      "CreateOrganization",
                RequestID:       requestID,
                OperationReason: operationReason,
                Success:         true,
                ModifiedFields:  modifiedFields,
                Changes:         createdFields,
                AfterData:       afterData,
                ContextPayload:  cloneMap(afterData),
        }

        return a.LogEvent(ctx, event)</span>
}

// LogOrganizationUpdate 记录组织更新事件 (v4.3.0 - 简化参数，保留FieldChange)
func (a *AuditLogger) LogOrganizationUpdate(ctx context.Context, code string, req *types.UpdateOrganizationRequest, oldOrg, newOrg *types.Organization, actorID, requestID, operationReason string) error <span class="cov0" title="0">{
        changes := a.calculateFieldChanges(oldOrg, newOrg)
        modifiedFields := make([]string, len(changes))
        for i, change := range changes </span><span class="cov0" title="0">{
                modifiedFields[i] = change.Field
        }</span>

        <span class="cov0" title="0">tenantID, _ := uuid.Parse(newOrg.TenantID)

        var beforeData, afterData map[string]interface{}
        if oldOrg != nil </span><span class="cov0" title="0">{
                beforeData = structToMap(oldOrg)
        }</span>
        <span class="cov0" title="0">if newOrg != nil </span><span class="cov0" title="0">{
                afterData = structToMap(newOrg)
        }</span>

        // 使用newOrg的RecordID作为ResourceID
        <span class="cov0" title="0">resourceID := ""
        if newOrg != nil </span><span class="cov0" title="0">{
                resourceID = newOrg.RecordID
        }</span> else<span class="cov0" title="0"> if oldOrg != nil </span><span class="cov0" title="0">{
                resourceID = oldOrg.RecordID
        }</span>
        <span class="cov0" title="0">recordUUID, _ := uuid.Parse(resourceID)

        event := &amp;AuditEvent{
                TenantID:        tenantID,
                EventType:       EventTypeUpdate,
                ResourceType:    ResourceTypeOrganization,
                ResourceID:      resourceID,
                RecordID:        recordUUID,
                EntityCode:      code,
                ActorID:         actorID,
                ActorType:       ActorTypeUser,
                ActionName:      "UpdateOrganization",
                RequestID:       requestID,
                OperationReason: operationReason,
                Success:         true,
                BeforeData:      beforeData,
                AfterData:       afterData,
                ContextPayload:  cloneMap(afterData),
                Changes:         changes,
                ModifiedFields:  modifiedFields,
        }

        return a.LogEvent(ctx, event)</span>
}

// LogOrganizationSuspend 记录组织停用事件 (v4.3.0 - 简化参数)
func (a *AuditLogger) LogOrganizationSuspend(ctx context.Context, code string, org *types.Organization, actorID, requestID, operationReason string) error <span class="cov0" title="0">{
        tenantID, _ := uuid.Parse(org.TenantID)
        // 停用：记录状态字段变更
        changes := []FieldChange{{Field: "status", OldValue: org.Status, NewValue: "INACTIVE", DataType: "string"}}
        modified := []string{"status"}
        recordID, _ := uuid.Parse(org.RecordID)
        afterData := map[string]interface{}{
                "code":   org.Code,
                "status": "INACTIVE",
                "level":  org.Level,
        }
        event := &amp;AuditEvent{
                TenantID:        tenantID,
                EventType:       EventTypeSuspend,
                ResourceType:    ResourceTypeOrganization,
                ResourceID:      org.RecordID,
                RecordID:        recordID,
                EntityCode:      org.Code,
                ActorID:         actorID,
                ActorType:       ActorTypeUser,
                ActionName:      "SuspendOrganization",
                RequestID:       requestID,
                OperationReason: operationReason,
                Success:         true,
                ModifiedFields:  modified,
                Changes:         changes,
                AfterData:       afterData,
                ContextPayload:  cloneMap(afterData),
        }

        return a.LogEvent(ctx, event)
}</span>

// LogOrganizationActivate 记录组织激活事件 (v4.3.0 - 简化参数)
func (a *AuditLogger) LogOrganizationActivate(ctx context.Context, code string, org *types.Organization, actorID, requestID, operationReason string) error <span class="cov0" title="0">{
        tenantID, _ := uuid.Parse(org.TenantID)
        // 激活：记录状态字段变更
        changes := []FieldChange{{Field: "status", OldValue: org.Status, NewValue: "ACTIVE", DataType: "string"}}
        modified := []string{"status"}
        recordID, _ := uuid.Parse(org.RecordID)
        afterData := map[string]interface{}{
                "code":   org.Code,
                "status": "ACTIVE",
                "level":  org.Level,
        }
        event := &amp;AuditEvent{
                TenantID:        tenantID,
                EventType:       EventTypeActivate,
                ResourceType:    ResourceTypeOrganization,
                ResourceID:      org.RecordID,
                RecordID:        recordID,
                EntityCode:      org.Code,
                ActorID:         actorID,
                ActorType:       ActorTypeUser,
                ActionName:      "ActivateOrganization",
                RequestID:       requestID,
                OperationReason: operationReason,
                Success:         true,
                ModifiedFields:  modified,
                Changes:         changes,
                AfterData:       afterData,
                ContextPayload:  cloneMap(afterData),
        }

        return a.LogEvent(ctx, event)
}</span>

// LogOrganizationDelete 记录组织删除事件 (v4.3.0 - 简化参数)
func (a *AuditLogger) LogOrganizationDelete(ctx context.Context, tenantID uuid.UUID, code string, org *types.Organization, actorID, requestID, operationReason string) error <span class="cov8" title="1">{
        if org == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("organization snapshot required for delete audit logging")
        }</span>

        <span class="cov8" title="1">resourceID := strings.TrimSpace(org.RecordID)
        if resourceID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("organization recordId is required for delete audit logging")
        }</span>
        <span class="cov8" title="1">recordUUID, err := uuid.Parse(resourceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid organization recordId for audit logging: %w", err)
        }</span>

        <span class="cov8" title="1">beforeData := map[string]interface{}{
                "code":   org.Code,
                "name":   org.Name,
                "status": org.Status,
                "level":  org.Level,
        }

        // 删除：记录状态字段变更为 DELETED
        changes := []FieldChange{{Field: "status", OldValue: org.Status, NewValue: "DELETED", DataType: "string"}}
        modified := []string{"status"}
        event := &amp;AuditEvent{
                TenantID:        tenantID,
                EventType:       EventTypeDelete,
                ResourceType:    ResourceTypeOrganization,
                ResourceID:      resourceID,
                RecordID:        recordUUID,
                EntityCode:      code,
                ActorID:         actorID,
                ActorType:       ActorTypeUser,
                ActionName:      "DeleteOrganization",
                RequestID:       requestID,
                OperationReason: operationReason,
                Success:         true,
                ModifiedFields:  modified,
                Changes:         changes,
                BeforeData:      beforeData,
                ContextPayload:  cloneMap(beforeData),
        }

        return a.LogEvent(ctx, event)</span>
}

// LogError 记录错误事件 (v4.3.0 - 简化参数)
func (a *AuditLogger) LogError(ctx context.Context, tenantID uuid.UUID, resourceType, resourceID, actionName, actorID, requestID, errorCode, errorMessage string, requestData map[string]interface{}) error <span class="cov8" title="1">{
        payload := cloneMap(requestData)
        businessContext := map[string]interface{}{}
        if ruleID, ok := payload["ruleId"]; ok </span><span class="cov0" title="0">{
                businessContext["ruleId"] = ruleID
        }</span>
        <span class="cov8" title="1">if severity, ok := payload["severity"]; ok </span><span class="cov0" title="0">{
                businessContext["severity"] = severity
        }</span>
        <span class="cov8" title="1">if rawPayload, ok := payload["payload"]; ok </span><span class="cov0" title="0">{
                businessContext["payload"] = rawPayload
        }</span>
        <span class="cov8" title="1">if httpStatus, ok := payload["httpStatus"]; ok </span><span class="cov0" title="0">{
                businessContext["httpStatus"] = httpStatus
        }</span>
        <span class="cov8" title="1">if len(businessContext) == 0 </span><span class="cov8" title="1">{
                businessContext = nil
        }</span>

        <span class="cov8" title="1">event := &amp;AuditEvent{
                TenantID:        tenantID,
                EventType:       EventTypeError,
                ResourceType:    resourceType,
                ResourceID:      resourceID,
                EntityCode:      resourceID,
                ActorID:         actorID,
                ActorType:       ActorTypeUser,
                ActionName:      actionName,
                RequestID:       requestID,
                Success:         false,
                ErrorCode:       errorCode,
                ErrorMessage:    errorMessage,
                BeforeData:      payload,
                ContextPayload:  payload,
                BusinessContext: businessContext,
        }

        return a.LogEvent(ctx, event)</span>
}

// calculateFieldChanges 计算字段变更
func (a *AuditLogger) calculateFieldChanges(oldOrg, newOrg *types.Organization) []FieldChange <span class="cov0" title="0">{
        var changes []FieldChange

        // 安全检查：确保两个组织对象都不为nil
        if oldOrg == nil || newOrg == nil </span><span class="cov0" title="0">{
                // 如果oldOrg为nil，表示这是创建操作或无法获取旧数据
                // 如果newOrg为nil，表示这是删除操作或数据获取失败
                // 在这些情况下，返回空的变更列表
                return changes
        }</span>

        <span class="cov0" title="0">if oldOrg.Name != newOrg.Name </span><span class="cov0" title="0">{
                changes = append(changes, FieldChange{
                        Field:    "name",
                        OldValue: oldOrg.Name,
                        NewValue: newOrg.Name,
                        DataType: "string",
                })
        }</span>

        <span class="cov0" title="0">if oldOrg.Status != newOrg.Status </span><span class="cov0" title="0">{
                changes = append(changes, FieldChange{
                        Field:    "status",
                        OldValue: oldOrg.Status,
                        NewValue: newOrg.Status,
                        DataType: "string",
                })
        }</span>

        <span class="cov0" title="0">if oldOrg.Description != newOrg.Description </span><span class="cov0" title="0">{
                changes = append(changes, FieldChange{
                        Field:    "description",
                        OldValue: oldOrg.Description,
                        NewValue: newOrg.Description,
                        DataType: "string",
                })
        }</span>

        <span class="cov0" title="0">if oldOrg.SortOrder != newOrg.SortOrder </span><span class="cov0" title="0">{
                changes = append(changes, FieldChange{
                        Field:    "sortOrder",
                        OldValue: oldOrg.SortOrder,
                        NewValue: newOrg.SortOrder,
                        DataType: "int",
                })
        }</span>

        // 检查父组织变更
        <span class="cov0" title="0">oldParent := ""
        newParent := ""
        if oldOrg.ParentCode != nil </span><span class="cov0" title="0">{
                oldParent = *oldOrg.ParentCode
        }</span>
        <span class="cov0" title="0">if newOrg.ParentCode != nil </span><span class="cov0" title="0">{
                newParent = *newOrg.ParentCode
        }</span>

        <span class="cov0" title="0">if oldParent != newParent </span><span class="cov0" title="0">{
                changes = append(changes, FieldChange{
                        Field:    "parentCode",
                        OldValue: oldParent,
                        NewValue: newParent,
                        DataType: "string",
                })
        }</span>

        // 检查生效日期变更
        <span class="cov0" title="0">if (oldOrg.EffectiveDate == nil) != (newOrg.EffectiveDate == nil) </span><span class="cov0" title="0">{
                // 一个为nil，一个不为nil
                changes = append(changes, FieldChange{
                        Field:    "effectiveDate",
                        OldValue: oldOrg.EffectiveDate,
                        NewValue: newOrg.EffectiveDate,
                        DataType: "date",
                })
        }</span> else<span class="cov0" title="0"> if oldOrg.EffectiveDate != nil &amp;&amp; newOrg.EffectiveDate != nil </span><span class="cov0" title="0">{
                // 都不为nil，比较日期值
                if !oldOrg.EffectiveDate.Time.Equal(newOrg.EffectiveDate.Time) </span><span class="cov0" title="0">{
                        changes = append(changes, FieldChange{
                                Field:    "effectiveDate",
                                OldValue: oldOrg.EffectiveDate,
                                NewValue: newOrg.EffectiveDate,
                                DataType: "date",
                        })
                }</span>
        }

        // 检查结束日期变更
        <span class="cov0" title="0">if (oldOrg.EndDate == nil) != (newOrg.EndDate == nil) </span><span class="cov0" title="0">{
                // 一个为nil，一个不为nil
                changes = append(changes, FieldChange{
                        Field:    "endDate",
                        OldValue: oldOrg.EndDate,
                        NewValue: newOrg.EndDate,
                        DataType: "date",
                })
        }</span> else<span class="cov0" title="0"> if oldOrg.EndDate != nil &amp;&amp; newOrg.EndDate != nil </span><span class="cov0" title="0">{
                // 都不为nil，比较日期值
                if !oldOrg.EndDate.Time.Equal(newOrg.EndDate.Time) </span><span class="cov0" title="0">{
                        changes = append(changes, FieldChange{
                                Field:    "endDate",
                                OldValue: oldOrg.EndDate,
                                NewValue: newOrg.EndDate,
                                DataType: "date",
                        })
                }</span>
        }

        // 检查变更原因
        <span class="cov0" title="0">if (oldOrg.ChangeReason == nil) != (newOrg.ChangeReason == nil) </span><span class="cov0" title="0">{
                // 一个为nil，一个不为nil
                changes = append(changes, FieldChange{
                        Field:    "changeReason",
                        OldValue: oldOrg.ChangeReason,
                        NewValue: newOrg.ChangeReason,
                        DataType: "string",
                })
        }</span> else<span class="cov0" title="0"> if oldOrg.ChangeReason != nil &amp;&amp; newOrg.ChangeReason != nil </span><span class="cov0" title="0">{
                // 都不为nil，比较字符串值
                if *oldOrg.ChangeReason != *newOrg.ChangeReason </span><span class="cov0" title="0">{
                        changes = append(changes, FieldChange{
                                Field:    "changeReason",
                                OldValue: *oldOrg.ChangeReason,
                                NewValue: *newOrg.ChangeReason,
                                DataType: "string",
                        })
                }</span>
        }

        <span class="cov0" title="0">return changes</span>
}

// structToMap 将结构体转换为map
func structToMap(obj interface{}) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        data, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetAuditHistory 获取资源审计历史
func (a *AuditLogger) GetAuditHistory(ctx context.Context, resourceType, resourceID string, tenantID uuid.UUID, limit int) ([]AuditEvent, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">query := `
        SELECT
                id, tenant_id, event_type, resource_type, resource_id,
                actor_id, actor_type, action_name, request_id,
                COALESCE(operation_reason, '') as operation_reason,
                timestamp, success,
                COALESCE(error_code, '') as error_code,
                COALESCE(error_message, '') as error_message,
                COALESCE(request_data, '{}'::jsonb)::text as request_data,
                COALESCE(response_data, '{}'::jsonb)::text as response_data,
                COALESCE(modified_fields, '[]'::jsonb)::text as modified_fields,
                COALESCE(changes, '[]'::jsonb)::text as changes,
                COALESCE(record_id::text, '') as record_id,
                COALESCE(business_context, '{}'::jsonb)::text as business_context
        FROM audit_logs
        WHERE resource_type = $1 AND resource_id = $2 AND tenant_id = $3
        ORDER BY timestamp DESC
        LIMIT $4`

        rows, err := a.db.QueryContext(ctx, query, resourceType, resourceID, tenantID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query audit history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []AuditEvent
        for rows.Next() </span><span class="cov0" title="0">{
                var event AuditEvent
                var beforeDataJSON, afterDataJSON, modifiedFieldsJSON, changesJSON string
                var recordIDStr, businessContextJSON string

                err := rows.Scan(
                        &amp;event.ID, &amp;event.TenantID, &amp;event.EventType, &amp;event.ResourceType, &amp;event.ResourceID,
                        &amp;event.ActorID, &amp;event.ActorType, &amp;event.ActionName, &amp;event.RequestID,
                        &amp;event.OperationReason, &amp;event.Timestamp, &amp;event.Success,
                        &amp;event.ErrorCode, &amp;event.ErrorMessage, &amp;beforeDataJSON, &amp;afterDataJSON,
                        &amp;modifiedFieldsJSON, &amp;changesJSON, &amp;recordIDStr, &amp;businessContextJSON,
                )
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Errorf("扫描审计记录失败: %v", err)
                        continue</span>
                }

                // 反序列化JSON字段
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(beforeDataJSON), &amp;event.BeforeData); err != nil </span><span class="cov0" title="0">{
                        a.logger.Warnf("解析before_data失败: %v", err)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(afterDataJSON), &amp;event.AfterData); err != nil </span><span class="cov0" title="0">{
                        a.logger.Warnf("解析after_data失败: %v", err)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(modifiedFieldsJSON), &amp;event.ModifiedFields); err != nil </span><span class="cov0" title="0">{
                        a.logger.Warnf("解析modified_fields失败: %v", err)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(changesJSON), &amp;event.Changes); err != nil </span><span class="cov0" title="0">{
                        a.logger.Warnf("解析changes失败: %v", err)
                }</span>
                <span class="cov0" title="0">if businessContextJSON != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(businessContextJSON), &amp;event.BusinessContext); err != nil </span><span class="cov0" title="0">{
                                a.logger.Warnf("解析business_context失败: %v", err)
                        }</span>
                }
                <span class="cov0" title="0">if recordIDStr != "" </span><span class="cov0" title="0">{
                        if rid, err := uuid.Parse(recordIDStr); err == nil </span><span class="cov0" title="0">{
                                event.RecordID = rid
                        }</span>
                }

                <span class="cov0" title="0">if event.BusinessContext != nil </span><span class="cov0" title="0">{
                        if v, ok := event.BusinessContext["correlationId"].(string); ok </span><span class="cov0" title="0">{
                                event.CorrelationID = v
                        }</span>
                        <span class="cov0" title="0">if v, ok := event.BusinessContext["sourceCorrelation"].(string); ok </span><span class="cov0" title="0">{
                                event.SourceCorrelation = v
                        }</span>
                        <span class="cov0" title="0">if v, ok := event.BusinessContext["entityCode"].(string); ok </span><span class="cov0" title="0">{
                                event.EntityCode = v
                        }</span>
                        <span class="cov0" title="0">if v, ok := event.BusinessContext["actorName"].(string); ok </span><span class="cov0" title="0">{
                                event.ActorName = v
                        }</span>
                        <span class="cov0" title="0">if payload, ok := event.BusinessContext["payload"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                event.ContextPayload = payload
                        }</span>
                }

                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">a.logger.Infof("审计历史查询: %s/%s, 返回%d条记录", resourceType, resourceID, len(events))
        return events, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dto

import (
        "fmt"
        "math"
        "strconv"
        "strings"
        "time"
)

// Organization 表示 GraphQL 暴露的组织实体，字段与数据库列保持一一对应
type Organization struct {
        RecordIDField         string     `json:"recordId" db:"record_id"`
        TenantIDField         string     `json:"tenantId" db:"tenant_id"`
        CodeField             string     `json:"code" db:"code"`
        ParentCodeField       *string    `json:"parentCode" db:"parent_code"`
        NameField             string     `json:"name" db:"name"`
        UnitTypeField         string     `json:"unitType" db:"unit_type"`
        StatusField           string     `json:"status" db:"status"`
        LevelField            int        `json:"level" db:"level"`
        CodePathField         string     `json:"codePath" db:"code_path"`
        NamePathField         string     `json:"namePath" db:"name_path"`
        SortOrderField        *int       `json:"sortOrder" db:"sort_order"`
        DescriptionField      *string    `json:"description" db:"description"`
        ProfileField          *string    `json:"profile" db:"profile"`
        CreatedAtField        time.Time  `json:"createdAt" db:"created_at"`
        UpdatedAtField        time.Time  `json:"updatedAt" db:"updated_at"`
        EffectiveDateField    time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField          *time.Time `json:"endDate" db:"end_date"`
        IsCurrentField        bool       `json:"isCurrent" db:"is_current"`
        ChangeReasonField     *string    `json:"changeReason" db:"change_reason"`
        DeletedAtField        *time.Time `json:"deletedAt" db:"deleted_at"`
        DeletedByField        *string    `json:"deletedBy" db:"deleted_by"`
        DeletionReasonField   *string    `json:"deletionReason" db:"deletion_reason"`
        SuspendedAtField      *time.Time `json:"suspendedAt" db:"suspended_at"`
        SuspendedByField      *string    `json:"suspendedBy" db:"suspended_by"`
        SuspensionReasonField *string    `json:"suspensionReason" db:"suspension_reason"`

        HierarchyDepthField int `json:"hierarchyDepth" db:"hierarchy_depth"`
        ChildrenCountField  int `json:"childrenCount" db:"children_count"`
}

func clampToInt32(value int) int32 <span class="cov8" title="1">{
        if value &gt; math.MaxInt32 </span><span class="cov8" title="1">{
                return math.MaxInt32
        }</span>
        <span class="cov8" title="1">if value &lt; math.MinInt32 </span><span class="cov8" title="1">{
                return math.MinInt32
        }</span>
        <span class="cov8" title="1">return int32(value)</span>
}

func clampToInt32Ptr(src *int) *int32 <span class="cov8" title="1">{
        if src == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">val := clampToInt32(*src)
        return &amp;val</span>
}

func (o Organization) RecordId() string <span class="cov8" title="1">{ return o.RecordIDField }</span>
func (o Organization) TenantId() string <span class="cov8" title="1">{ return o.TenantIDField }</span>
func (o Organization) Code() string     <span class="cov8" title="1">{ return o.CodeField }</span>

func (o Organization) ParentCode() string <span class="cov8" title="1">{
        if o.ParentCodeField == nil </span><span class="cov0" title="0">{
                return "0"
        }</span>
        <span class="cov8" title="1">return *o.ParentCodeField</span>
}

func (o Organization) Name() string     <span class="cov8" title="1">{ return o.NameField }</span>
func (o Organization) UnitType() string <span class="cov8" title="1">{ return o.UnitTypeField }</span>
func (o Organization) Status() string   <span class="cov8" title="1">{ return o.StatusField }</span>
func (o Organization) Level() int32     <span class="cov8" title="1">{ return clampToInt32(o.LevelField) }</span>
func (o Organization) Path() *string <span class="cov8" title="1">{
        if o.CodePathField == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">path := o.CodePathField
        return &amp;path</span>
}
func (o Organization) CodePath() string <span class="cov8" title="1">{
        if o.CodePathField != "" </span><span class="cov8" title="1">{
                return o.CodePathField
        }</span>
        <span class="cov8" title="1">return ""</span>
}
func (o Organization) NamePath() string <span class="cov8" title="1">{
        if o.NamePathField != "" </span><span class="cov8" title="1">{
                return o.NamePathField
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func (o Organization) SortOrder() *int32 <span class="cov8" title="1">{
        return clampToInt32Ptr(o.SortOrderField)
}</span>
func (o Organization) Description() *string  <span class="cov8" title="1">{ return o.DescriptionField }</span>
func (o Organization) Profile() *string      <span class="cov8" title="1">{ return o.ProfileField }</span>
func (o Organization) CreatedAt() string     <span class="cov8" title="1">{ return o.CreatedAtField.Format(time.RFC3339) }</span>
func (o Organization) UpdatedAt() string     <span class="cov8" title="1">{ return o.UpdatedAtField.Format(time.RFC3339) }</span>
func (o Organization) EffectiveDate() string <span class="cov8" title="1">{ return o.EffectiveDateField.Format("2006-01-02") }</span>

func (o Organization) EndDate() *string <span class="cov8" title="1">{
        if o.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">date := o.EndDateField.Format("2006-01-02")
        return &amp;date</span>
}

func (o Organization) IsCurrent() bool <span class="cov8" title="1">{ return o.IsCurrentField }</span>

func cnTodayDate() time.Time <span class="cov8" title="1">{
        loc, err := time.LoadLocation("Asia/Shanghai")
        if err != nil </span><span class="cov0" title="0">{
                return time.Now().UTC().Truncate(24 * time.Hour)
        }</span>
        <span class="cov8" title="1">nowCN := time.Now().In(loc)
        return time.Date(nowCN.Year(), nowCN.Month(), nowCN.Day(), 0, 0, 0, 0, loc)</span>
}

func (o Organization) IsTemporal() bool <span class="cov8" title="1">{
        return o.EndDateField != nil
}</span>

func (o Organization) IsFuture() bool <span class="cov8" title="1">{
        todayCN := cnTodayDate()
        eff := time.Date(o.EffectiveDateField.Year(), o.EffectiveDateField.Month(), o.EffectiveDateField.Day(), 0, 0, 0, 0, todayCN.Location())
        return eff.After(todayCN)
}</span>

func (o Organization) ChangeReason() *string <span class="cov8" title="1">{ return o.ChangeReasonField }</span>

func (o Organization) HierarchyDepth() int32 <span class="cov8" title="1">{ return clampToInt32(o.HierarchyDepthField) }</span>
func (o Organization) ChildrenCount() int32  <span class="cov8" title="1">{ return clampToInt32(o.ChildrenCountField) }</span>

func (o Organization) DeletedAt() *string <span class="cov8" title="1">{
        if o.DeletedAtField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ts := o.DeletedAtField.Format(time.RFC3339)
        return &amp;ts</span>
}

func (o Organization) DeletedBy() *string <span class="cov8" title="1">{ return o.DeletedByField }</span>

func (o Organization) DeletionReason() *string <span class="cov8" title="1">{ return o.DeletionReasonField }</span>

func (o Organization) SuspendedAt() *string <span class="cov8" title="1">{
        if o.SuspendedAtField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ts := o.SuspendedAtField.Format(time.RFC3339)
        return &amp;ts</span>
}

func (o Organization) SuspendedBy() *string <span class="cov8" title="1">{ return o.SuspendedByField }</span>

func (o Organization) SuspensionReason() *string <span class="cov8" title="1">{ return o.SuspensionReasonField }</span>

// OrganizationStats 统计信息
type OrganizationStats struct {
        TotalCountField    int           `json:"totalCount"`
        ActiveCountField   int           `json:"activeCount"`
        InactiveCountField int           `json:"inactiveCount"`
        PlannedCountField  int           `json:"plannedCount"`
        DeletedCountField  int           `json:"deletedCount"`
        ByTypeField        []TypeCount   `json:"byType"`
        ByStatusField      []StatusCount `json:"byStatus"`
        ByLevelField       []LevelCount  `json:"byLevel"`
        TemporalStatsField TemporalStats `json:"temporalStats"`
}

func (s OrganizationStats) TotalCount() int32    <span class="cov8" title="1">{ return int32(s.TotalCountField) }</span>
func (s OrganizationStats) ActiveCount() int32   <span class="cov8" title="1">{ return int32(s.ActiveCountField) }</span>
func (s OrganizationStats) InactiveCount() int32 <span class="cov8" title="1">{ return int32(s.InactiveCountField) }</span>
func (s OrganizationStats) PlannedCount() int32  <span class="cov0" title="0">{ return int32(s.PlannedCountField) }</span>
func (s OrganizationStats) DeletedCount() int32  <span class="cov0" title="0">{ return int32(s.DeletedCountField) }</span>
func (s OrganizationStats) ByType() []TypeCount  <span class="cov8" title="1">{ return s.ByTypeField }</span>
func (s OrganizationStats) ByStatus() []StatusCount <span class="cov8" title="1">{
        return s.ByStatusField
}</span>
func (s OrganizationStats) ByLevel() []LevelCount <span class="cov8" title="1">{ return s.ByLevelField }</span>
func (s OrganizationStats) TemporalStats() TemporalStats <span class="cov8" title="1">{
        return s.TemporalStatsField
}</span>

// TemporalStats 时态统计信息
type TemporalStats struct {
        TotalVersionsField         int     `json:"totalVersions"`
        AverageVersionsPerOrgField float64 `json:"averageVersionsPerOrg"`
        OldestEffectiveDateField   string  `json:"oldestEffectiveDate"`
        NewestEffectiveDateField   string  `json:"newestEffectiveDate"`
}

func (t TemporalStats) TotalVersions() int32 <span class="cov8" title="1">{ return int32(t.TotalVersionsField) }</span>
func (t TemporalStats) AverageVersionsPerOrg() float64 <span class="cov0" title="0">{
        return t.AverageVersionsPerOrgField
}</span>
func (t TemporalStats) OldestEffectiveDate() string <span class="cov0" title="0">{
        return t.OldestEffectiveDateField
}</span>
func (t TemporalStats) NewestEffectiveDate() string <span class="cov0" title="0">{
        return t.NewestEffectiveDateField
}</span>

// TypeCount 类型统计
type TypeCount struct {
        UnitTypeField string `json:"unitType"`
        CountField    int    `json:"count"`
}

func (t TypeCount) UnitType() string <span class="cov8" title="1">{ return t.UnitTypeField }</span>
func (t TypeCount) Count() int32     <span class="cov8" title="1">{ return int32(t.CountField) }</span>

// LevelCount 层级统计
type LevelCount struct {
        LevelField int `json:"level"`
        CountField int `json:"count"`
}

func (l LevelCount) Level() int32 <span class="cov8" title="1">{ return int32(l.LevelField) }</span>
func (l LevelCount) Count() int32 <span class="cov8" title="1">{ return int32(l.CountField) }</span>

// StatusCount 状态统计
type StatusCount struct {
        StatusField string `json:"status"`
        CountField  int    `json:"count"`
}

func (s StatusCount) Status() string <span class="cov8" title="1">{ return s.StatusField }</span>
func (s StatusCount) Count() int32   <span class="cov8" title="1">{ return int32(s.CountField) }</span>

// OrganizationConnection GraphQL 分页封装
type OrganizationConnection struct {
        DataField       []Organization `json:"data"`
        PaginationField PaginationInfo `json:"pagination"`
        TemporalField   TemporalInfo   `json:"temporal"`
}

func (c OrganizationConnection) Data() []Organization <span class="cov8" title="1">{ return c.DataField }</span>
func (c OrganizationConnection) Pagination() PaginationInfo <span class="cov8" title="1">{
        return c.PaginationField
}</span>
func (c OrganizationConnection) Temporal() TemporalInfo <span class="cov8" title="1">{ return c.TemporalField }</span>

// PaginationInfo 分页元信息
type PaginationInfo struct {
        TotalField       int  `json:"total"`
        PageField        int  `json:"page"`
        PageSizeField    int  `json:"pageSize"`
        HasNextField     bool `json:"hasNext"`
        HasPreviousField bool `json:"hasPrevious"`
}

func (p PaginationInfo) Total() int32      <span class="cov8" title="1">{ return int32(p.TotalField) }</span>
func (p PaginationInfo) Page() int32       <span class="cov8" title="1">{ return int32(p.PageField) }</span>
func (p PaginationInfo) PageSize() int32   <span class="cov8" title="1">{ return int32(p.PageSizeField) }</span>
func (p PaginationInfo) HasNext() bool     <span class="cov8" title="1">{ return p.HasNextField }</span>
func (p PaginationInfo) HasPrevious() bool <span class="cov8" title="1">{ return p.HasPreviousField }</span>

// TemporalInfo 时态信息
type TemporalInfo struct {
        AsOfDateField        string `json:"asOfDate"`
        CurrentCountField    int    `json:"currentCount"`
        FutureCountField     int    `json:"futureCount"`
        HistoricalCountField int    `json:"historicalCount"`
}

func (t TemporalInfo) AsOfDate() string       <span class="cov0" title="0">{ return t.AsOfDateField }</span>
func (t TemporalInfo) CurrentCount() int32    <span class="cov8" title="1">{ return int32(t.CurrentCountField) }</span>
func (t TemporalInfo) FutureCount() int32     <span class="cov0" title="0">{ return int32(t.FutureCountField) }</span>
func (t TemporalInfo) HistoricalCount() int32 <span class="cov0" title="0">{ return int32(t.HistoricalCountField) }</span>

// OrganizationHierarchyData 组织层级数据
type OrganizationHierarchyData struct {
        CodeField           string                      `json:"code"`
        NameField           string                      `json:"name"`
        LevelField          int                         `json:"level"`
        HierarchyDepthField int                         `json:"hierarchyDepth"`
        CodePathField       *string                     `json:"codePath"`
        NamePathField       *string                     `json:"namePath"`
        ParentChainField    []string                    `json:"parentChain"`
        ChildrenCountField  int                         `json:"childrenCount"`
        IsRootField         bool                        `json:"isRoot"`
        IsLeafField         bool                        `json:"isLeaf"`
        ChildrenField       []OrganizationHierarchyData `json:"children"`
}

func (o OrganizationHierarchyData) Code() string          <span class="cov8" title="1">{ return o.CodeField }</span>
func (o OrganizationHierarchyData) Name() string          <span class="cov8" title="1">{ return o.NameField }</span>
func (o OrganizationHierarchyData) Level() int32          <span class="cov8" title="1">{ return int32(o.LevelField) }</span>
func (o OrganizationHierarchyData) HierarchyDepth() int32 <span class="cov0" title="0">{ return int32(o.HierarchyDepthField) }</span>
func (o OrganizationHierarchyData) CodePath() string <span class="cov8" title="1">{
        if o.CodePathField == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return *o.CodePathField</span>
}
func (o OrganizationHierarchyData) NamePath() string <span class="cov8" title="1">{
        if o.NamePathField == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return *o.NamePathField</span>
}
func (o OrganizationHierarchyData) ParentChain() []string <span class="cov0" title="0">{ return o.ParentChainField }</span>
func (o OrganizationHierarchyData) ChildrenCount() int32  <span class="cov0" title="0">{ return int32(o.ChildrenCountField) }</span>
func (o OrganizationHierarchyData) IsRoot() bool          <span class="cov8" title="1">{ return o.IsRootField }</span>
func (o OrganizationHierarchyData) IsLeaf() bool          <span class="cov8" title="1">{ return o.IsLeafField }</span>
func (o OrganizationHierarchyData) Children() []OrganizationHierarchyData <span class="cov8" title="1">{
        return o.ChildrenField
}</span>

// OrganizationSubtreeData 子树数据模型
type OrganizationSubtreeData struct {
        CodeField           string                    `json:"code"`
        NameField           string                    `json:"name"`
        LevelField          int                       `json:"level"`
        HierarchyDepthField int                       `json:"hierarchyDepth"`
        CodePathField       *string                   `json:"codePath"`
        NamePathField       *string                   `json:"namePath"`
        ParentChainField    []string                  `json:"parentChain"`
        ChildrenCountField  int                       `json:"childrenCount"`
        IsRootField         bool                      `json:"isRoot"`
        IsLeafField         bool                      `json:"isLeaf"`
        ChildrenField       []OrganizationSubtreeData `json:"children"`
}

func (o OrganizationSubtreeData) Code() string <span class="cov0" title="0">{ return o.CodeField }</span>
func (o OrganizationSubtreeData) Name() string <span class="cov0" title="0">{ return o.NameField }</span>
func (o OrganizationSubtreeData) Level() int32 <span class="cov0" title="0">{ return int32(o.LevelField) }</span>
func (o OrganizationSubtreeData) HierarchyDepth() int32 <span class="cov0" title="0">{
        return int32(o.HierarchyDepthField)
}</span>
func (o OrganizationSubtreeData) CodePath() string <span class="cov8" title="1">{
        if o.CodePathField == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return *o.CodePathField</span>
}
func (o OrganizationSubtreeData) NamePath() string <span class="cov8" title="1">{
        if o.NamePathField == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return *o.NamePathField</span>
}
func (o OrganizationSubtreeData) ParentChain() []string <span class="cov0" title="0">{
        return o.ParentChainField
}</span>
func (o OrganizationSubtreeData) ChildrenCount() int32 <span class="cov0" title="0">{ return int32(o.ChildrenCountField) }</span>
func (o OrganizationSubtreeData) IsRoot() bool         <span class="cov0" title="0">{ return o.IsRootField }</span>
func (o OrganizationSubtreeData) IsLeaf() bool         <span class="cov0" title="0">{ return o.IsLeafField }</span>
func (o OrganizationSubtreeData) Children() []OrganizationSubtreeData <span class="cov0" title="0">{
        return o.ChildrenField
}</span>

// HierarchyStatistics 层级统计模型
type HierarchyStatistics struct {
        TenantIdField           string              `json:"tenantId"`
        TotalOrganizationsField int                 `json:"totalOrganizations"`
        MaxDepthField           int                 `json:"maxDepth"`
        AvgDepthField           float64             `json:"avgDepth"`
        DepthDistributionField  []DepthDistribution `json:"depthDistribution"`
        RootOrganizationsField  int                 `json:"rootOrganizations"`
        LeafOrganizationsField  int                 `json:"leafOrganizations"`
        IntegrityIssuesField    []IntegrityIssue    `json:"integrityIssues"`
        LastAnalyzedField       string              `json:"lastAnalyzed"`
}

func (h HierarchyStatistics) TenantId() string          <span class="cov0" title="0">{ return h.TenantIdField }</span>
func (h HierarchyStatistics) TotalOrganizations() int32 <span class="cov0" title="0">{ return int32(h.TotalOrganizationsField) }</span>
func (h HierarchyStatistics) MaxDepth() int32           <span class="cov0" title="0">{ return int32(h.MaxDepthField) }</span>
func (h HierarchyStatistics) AvgDepth() float64         <span class="cov0" title="0">{ return h.AvgDepthField }</span>
func (h HierarchyStatistics) DepthDistribution() []DepthDistribution <span class="cov0" title="0">{
        return h.DepthDistributionField
}</span>
func (h HierarchyStatistics) RootOrganizations() int32 <span class="cov0" title="0">{ return int32(h.RootOrganizationsField) }</span>
func (h HierarchyStatistics) LeafOrganizations() int32 <span class="cov0" title="0">{ return int32(h.LeafOrganizationsField) }</span>
func (h HierarchyStatistics) IntegrityIssues() []IntegrityIssue <span class="cov0" title="0">{
        return h.IntegrityIssuesField
}</span>
func (h HierarchyStatistics) LastAnalyzed() string <span class="cov0" title="0">{ return h.LastAnalyzedField }</span>

// DepthDistribution 层级分布
type DepthDistribution struct {
        DepthField int `json:"depth"`
        CountField int `json:"count"`
}

func (d DepthDistribution) Depth() int32 <span class="cov0" title="0">{ return int32(d.DepthField) }</span>
func (d DepthDistribution) Count() int32 <span class="cov0" title="0">{ return int32(d.CountField) }</span>

// IntegrityIssue 数据一致性问题
type IntegrityIssue struct {
        TypeField          string   `json:"type"`
        CountField         int      `json:"count"`
        AffectedCodesField []string `json:"affectedCodes"`
}

func (i IntegrityIssue) Type() string            <span class="cov0" title="0">{ return i.TypeField }</span>
func (i IntegrityIssue) Count() int32            <span class="cov0" title="0">{ return int32(i.CountField) }</span>
func (i IntegrityIssue) AffectedCodes() []string <span class="cov0" title="0">{ return i.AffectedCodesField }</span>

// FieldChangeData 审计字段变更详情
type FieldChangeData struct {
        FieldField    string      `json:"field"`
        DataTypeField string      `json:"dataType"`
        OldValueField interface{} `json:"oldValue"`
        NewValueField interface{} `json:"newValue"`
}

func (f FieldChangeData) Field() string    <span class="cov0" title="0">{ return f.FieldField }</span>
func (f FieldChangeData) DataType() string <span class="cov0" title="0">{ return f.DataTypeField }</span>
func (f FieldChangeData) OldValue() *string <span class="cov0" title="0">{
        if f.OldValueField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">str := fmt.Sprint(f.OldValueField)
        return &amp;str</span>
}
func (f FieldChangeData) NewValue() *string <span class="cov0" title="0">{
        if f.NewValueField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">str := fmt.Sprint(f.NewValueField)
        return &amp;str</span>
}

// AuditRecordData 审计记录-包含变更详情
type AuditRecordData struct {
        AuditIDField         string            `json:"auditId"`
        RecordIDField        string            `json:"recordId"`
        OperationTypeField   string            `json:"operationType"`
        OperatedByField      OperatedByData    `json:"operatedBy"`
        ChangesSummaryField  string            `json:"changesSummary"`
        OperationReasonField *string           `json:"operationReason"`
        TimestampField       string            `json:"timestamp"`
        BeforeDataField      *string           `json:"beforeData"`
        AfterDataField       *string           `json:"afterData"`
        ModifiedFieldsField  []string          `json:"modifiedFields"`
        ChangesField         []FieldChangeData `json:"changes"`
}

func (a AuditRecordData) AuditId() string            <span class="cov0" title="0">{ return a.AuditIDField }</span>
func (a AuditRecordData) RecordId() string           <span class="cov0" title="0">{ return a.RecordIDField }</span>
func (a AuditRecordData) OperationType() string      <span class="cov0" title="0">{ return a.OperationTypeField }</span>
func (a AuditRecordData) Operation() string          <span class="cov0" title="0">{ return a.OperationTypeField }</span>
func (a AuditRecordData) OperatedBy() OperatedByData <span class="cov0" title="0">{ return a.OperatedByField }</span>
func (a AuditRecordData) ChangesSummary() string     <span class="cov0" title="0">{ return a.ChangesSummaryField }</span>
func (a AuditRecordData) OperationReason() *string   <span class="cov0" title="0">{ return a.OperationReasonField }</span>
func (a AuditRecordData) Timestamp() string          <span class="cov0" title="0">{ return a.TimestampField }</span>
func (a AuditRecordData) BeforeData() *string        <span class="cov0" title="0">{ return a.BeforeDataField }</span>
func (a AuditRecordData) AfterData() *string         <span class="cov0" title="0">{ return a.AfterDataField }</span>
func (a AuditRecordData) ModifiedFields() []string   <span class="cov0" title="0">{ return a.ModifiedFieldsField }</span>
func (a AuditRecordData) Changes() []FieldChangeData <span class="cov0" title="0">{ return a.ChangesField }</span>

// OperatedByData 审计操作人信息
type OperatedByData struct {
        IDField   string `json:"id"`
        NameField string `json:"name"`
}

func (o OperatedByData) Id() string   <span class="cov0" title="0">{ return o.IDField }</span>
func (o OperatedByData) Name() string <span class="cov0" title="0">{ return o.NameField }</span>

// DateRangeInput GraphQL 输入
type DateRangeInput struct {
        From *string `json:"from"`
        To   *string `json:"to"`
}

// OrganizationFilter 查询过滤条件
type OrganizationFilter struct {
        AsOfDate                 *string         `json:"asOfDate"`
        IncludeFuture            bool            `json:"includeFuture"`
        OnlyFuture               bool            `json:"onlyFuture"`
        UnitType                 *string         `json:"unitType"`
        Status                   *string         `json:"status"`
        ParentCode               *string         `json:"parentCode"`
        Codes                    *[]string       `json:"codes"`
        ExcludeCodes             *[]string       `json:"excludeCodes"`
        ExcludeDescendantsOf     *string         `json:"excludeDescendantsOf"`
        IncludeDisabledAncestors bool            `json:"includeDisabledAncestors"`
        Level                    *int32          `json:"level"`
        MinLevel                 *int32          `json:"minLevel"`
        MaxLevel                 *int32          `json:"maxLevel"`
        RootsOnly                bool            `json:"rootsOnly"`
        LeavesOnly               bool            `json:"leavesOnly"`
        SearchText               *string         `json:"searchText"`
        SearchFields             []string        `json:"searchFields"`
        HasChildren              *bool           `json:"hasChildren"`
        HasProfile               *bool           `json:"hasProfile"`
        ProfileContains          *string         `json:"profileContains"`
        OperationType            *string         `json:"operationType"`
        OperatedBy               *string         `json:"operatedBy"`
        OperationDateRange       *DateRangeInput `json:"operationDateRange"`
}

func (f *OrganizationFilter) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("OrganizationFilter: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov0" title="0">if value, exists := raw["asOfDate"]; exists </span><span class="cov0" title="0">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.asOfDate: %w", err)
                }</span>
                <span class="cov0" title="0">f.AsOfDate = strPtr</span>
        }
        <span class="cov0" title="0">if value, exists := raw["includeFuture"]; exists </span><span class="cov0" title="0">{
                boolVal, err := asBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.includeFuture: %w", err)
                }</span>
                <span class="cov0" title="0">f.IncludeFuture = boolVal</span>
        }
        <span class="cov0" title="0">if value, exists := raw["onlyFuture"]; exists </span><span class="cov0" title="0">{
                boolVal, err := asBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.onlyFuture: %w", err)
                }</span>
                <span class="cov0" title="0">f.OnlyFuture = boolVal</span>
        }
        <span class="cov0" title="0">if value, exists := raw["unitType"]; exists </span><span class="cov0" title="0">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.unitType: %w", err)
                }</span>
                <span class="cov0" title="0">f.UnitType = strPtr</span>
        }
        <span class="cov0" title="0">if value, exists := raw["status"]; exists </span><span class="cov0" title="0">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.status: %w", err)
                }</span>
                <span class="cov0" title="0">f.Status = strPtr</span>
        }
        <span class="cov0" title="0">if value, exists := raw["parentCode"]; exists </span><span class="cov0" title="0">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.parentCode: %w", err)
                }</span>
                <span class="cov0" title="0">f.ParentCode = strPtr</span>
        }
        <span class="cov0" title="0">if value, exists := raw["hasChildren"]; exists </span><span class="cov0" title="0">{
                boolPtr, err := asOptionalBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.hasChildren: %w", err)
                }</span>
                <span class="cov0" title="0">f.HasChildren = boolPtr</span>
        }
        <span class="cov0" title="0">if value, exists := raw["hasProfile"]; exists </span><span class="cov0" title="0">{
                boolPtr, err := asOptionalBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("OrganizationFilter.hasProfile: %w", err)
                }</span>
                <span class="cov0" title="0">f.HasProfile = boolPtr</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// PaginationInput 查询分页参数
type PaginationInput struct {
        Page      int32  `json:"page"`
        PageSize  int32  `json:"pageSize"`
        SortBy    string `json:"sortBy"`
        SortOrder string `json:"sortOrder"`
}

// Position 数据实体
type Position struct {
        CodeField               string               `json:"code" db:"code"`
        RecordIDField           string               `json:"recordId" db:"record_id"`
        TenantIDField           string               `json:"tenantId" db:"tenant_id"`
        TitleField              string               `json:"title" db:"title"`
        JobProfileCodeField     *string              `json:"jobProfileCode" db:"job_profile_code"`
        JobProfileNameField     *string              `json:"jobProfileName" db:"job_profile_name"`
        JobFamilyGroupCodeField string               `json:"jobFamilyGroupCode" db:"job_family_group_code"`
        JobFamilyCodeField      string               `json:"jobFamilyCode" db:"job_family_code"`
        JobRoleCodeField        string               `json:"jobRoleCode" db:"job_role_code"`
        JobLevelCodeField       string               `json:"jobLevelCode" db:"job_level_code"`
        OrganizationCodeField   string               `json:"organizationCode" db:"organization_code"`
        PositionTypeField       string               `json:"positionType" db:"position_type"`
        EmploymentTypeField     string               `json:"employmentType" db:"employment_type"`
        GradeLevelField         *string              `json:"gradeLevel" db:"grade_level"`
        HeadcountCapacityField  float64              `json:"headcountCapacity" db:"headcount_capacity"`
        HeadcountInUseField     float64              `json:"headcountInUse" db:"headcount_in_use"`
        ReportsToPositionField  *string              `json:"reportsToPositionCode" db:"reports_to_position_code"`
        StatusField             string               `json:"status" db:"status"`
        EffectiveDateField      time.Time            `json:"effectiveDate" db:"effective_date"`
        EndDateField            *time.Time           `json:"endDate" db:"end_date"`
        IsCurrentField          bool                 `json:"isCurrent" db:"is_current"`
        CreatedAtField          time.Time            `json:"createdAt" db:"created_at"`
        UpdatedAtField          time.Time            `json:"updatedAt" db:"updated_at"`
        JobFamilyGroupNameField *string              `json:"jobFamilyGroupName" db:"job_family_group_name"`
        JobFamilyNameField      *string              `json:"jobFamilyName" db:"job_family_name"`
        JobRoleNameField        *string              `json:"jobRoleName" db:"job_role_name"`
        JobLevelNameField       *string              `json:"jobLevelName" db:"job_level_name"`
        OrganizationNameField   *string              `json:"organizationName" db:"organization_name"`
        CurrentAssignmentField  *PositionAssignment  `json:"currentAssignment"`
        AssignmentHistoryField  []PositionAssignment `json:"assignmentHistory"`
}

func (p Position) Code() PositionCode      <span class="cov8" title="1">{ return PositionCode(p.CodeField) }</span>
func (p Position) RecordId() UUID          <span class="cov8" title="1">{ return UUID(p.RecordIDField) }</span>
func (p Position) TenantId() UUID          <span class="cov8" title="1">{ return UUID(p.TenantIDField) }</span>
func (p Position) Title() string           <span class="cov8" title="1">{ return p.TitleField }</span>
func (p Position) JobProfileCode() *string <span class="cov8" title="1">{ return p.JobProfileCodeField }</span>
func (p Position) JobProfileName() *string <span class="cov8" title="1">{ return p.JobProfileNameField }</span>
func (p Position) JobFamilyGroupCode() JobFamilyGroupCode <span class="cov8" title="1">{
        return JobFamilyGroupCode(p.JobFamilyGroupCodeField)
}</span>
func (p Position) JobFamilyCode() JobFamilyCode <span class="cov8" title="1">{ return JobFamilyCode(p.JobFamilyCodeField) }</span>
func (p Position) JobRoleCode() JobRoleCode     <span class="cov8" title="1">{ return JobRoleCode(p.JobRoleCodeField) }</span>
func (p Position) JobLevelCode() JobLevelCode   <span class="cov8" title="1">{ return JobLevelCode(p.JobLevelCodeField) }</span>
func (p Position) OrganizationCode() string     <span class="cov8" title="1">{ return p.OrganizationCodeField }</span>
func (p Position) PositionType() string         <span class="cov8" title="1">{ return p.PositionTypeField }</span>
func (p Position) EmploymentType() string       <span class="cov8" title="1">{ return p.EmploymentTypeField }</span>
func (p Position) GradeLevel() *string          <span class="cov8" title="1">{ return p.GradeLevelField }</span>
func (p Position) HeadcountCapacity() float64   <span class="cov8" title="1">{ return p.HeadcountCapacityField }</span>
func (p Position) HeadcountInUse() float64      <span class="cov8" title="1">{ return p.HeadcountInUseField }</span>
func (p Position) OrganizationName() *string    <span class="cov8" title="1">{ return p.OrganizationNameField }</span>
func (p Position) AvailableHeadcount() float64 <span class="cov8" title="1">{
        available := p.HeadcountCapacityField - p.HeadcountInUseField
        if available &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return available</span>
}
func (p Position) ReportsToPositionCode() *PositionCode <span class="cov8" title="1">{
        if p.ReportsToPositionField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">value := PositionCode(strings.TrimSpace(*p.ReportsToPositionField))
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;value</span>
}
func (p Position) Status() string <span class="cov8" title="1">{ return p.StatusField }</span>
func (p Position) EffectiveDate() Date <span class="cov8" title="1">{
        return Date(p.EffectiveDateField.Format("2006-01-02"))
}</span>
func (p Position) EndDate() *Date <span class="cov8" title="1">{
        if p.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">val := Date(p.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (p Position) IsCurrent() bool <span class="cov8" title="1">{ return p.IsCurrentField }</span>
func (p Position) IsFuture() bool <span class="cov8" title="1">{
        today := cnTodayDate()
        return p.EffectiveDateField.After(today)
}</span>
func (p Position) CreatedAt() DateTime <span class="cov8" title="1">{ return DateTime(p.CreatedAtField.Format(time.RFC3339)) }</span>
func (p Position) UpdatedAt() DateTime <span class="cov8" title="1">{ return DateTime(p.UpdatedAtField.Format(time.RFC3339)) }</span>
func (p Position) CurrentAssignment() *PositionAssignment <span class="cov8" title="1">{
        return p.CurrentAssignmentField
}</span>

func (p Position) AssignmentHistory() []PositionAssignment <span class="cov8" title="1">{
        if p.AssignmentHistoryField == nil </span><span class="cov8" title="1">{
                return []PositionAssignment{}
        }</span>
        <span class="cov8" title="1">return p.AssignmentHistoryField</span>
}

// PositionConnection 连接结果
type PositionConnection struct {
        EdgesField      []PositionEdge `json:"edges"`
        DataField       []Position     `json:"data"`
        PaginationField PaginationInfo `json:"pagination"`
        TotalCountField int            `json:"totalCount"`
}

func (c PositionConnection) Edges() []PositionEdge      <span class="cov8" title="1">{ return c.EdgesField }</span>
func (c PositionConnection) Data() []Position           <span class="cov8" title="1">{ return c.DataField }</span>
func (c PositionConnection) Pagination() PaginationInfo <span class="cov8" title="1">{ return c.PaginationField }</span>
func (c PositionConnection) TotalCount() int32          <span class="cov8" title="1">{ return int32(c.TotalCountField) }</span>

// PositionEdge 用于游标分页
type PositionEdge struct {
        CursorField string   `json:"cursor"`
        NodeField   Position `json:"node"`
}

func (e PositionEdge) Cursor() string <span class="cov8" title="1">{ return e.CursorField }</span>
func (e PositionEdge) Node() Position <span class="cov8" title="1">{ return e.NodeField }</span>

// PositionAssignment 表示职位任职记录
type PositionAssignment struct {
        AssignmentIDField     string     `json:"assignmentId" db:"assignment_id"`
        TenantIDField         string     `json:"tenantId" db:"tenant_id"`
        PositionCodeField     string     `json:"positionCode" db:"position_code"`
        PositionRecordIDField string     `json:"positionRecordId" db:"position_record_id"`
        EmployeeIDField       string     `json:"employeeId" db:"employee_id"`
        EmployeeNameField     string     `json:"employeeName" db:"employee_name"`
        EmployeeNumberField   *string    `json:"employeeNumber" db:"employee_number"`
        AssignmentTypeField   string     `json:"assignmentType" db:"assignment_type"`
        AssignmentStatusField string     `json:"assignmentStatus" db:"assignment_status"`
        FTEField              float64    `json:"fte" db:"fte"`
        EffectiveDateField    time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField          *time.Time `json:"endDate" db:"end_date"`
        ActingUntilField      *time.Time `json:"actingUntil" db:"acting_until"`
        AutoRevertField       bool       `json:"autoRevert" db:"auto_revert"`
        ReminderSentAtField   *time.Time `json:"reminderSentAt" db:"reminder_sent_at"`
        IsCurrentField        bool       `json:"isCurrent" db:"is_current"`
        NotesField            *string    `json:"notes" db:"notes"`
        CreatedAtField        time.Time  `json:"createdAt" db:"created_at"`
        UpdatedAtField        time.Time  `json:"updatedAt" db:"updated_at"`
}

func (a PositionAssignment) AssignmentId() UUID         <span class="cov0" title="0">{ return UUID(a.AssignmentIDField) }</span>
func (a PositionAssignment) TenantId() UUID             <span class="cov0" title="0">{ return UUID(a.TenantIDField) }</span>
func (a PositionAssignment) PositionCode() PositionCode <span class="cov0" title="0">{ return PositionCode(a.PositionCodeField) }</span>
func (a PositionAssignment) PositionRecordId() UUID     <span class="cov0" title="0">{ return UUID(a.PositionRecordIDField) }</span>
func (a PositionAssignment) EmployeeId() UUID           <span class="cov0" title="0">{ return UUID(a.EmployeeIDField) }</span>
func (a PositionAssignment) EmployeeName() string       <span class="cov0" title="0">{ return a.EmployeeNameField }</span>
func (a PositionAssignment) EmployeeNumber() *string    <span class="cov0" title="0">{ return a.EmployeeNumberField }</span>
func (a PositionAssignment) AssignmentType() string     <span class="cov0" title="0">{ return a.AssignmentTypeField }</span>
func (a PositionAssignment) AssignmentStatus() string   <span class="cov0" title="0">{ return a.AssignmentStatusField }</span>
func (a PositionAssignment) Fte() float64               <span class="cov0" title="0">{ return a.FTEField }</span>
func (a PositionAssignment) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(a.EffectiveDateField.Format("2006-01-02"))
}</span>
func (a PositionAssignment) EndDate() *Date <span class="cov0" title="0">{
        if a.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(a.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (a PositionAssignment) ActingUntil() *Date <span class="cov0" title="0">{
        if a.ActingUntilField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(a.ActingUntilField.Format("2006-01-02"))
        return &amp;val</span>
}
func (a PositionAssignment) AutoRevert() bool <span class="cov0" title="0">{ return a.AutoRevertField }</span>
func (a PositionAssignment) ReminderSentAt() *DateTime <span class="cov0" title="0">{
        if a.ReminderSentAtField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := DateTime(a.ReminderSentAtField.Format(time.RFC3339))
        return &amp;val</span>
}
func (a PositionAssignment) IsCurrent() bool <span class="cov0" title="0">{ return a.IsCurrentField }</span>
func (a PositionAssignment) Notes() *string  <span class="cov0" title="0">{ return a.NotesField }</span>
func (a PositionAssignment) CreatedAt() DateTime <span class="cov0" title="0">{
        return DateTime(a.CreatedAtField.Format(time.RFC3339))
}</span>
func (a PositionAssignment) UpdatedAt() DateTime <span class="cov0" title="0">{
        return DateTime(a.UpdatedAtField.Format(time.RFC3339))
}</span>

// PositionAssignmentEdge 游标数据
type PositionAssignmentEdge struct {
        CursorField string             `json:"cursor"`
        NodeField   PositionAssignment `json:"node"`
}

func (e PositionAssignmentEdge) Cursor() string           <span class="cov0" title="0">{ return e.CursorField }</span>
func (e PositionAssignmentEdge) Node() PositionAssignment <span class="cov0" title="0">{ return e.NodeField }</span>

// PositionAssignmentConnection 连接响应
type PositionAssignmentConnection struct {
        EdgesField      []PositionAssignmentEdge `json:"edges"`
        DataField       []PositionAssignment     `json:"data"`
        PaginationField PaginationInfo           `json:"pagination"`
        TotalCountField int                      `json:"totalCount"`
}

func (c PositionAssignmentConnection) Edges() []PositionAssignmentEdge <span class="cov0" title="0">{
        return c.EdgesField
}</span>
func (c PositionAssignmentConnection) Data() []PositionAssignment <span class="cov0" title="0">{ return c.DataField }</span>
func (c PositionAssignmentConnection) Pagination() PaginationInfo <span class="cov0" title="0">{
        return c.PaginationField
}</span>
func (c PositionAssignmentConnection) TotalCount() int32 <span class="cov0" title="0">{
        return int32(c.TotalCountField)
}</span>

// AssignmentStats 任职统计
type AssignmentStats struct {
        PositionCodeField     *string   `json:"positionCode"`
        OrganizationCodeField *string   `json:"organizationCode"`
        TotalCountField       int       `json:"totalAssignments"`
        ActiveCountField      int       `json:"activeAssignments"`
        PendingCountField     int       `json:"pendingAssignments"`
        EndedCountField       int       `json:"endedAssignments"`
        PrimaryCountField     int       `json:"primaryAssignments"`
        SecondaryCountField   int       `json:"secondaryAssignments"`
        ActingCountField      int       `json:"actingAssignments"`
        LastUpdatedAtField    time.Time `json:"lastUpdatedAt"`
}

func (s AssignmentStats) PositionCode() *PositionCode <span class="cov0" title="0">{
        if s.PositionCodeField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">value := strings.TrimSpace(*s.PositionCodeField)
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">code := PositionCode(value)
        return &amp;code</span>
}

func (s AssignmentStats) OrganizationCode() *string <span class="cov0" title="0">{
        if s.OrganizationCodeField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">value := strings.TrimSpace(*s.OrganizationCodeField)
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;value</span>
}

func (s AssignmentStats) TotalAssignments() int32     <span class="cov0" title="0">{ return int32(s.TotalCountField) }</span>
func (s AssignmentStats) ActiveAssignments() int32    <span class="cov0" title="0">{ return int32(s.ActiveCountField) }</span>
func (s AssignmentStats) PendingAssignments() int32   <span class="cov0" title="0">{ return int32(s.PendingCountField) }</span>
func (s AssignmentStats) EndedAssignments() int32     <span class="cov0" title="0">{ return int32(s.EndedCountField) }</span>
func (s AssignmentStats) PrimaryAssignments() int32   <span class="cov0" title="0">{ return int32(s.PrimaryCountField) }</span>
func (s AssignmentStats) SecondaryAssignments() int32 <span class="cov0" title="0">{ return int32(s.SecondaryCountField) }</span>
func (s AssignmentStats) ActingAssignments() int32    <span class="cov0" title="0">{ return int32(s.ActingCountField) }</span>
func (s AssignmentStats) LastUpdatedAt() DateTime <span class="cov0" title="0">{
        return DateTime(s.LastUpdatedAtField.Format(time.RFC3339))
}</span>

type PositionAssignmentAudit struct {
        AssignmentIDField  string                 `json:"assignmentId"`
        EventTypeField     string                 `json:"eventType"`
        EffectiveDateField time.Time              `json:"effectiveDate"`
        EndDateField       *time.Time             `json:"endDate"`
        ActorField         string                 `json:"actor"`
        ChangesField       map[string]interface{} `json:"changes"`
        CreatedAtField     time.Time              `json:"createdAt"`
}

func (a PositionAssignmentAudit) AssignmentId() UUID <span class="cov0" title="0">{ return UUID(a.AssignmentIDField) }</span>
func (a PositionAssignmentAudit) EventType() string  <span class="cov0" title="0">{ return a.EventTypeField }</span>
func (a PositionAssignmentAudit) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(a.EffectiveDateField.Format("2006-01-02"))
}</span>
func (a PositionAssignmentAudit) EndDate() *Date <span class="cov0" title="0">{
        if a.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(a.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (a PositionAssignmentAudit) Actor() string <span class="cov0" title="0">{ return a.ActorField }</span>
func (a PositionAssignmentAudit) Changes() *JSON <span class="cov0" title="0">{
        if a.ChangesField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := JSON(a.ChangesField)
        return &amp;val</span>
}
func (a PositionAssignmentAudit) CreatedAt() DateTime <span class="cov0" title="0">{
        return DateTime(a.CreatedAtField.Format(time.RFC3339))
}</span>

type PositionAssignmentAuditConnection struct {
        DataField       []PositionAssignmentAudit `json:"data"`
        PaginationField PaginationInfo            `json:"pagination"`
        TotalCountField int                       `json:"totalCount"`
}

func (c PositionAssignmentAuditConnection) Data() []PositionAssignmentAudit <span class="cov0" title="0">{ return c.DataField }</span>
func (c PositionAssignmentAuditConnection) Pagination() PaginationInfo      <span class="cov0" title="0">{ return c.PaginationField }</span>
func (c PositionAssignmentAuditConnection) TotalCount() int32               <span class="cov0" title="0">{ return int32(c.TotalCountField) }</span>

// VacantPosition 空缺职位视图
type VacantPosition struct {
        PositionCodeField       string    `json:"positionCode" db:"position_code"`
        OrganizationCodeField   string    `json:"organizationCode" db:"organization_code"`
        OrganizationNameField   *string   `json:"organizationName" db:"organization_name"`
        JobFamilyCodeField      string    `json:"jobFamilyCode" db:"job_family_code"`
        JobRoleCodeField        string    `json:"jobRoleCode" db:"job_role_code"`
        JobLevelCodeField       string    `json:"jobLevelCode" db:"job_level_code"`
        VacantSinceField        time.Time `json:"vacantSince" db:"vacant_since"`
        HeadcountCapacityField  float64   `json:"headcountCapacity" db:"headcount_capacity"`
        HeadcountAvailableField float64   `json:"headcountAvailable" db:"headcount_available"`
        TotalAssignmentsField   int       `json:"totalAssignments" db:"total_assignments"`
}

func (v VacantPosition) PositionCode() PositionCode <span class="cov8" title="1">{ return PositionCode(v.PositionCodeField) }</span>
func (v VacantPosition) OrganizationCode() string   <span class="cov8" title="1">{ return v.OrganizationCodeField }</span>
func (v VacantPosition) OrganizationName() *string  <span class="cov8" title="1">{ return v.OrganizationNameField }</span>
func (v VacantPosition) JobFamilyCode() JobFamilyCode <span class="cov8" title="1">{
        return JobFamilyCode(v.JobFamilyCodeField)
}</span>
func (v VacantPosition) JobRoleCode() JobRoleCode <span class="cov8" title="1">{ return JobRoleCode(v.JobRoleCodeField) }</span>
func (v VacantPosition) JobLevelCode() JobLevelCode <span class="cov8" title="1">{
        return JobLevelCode(v.JobLevelCodeField)
}</span>
func (v VacantPosition) VacantSince() Date <span class="cov8" title="1">{
        return Date(v.VacantSinceField.Format("2006-01-02"))
}</span>
func (v VacantPosition) HeadcountCapacity() float64  <span class="cov8" title="1">{ return v.HeadcountCapacityField }</span>
func (v VacantPosition) HeadcountAvailable() float64 <span class="cov8" title="1">{ return v.HeadcountAvailableField }</span>
func (v VacantPosition) TotalAssignments() int32     <span class="cov8" title="1">{ return int32(v.TotalAssignmentsField) }</span>

// VacantPositionEdge 游标包装
type VacantPositionEdge struct {
        CursorField string         `json:"cursor"`
        NodeField   VacantPosition `json:"node"`
}

func (e VacantPositionEdge) Cursor() string       <span class="cov8" title="1">{ return e.CursorField }</span>
func (e VacantPositionEdge) Node() VacantPosition <span class="cov8" title="1">{ return e.NodeField }</span>

// VacantPositionConnection 连接响应
type VacantPositionConnection struct {
        EdgesField      []VacantPositionEdge `json:"edges"`
        DataField       []VacantPosition     `json:"data"`
        PaginationField PaginationInfo       `json:"pagination"`
        TotalCountField int                  `json:"totalCount"`
}

func (c VacantPositionConnection) Edges() []VacantPositionEdge <span class="cov8" title="1">{ return c.EdgesField }</span>
func (c VacantPositionConnection) Data() []VacantPosition      <span class="cov8" title="1">{ return c.DataField }</span>
func (c VacantPositionConnection) Pagination() PaginationInfo  <span class="cov0" title="0">{ return c.PaginationField }</span>
func (c VacantPositionConnection) TotalCount() int32           <span class="cov8" title="1">{ return int32(c.TotalCountField) }</span>

// PositionTransfer 职位转移记录
type PositionTransfer struct {
        TransferIDField           string         `json:"transferId"`
        PositionCodeField         string         `json:"positionCode"`
        FromOrganizationCodeField string         `json:"fromOrganizationCode"`
        ToOrganizationCodeField   string         `json:"toOrganizationCode"`
        EffectiveDateField        time.Time      `json:"effectiveDate"`
        InitiatedByField          OperatedByData `json:"initiatedBy"`
        OperationReasonField      *string        `json:"operationReason"`
        CreatedAtField            time.Time      `json:"createdAt"`
}

func (t PositionTransfer) TransferId() UUID             <span class="cov8" title="1">{ return UUID(t.TransferIDField) }</span>
func (t PositionTransfer) PositionCode() PositionCode   <span class="cov8" title="1">{ return PositionCode(t.PositionCodeField) }</span>
func (t PositionTransfer) FromOrganizationCode() string <span class="cov8" title="1">{ return t.FromOrganizationCodeField }</span>
func (t PositionTransfer) ToOrganizationCode() string   <span class="cov8" title="1">{ return t.ToOrganizationCodeField }</span>
func (t PositionTransfer) EffectiveDate() Date <span class="cov8" title="1">{
        return Date(t.EffectiveDateField.Format("2006-01-02"))
}</span>
func (t PositionTransfer) InitiatedBy() OperatedByData <span class="cov0" title="0">{ return t.InitiatedByField }</span>
func (t PositionTransfer) OperationReason() *string    <span class="cov8" title="1">{ return t.OperationReasonField }</span>
func (t PositionTransfer) CreatedAt() DateTime <span class="cov8" title="1">{
        return DateTime(t.CreatedAtField.Format(time.RFC3339))
}</span>

// PositionTransferEdge 游标结果
type PositionTransferEdge struct {
        CursorField string           `json:"cursor"`
        NodeField   PositionTransfer `json:"node"`
}

func (e PositionTransferEdge) Cursor() string         <span class="cov8" title="1">{ return e.CursorField }</span>
func (e PositionTransferEdge) Node() PositionTransfer <span class="cov8" title="1">{ return e.NodeField }</span>

// PositionTransferConnection 连接结果
type PositionTransferConnection struct {
        EdgesField      []PositionTransferEdge `json:"edges"`
        DataField       []PositionTransfer     `json:"data"`
        PaginationField PaginationInfo         `json:"pagination"`
        TotalCountField int                    `json:"totalCount"`
}

func (c PositionTransferConnection) Edges() []PositionTransferEdge <span class="cov8" title="1">{ return c.EdgesField }</span>
func (c PositionTransferConnection) Data() []PositionTransfer      <span class="cov8" title="1">{ return c.DataField }</span>
func (c PositionTransferConnection) Pagination() PaginationInfo    <span class="cov0" title="0">{ return c.PaginationField }</span>
func (c PositionTransferConnection) TotalCount() int32             <span class="cov8" title="1">{ return int32(c.TotalCountField) }</span>

// PositionFilterInput 过滤条件
type PositionFilterInput struct {
        OrganizationCode    *string         `json:"organizationCode"`
        PositionCodes       *[]string       `json:"positionCodes"`
        Status              *string         `json:"status"`
        JobFamilyGroupCodes *[]string       `json:"jobFamilyGroupCodes"`
        JobFamilyCodes      *[]string       `json:"jobFamilyCodes"`
        JobRoleCodes        *[]string       `json:"jobRoleCodes"`
        JobLevelCodes       *[]string       `json:"jobLevelCodes"`
        PositionTypes       *[]string       `json:"positionTypes"`
        EmploymentTypes     *[]string       `json:"employmentTypes"`
        EffectiveRange      *DateRangeInput `json:"effectiveRange"`
}

func (f *PositionFilterInput) UnmarshalGraphQL(input interface{}) error <span class="cov8" title="1">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionFilterInput: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov8" title="1">if value, exists := raw["organizationCode"]; exists </span><span class="cov0" title="0">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.organizationCode: %w", err)
                }</span>
                <span class="cov0" title="0">f.OrganizationCode = strPtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["positionCodes"]; exists </span><span class="cov0" title="0">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.positionCodes: %w", err)
                }</span>
                <span class="cov0" title="0">f.PositionCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["status"]; exists </span><span class="cov8" title="1">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.status: %w", err)
                }</span>
                <span class="cov8" title="1">f.Status = strPtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobFamilyGroupCodes"]; exists </span><span class="cov0" title="0">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.jobFamilyGroupCodes: %w", err)
                }</span>
                <span class="cov0" title="0">f.JobFamilyGroupCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobFamilyCodes"]; exists </span><span class="cov0" title="0">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.jobFamilyCodes: %w", err)
                }</span>
                <span class="cov0" title="0">f.JobFamilyCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobRoleCodes"]; exists </span><span class="cov0" title="0">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.jobRoleCodes: %w", err)
                }</span>
                <span class="cov0" title="0">f.JobRoleCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobLevelCodes"]; exists </span><span class="cov0" title="0">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.jobLevelCodes: %w", err)
                }</span>
                <span class="cov0" title="0">f.JobLevelCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["positionTypes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.positionTypes: %w", err)
                }</span>
                <span class="cov8" title="1">f.PositionTypes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["employmentTypes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.employmentTypes: %w", err)
                }</span>
                <span class="cov8" title="1">f.EmploymentTypes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["effectiveRange"]; exists </span><span class="cov0" title="0">{
                rangePtr, err := asOptionalDateRange(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionFilterInput.effectiveRange: %w", err)
                }</span>
                <span class="cov0" title="0">f.EffectiveRange = rangePtr</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// PositionSortInput 排序输入
type PositionSortInput struct {
        Field     string `json:"field"`
        Direction string `json:"direction"`
}

func (s *PositionSortInput) UnmarshalGraphQL(input interface{}) error <span class="cov8" title="1">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionSortInput: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov8" title="1">field, err := asRequiredString(raw, "field")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionSortInput.field: %w", err)
        }</span>
        <span class="cov8" title="1">direction, err := asRequiredString(raw, "direction")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionSortInput.direction: %w", err)
        }</span>

        <span class="cov8" title="1">s.Field = field
        s.Direction = direction
        return nil</span>
}

// VacantPositionFilterInput 空缺职位过滤条件
type VacantPositionFilterInput struct {
        OrganizationCodes *[]string `json:"organizationCodes"`
        JobFamilyCodes    *[]string `json:"jobFamilyCodes"`
        JobRoleCodes      *[]string `json:"jobRoleCodes"`
        JobLevelCodes     *[]string `json:"jobLevelCodes"`
        PositionTypes     *[]string `json:"positionTypes"`
        MinimumVacantDays *int      `json:"minimumVacantDays"`
        AsOfDate          *string   `json:"asOfDate"`
}

func (f *VacantPositionFilterInput) UnmarshalGraphQL(input interface{}) error <span class="cov8" title="1">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("VacantPositionFilterInput: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov8" title="1">if value, exists := raw["organizationCodes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.organizationCodes: %w", err)
                }</span>
                <span class="cov8" title="1">f.OrganizationCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobFamilyCodes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.jobFamilyCodes: %w", err)
                }</span>
                <span class="cov8" title="1">f.JobFamilyCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobRoleCodes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.jobRoleCodes: %w", err)
                }</span>
                <span class="cov8" title="1">f.JobRoleCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["jobLevelCodes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.jobLevelCodes: %w", err)
                }</span>
                <span class="cov8" title="1">f.JobLevelCodes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["positionTypes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.positionTypes: %w", err)
                }</span>
                <span class="cov8" title="1">f.PositionTypes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["minimumVacantDays"]; exists </span><span class="cov8" title="1">{
                intPtr, err := asOptionalInt(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.minimumVacantDays: %w", err)
                }</span>
                <span class="cov8" title="1">f.MinimumVacantDays = intPtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["asOfDate"]; exists </span><span class="cov8" title="1">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("VacantPositionFilterInput.asOfDate: %w", err)
                }</span>
                <span class="cov8" title="1">f.AsOfDate = strPtr</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VacantPositionSortInput 空缺职位排序输入
type VacantPositionSortInput struct {
        Field     string `json:"field"`
        Direction string `json:"direction"`
}

func (s *VacantPositionSortInput) UnmarshalGraphQL(input interface{}) error <span class="cov8" title="1">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("VacantPositionSortInput: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov8" title="1">field, err := asRequiredString(raw, "field")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("VacantPositionSortInput.field: %w", err)
        }</span>
        <span class="cov8" title="1">direction, err := asOptionalString(raw["direction"])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("VacantPositionSortInput.direction: %w", err)
        }</span>

        <span class="cov8" title="1">s.Field = field
        if direction != nil </span><span class="cov8" title="1">{
                s.Direction = *direction
        }</span> else<span class="cov0" title="0"> {
                s.Direction = "DESC"
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PositionAssignmentFilterInput GraphQL 任职过滤条件
type PositionAssignmentFilterInput struct {
        EmployeeID        *string         `json:"employeeId"`
        Status            *string         `json:"status"`
        AssignmentTypes   *[]string       `json:"assignmentTypes"`
        DateRange         *DateRangeInput `json:"dateRange"`
        AsOfDate          *string         `json:"asOfDate"`
        IncludeHistorical bool            `json:"includeHistorical"`
        IncludeActingOnly bool            `json:"includeActingOnly"`
}

func (f *PositionAssignmentFilterInput) UnmarshalGraphQL(input interface{}) error <span class="cov8" title="1">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionAssignmentFilterInput: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov8" title="1">f.IncludeHistorical = true

        if value, exists := raw["employeeId"]; exists </span><span class="cov8" title="1">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.employeeId: %w", err)
                }</span>
                <span class="cov8" title="1">f.EmployeeID = strPtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["status"]; exists </span><span class="cov8" title="1">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.status: %w", err)
                }</span>
                <span class="cov8" title="1">f.Status = strPtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["assignmentTypes"]; exists </span><span class="cov8" title="1">{
                slicePtr, err := asOptionalStringSlice(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.assignmentTypes: %w", err)
                }</span>
                <span class="cov8" title="1">f.AssignmentTypes = slicePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["dateRange"]; exists </span><span class="cov0" title="0">{
                rangePtr, err := asOptionalDateRange(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.dateRange: %w", err)
                }</span>
                <span class="cov0" title="0">f.DateRange = rangePtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["asOfDate"]; exists </span><span class="cov0" title="0">{
                strPtr, err := asOptionalString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.asOfDate: %w", err)
                }</span>
                <span class="cov0" title="0">f.AsOfDate = strPtr</span>
        }
        <span class="cov8" title="1">if value, exists := raw["includeHistorical"]; exists </span><span class="cov8" title="1">{
                boolVal, err := asBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.includeHistorical: %w", err)
                }</span>
                <span class="cov8" title="1">f.IncludeHistorical = boolVal</span>
        }
        <span class="cov8" title="1">if value, exists := raw["includeActingOnly"]; exists </span><span class="cov0" title="0">{
                boolVal, err := asBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("PositionAssignmentFilterInput.includeActingOnly: %w", err)
                }</span>
                <span class="cov0" title="0">f.IncludeActingOnly = boolVal</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// PositionAssignmentSortInput 任职排序输入
type PositionAssignmentSortInput struct {
        Field     string `json:"field"`
        Direction string `json:"direction"`
}

func (s *PositionAssignmentSortInput) UnmarshalGraphQL(input interface{}) error <span class="cov8" title="1">{
        raw, ok := input.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionAssignmentSortInput: 期望对象类型，实际得到 %T", input)
        }</span>

        <span class="cov8" title="1">field, err := asRequiredString(raw, "field")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionAssignmentSortInput.field: %w", err)
        }</span>
        <span class="cov8" title="1">direction, err := asOptionalString(raw["direction"])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PositionAssignmentSortInput.direction: %w", err)
        }</span>

        <span class="cov8" title="1">s.Field = field
        if direction != nil </span><span class="cov8" title="1">{
                s.Direction = *direction
        }</span> else<span class="cov0" title="0"> {
                s.Direction = "DESC"
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PositionTimelineEntry 时间线条目
type PositionTimelineEntry struct {
        RecordIDField         string     `json:"recordId" db:"record_id"`
        StatusField           string     `json:"status" db:"status"`
        TitleField            string     `json:"title" db:"title"`
        EffectiveDateField    time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField          *time.Time `json:"endDate" db:"end_date"`
        IsCurrentField        bool       `json:"isCurrent" db:"is_current"`
        ChangeReasonField     *string    `json:"changeReason" db:"operation_reason"`
        TimelineCategoryField string     `json:"timelineCategory" db:"timeline_category"`
        AssignmentTypeField   *string    `json:"assignmentType" db:"assignment_type"`
        AssignmentStatusField *string    `json:"assignmentStatus" db:"assignment_status"`
}

func (e PositionTimelineEntry) RecordId() UUID <span class="cov0" title="0">{ return UUID(e.RecordIDField) }</span>
func (e PositionTimelineEntry) Status() string <span class="cov0" title="0">{ return e.StatusField }</span>
func (e PositionTimelineEntry) Title() string  <span class="cov0" title="0">{ return e.TitleField }</span>
func (e PositionTimelineEntry) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(e.EffectiveDateField.Format("2006-01-02"))
}</span>
func (e PositionTimelineEntry) EndDate() *Date <span class="cov0" title="0">{
        if e.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(e.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (e PositionTimelineEntry) IsCurrent() bool <span class="cov0" title="0">{ return e.IsCurrentField }</span>
func (e PositionTimelineEntry) ChangeReason() *string <span class="cov0" title="0">{
        return e.ChangeReasonField
}</span>

func (e PositionTimelineEntry) TimelineCategory() string <span class="cov0" title="0">{
        if strings.TrimSpace(e.TimelineCategoryField) == "" </span><span class="cov0" title="0">{
                return "POSITION_VERSION"
        }</span>
        <span class="cov0" title="0">return e.TimelineCategoryField</span>
}

func (e PositionTimelineEntry) AssignmentType() *string <span class="cov0" title="0">{
        return e.AssignmentTypeField
}</span>

func (e PositionTimelineEntry) AssignmentStatus() *string <span class="cov0" title="0">{
        return e.AssignmentStatusField
}</span>

// HeadcountStats 编制统计
type HeadcountStats struct {
        OrganizationCodeField string            `json:"organizationCode"`
        OrganizationNameField string            `json:"organizationName"`
        TotalCapacityField    float64           `json:"totalCapacity"`
        TotalFilledField      float64           `json:"totalFilled"`
        TotalAvailableField   float64           `json:"totalAvailable"`
        LevelBreakdownField   []LevelHeadcount  `json:"levelBreakdown"`
        TypeBreakdownField    []TypeHeadcount   `json:"typeBreakdown"`
        FamilyBreakdownField  []FamilyHeadcount `json:"familyBreakdown"`
}

func (h HeadcountStats) OrganizationCode() string <span class="cov0" title="0">{ return h.OrganizationCodeField }</span>
func (h HeadcountStats) OrganizationName() string <span class="cov0" title="0">{ return h.OrganizationNameField }</span>
func (h HeadcountStats) TotalCapacity() float64   <span class="cov0" title="0">{ return h.TotalCapacityField }</span>
func (h HeadcountStats) TotalFilled() float64     <span class="cov0" title="0">{ return h.TotalFilledField }</span>
func (h HeadcountStats) TotalAvailable() float64  <span class="cov0" title="0">{ return h.TotalAvailableField }</span>
func (h HeadcountStats) FillRate() float64 <span class="cov0" title="0">{
        if h.TotalCapacityField &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">rate := h.TotalFilledField / h.TotalCapacityField
        if rate &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if rate &gt; 1 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return rate</span>
}
func (h HeadcountStats) ByLevel() []LevelHeadcount   <span class="cov0" title="0">{ return h.LevelBreakdownField }</span>
func (h HeadcountStats) ByType() []TypeHeadcount     <span class="cov0" title="0">{ return h.TypeBreakdownField }</span>
func (h HeadcountStats) ByFamily() []FamilyHeadcount <span class="cov0" title="0">{ return h.FamilyBreakdownField }</span>

// LevelHeadcount 按职级统计
type LevelHeadcount struct {
        JobLevelCodeField string  `json:"jobLevelCode" db:"job_level_code"`
        CapacityField     float64 `json:"capacity" db:"capacity"`
        UtilizedField     float64 `json:"utilized" db:"utilized"`
        AvailableField    float64 `json:"available" db:"available"`
}

// FamilyHeadcount 按职种统计
type FamilyHeadcount struct {
        JobFamilyCodeField string  `json:"jobFamilyCode" db:"job_family_code"`
        JobFamilyNameField *string `json:"jobFamilyName" db:"job_family_name"`
        CapacityField      float64 `json:"capacity" db:"capacity"`
        UtilizedField      float64 `json:"utilized" db:"utilized"`
        AvailableField     float64 `json:"available" db:"available"`
}

func (f FamilyHeadcount) JobFamilyCode() JobFamilyCode <span class="cov0" title="0">{
        return JobFamilyCode(f.JobFamilyCodeField)
}</span>
func (f FamilyHeadcount) JobFamilyName() *string <span class="cov0" title="0">{
        return f.JobFamilyNameField
}</span>
func (f FamilyHeadcount) Capacity() float64  <span class="cov0" title="0">{ return f.CapacityField }</span>
func (f FamilyHeadcount) Utilized() float64  <span class="cov0" title="0">{ return f.UtilizedField }</span>
func (f FamilyHeadcount) Available() float64 <span class="cov0" title="0">{ return f.AvailableField }</span>

func (l LevelHeadcount) JobLevelCode() JobLevelCode <span class="cov0" title="0">{ return JobLevelCode(l.JobLevelCodeField) }</span>
func (l LevelHeadcount) Capacity() float64          <span class="cov0" title="0">{ return l.CapacityField }</span>
func (l LevelHeadcount) Utilized() float64          <span class="cov0" title="0">{ return l.UtilizedField }</span>
func (l LevelHeadcount) Available() float64         <span class="cov0" title="0">{ return l.AvailableField }</span>

// TypeHeadcount 按职位类型统计
type TypeHeadcount struct {
        PositionTypeField string  `json:"positionType" db:"position_type"`
        CapacityField     float64 `json:"capacity" db:"capacity"`
        FilledField       float64 `json:"filled" db:"filled"`
        AvailableField    float64 `json:"available" db:"available"`
}

func (t TypeHeadcount) PositionType() string <span class="cov0" title="0">{ return t.PositionTypeField }</span>
func (t TypeHeadcount) Capacity() float64    <span class="cov0" title="0">{ return t.CapacityField }</span>
func (t TypeHeadcount) Filled() float64      <span class="cov0" title="0">{ return t.FilledField }</span>
func (t TypeHeadcount) Available() float64   <span class="cov0" title="0">{ return t.AvailableField }</span>

// Job catalog 基础类型
type JobFamilyGroup struct {
        RecordIDField      string     `json:"recordId" db:"record_id"`
        TenantIDField      string     `json:"tenantId" db:"tenant_id"`
        CodeField          string     `json:"code" db:"family_group_code"`
        NameField          string     `json:"name" db:"name"`
        DescriptionField   *string    `json:"description" db:"description"`
        StatusField        string     `json:"status" db:"status"`
        EffectiveDateField time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField       *time.Time `json:"endDate" db:"end_date"`
        IsCurrentField     bool       `json:"isCurrent" db:"is_current"`
}

func (g JobFamilyGroup) RecordId() UUID <span class="cov0" title="0">{ return UUID(g.RecordIDField) }</span>
func (g JobFamilyGroup) TenantId() UUID <span class="cov0" title="0">{ return UUID(g.TenantIDField) }</span>
func (g JobFamilyGroup) Code() JobFamilyGroupCode <span class="cov0" title="0">{
        return JobFamilyGroupCode(g.CodeField)
}</span>
func (g JobFamilyGroup) Name() string         <span class="cov0" title="0">{ return g.NameField }</span>
func (g JobFamilyGroup) Description() *string <span class="cov0" title="0">{ return g.DescriptionField }</span>
func (g JobFamilyGroup) Status() string       <span class="cov0" title="0">{ return g.StatusField }</span>
func (g JobFamilyGroup) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(g.EffectiveDateField.Format("2006-01-02"))
}</span>
func (g JobFamilyGroup) EndDate() *Date <span class="cov0" title="0">{
        if g.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(g.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (g JobFamilyGroup) IsCurrent() bool <span class="cov0" title="0">{ return g.IsCurrentField }</span>

type JobFamily struct {
        RecordIDField        string     `json:"recordId" db:"record_id"`
        TenantIDField        string     `json:"tenantId" db:"tenant_id"`
        CodeField            string     `json:"code" db:"family_code"`
        NameField            string     `json:"name" db:"name"`
        DescriptionField     *string    `json:"description" db:"description"`
        StatusField          string     `json:"status" db:"status"`
        EffectiveDateField   time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField         *time.Time `json:"endDate" db:"end_date"`
        IsCurrentField       bool       `json:"isCurrent" db:"is_current"`
        FamilyGroupCodeField string     `json:"groupCode" db:"family_group_code"`
}

func (f JobFamily) RecordId() UUID       <span class="cov0" title="0">{ return UUID(f.RecordIDField) }</span>
func (f JobFamily) TenantId() UUID       <span class="cov0" title="0">{ return UUID(f.TenantIDField) }</span>
func (f JobFamily) Code() JobFamilyCode  <span class="cov0" title="0">{ return JobFamilyCode(f.CodeField) }</span>
func (f JobFamily) Name() string         <span class="cov0" title="0">{ return f.NameField }</span>
func (f JobFamily) Description() *string <span class="cov0" title="0">{ return f.DescriptionField }</span>
func (f JobFamily) Status() string       <span class="cov0" title="0">{ return f.StatusField }</span>
func (f JobFamily) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(f.EffectiveDateField.Format("2006-01-02"))
}</span>
func (f JobFamily) EndDate() *Date <span class="cov0" title="0">{
        if f.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(f.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (f JobFamily) IsCurrent() bool <span class="cov0" title="0">{ return f.IsCurrentField }</span>
func (f JobFamily) GroupCode() JobFamilyGroupCode <span class="cov0" title="0">{
        return JobFamilyGroupCode(f.FamilyGroupCodeField)
}</span>

type JobRole struct {
        RecordIDField      string     `json:"recordId" db:"record_id"`
        TenantIDField      string     `json:"tenantId" db:"tenant_id"`
        CodeField          string     `json:"code" db:"role_code"`
        NameField          string     `json:"name" db:"name"`
        DescriptionField   *string    `json:"description" db:"description"`
        StatusField        string     `json:"status" db:"status"`
        EffectiveDateField time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField       *time.Time `json:"endDate" db:"end_date"`
        IsCurrentField     bool       `json:"isCurrent" db:"is_current"`
        FamilyCodeField    string     `json:"familyCode" db:"family_code"`
}

func (r JobRole) RecordId() UUID       <span class="cov0" title="0">{ return UUID(r.RecordIDField) }</span>
func (r JobRole) TenantId() UUID       <span class="cov0" title="0">{ return UUID(r.TenantIDField) }</span>
func (r JobRole) Code() JobRoleCode    <span class="cov0" title="0">{ return JobRoleCode(r.CodeField) }</span>
func (r JobRole) Name() string         <span class="cov0" title="0">{ return r.NameField }</span>
func (r JobRole) Description() *string <span class="cov0" title="0">{ return r.DescriptionField }</span>
func (r JobRole) Status() string       <span class="cov0" title="0">{ return r.StatusField }</span>
func (r JobRole) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(r.EffectiveDateField.Format("2006-01-02"))
}</span>
func (r JobRole) EndDate() *Date <span class="cov0" title="0">{
        if r.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(r.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (r JobRole) IsCurrent() bool           <span class="cov0" title="0">{ return r.IsCurrentField }</span>
func (r JobRole) FamilyCode() JobFamilyCode <span class="cov0" title="0">{ return JobFamilyCode(r.FamilyCodeField) }</span>

type JobLevel struct {
        RecordIDField      string     `json:"recordId" db:"record_id"`
        TenantIDField      string     `json:"tenantId" db:"tenant_id"`
        CodeField          string     `json:"code" db:"level_code"`
        NameField          string     `json:"name" db:"name"`
        DescriptionField   *string    `json:"description" db:"description"`
        StatusField        string     `json:"status" db:"status"`
        EffectiveDateField time.Time  `json:"effectiveDate" db:"effective_date"`
        EndDateField       *time.Time `json:"endDate" db:"end_date"`
        IsCurrentField     bool       `json:"isCurrent" db:"is_current"`
        RoleCodeField      string     `json:"roleCode" db:"role_code"`
        LevelRankField     string     `json:"levelRank" db:"level_rank"`
}

func (l JobLevel) RecordId() UUID       <span class="cov0" title="0">{ return UUID(l.RecordIDField) }</span>
func (l JobLevel) TenantId() UUID       <span class="cov0" title="0">{ return UUID(l.TenantIDField) }</span>
func (l JobLevel) Code() JobLevelCode   <span class="cov0" title="0">{ return JobLevelCode(l.CodeField) }</span>
func (l JobLevel) Name() string         <span class="cov0" title="0">{ return l.NameField }</span>
func (l JobLevel) Description() *string <span class="cov0" title="0">{ return l.DescriptionField }</span>
func (l JobLevel) Status() string       <span class="cov0" title="0">{ return l.StatusField }</span>
func (l JobLevel) EffectiveDate() Date <span class="cov0" title="0">{
        return Date(l.EffectiveDateField.Format("2006-01-02"))
}</span>
func (l JobLevel) EndDate() *Date <span class="cov0" title="0">{
        if l.EndDateField == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := Date(l.EndDateField.Format("2006-01-02"))
        return &amp;val</span>
}
func (l JobLevel) IsCurrent() bool       <span class="cov0" title="0">{ return l.IsCurrentField }</span>
func (l JobLevel) RoleCode() JobRoleCode <span class="cov0" title="0">{ return JobRoleCode(l.RoleCodeField) }</span>
func (l JobLevel) LevelRank() int32 <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(l.LevelRankField)
        if trimmed == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, err := strconv.Atoi(trimmed); err == nil </span><span class="cov0" title="0">{
                return int32(v)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func asOptionalString(value interface{}) (*string, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("期望字符串，实际得到 %T", value)
        }</span>
        <span class="cov8" title="1">str = strings.TrimSpace(str)
        if str == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;str, nil</span>
}

func asOptionalStringSlice(value interface{}) (*[]string, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var rawItems []string
        switch v := value.(type) </span>{
        case []string:<span class="cov0" title="0">
                rawItems = v</span>
        case []interface{}:<span class="cov8" title="1">
                rawItems = make([]string, 0, len(v))
                for _, item := range v </span><span class="cov8" title="1">{
                        str, ok := item.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("期望字符串数组，实际包含 %T", item)
                        }</span>
                        <span class="cov8" title="1">rawItems = append(rawItems, str)</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("期望字符串数组，实际得到 %T", value)</span>
        }

        <span class="cov8" title="1">result := make([]string, 0, len(rawItems))
        for _, item := range rawItems </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(item)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, trimmed)</span>
        }

        <span class="cov8" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;result, nil</span>
}

func asOptionalDateRange(value interface{}) (*DateRangeInput, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">raw, ok := value.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("期望对象类型，实际得到 %T", value)
        }</span>

        <span class="cov0" title="0">from, err := asOptionalString(raw["from"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("from: %w", err)
        }</span>
        <span class="cov0" title="0">to, err := asOptionalString(raw["to"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("to: %w", err)
        }</span>

        <span class="cov0" title="0">if from == nil &amp;&amp; to == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;DateRangeInput{
                From: from,
                To:   to,
        }, nil</span>
}

func asBool(value interface{}) (bool, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                lower := strings.TrimSpace(strings.ToLower(v))
                if lower == "true" || lower == "1" || lower == "yes" || lower == "y" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov0" title="0">if lower == "false" || lower == "0" || lower == "no" || lower == "n" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("期望布尔值，实际得到 %T", value)</span>
}

func asOptionalBool(value interface{}) (*bool, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">boolVal, err := asBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;boolVal, nil</span>
}

func asRequiredString(raw map[string]interface{}, key string) (string, error) <span class="cov8" title="1">{
        value, exists := raw[key]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("缺少必填字段 %q", key)
        }</span>
        <span class="cov8" title="1">str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("字段 %q 期望为字符串，实际得到 %T", key, value)
        }</span>
        <span class="cov8" title="1">str = strings.TrimSpace(str)
        if str == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("字段 %q 不能为空字符串", key)
        }</span>
        <span class="cov8" title="1">return str, nil</span>
}

func asOptionalInt(value interface{}) (*int, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return &amp;v, nil</span>
        case int32:<span class="cov0" title="0">
                val := int(v)
                return &amp;val, nil</span>
        case int64:<span class="cov0" title="0">
                val := int(v)
                return &amp;val, nil</span>
        case float64:<span class="cov0" title="0">
                return nil, fmt.Errorf("期望整数，实际得到浮点数")</span>
        case string:<span class="cov0" title="0">
                trimmed := strings.TrimSpace(v)
                if trimmed == "" </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">parsed, err := strconv.Atoi(trimmed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("期望整数，实际得到 %q", trimmed)
                }</span>
                <span class="cov0" title="0">return &amp;parsed, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("期望整数，实际得到 %T", value)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package dto

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/99designs/gqlgen/graphql"
)

type scalarString string

func (scalarString) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return true }</span>

func (s *scalarString) unmarshal(name string, input interface{}) error <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">str, ok := input.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: 期望字符串，实际得到 %T", name, input)
        }</span>
        <span class="cov0" title="0">trimmed := strings.TrimSpace(str)
        value := scalarString(trimmed)
        *s = value
        return nil</span>
}

func (s scalarString) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(string(s))
}</span>

type PositionCode string

func (PositionCode) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "PositionCode" }</span>

func (p *PositionCode) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("PositionCode", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*p = PositionCode(base)
        return nil</span>
}

type JobFamilyGroupCode string

func (JobFamilyGroupCode) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{
        return name == "JobFamilyGroupCode"
}</span>

func (c *JobFamilyGroupCode) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("JobFamilyGroupCode", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*c = JobFamilyGroupCode(base)
        return nil</span>
}

type JobFamilyCode string

func (JobFamilyCode) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "JobFamilyCode" }</span>

func (c *JobFamilyCode) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("JobFamilyCode", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*c = JobFamilyCode(base)
        return nil</span>
}

type JobRoleCode string

func (JobRoleCode) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "JobRoleCode" }</span>

func (c *JobRoleCode) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("JobRoleCode", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*c = JobRoleCode(base)
        return nil</span>
}

type JobLevelCode string

func (JobLevelCode) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "JobLevelCode" }</span>

func (c *JobLevelCode) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("JobLevelCode", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*c = JobLevelCode(base)
        return nil</span>
}

type UUID string

func (UUID) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "UUID" }</span>

func (u *UUID) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("UUID", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*u = UUID(base)
        return nil</span>
}

type Date string

func (Date) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "Date" }</span>

func (d *Date) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("Date", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*d = Date(base)
        return nil</span>
}

type DateTime string

func (DateTime) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "DateTime" }</span>

func (d *DateTime) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        var base scalarString
        if err := base.unmarshal("DateTime", input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*d = DateTime(base)
        return nil</span>
}

type JSON map[string]interface{}

func (JSON) ImplementsGraphQLType(name string) bool <span class="cov0" title="0">{ return name == "JSON" }</span>

func (j *JSON) UnmarshalGraphQL(input interface{}) error <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                *j = nil
                return nil
        }</span>
        <span class="cov0" title="0">switch value := input.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                *j = JSON(value)
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("JSON: 期望对象类型，实际得到 %T", input)</span>
        }
}

func MarshalDate(value Date) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalDate(v interface{}) (Date, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return Date(str), err
}</span>

func MarshalDateTime(value DateTime) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalDateTime(v interface{}) (DateTime, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return DateTime(str), err
}</span>

func MarshalJobFamilyGroupCode(value JobFamilyGroupCode) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalJobFamilyGroupCode(v interface{}) (JobFamilyGroupCode, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return JobFamilyGroupCode(str), err
}</span>

func MarshalJobFamilyCode(value JobFamilyCode) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalJobFamilyCode(v interface{}) (JobFamilyCode, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return JobFamilyCode(str), err
}</span>

func MarshalJobRoleCode(value JobRoleCode) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalJobRoleCode(v interface{}) (JobRoleCode, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return JobRoleCode(str), err
}</span>

func MarshalJobLevelCode(value JobLevelCode) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalJobLevelCode(v interface{}) (JobLevelCode, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return JobLevelCode(str), err
}</span>

func MarshalPositionCode(value PositionCode) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalPositionCode(v interface{}) (PositionCode, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return PositionCode(str), err
}</span>

func MarshalUUID(value UUID) graphql.Marshaler <span class="cov0" title="0">{
        return graphql.MarshalString(string(value))
}</span>

func UnmarshalUUID(v interface{}) (UUID, error) <span class="cov0" title="0">{
        str, err := graphql.UnmarshalString(v)
        return UUID(str), err
}</span>

func MarshalJSON(value JSON) graphql.Marshaler <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return graphql.MarshalAny(map[string]interface{}(value))</span>
}

func UnmarshalJSON(v interface{}) (JSON, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">switch data := v.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return JSON(data), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("JSON: 期望对象类型，实际得到 %T", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package events

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "cube-castle/pkg/database"
        "github.com/google/uuid"
)

const (
        // DefaultSourceCommand 是组织命令服务在事件中的 source 值。
        DefaultSourceCommand = "command-service"

        aggregateAssignment = "assignment"
        aggregatePosition   = "position"
        aggregateJobLevel   = "jobLevel"

        EventAssignmentFilled  = "assignment.filled"
        EventAssignmentVacated = "assignment.vacated"
        EventAssignmentUpdated = "assignment.updated"
        EventAssignmentClosed  = "assignment.closed"

        EventPositionCreated = "position.created"
        EventPositionUpdated = "position.updated"

        EventJobLevelVersionCreated  = "jobLevel.versionCreated"
        EventJobLevelVersionConflict = "jobLevel.versionConflict"
)

// Context 描述 outbox 事件的通用上下文。
type Context struct {
        TenantID      uuid.UUID
        RequestID     string
        CorrelationID string
        Operation     string
        Source        string
}

// NewAssignmentEvent 构造 assignment.* 事件。
func NewAssignmentEvent(eventType string, ctx Context, assignmentID, positionCode string, payload map[string]interface{}) (*database.OutboxEvent, error) <span class="cov0" title="0">{
        aggregateID := strings.TrimSpace(assignmentID)
        if aggregateID == "" </span><span class="cov0" title="0">{
                aggregateID = strings.TrimSpace(positionCode)
        }</span>
        <span class="cov0" title="0">if aggregateID == "" </span><span class="cov0" title="0">{
                aggregateID = ctx.TenantID.String()
        }</span>
        <span class="cov0" title="0">if payload == nil </span><span class="cov0" title="0">{
                payload = map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">payload["positionCode"] = strings.TrimSpace(positionCode)
        if assignmentID != "" </span><span class="cov0" title="0">{
                payload["assignmentId"] = strings.TrimSpace(assignmentID)
        }</span>
        <span class="cov0" title="0">return newOutboxEvent(eventType, aggregateAssignment, aggregateID, ctx, payload)</span>
}

// NewPositionEvent 构造 position.* 事件。
func NewPositionEvent(eventType string, ctx Context, positionCode string, payload map[string]interface{}) (*database.OutboxEvent, error) <span class="cov0" title="0">{
        aggregateID := strings.TrimSpace(positionCode)
        if aggregateID == "" </span><span class="cov0" title="0">{
                aggregateID = ctx.TenantID.String()
        }</span>
        <span class="cov0" title="0">if payload == nil </span><span class="cov0" title="0">{
                payload = map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">payload["positionCode"] = strings.TrimSpace(positionCode)
        return newOutboxEvent(eventType, aggregatePosition, aggregateID, ctx, payload)</span>
}

// NewJobLevelEvent 构造 jobLevel.* 事件。
func NewJobLevelEvent(eventType string, ctx Context, jobLevelCode string, payload map[string]interface{}) (*database.OutboxEvent, error) <span class="cov0" title="0">{
        aggregateID := strings.TrimSpace(jobLevelCode)
        if aggregateID == "" </span><span class="cov0" title="0">{
                aggregateID = ctx.TenantID.String()
        }</span>
        <span class="cov0" title="0">if payload == nil </span><span class="cov0" title="0">{
                payload = map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">payload["jobLevelCode"] = strings.TrimSpace(jobLevelCode)
        return newOutboxEvent(eventType, aggregateJobLevel, aggregateID, ctx, payload)</span>
}

func newOutboxEvent(eventType, aggregateType, aggregateID string, ctx Context, attributes map[string]interface{}) (*database.OutboxEvent, error) <span class="cov0" title="0">{
        aggregateID = strings.TrimSpace(aggregateID)
        if aggregateID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aggregateID is required for event %s", eventType)
        }</span>

        <span class="cov0" title="0">data := make(map[string]interface{}, len(attributes)+8)
        for k, v := range attributes </span><span class="cov0" title="0">{
                if k == "" || v == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">data[k] = v</span>
        }

        <span class="cov0" title="0">if ctx.TenantID != uuid.Nil </span><span class="cov0" title="0">{
                data["tenantId"] = ctx.TenantID.String()
        }</span>
        <span class="cov0" title="0">if rid := strings.TrimSpace(ctx.RequestID); rid != "" </span><span class="cov0" title="0">{
                data["requestId"] = rid
        }</span>
        <span class="cov0" title="0">if cid := strings.TrimSpace(ctx.CorrelationID); cid != "" </span><span class="cov0" title="0">{
                data["correlationId"] = cid
        }</span>
        <span class="cov0" title="0">if op := strings.TrimSpace(ctx.Operation); op != "" </span><span class="cov0" title="0">{
                data["operation"] = op
        }</span>

        <span class="cov0" title="0">source := strings.TrimSpace(ctx.Source)
        if source == "" </span><span class="cov0" title="0">{
                source = DefaultSourceCommand
        }</span>
        <span class="cov0" title="0">data["source"] = source
        data["aggregateType"] = aggregateType
        data["aggregateId"] = aggregateID
        data["eventType"] = eventType
        data["occurredAt"] = time.Now().UTC().Format(time.RFC3339Nano)

        raw, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal outbox payload: %w", err)
        }</span>

        <span class="cov0" title="0">event := database.NewOutboxEvent()
        event.AggregateID = aggregateID
        event.AggregateType = aggregateType
        event.EventType = eventType
        event.Payload = string(raw)
        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "net/http"
        "strings"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

func getTenantIDFromRequest(r *http.Request) uuid.UUID <span class="cov8" title="1">{
        tenantIDHeader := strings.TrimSpace(r.Header.Get("X-Tenant-ID"))
        if tenantIDHeader != "" </span><span class="cov8" title="1">{
                if tenantID, err := uuid.Parse(tenantIDHeader); err == nil </span><span class="cov8" title="1">{
                        return tenantID
                }</span>
        }
        <span class="cov8" title="1">return types.DefaultTenantID</span>
}

func getOperatorFromRequest(r *http.Request) types.OperatedByInfo <span class="cov8" title="1">{
        operatorID := getActorID(r)
        operatorName := strings.TrimSpace(r.Header.Get("X-Actor-Name"))
        if operatorName == "" </span><span class="cov8" title="1">{
                operatorName = operatorID
        }</span>
        <span class="cov8" title="1">return types.OperatedByInfo{
                ID:   operatorID,
                Name: operatorName,
        }</span>
}

func getActorID(r *http.Request) string <span class="cov8" title="1">{
        if mock := strings.TrimSpace(r.Header.Get("X-Mock-User")); mock != "" </span><span class="cov8" title="1">{
                return mock
        }</span>
        <span class="cov8" title="1">if val := r.Context().Value("user_id"); val != nil </span><span class="cov0" title="0">{
                if uid, ok := val.(string); ok &amp;&amp; strings.TrimSpace(uid) != "" </span><span class="cov0" title="0">{
                        return strings.TrimSpace(uid)
                }</span>
        }
        <span class="cov8" title="1">return "system"</span>
}

func getIfMatchHeader(r *http.Request) *string <span class="cov8" title="1">{
        raw := strings.TrimSpace(r.Header.Get("If-Match"))
        if raw == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(strings.ToLower(raw), "w/") </span><span class="cov8" title="1">{
                raw = strings.TrimSpace(raw[2:])
        }</span>
        <span class="cov8" title="1">value := strings.Trim(raw, "\"")
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;value</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "runtime"
        "strings"
        "time"

        auth "cube-castle/internal/auth"
        "cube-castle/internal/middleware"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
)

// DevToolsHandler 开发工具处理器
type DevToolsHandler struct {
        jwtMiddleware *auth.JWTMiddleware
        logger        pkglogger.Logger
        devMode       bool
        db            *sql.DB
}

// NewDevToolsHandler 创建开发工具处理器
func NewDevToolsHandler(jwtMiddleware *auth.JWTMiddleware, baseLogger pkglogger.Logger, devMode bool, db *sql.DB) *DevToolsHandler <span class="cov0" title="0">{
        return &amp;DevToolsHandler{
                jwtMiddleware: jwtMiddleware,
                logger:        scopedLogger(baseLogger, "devTools", pkglogger.Fields{"routeGroup": "devtools"}),
                devMode:       devMode,
                db:            db,
        }
}</span>

func (h *DevToolsHandler) requestLogger(r *http.Request, action string) pkglogger.Logger <span class="cov0" title="0">{
        fields := pkglogger.Fields{
                "action": action,
        }
        if r != nil </span><span class="cov0" title="0">{
                fields["method"] = r.Method
                fields["path"] = r.URL.Path
                fields["requestId"] = middleware.GetRequestID(r.Context())
        }</span>
        <span class="cov0" title="0">return h.logger.WithFields(fields)</span>
}

// SetupRoutes 设置开发工具路由
func (h *DevToolsHandler) SetupRoutes(r chi.Router) <span class="cov0" title="0">{
        // 只在开发模式下启用开发工具端点
        if h.devMode </span><span class="cov0" title="0">{
                r.Route("/auth", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/dev-token", h.GenerateDevToken)
                        r.Get("/dev-token/info", h.GetTokenInfo)
                }</span>)

                <span class="cov0" title="0">r.Route("/dev", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/status", h.DevStatus)
                        r.Get("/test-endpoints", h.ListTestEndpoints)
                        r.Get("/database-status", h.DatabaseStatus)
                        r.Get("/performance-metrics", h.PerformanceMetrics)
                        r.Post("/test-api", h.TestAPI)
                }</span>)
        }
}

// GenerateDevToken 生成开发测试令牌
func (h *DevToolsHandler) GenerateDevToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>
        <span class="cov0" title="0">logger := h.requestLogger(r, "generateDevToken")

        var req auth.TestTokenRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "INVALID_REQUEST", "Invalid JSON request body", http.StatusBadRequest, r)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.UserID == "" </span><span class="cov0" title="0">{
                req.UserID = "dev-user"
        }</span>
        <span class="cov0" title="0">if req.TenantID == "" </span><span class="cov0" title="0">{
                req.TenantID = "3b99930c-4dc6-4cc9-8e4d-7d960a931cb9"
        }</span>
        <span class="cov0" title="0">if len(req.Roles) == 0 </span><span class="cov0" title="0">{
                req.Roles = []string{"ADMIN", "USER"}
        }</span>
        <span class="cov0" title="0">if req.Duration == "" </span><span class="cov0" title="0">{
                req.Duration = "24h"
        }</span>

        // 解析持续时间
        <span class="cov0" title="0">duration, err := time.ParseDuration(req.Duration)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "INVALID_DURATION", "Invalid duration format", http.StatusBadRequest, r)
                return
        }</span>

        <span class="cov0" title="0">scope := strings.TrimSpace(req.Scope)
        var permissions []string
        for _, p := range req.Permissions </span><span class="cov0" title="0">{
                p = strings.TrimSpace(p)
                if p != "" </span><span class="cov0" title="0">{
                        permissions = append(permissions, p)
                }</span>
        }

        // 生成令牌
        <span class="cov0" title="0">token, err := h.jwtMiddleware.GenerateTestTokenWithClaims(req.UserID, req.TenantID, req.Roles, scope, permissions, duration)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("generate dev token failed")
                h.writeErrorResponse(w, "TOKEN_GENERATION_FAILED", "Failed to generate token", http.StatusInternalServerError, r)
                return
        }</span>

        <span class="cov0" title="0">response := auth.TestTokenResponse{
                Token:       token,
                ExpiresAt:   time.Now().Add(duration),
                UserID:      req.UserID,
                TenantID:    req.TenantID,
                Roles:       req.Roles,
                Scope:       scope,
                Permissions: permissions,
        }

        h.writeSuccessResponse(w, response, "Dev token generated successfully", r)</span>
}

// GetTokenInfo 获取令牌信息
func (h *DevToolsHandler) GetTokenInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>

        <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "NO_TOKEN", "No authorization token provided", http.StatusBadRequest, r)
                return
        }</span>

        <span class="cov0" title="0">claims, err := h.jwtMiddleware.ValidateToken(authHeader)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "INVALID_TOKEN", err.Error(), http.StatusUnauthorized, r)
                return
        }</span>

        <span class="cov0" title="0">info := map[string]interface{}{
                "userId":      claims.UserID,
                "tenantId":    claims.TenantID,
                "roles":       claims.Roles,
                "scope":       claims.Scope,
                "permissions": claims.Permissions,
                "expiresAt":   time.Unix(claims.ExpiresAt, 0),
                "valid":       time.Now().Unix() &lt; claims.ExpiresAt,
        }

        h.writeSuccessResponse(w, info, "Token information retrieved", r)</span>
}

// DevStatus 开发环境状态
func (h *DevToolsHandler) DevStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "devMode":     h.devMode,
                "timestamp":   time.Now().UTC(),
                "service":     "organization-command-service",
                "environment": "development",
                "features": map[string]bool{
                        "jwtDevTools":    true,
                        "testEndpoints":  true,
                        "debugEndpoints": true,
                        "mockData":       true,
                },
        }

        h.writeSuccessResponse(w, status, "Development status retrieved", r)</span>
}

// ListTestEndpoints 列出测试端点
func (h *DevToolsHandler) ListTestEndpoints(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>

        <span class="cov0" title="0">endpoints := map[string]interface{}{
                "devTools": []map[string]string{
                        {"method": "POST", "path": "/auth/dev-token", "description": "Generate development JWT token"},
                        {"method": "GET", "path": "/auth/dev-token/info", "description": "Get token information"},
                        {"method": "GET", "path": "/dev/status", "description": "Get development status"},
                        {"method": "GET", "path": "/dev/test-endpoints", "description": "List all test endpoints"},
                        {"method": "GET", "path": "/dev/database-status", "description": "Check database connection and table stats"},
                        {"method": "GET", "path": "/dev/performance-metrics", "description": "Get runtime performance metrics"},
                        {"method": "POST", "path": "/dev/test-api", "description": "Test API endpoints with custom requests"},
                },
                "api": []map[string]string{
                        {"method": "POST", "path": "/api/v1/organization-units", "description": "Create organization unit"},
                        {"method": "PUT", "path": "/api/v1/organization-units/{code}", "description": "Update organization unit"},
                        {"method": "POST", "path": "/api/v1/organization-units/{code}/suspend", "description": "Suspend organization unit"},
                        {"method": "POST", "path": "/api/v1/organization-units/{code}/activate", "description": "Activate organization unit"},
                },
                "system": []map[string]string{
                        {"method": "GET", "path": "/health", "description": "Health check endpoint"},
                        {"method": "GET", "path": "/metrics", "description": "Prometheus metrics endpoint"},
                },
        }

        h.writeSuccessResponse(w, endpoints, "Test endpoints listed", r)</span>
}

// writeSuccessResponse 写入成功响应
func (h *DevToolsHandler) writeSuccessResponse(w http.ResponseWriter, data interface{}, message string, r *http.Request) <span class="cov0" title="0">{
        requestID := middleware.GetRequestID(r.Context())

        response := map[string]interface{}{
                "success":   true,
                "data":      data,
                "message":   message,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
                "requestId": requestID,
        }

        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("X-Request-ID", requestID)
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.requestLogger(r, "writeSuccessResponse").
                        WithFields(pkglogger.Fields{"error": err}).
                        Error("encode devtools success response failed")
        }</span>
}

// DatabaseStatus 数据库状态检查
func (h *DevToolsHandler) DatabaseStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "connected": false,
                "tables":    make(map[string]interface{}),
                "stats":     make(map[string]interface{}),
        }

        // 检查数据库连接
        if err := h.db.Ping(); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DATABASE_DISCONNECTED", fmt.Sprintf("Database connection failed: %v", err), http.StatusServiceUnavailable, r)
                return
        }</span>
        <span class="cov0" title="0">status["connected"] = true

        // 检查主要表的记录数（固定白名单，避免动态拼接）
        tableQueries := map[string]string{
                "organization_units":         "SELECT COUNT(*) FROM organization_units",
                "organization_units_history": "SELECT COUNT(*) FROM organization_units_history",
                "audit_logs":                 "SELECT COUNT(*) FROM audit_logs",
        }
        tableOrder := []string{"organization_units", "organization_units_history", "audit_logs"}
        for _, table := range tableOrder </span><span class="cov0" title="0">{
                query := tableQueries[table]
                var count int
                if err := h.db.QueryRow(query).Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                        status["tables"].(map[string]interface{})[table] = map[string]interface{}{
                                "error": err.Error(),
                                "count": -1,
                        }
                        continue</span>
                }
                <span class="cov0" title="0">status["tables"].(map[string]interface{})[table] = map[string]interface{}{
                        "count":  count,
                        "status": "healthy",
                }</span>
        }

        // 数据库统计信息
        <span class="cov0" title="0">var dbSize string
        if err := h.db.QueryRow("SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&amp;dbSize); err == nil </span><span class="cov0" title="0">{
                status["stats"].(map[string]interface{})["database_size"] = dbSize
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, status, "Database status retrieved", r)</span>
}

// PerformanceMetrics 性能指标
func (h *DevToolsHandler) PerformanceMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>

        <span class="cov0" title="0">var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        metrics := map[string]interface{}{
                "memory": map[string]interface{}{
                        "allocated_mb":    fmt.Sprintf("%.2f", float64(memStats.Alloc)/1024/1024),
                        "total_allocated": fmt.Sprintf("%.2f", float64(memStats.TotalAlloc)/1024/1024),
                        "sys_mb":          fmt.Sprintf("%.2f", float64(memStats.Sys)/1024/1024),
                        "gc_cycles":       memStats.NumGC,
                },
                "goroutines": runtime.NumGoroutine(),
                "timestamp":  time.Now().UTC(),
        }

        // 数据库连接池统计
        if h.db != nil </span><span class="cov0" title="0">{
                dbStats := h.db.Stats()
                metrics["database"] = map[string]interface{}{
                        "open_connections":    dbStats.OpenConnections,
                        "in_use":              dbStats.InUse,
                        "idle":                dbStats.Idle,
                        "wait_count":          dbStats.WaitCount,
                        "wait_duration_ms":    dbStats.WaitDuration.Milliseconds(),
                        "max_idle_closed":     dbStats.MaxIdleClosed,
                        "max_lifetime_closed": dbStats.MaxLifetimeClosed,
                }
        }</span>

        <span class="cov0" title="0">h.writeSuccessResponse(w, metrics, "Performance metrics retrieved", r)</span>
}

// TestAPI API测试工具
func (h *DevToolsHandler) TestAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.devMode </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "DEV_MODE_DISABLED", "Development tools are disabled", http.StatusForbidden, r)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Method  string            `json:"method"`
                Path    string            `json:"path"`
                Headers map[string]string `json:"headers"`
                Body    interface{}       `json:"body"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "INVALID_REQUEST", "Invalid JSON request body", http.StatusBadRequest, r)
                return
        }</span>

        // 构建测试请求
        <span class="cov0" title="0">var bodyReader io.Reader
        if req.Body != nil </span><span class="cov0" title="0">{
                bodyData, err := json.Marshal(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, "BODY_MARSHAL_ERROR", "Failed to marshal request body", http.StatusBadRequest, r)
                        return
                }</span>
                <span class="cov0" title="0">bodyReader = bytes.NewReader(bodyData)</span>
        }

        // 构建目标URL
        <span class="cov0" title="0">targetURL := fmt.Sprintf("http://localhost:9090%s", req.Path)

        // 创建请求
        testReq, err := http.NewRequest(req.Method, targetURL, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "REQUEST_CREATE_ERROR", err.Error(), http.StatusInternalServerError, r)
                return
        }</span>

        // 设置头部
        <span class="cov0" title="0">for key, value := range req.Headers </span><span class="cov0" title="0">{
                testReq.Header.Set(key, value)
        }</span>

        // 默认设置Content-Type
        <span class="cov0" title="0">if req.Body != nil &amp;&amp; testReq.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                testReq.Header.Set("Content-Type", "application/json")
        }</span>

        // 执行请求
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 30 * time.Second}
        start := time.Now()
        resp, err := client.Do(testReq)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "REQUEST_EXECUTION_ERROR", err.Error(), http.StatusInternalServerError, r)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // 读取响应
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, "RESPONSE_READ_ERROR", err.Error(), http.StatusInternalServerError, r)
                return
        }</span>

        // 构建测试结果
        <span class="cov0" title="0">result := map[string]interface{}{
                "request": map[string]interface{}{
                        "method":  req.Method,
                        "url":     targetURL,
                        "headers": req.Headers,
                        "body":    req.Body,
                },
                "response": map[string]interface{}{
                        "status_code":  resp.StatusCode,
                        "status":       resp.Status,
                        "headers":      resp.Header,
                        "body":         string(respBody),
                        "content_type": resp.Header.Get("Content-Type"),
                },
                "timing": map[string]interface{}{
                        "duration_ms": duration.Milliseconds(),
                        "duration":    duration.String(),
                },
                "test_metadata": map[string]interface{}{
                        "timestamp": time.Now().UTC(),
                        "success":   resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400,
                },
        }

        h.writeSuccessResponse(w, result, "API test completed", r)</span>
}

// writeErrorResponse 写入错误响应
func (h *DevToolsHandler) writeErrorResponse(w http.ResponseWriter, code, message string, statusCode int, r *http.Request) <span class="cov0" title="0">{
        requestID := middleware.GetRequestID(r.Context())

        response := map[string]interface{}{
                "success": false,
                "error": map[string]interface{}{
                        "code":    code,
                        "message": message,
                },
                "timestamp": time.Now().UTC().Format(time.RFC3339),
                "requestId": requestID,
        }

        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("X-Request-ID", requestID)
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.requestLogger(r, "writeErrorResponse").
                        WithFields(pkglogger.Fields{"error": err}).
                        Error("encode devtools error response failed")
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/service"
        "cube-castle/internal/organization/utils"
        validator "cube-castle/internal/organization/validator"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
)

type JobCatalogHandler struct {
        service *service.JobCatalogService
        logger  pkglogger.Logger
}

func NewJobCatalogHandler(service *service.JobCatalogService, baseLogger pkglogger.Logger) *JobCatalogHandler <span class="cov0" title="0">{
        return &amp;JobCatalogHandler{
                service: service,
                logger: scopedLogger(baseLogger, "jobCatalog", pkglogger.Fields{
                        "routeGroup": "/api/v1/job-*",
                        "module":     "jobCatalog",
                }),
        }
}</span>

func (h *JobCatalogHandler) requestLogger(r *http.Request, action string) pkglogger.Logger <span class="cov0" title="0">{
        fields := pkglogger.Fields{
                "action":    action,
                "requestId": middleware.GetRequestID(r.Context()),
        }
        if r != nil </span><span class="cov0" title="0">{
                fields["method"] = r.Method
                fields["path"] = r.URL.Path
        }</span>
        <span class="cov0" title="0">return h.logger.WithFields(fields)</span>
}

func (h *JobCatalogHandler) SetupRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Post("/api/v1/job-family-groups", h.CreateJobFamilyGroup)
        r.Put("/api/v1/job-family-groups/{code}", h.UpdateJobFamilyGroup)
        r.Post("/api/v1/job-family-groups/{code}/versions", h.CreateJobFamilyGroupVersion)
        r.Post("/api/v1/job-families", h.CreateJobFamily)
        r.Put("/api/v1/job-families/{code}", h.UpdateJobFamily)
        r.Post("/api/v1/job-families/{code}/versions", h.CreateJobFamilyVersion)
        r.Post("/api/v1/job-roles", h.CreateJobRole)
        r.Put("/api/v1/job-roles/{code}", h.UpdateJobRole)
        r.Post("/api/v1/job-roles/{code}/versions", h.CreateJobRoleVersion)
        r.Post("/api/v1/job-levels", h.CreateJobLevel)
        r.Put("/api/v1/job-levels/{code}", h.UpdateJobLevel)
        r.Post("/api/v1/job-levels/{code}/versions", h.CreateJobLevelVersion)
}</span>

func (h *JobCatalogHandler) CreateJobFamilyGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.CreateJobFamilyGroupRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobFamilyGroup")

        tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobFamilyGroup(r.Context(), tenantID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job family group created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job family group response failed")
        }</span>
}

func (h *JobCatalogHandler) UpdateJobFamilyGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职类代码", nil)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "UpdateJobFamilyGroup")

        var req types.UpdateJobFamilyGroupRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">req.Name = strings.TrimSpace(req.Name)
        req.Status = strings.TrimSpace(req.Status)
        req.EffectiveDate = strings.TrimSpace(req.EffectiveDate)
        if req.Name == "" || req.Status == "" || req.EffectiveDate == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "VALIDATION_ERROR", "名称、状态与生效日期为必填项", map[string]interface{}{
                        "name":          req.Name,
                        "status":        req.Status,
                        "effectiveDate": req.EffectiveDate,
                })
                return
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*req.Description)
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.Description = nil
                }</span> else<span class="cov0" title="0"> {
                        req.Description = &amp;trimmed
                }</span>
        }

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)
        ifMatch := getIfMatchHeader(r)

        entity, err := h.service.UpdateJobFamilyGroup(r.Context(), tenantID, code, &amp;req, ifMatch, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, entity, "Job family group updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job family group update response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobFamilyGroupVersion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.JobCatalogVersionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobFamilyGroupVersion")

        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职类代码", nil)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobFamilyGroupVersion(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job family group version created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job family group version response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobFamily(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.CreateJobFamilyRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobFamily")

        tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobFamily(r.Context(), tenantID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job family created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job family response failed")
        }</span>
}

func (h *JobCatalogHandler) UpdateJobFamily(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职种代码", nil)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "UpdateJobFamily")

        var req types.UpdateJobFamilyRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">req.Name = strings.TrimSpace(req.Name)
        req.Status = strings.TrimSpace(req.Status)
        req.EffectiveDate = strings.TrimSpace(req.EffectiveDate)
        if req.Name == "" || req.Status == "" || req.EffectiveDate == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "VALIDATION_ERROR", "名称、状态与生效日期为必填项", map[string]interface{}{
                        "name":          req.Name,
                        "status":        req.Status,
                        "effectiveDate": req.EffectiveDate,
                })
                return
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*req.Description)
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.Description = nil
                }</span> else<span class="cov0" title="0"> {
                        req.Description = &amp;trimmed
                }</span>
        }
        <span class="cov0" title="0">if req.JobFamilyGroupCode != nil </span><span class="cov0" title="0">{
                trimmed := strings.ToUpper(strings.TrimSpace(*req.JobFamilyGroupCode))
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.JobFamilyGroupCode = nil
                }</span> else<span class="cov0" title="0"> {
                        req.JobFamilyGroupCode = &amp;trimmed
                }</span>
        }

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)
        ifMatch := getIfMatchHeader(r)

        entity, err := h.service.UpdateJobFamily(r.Context(), tenantID, code, &amp;req, ifMatch, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, entity, "Job family updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job family update response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobFamilyVersion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.JobCatalogVersionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobFamilyVersion")

        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职种代码", nil)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobFamilyVersion(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job family version created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job family version response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.CreateJobRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobRole")

        tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobRole(r.Context(), tenantID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job role created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job role response failed")
        }</span>
}

func (h *JobCatalogHandler) UpdateJobRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职务代码", nil)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "UpdateJobRole")

        var req types.UpdateJobRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">req.Name = strings.TrimSpace(req.Name)
        req.Status = strings.TrimSpace(req.Status)
        req.EffectiveDate = strings.TrimSpace(req.EffectiveDate)
        if req.Name == "" || req.Status == "" || req.EffectiveDate == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "VALIDATION_ERROR", "名称、状态与生效日期为必填项", map[string]interface{}{
                        "name":          req.Name,
                        "status":        req.Status,
                        "effectiveDate": req.EffectiveDate,
                })
                return
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*req.Description)
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.Description = nil
                }</span> else<span class="cov0" title="0"> {
                        req.Description = &amp;trimmed
                }</span>
        }
        <span class="cov0" title="0">if req.JobFamilyCode != nil </span><span class="cov0" title="0">{
                trimmed := strings.ToUpper(strings.TrimSpace(*req.JobFamilyCode))
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.JobFamilyCode = nil
                }</span> else<span class="cov0" title="0"> {
                        req.JobFamilyCode = &amp;trimmed
                }</span>
        }

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)
        ifMatch := getIfMatchHeader(r)

        entity, err := h.service.UpdateJobRole(r.Context(), tenantID, code, &amp;req, ifMatch, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, entity, "Job role updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job role update response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobRoleVersion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.JobCatalogVersionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobRoleVersion")

        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职务代码", nil)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobRoleVersion(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job role version created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job role version response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobLevel(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.CreateJobLevelRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobLevel")

        // Validate required fields
        if err := validateCreateJobLevelRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobLevel(r.Context(), tenantID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job level created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job level response failed")
        }</span>
}

func (h *JobCatalogHandler) UpdateJobLevel(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职级代码", nil)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "UpdateJobLevel")

        var req types.UpdateJobLevelRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">req.Name = strings.TrimSpace(req.Name)
        req.Status = strings.TrimSpace(req.Status)
        req.EffectiveDate = strings.TrimSpace(req.EffectiveDate)
        if err := validateUpdateJobLevelRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*req.Description)
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.Description = nil
                }</span> else<span class="cov0" title="0"> {
                        req.Description = &amp;trimmed
                }</span>
        }
        <span class="cov0" title="0">if req.JobRoleCode != nil </span><span class="cov0" title="0">{
                trimmed := strings.ToUpper(strings.TrimSpace(*req.JobRoleCode))
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.JobRoleCode = nil
                }</span> else<span class="cov0" title="0"> {
                        req.JobRoleCode = &amp;trimmed
                }</span>
        }

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)
        ifMatch := getIfMatchHeader(r)

        entity, err := h.service.UpdateJobLevel(r.Context(), tenantID, code, &amp;req, ifMatch, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, entity, "Job level updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job level update response failed")
        }</span>
}

func (h *JobCatalogHandler) CreateJobLevelVersion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.JobCatalogVersionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">reqLogger := h.requestLogger(r, "CreateJobLevelVersion")

        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职级代码", nil)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">req.Name = strings.TrimSpace(req.Name)
        req.Status = strings.TrimSpace(req.Status)
        req.EffectiveDate = strings.TrimSpace(req.EffectiveDate)
        if err := validateJobCatalogVersionRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        operator := getOperatorFromRequest(r)

        entity, err := h.service.CreateJobLevelVersion(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, entity, "Job level version created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                reqLogger.WithFields(pkglogger.Fields{"error": err}).Error("write job level version response failed")
        }</span>
}

func (h *JobCatalogHandler) handleServiceError(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        var validationErr *validator.ValidationFailedError
        if errors.As(err, &amp;validationErr) </span><span class="cov0" title="0">{
                h.writeValidationFailure(w, r, validationErr.Result())
                return
        }</span>

        <span class="cov8" title="1">switch </span>{
        case errors.Is(err, service.ErrJobCatalogParentMissing):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusBadRequest, "JOB_CATALOG_PARENT_MISSING", "上级职位分类不存在", err)</span>
        case errors.Is(err, service.ErrJobCatalogInvalidInput):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusBadRequest, "JOB_CATALOG_INVALID_INPUT", "职位分类输入无效", err)</span>
        case errors.Is(err, service.ErrJobCatalogNotFound):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusNotFound, "JOB_CATALOG_NOT_FOUND", "职位分类不存在", err)</span>
        case errors.Is(err, service.ErrJobCatalogConflict):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusConflict, "JOB_CATALOG_CONFLICT", "职位分类存在冲突的生效日期", err)</span>
        case errors.Is(err, service.ErrJobCatalogPreconditionFailed):<span class="cov8" title="1">
                h.writeError(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "资源版本已过期，请刷新后重试", err)</span>
        default:<span class="cov0" title="0">
                h.writeError(w, r, http.StatusInternalServerError, "INTERNAL_ERROR", "服务器内部错误", err)</span>
        }
}

func (h *JobCatalogHandler) writeError(w http.ResponseWriter, r *http.Request, status int, code, message string, details interface{}) <span class="cov8" title="1">{
        requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteError(w, status, code, message, requestID, details); err != nil </span><span class="cov0" title="0">{
                h.requestLogger(r, "writeError").WithFields(pkglogger.Fields{"error": err, "status": status, "code": code}).Error("write job catalog error response failed")
        }</span>
}

func (h *JobCatalogHandler) writeValidationFailure(w http.ResponseWriter, r *http.Request, result *validator.ValidationResult) <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "BUSINESS_RULE_VIOLATION", "业务规则校验失败", nil)
                return
        }</span>

        <span class="cov0" title="0">status := http.StatusBadRequest
        ruleCode := "BUSINESS_RULE_VIOLATION"
        message := "业务规则校验失败"
        if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                first := result.Errors[0]
                if trimmed := strings.TrimSpace(first.Code); trimmed != "" </span><span class="cov0" title="0">{
                        ruleCode = trimmed
                }</span>
                <span class="cov0" title="0">if trimmed := strings.TrimSpace(first.Message); trimmed != "" </span><span class="cov0" title="0">{
                        message = trimmed
                }</span>
                <span class="cov0" title="0">severity := strings.ToUpper(strings.TrimSpace(first.Severity))
                if severity == "" </span><span class="cov0" title="0">{
                        severity = string(validator.SeverityHigh)
                }</span>
                <span class="cov0" title="0">mapped := validator.SeverityToHTTPStatus(severity)
                if mapped &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                        status = mapped
                }</span>
        }

        <span class="cov0" title="0">details := map[string]interface{}{
                "validationErrors": result.Errors,
                "warnings":         result.Warnings,
                "chainContext":     result.Context,
                "errorCount":       len(result.Errors),
                "warningCount":     len(result.Warnings),
        }

        requestID := middleware.GetRequestID(r.Context())
        logger := h.requestLogger(r, "writeValidationFailure")
        if err := utils.WriteError(w, status, ruleCode, message, requestID, details); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err, "status": status, "code": ruleCode}).Error("write validation failure response failed")
        }</span>
}

// Validation helpers
func validateCreateJobLevelRequest(req *types.CreateJobLevelRequest) error <span class="cov8" title="1">{
        if strings.TrimSpace(req.Code) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职级代码不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.JobRoleCode) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职位角色代码不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Name) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职级名称不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Status) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职级状态不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.LevelRank) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职级排序号不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.EffectiveDate) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("生效日期不能为空")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateUpdateJobLevelRequest validates UpdateJobLevelRequest required fields
func validateUpdateJobLevelRequest(req *types.UpdateJobLevelRequest) error <span class="cov8" title="1">{
        if strings.TrimSpace(req.Name) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职级名称不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Status) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("职级状态不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.EffectiveDate) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("生效日期不能为空")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateJobCatalogVersionRequest validates JobCatalogVersionRequest required fields
func validateJobCatalogVersionRequest(req *types.JobCatalogVersionRequest) error <span class="cov8" title="1">{
        if strings.TrimSpace(req.Name) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("名称不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Status) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("状态不能为空")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.EffectiveDate) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("生效日期不能为空")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "net/http"

        "cube-castle/internal/organization/middleware"
        pkglogger "cube-castle/pkg/logger"
)

func scopedLogger(base pkglogger.Logger, handler string, extra pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        if base == nil </span><span class="cov0" title="0">{
                base = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov8" title="1">fields := pkglogger.Fields{
                "component": "handler",
        }
        if handler != "" </span><span class="cov8" title="1">{
                fields["handler"] = handler
        }</span>
        <span class="cov8" title="1">for k, v := range extra </span><span class="cov8" title="1">{
                fields[k] = v
        }</span>
        <span class="cov8" title="1">return base.WithFields(fields)</span>
}

func requestScopedLogger(base pkglogger.Logger, r *http.Request, action string, extra pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        if base == nil </span><span class="cov0" title="0">{
                base = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">fields := cloneFields(extra)
        if fields == nil </span><span class="cov8" title="1">{
                fields = pkglogger.Fields{}
        }</span>
        <span class="cov8" title="1">if action != "" </span><span class="cov8" title="1">{
                fields["action"] = action
        }</span>
        <span class="cov8" title="1">if r != nil </span><span class="cov8" title="1">{
                fields["method"] = r.Method
                fields["path"] = r.URL.Path
                fields["requestId"] = middleware.GetRequestID(r.Context())
        }</span>
        <span class="cov8" title="1">return base.WithFields(fields)</span>
}

func cloneFields(src pkglogger.Fields) pkglogger.Fields <span class="cov8" title="1">{
        if len(src) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">dup := make(pkglogger.Fields, len(src))
        for k, v := range src </span><span class="cov8" title="1">{
                dup[k] = v
        }</span>
        <span class="cov8" title="1">return dup</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "cube-castle/internal/organization/middleware"
        scheduler "cube-castle/internal/organization/scheduler"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
)

// OperationalHandler 运维管理处理器
type OperationalHandler struct {
        monitor   *scheduler.TemporalMonitor
        scheduler *scheduler.OperationalScheduler
        logger    pkglogger.Logger
        rateLimit *middleware.RateLimitMiddleware
}

// NewOperationalHandler 创建运维管理处理器
func NewOperationalHandler(monitor *scheduler.TemporalMonitor, scheduler *scheduler.OperationalScheduler, rateLimit *middleware.RateLimitMiddleware, baseLogger pkglogger.Logger) *OperationalHandler <span class="cov0" title="0">{
        return &amp;OperationalHandler{
                monitor:   monitor,
                scheduler: scheduler,
                rateLimit: rateLimit,
                logger:    scopedLogger(baseLogger, "operational", pkglogger.Fields{"module": "operational"}),
        }
}</span>

func (h *OperationalHandler) requestLogger(r *http.Request, action string, extra pkglogger.Fields) pkglogger.Logger <span class="cov0" title="0">{
        return requestScopedLogger(h.logger, r, action, extra)
}</span>

// SetupRoutes 设置运维管理路由
func (h *OperationalHandler) SetupRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Route("/api/v1/operational", func(r chi.Router) </span><span class="cov0" title="0">{
                // 监控相关端点
                r.Get("/health", h.GetHealth)
                r.Get("/metrics", h.GetMetrics)
                r.Get("/alerts", h.GetAlerts)
                r.Get("/rate-limit/stats", h.GetRateLimitStats)

                // 任务调度相关端点
                r.Get("/tasks", h.GetTasks)
                r.Get("/tasks/status", h.GetTaskStatus)
                r.Post("/tasks/{taskName}/trigger", h.TriggerTask)

                // 系统操作端点
                r.Post("/cutover", h.TriggerCutover)
                r.Post("/consistency-check", h.TriggerConsistencyCheck)
        }</span>)
}

// GetRateLimitStats 获取限流统计（受PBAC保护）
func (h *OperationalHandler) GetRateLimitStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stats := h.rateLimit.GetStats()
        logger := h.requestLogger(r, "GetRateLimitStats", pkglogger.Fields{
                "totalRequests":   stats.TotalRequests,
                "blockedRequests": stats.BlockedRequests,
                "activeClients":   stats.ActiveClients,
        })
        response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "totalRequests":   stats.TotalRequests,
                        "blockedRequests": stats.BlockedRequests,
                        "activeClients":   stats.ActiveClients,
                        "lastReset":       stats.LastReset.Format(time.RFC3339),
                        // 统一固定类型为字符串百分比，前端展示直用
                        "blockRate": func() string </span><span class="cov0" title="0">{
                                if stats.TotalRequests == 0 </span><span class="cov0" title="0">{
                                        return "0.00%"
                                }</span>
                                <span class="cov0" title="0">return fmt.Sprintf("%.2f%%", float64(stats.BlockedRequests)/float64(stats.TotalRequests)*100)</span>
                        }(),
                },
        }
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode rate limit stats response failed")
        }</span>
}

// GetHealth 获取系统健康状态
func (h *OperationalHandler) GetHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
        defer cancel()
        logger := h.requestLogger(r, "GetHealth", nil)

        metrics, err := h.monitor.CollectMetrics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("collect health metrics failed")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">healthResponse := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "status":      metrics.AlertLevel,
                        "healthScore": metrics.HealthScore,
                        "summary": map[string]interface{}{
                                "totalOrganizations": metrics.TotalOrganizations,
                                "currentRecords":     metrics.CurrentRecords,
                                "futureRecords":      metrics.FutureRecords,
                                "historicalRecords":  metrics.HistoricalRecords,
                        },
                        "issues": map[string]interface{}{
                                "duplicateCurrentCount": metrics.DuplicateCurrentCount,
                                "missingCurrentCount":   metrics.MissingCurrentCount,
                                "timelineOverlapCount":  metrics.TimelineOverlapCount,
                                "inconsistentFlagCount": metrics.InconsistentFlagCount,
                                "orphanRecordCount":     metrics.OrphanRecordCount,
                        },
                        "lastCheckTime": metrics.LastCheckTime.Format(time.RFC3339),
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(healthResponse); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode health response failed")
        }</span>
}

// GetMetrics 获取详细监控指标
func (h *OperationalHandler) GetMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
        defer cancel()
        logger := h.requestLogger(r, "GetMetrics", nil)

        metrics, err := h.monitor.CollectMetrics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("collect monitoring metrics failed")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data":      metrics,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode metrics response failed")
        }</span>
}

// GetAlerts 获取当前告警
func (h *OperationalHandler) GetAlerts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
        defer cancel()
        logger := h.requestLogger(r, "GetAlerts", nil)

        alerts, err := h.monitor.CheckAlerts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("fetch alerts failed")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "alertCount": len(alerts),
                        "alerts":     alerts,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode alerts response failed")
        }</span>
}

// GetTasks 获取任务配置
func (h *OperationalHandler) GetTasks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := h.requestLogger(r, "GetTasks", nil)
        if h.scheduler == nil </span><span class="cov0" title="0">{
                http.Error(w, "Scheduler module disabled", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">tasks := h.scheduler.ListTasks()

        response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "tasks":            tasks,
                        "schedulerRunning": h.scheduler.IsRunning(),
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode tasks response failed")
        }</span>
}

// GetTaskStatus 获取任务运行状态
func (h *OperationalHandler) GetTaskStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := h.requestLogger(r, "GetTaskStatus", nil)
        if h.scheduler == nil </span><span class="cov0" title="0">{
                http.Error(w, "Scheduler module disabled", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">tasks := h.scheduler.ListTasks()

        // 计算任务统计
        var enabledCount, runningCount int
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.Enabled </span><span class="cov0" title="0">{
                        enabledCount++
                }</span>
                <span class="cov0" title="0">if task.Running </span><span class="cov0" title="0">{
                        runningCount++
                }</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "totalTasks":       len(tasks),
                        "enabledTasks":     enabledCount,
                        "runningTasks":     runningCount,
                        "schedulerRunning": h.scheduler.IsRunning(),
                        "tasks":            tasks,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode task status response failed")
        }</span>
}

// TriggerTask 手动触发任务
func (h *OperationalHandler) TriggerTask(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        taskName := chi.URLParam(r, "taskName")
        if taskName == "" </span><span class="cov0" title="0">{
                http.Error(w, "Task name is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">if h.scheduler == nil </span><span class="cov0" title="0">{
                http.Error(w, "Scheduler module disabled", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">logger := h.requestLogger(r, "TriggerTask", pkglogger.Fields{"taskName": taskName})

        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        if err := h.scheduler.RunTask(ctx, taskName); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("manual task execution failed")
                response := map[string]interface{}{
                        "success":   false,
                        "timestamp": time.Now().Format(time.RFC3339),
                        "error": map[string]interface{}{
                                "message": "Task execution failed",
                                "details": err.Error(),
                        },
                }
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("encode manual task error response failed")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "taskName": taskName,
                        "message":  fmt.Sprintf("%s triggered successfully", taskName),
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode manual task success response failed")
        }</span>
}

// TriggerCutover 手动触发cutover操作
func (h *OperationalHandler) TriggerCutover(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()
        logger := h.requestLogger(r, "TriggerCutover", nil)

        if h.scheduler == nil </span><span class="cov0" title="0">{
                http.Error(w, "Scheduler module disabled", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">err := h.scheduler.RunTask(ctx, "daily_cutover")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("manual cutover failed")
                response := map[string]interface{}{
                        "success":   false,
                        "timestamp": time.Now().Format(time.RFC3339),
                        "error": map[string]interface{}{
                                "message": "Cutover operation failed",
                                "details": err.Error(),
                        },
                }
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("encode cutover error response failed")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "message": "Cutover操作已完成",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode cutover success response failed")
        }</span>
}

// TriggerConsistencyCheck 手动触发一致性检查
func (h *OperationalHandler) TriggerConsistencyCheck(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()
        logger := h.requestLogger(r, "TriggerConsistencyCheck", nil)

        if h.scheduler == nil </span><span class="cov0" title="0">{
                http.Error(w, "Scheduler module disabled", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">err := h.scheduler.RunTask(ctx, "data_consistency_check")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("manual consistency check failed")
                response := map[string]interface{}{
                        "success":   false,
                        "timestamp": time.Now().Format(time.RFC3339),
                        "error": map[string]interface{}{
                                "message": "Consistency check failed",
                                "details": err.Error(),
                        },
                }
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("encode consistency check error response failed")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":   true,
                "timestamp": time.Now().Format(time.RFC3339),
                "data": map[string]interface{}{
                        "message": "数据一致性检查已完成",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("encode consistency check success response failed")
        }</span>
}

// 辅助方法已移除，统一通过 scheduler.RunTask 管理任务触发
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "net/http"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/repository"
        scheduler "cube-castle/internal/organization/scheduler"
        "cube-castle/internal/organization/validator"
        pkglogger "cube-castle/pkg/logger"
)

type OrganizationHandler struct {
        repo            *repository.OrganizationRepository
        temporalService *scheduler.TemporalService
        auditLogger     *audit.AuditLogger
        logger          pkglogger.Logger
        timelineManager *repository.TemporalTimelineManager
        hierarchyRepo   *repository.HierarchyRepository
        validator       *validator.BusinessRuleValidator
}

func NewOrganizationHandler(repo *repository.OrganizationRepository, temporalService *scheduler.TemporalService, auditLogger *audit.AuditLogger, baseLogger pkglogger.Logger, timelineManager *repository.TemporalTimelineManager, hierarchyRepo *repository.HierarchyRepository, validator *validator.BusinessRuleValidator) *OrganizationHandler <span class="cov0" title="0">{
        return &amp;OrganizationHandler{
                repo:            repo,
                temporalService: temporalService,
                auditLogger:     auditLogger,
                logger: scopedLogger(baseLogger, "organization", pkglogger.Fields{
                        "module": "organization",
                }),
                timelineManager: timelineManager,
                hierarchyRepo:   hierarchyRepo,
                validator:       validator,
        }
}</span>

func (h *OrganizationHandler) requestLogger(r *http.Request, action string, extra pkglogger.Fields) pkglogger.Logger <span class="cov0" title="0">{
        return requestScopedLogger(h.logger, r, action, extra)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "strings"
        "time"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/utils"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
)

func (h *OrganizationHandler) CreateOrganization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req types.CreateOrganizationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">logger := h.requestLogger(r, "CreateOrganization", nil)

        tenantID := h.getTenantID(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String()})

        req.ParentCode = utils.NormalizeParentCodePointer(req.ParentCode)

        var code string
        if req.Code != nil &amp;&amp; strings.TrimSpace(*req.Code) != "" </span><span class="cov0" title="0">{
                code = strings.TrimSpace(*req.Code)
        }</span> else<span class="cov0" title="0"> {
                var err error
                code, err = h.repo.GenerateCode(r.Context(), tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusInternalServerError, "CODE_GENERATION_ERROR", "生成组织代码失败", err)
                        return
                }</span>
        }
        <span class="cov0" title="0">logger = logger.WithFields(pkglogger.Fields{"code": code})

        normalizedParent := utils.NormalizeParentCodePointer(req.ParentCode)

        if h.validator != nil </span><span class="cov0" title="0">{
                if result := h.validator.ValidateOrganizationCreation(r.Context(), &amp;req, tenantID); !result.Valid </span><span class="cov0" title="0">{
                        h.writeValidationErrors(w, r, result, &amp;validationFailureContext{
                                TenantID:     tenantID,
                                ResourceType: audit.ResourceTypeOrganization,
                                ResourceID:   code,
                                Action:       "ValidateOrganizationCreation",
                                Payload: map[string]interface{}{
                                        "request": req,
                                },
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">fields, err := h.repo.ComputeHierarchyForNew(r.Context(), tenantID, code, normalizedParent, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                errorMessage := err.Error()
                switch </span>{
                case strings.Contains(errorMessage, "父组织不存在"):<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "PARENT_ERROR", "父组织不存在或不可用", err)</span>
                case strings.Contains(errorMessage, "组织名称不能为空"):<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "VALIDATION_ERROR", "组织名称不能为空", err)</span>
                default:<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "HIERARCHY_CALCULATION_FAILED", "层级路径计算失败", err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">now := time.Now().UTC()
        org := &amp;types.Organization{
                TenantID:      tenantID.String(),
                Code:          code,
                ParentCode:    normalizedParent,
                Name:          req.Name,
                UnitType:      req.UnitType,
                Status:        "ACTIVE",
                Level:         fields.Level,
                CodePath:      fields.CodePath,
                NamePath:      fields.NamePath,
                SortOrder:     req.SortOrder,
                Description:   req.Description,
                EffectiveDate: req.EffectiveDate,
                EndDate:       req.EndDate,
                ChangeReason: func() *string </span><span class="cov0" title="0">{
                        if req.ChangeReason == "" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return &amp;req.ChangeReason</span>
                }(),
                IsCurrent: true,
        }
        <span class="cov0" title="0">if org.EffectiveDate == nil </span><span class="cov0" title="0">{
                today := types.NewDate(now.Year(), now.Month(), now.Day())
                org.EffectiveDate = today
        }</span>

        <span class="cov0" title="0">createdOrg, err := h.repo.Create(r.Context(), org)
        if err != nil </span><span class="cov0" title="0">{
                requestID := middleware.GetRequestID(r.Context())
                actorID := h.getActorID(r)
                requestData := map[string]interface{}{
                        "code":       code,
                        "name":       req.Name,
                        "unitType":   req.UnitType,
                        "parentCode": normalizedParent,
                }

                if logErr := h.auditLogger.LogError(
                        r.Context(), tenantID, audit.ResourceTypeOrganization, code,
                        "CreateOrganization", actorID, requestID, "CREATE_ERROR", err.Error(), requestData,
                ); logErr != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": logErr}).Warn("record create failure audit log failed")
                }</span>

                <span class="cov0" title="0">h.handleRepositoryError(w, r, "CREATE", err)
                return</span>
        }

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        actorID := h.getActorID(r)
        ipAddress := h.getIPAddress(r)

        if err := h.auditLogger.LogOrganizationCreate(r.Context(), &amp;req, createdOrg, actorID, requestID, ipAddress); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Warn("audit log for organization create failed")
        }</span>

        <span class="cov0" title="0">response := h.toOrganizationResponse(createdOrg)
        if err := utils.WriteCreated(w, response, "Organization created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write organization create response failed")
        }</span>

        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"name": createdOrg.Name}).Info("organization created")</span>
}

func (h *OrganizationHandler) CreateOrganizationVersion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := chi.URLParam(r, "code")
        if code == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少组织代码", nil)
                return
        }</span>
        <span class="cov0" title="0">logger := h.requestLogger(r, "CreateOrganizationVersion", pkglogger.Fields{"code": code})

        // 验证组织代码格式
        if len(code) != 7 </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_CODE_FORMAT", "组织代码必须是7位数字", nil)
                return
        }</span>

        <span class="cov0" title="0">var req types.CreateVersionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        // 业务验证
        <span class="cov0" title="0">if err := utils.ValidateCreateVersionRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "VALIDATION_ERROR", "输入验证失败", err)
                return
        }</span>

        <span class="cov0" title="0">tenantID := h.getTenantID(r)

        // 验证组织是否存在
        existingOrg, err := h.repo.GetByCode(r.Context(), tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "organization not found" </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusNotFound, "ORGANIZATION_NOT_FOUND", "组织不存在", nil)
                        return
                }</span>
                <span class="cov0" title="0">h.writeErrorResponse(w, r, http.StatusInternalServerError, "DATABASE_ERROR", "查询组织失败", err)
                return</span>
        }

        // 解析生效日期
        <span class="cov0" title="0">effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_DATE_FORMAT", "生效日期格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">var endDate *time.Time
        if req.EndDate != nil </span><span class="cov0" title="0">{
                parsed, err := time.Parse("2006-01-02", *req.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_END_DATE_FORMAT", "结束日期格式无效", err)
                        return
                }</span>
                <span class="cov0" title="0">endDate = &amp;parsed</span>
        }

        <span class="cov0" title="0">var targetParent *string
        if req.ParentCode != nil </span><span class="cov0" title="0">{
                targetParent = utils.NormalizeParentCodePointer(req.ParentCode)
        }</span> else<span class="cov0" title="0"> {
                targetParent = existingOrg.ParentCode
        }</span>

        <span class="cov0" title="0">if h.validator != nil &amp;&amp; targetParent != nil </span><span class="cov0" title="0">{
                validation := h.validator.ValidateTemporalParentAvailability(r.Context(), tenantID, strings.TrimSpace(*targetParent), effectiveDate)
                if !validation.Valid </span><span class="cov0" title="0">{
                        payload := map[string]interface{}{
                                "effectiveDate": effectiveDate.Format("2006-01-02"),
                        }
                        if targetParent != nil </span><span class="cov0" title="0">{
                                payload["parentCode"] = strings.TrimSpace(*targetParent)
                        }</span>
                        <span class="cov0" title="0">h.writeValidationErrors(w, r, validation, &amp;validationFailureContext{
                                TenantID:     tenantID,
                                ResourceType: audit.ResourceTypeOrganization,
                                ResourceID:   code,
                                Action:       "ValidateTemporalParentAvailability",
                                Payload:      payload,
                        })
                        return</span>
                }
        }

        <span class="cov0" title="0">fields, err := h.repo.ComputeHierarchyForNew(r.Context(), tenantID, code, targetParent, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                errorMessage := err.Error()
                if strings.Contains(errorMessage, "父组织不存在") </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "PARENT_ERROR", "父组织不存在或不可用", err)
                }</span> else<span class="cov0" title="0"> if strings.Contains(errorMessage, "组织名称不能为空") </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "VALIDATION_ERROR", "组织名称不能为空", err)
                }</span> else<span class="cov0" title="0"> {
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "HIERARCHY_CALCULATION_FAILED", "层级路径计算失败", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // 创建新的时态版本
        <span class="cov0" title="0">now := time.Now().UTC()
        newVersion := &amp;types.Organization{
                TenantID:   tenantID.String(),
                Code:       code,
                ParentCode: targetParent,
                Name:       req.Name,
                UnitType:   req.UnitType,
                Status:     "ACTIVE", // 新版本默认激活
                Level:      fields.Level,
                CodePath:   fields.CodePath,
                NamePath:   fields.NamePath,
                SortOrder: func() int </span><span class="cov0" title="0">{
                        if req.SortOrder != nil </span><span class="cov0" title="0">{
                                return *req.SortOrder
                        }</span>
                        <span class="cov0" title="0">return existingOrg.SortOrder</span> // 继承原有排序
                }(),
                Description: func() string <span class="cov0" title="0">{
                        if req.Description != nil </span><span class="cov0" title="0">{
                                return *req.Description
                        }</span>
                        <span class="cov0" title="0">return existingOrg.Description</span> // 继承原有描述
                }(),
                // 时态管理字段
                EffectiveDate: types.NewDateFromTime(effectiveDate),
                EndDate: func() *types.Date <span class="cov0" title="0">{
                        if endDate != nil </span><span class="cov0" title="0">{
                                return types.NewDateFromTime(*endDate)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }(),
                // isTemporal 移除：由 endDate 是否为空派生
                ChangeReason: func() *string <span class="cov0" title="0">{
                        return &amp;req.OperationReason
                }</span>(),
                IsCurrent: effectiveDate.Before(now) || effectiveDate.Equal(now.Truncate(24*time.Hour)),
        }

        // 🚀 使用新的时态时间轴管理器 - 实现完整的时态一致性保证
        <span class="cov0" title="0">createdVersion, err := h.timelineManager.InsertVersion(r.Context(), newVersion)
        if err != nil </span><span class="cov0" title="0">{
                // 检查是否是版本冲突错误
                if strings.Contains(err.Error(), "duplicate key") || strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusConflict, "VERSION_CONFLICT", "生效日期与现有版本冲突", err)
                        return
                }</span>

                // 记录创建失败的审计日志
                <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
                actorID := h.getActorID(r)
                requestData := map[string]interface{}{
                        "code":          code,
                        "name":          req.Name,
                        "unitType":      req.UnitType,
                        "effectiveDate": req.EffectiveDate,
                        "parentCode":    targetParent,
                }

                if logErr := h.auditLogger.LogError(
                        r.Context(), tenantID, audit.ResourceTypeOrganization, existingOrg.RecordID,
                        "CreateOrganizationVersion", actorID, requestID, "VERSION_CREATE_ERROR", err.Error(), requestData,
                ); logErr != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": logErr}).Warn("audit log for version create failure failed")
                }</span>

                <span class="cov0" title="0">h.handleRepositoryError(w, r, "CREATE_VERSION", err)
                return</span>
        }

        // 记录版本创建成功的审计日志（排除 isCurrent/isTemporal 等动态字段）
        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        actorID := h.getActorID(r)

        // 记录审计日志 - 创建版本事件（填充变更字段）
        createdFields := []audit.FieldChange{
                {Field: "name", OldValue: nil, NewValue: req.Name, DataType: "string"},
                {Field: "unitType", OldValue: nil, NewValue: req.UnitType, DataType: "string"},
                {Field: "parentCode", OldValue: nil, NewValue: targetParent, DataType: "string"},
                {Field: "description", OldValue: nil, NewValue: req.Description, DataType: "string"},
                {Field: "effectiveDate", OldValue: nil, NewValue: req.EffectiveDate, DataType: "date"},
        }
        modifiedFields := []string{"name", "unitType", "parentCode", "description", "effectiveDate"}

        event := &amp;audit.AuditEvent{
                TenantID:        tenantID,
                EventType:       audit.EventTypeCreate,
                ResourceType:    audit.ResourceTypeOrganization,
                ResourceID:      createdVersion.RecordID.String(),
                ActorID:         actorID,
                ActorType:       audit.ActorTypeUser,
                ActionName:      "CREATE_VERSION",
                RequestID:       requestID,
                OperationReason: req.OperationReason,
                Success:         true,
                ModifiedFields:  modifiedFields,
                Changes:         createdFields,
                AfterData: map[string]interface{}{
                        "code":          createdVersion.Code,
                        "name":          createdVersion.Name,
                        "unitType":      req.UnitType,
                        "parentCode":    targetParent,
                        "description":   req.Description,
                        "effectiveDate": req.EffectiveDate,
                        "endDate":       req.EndDate,
                        "status":        createdVersion.Status,
                },
        }

        err = h.auditLogger.LogEvent(r.Context(), event)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Warn("audit log for version create failed")
                // 审计日志失败不影响业务操作，仅记录警告
        }</span>

        // 构建响应数据
        <span class="cov0" title="0">responseData := map[string]interface{}{
                "recordId":      createdVersion.RecordID.String(),
                "code":          createdVersion.Code,
                "name":          createdVersion.Name,
                "effectiveDate": req.EffectiveDate,
                "status":        createdVersion.Status,
        }

        // 返回企业级成功响应
        if err := utils.WriteCreated(w, responseData, "Temporal version created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write organization version response failed")
        }</span>

        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"name": createdVersion.Name, "effectiveDate": req.EffectiveDate}).Info("organization version created")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handler

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/repository"
        "cube-castle/internal/organization/utils"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
)

func (h *OrganizationHandler) CreateOrganizationEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := chi.URLParam(r, "code")
        if code == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少组织代码", nil)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                EventType     string `json:"eventType"`
                RecordID      string `json:"recordId"`
                EffectiveDate string `json:"effectiveDate"`
                ChangeReason  string `json:"changeReason"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">eventType := strings.TrimSpace(req.EventType)
        logger := h.requestLogger(r, "CreateOrganizationEvent", pkglogger.Fields{
                "code":      code,
                "eventType": eventType,
        })

        tenantID := h.getTenantID(r)
        operationReason := strings.TrimSpace(req.ChangeReason)

        switch eventType </span>{
        case "DEACTIVATE":<span class="cov0" title="0">
                if strings.TrimSpace(req.RecordID) == "" </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "MISSING_RECORD_ID", "缺少记录ID", nil)
                        return
                }</span>

                // 处理版本作废事件
                <span class="cov0" title="0">actorID := h.getActorID(r)
                requestID := middleware.GetRequestID(r.Context())

                err := h.handleDeactivateEvent(r.Context(), tenantID, code, req.RecordID, operationReason, actorID, requestID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, repository.ErrOrganizationHasChildren) </span><span class="cov0" title="0">{
                                details := map[string]interface{}{
                                        "resolution": "Delete or reassign child units first",
                                }
                                var childErr *repository.OrganizationHasChildrenError
                                if errors.As(err, &amp;childErr) &amp;&amp; childErr.Count &gt; 0 </span><span class="cov0" title="0">{
                                        details["affectedCount"] = childErr.Count
                                }</span>
                                <span class="cov0" title="0">h.writeErrorResponse(w, r, http.StatusConflict, "HAS_CHILD_UNITS", "Cannot delete organization unit with child units", details)
                                return</span>
                        }
                        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"error": err}).Error("deactivate organization version failed")
                        h.writeErrorResponse(w, r, http.StatusInternalServerError, "DEACTIVATE_ERROR", "作废版本失败", err)
                        return</span>
                }

                // 获取最新时间线（非删除记录），用于前端立即刷新，避免读缓存延迟
                <span class="cov0" title="0">versions, listErr := h.repo.ListVersionsByCode(r.Context(), tenantID, code)
                if listErr != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": listErr}).Warn("fetch latest timeline failed (non-blocking)")
                }</span>

                // 构建轻量时间线返回
                <span class="cov0" title="0">timeline := make([]map[string]interface{}, 0, len(versions))
                for _, v := range versions </span><span class="cov0" title="0">{
                        timeline = append(timeline, map[string]interface{}{
                                "recordId":  v.RecordID,
                                "code":      v.Code,
                                "name":      v.Name,
                                "unitType":  v.UnitType,
                                "status":    v.Status,
                                "level":     v.Level,
                                "codePath":  v.CodePath,
                                "namePath":  v.NamePath,
                                "sortOrder": v.SortOrder,
                                "effectiveDate": func() string </span><span class="cov0" title="0">{
                                        if v.EffectiveDate != nil </span><span class="cov0" title="0">{
                                                return v.EffectiveDate.String()
                                        }</span>
                                        <span class="cov0" title="0">return ""</span>
                                }(),
                                "endDate": func() *string <span class="cov0" title="0">{
                                        if v.EndDate != nil </span><span class="cov0" title="0">{
                                                s := v.EndDate.String()
                                                return &amp;s
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }(),
                                "isCurrent":   v.IsCurrent,
                                "createdAt":   v.CreatedAt,
                                "updatedAt":   v.UpdatedAt,
                                "parentCode":  v.ParentCode,
                                "description": v.Description,
                        })
                }

                <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{
                        "timelineCount": len(timeline),
                }).Info("organization version deactivated")
                if err := utils.WriteSuccess(w, map[string]interface{}{
                        "code":      code,
                        "record_id": req.RecordID,
                        "timeline":  timeline,
                }, "版本作废成功", requestID); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("write deactivate response failed")
                }</span>

        case "DELETE_ORGANIZATION":<span class="cov0" title="0">
                actorID := h.getActorID(r)
                requestID := middleware.GetRequestID(r.Context())

                if strings.TrimSpace(req.EffectiveDate) == "" </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "缺少生效日期", nil)
                        return
                }</span>

                <span class="cov0" title="0">effectiveDate, err := time.Parse("2006-01-02", strings.TrimSpace(req.EffectiveDate))
                if err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_EFFECTIVE_DATE", "生效日期格式无效，应为YYYY-MM-DD", err)
                        return
                }</span>

                <span class="cov0" title="0">ifMatch, err := h.getIfMatchValue(r)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "缺少或无效的 If-Match 标头", err)
                        return
                }</span>

                <span class="cov0" title="0">currentOrg, err := h.repo.GetByCode(r.Context(), tenantID, code)
                if err != nil </span><span class="cov0" title="0">{
                        h.handleRepositoryError(w, r, "GET_FOR_DELETE", err)
                        return
                }</span>

                <span class="cov0" title="0">expectedETag := strings.TrimSpace(currentOrg.RecordID)
                if expectedETag == "" </span><span class="cov0" title="0">{
                        expectedETag = currentOrg.UpdatedAt.Format(time.RFC3339Nano)
                }</span>

                <span class="cov0" title="0">if ifMatch != expectedETag </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "资源已发生变更，请刷新后重试", map[string]interface{}{
                                "expected": expectedETag,
                                "provided": ifMatch,
                        })
                        return
                }</span>

                <span class="cov0" title="0">childCount, err := h.repo.CountNonDeletedChildren(r.Context(), tenantID, code)
                if err != nil </span><span class="cov0" title="0">{
                        h.handleRepositoryError(w, r, "COUNT_CHILDREN", err)
                        return
                }</span>

                <span class="cov0" title="0">if childCount &gt; 0 </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusConflict, "HAS_CHILD_UNITS", "Cannot delete organization unit with child units", map[string]interface{}{
                                "affectedCount": childCount,
                                "resolution":    "Delete or reassign child units first",
                        })
                        return
                }</span>

                <span class="cov0" title="0">deletionMoment := time.Date(effectiveDate.Year(), effectiveDate.Month(), effectiveDate.Day(), 0, 0, 0, 0, time.UTC)

                if err := h.repo.SoftDeleteOrganization(r.Context(), tenantID, code, deletionMoment, actorID, operationReason); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                h.writeErrorResponse(w, r, http.StatusNotFound, "ORGANIZATION_NOT_FOUND", "组织单元不存在或已删除", err)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"error": err}).Error("soft delete organization failed")
                        h.handleRepositoryError(w, r, "DELETE", err)
                        return</span>
                }

                <span class="cov0" title="0">if err := h.auditLogger.LogOrganizationDelete(r.Context(), tenantID, code, currentOrg, actorID, requestID, operationReason); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Warn("record organization delete audit log failed")
                }</span>

                <span class="cov0" title="0">responseData := map[string]interface{}{
                        "code":            code,
                        "status":          "DELETED",
                        "operationType":   "DELETE_ORGANIZATION",
                        "record_id":       nil,
                        "effectiveDate":   effectiveDate.Format("2006-01-02"),
                        "operationReason": operationReason,
                        "timeline":        []map[string]interface{}{},
                }

                if err := utils.WriteSuccess(w, responseData, "组织删除成功", requestID); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("write organization delete response failed")
                }</span>

                <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"tenantId": tenantID}).Info("organization deleted")</span>

        default:<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusBadRequest, "UNSUPPORTED_EVENT", fmt.Sprintf("不支持的事件类型: %s", req.EventType), nil)</span>
        }
}

func (h *OrganizationHandler) handleDeactivateEvent(ctx context.Context, tenantID uuid.UUID, code string, recordID string, changeReason string, actorID string, requestID string) error <span class="cov0" title="0">{
        // 验证UUID格式
        if _, err := uuid.Parse(recordID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无效的记录ID格式: %w", err)
        }</span>

        // 获取删除前的组织数据用于审计日志
        <span class="cov0" title="0">oldOrg, err := h.repo.GetByRecordId(ctx, tenantID, recordID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取记录失败: %w", err)
        }</span>

        <span class="cov0" title="0">if oldOrg != nil </span><span class="cov0" title="0">{
                hasOtherVersions, err := h.repo.HasOtherNonDeletedVersions(ctx, tenantID, oldOrg.Code, recordID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("检查版本数量失败: %w", err)
                }</span>
                <span class="cov0" title="0">if !hasOtherVersions </span><span class="cov0" title="0">{
                        childCount, err := h.repo.CountNonDeletedChildren(ctx, tenantID, oldOrg.Code)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("检查子组织失败: %w", err)
                        }</span>
                        <span class="cov0" title="0">if childCount &gt; 0 </span><span class="cov0" title="0">{
                                return repository.NewOrganizationHasChildrenError(childCount)
                        }</span>
                }
        }

        // 使用时间线管理器执行“单事务 软删 + 全链重算”
        <span class="cov0" title="0">rid, _ := uuid.Parse(recordID)
        if _, err := h.timelineManager.DeleteVersion(ctx, tenantID, rid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("作废记录失败: %w", err)
        }</span>

        // 记录审计日志 - 使用删除日志方法
        <span class="cov0" title="0">err = h.auditLogger.LogOrganizationDelete(ctx, tenantID, code, oldOrg, actorID, requestID, changeReason)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithFields(pkglogger.Fields{"error": err, "recordId": recordID}).Warn("audit log for organization version delete failed")
                // 审计日志失败不应该导致业务操作失败，只记录警告
        }</span> else<span class="cov0" title="0"> {
                h.logger.WithFields(pkglogger.Fields{"recordId": recordID}).Info("audit log recorded for organization version delete")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handler

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/repository"
        "cube-castle/internal/organization/utils"
        "cube-castle/internal/organization/validator"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

type validationFailureContext struct {
        TenantID     uuid.UUID
        ResourceType string
        ResourceID   string
        Action       string
        Payload      map[string]interface{}
}

func (h *OrganizationHandler) getTenantID(r *http.Request) uuid.UUID <span class="cov0" title="0">{
        tenantIDHeader := r.Header.Get("X-Tenant-ID")
        if tenantIDHeader != "" </span><span class="cov0" title="0">{
                if tenantID, err := uuid.Parse(tenantIDHeader); err == nil </span><span class="cov0" title="0">{
                        return tenantID
                }</span>
        }
        <span class="cov0" title="0">return types.DefaultTenantID</span>
}

func (h *OrganizationHandler) getIfMatchValue(r *http.Request) (string, error) <span class="cov8" title="1">{
        raw := strings.TrimSpace(r.Header.Get("If-Match"))
        if raw == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("missing If-Match header")
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(strings.ToLower(raw), "w/") </span><span class="cov8" title="1">{
                raw = strings.TrimSpace(raw[2:])
        }</span>

        <span class="cov8" title="1">trimmed := strings.Trim(raw, "\"")
        trimmed = strings.TrimSpace(trimmed)
        if trimmed == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid If-Match header")
        }</span>

        <span class="cov8" title="1">return trimmed, nil</span>
}

func (h *OrganizationHandler) writeValidationErrors(w http.ResponseWriter, r *http.Request, result *validator.ValidationResult, failureCtx *validationFailureContext) <span class="cov0" title="0">{
        requestID := middleware.GetRequestID(r.Context())

        var (
                firstError validator.ValidationError
                hasError   = len(result.Errors) &gt; 0
        )

        if hasError </span><span class="cov0" title="0">{
                firstError = result.Errors[0]
        }</span>

        <span class="cov0" title="0">severity := strings.ToUpper(strings.TrimSpace(firstError.Severity))
        if severity == "" </span><span class="cov0" title="0">{
                severity = string(validator.SeverityHigh)
        }</span>

        <span class="cov0" title="0">httpStatus := validator.SeverityToHTTPStatus(severity)
        if httpStatus &lt; http.StatusBadRequest </span><span class="cov0" title="0">{
                httpStatus = http.StatusBadRequest
        }</span>

        <span class="cov0" title="0">responseCode := strings.TrimSpace(firstError.Code)
        if responseCode == "" </span><span class="cov0" title="0">{
                responseCode = "BUSINESS_RULE_VIOLATION"
        }</span>

        <span class="cov0" title="0">responseMessage := strings.TrimSpace(firstError.Message)
        if responseMessage == "" </span><span class="cov0" title="0">{
                responseMessage = "业务规则校验失败"
        }</span>

        <span class="cov0" title="0">ruleID := responseCode
        if ctx := firstError.Context; ctx != nil </span><span class="cov0" title="0">{
                if val, ok := ctx["ruleId"]; ok </span><span class="cov0" title="0">{
                        ruleID = fmt.Sprintf("%v", val)
                }</span>
        }
        <span class="cov0" title="0">ruleID = strings.TrimSpace(ruleID)
        if ruleID == "" </span><span class="cov0" title="0">{
                ruleID = responseCode
        }</span>

        <span class="cov0" title="0">details := map[string]interface{}{
                "ruleId":           ruleID,
                "severity":         severity,
                "httpStatus":       httpStatus,
                "validationErrors": result.Errors,
                "errorCount":       len(result.Errors),
        }

        if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                details["warnings"] = result.Warnings
                details["warningCount"] = len(result.Warnings)
        }</span>

        <span class="cov0" title="0">if field := strings.TrimSpace(firstError.Field); field != "" </span><span class="cov0" title="0">{
                details["field"] = field
        }</span>

        <span class="cov0" title="0">if len(result.Context) &gt; 0 </span><span class="cov0" title="0">{
                details["chainContext"] = result.Context
        }</span>

        <span class="cov0" title="0">if ctx := firstError.Context; ctx != nil </span><span class="cov0" title="0">{
                metadata := make(map[string]interface{})
                for k, v := range ctx </span><span class="cov0" title="0">{
                        if strings.EqualFold(k, "ruleId") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">metadata[k] = v</span>
                }
                <span class="cov0" title="0">if len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                        details["metadata"] = metadata
                }</span>
        }

        <span class="cov0" title="0">logger := h.requestLogger(r, "writeValidationErrors", pkglogger.Fields{
                "errorCount": len(result.Errors),
                "ruleId":     ruleID,
                "severity":   severity,
                "httpStatus": httpStatus,
                "code":       responseCode,
        })

        if !hasError </span><span class="cov0" title="0">{
                if err := utils.WriteError(w, http.StatusBadRequest, responseCode, responseMessage, requestID, details); err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("write validation error response failed")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := utils.WriteError(w, httpStatus, responseCode, responseMessage, requestID, details); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write validation error response failed")
        }</span>

        <span class="cov0" title="0">if failureCtx == nil || h.auditLogger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">auditPayload := map[string]interface{}{
                "ruleId":           ruleID,
                "severity":         severity,
                "httpStatus":       httpStatus,
                "validationErrors": result.Errors,
        }
        if len(result.Context) &gt; 0 </span><span class="cov0" title="0">{
                auditPayload["chainContext"] = result.Context
        }</span>

        <span class="cov0" title="0">if failureCtx.Payload != nil </span><span class="cov0" title="0">{
                payloadCopy := make(map[string]interface{}, len(failureCtx.Payload))
                for k, v := range failureCtx.Payload </span><span class="cov0" title="0">{
                        payloadCopy[k] = v
                }</span>
                <span class="cov0" title="0">auditPayload["payload"] = payloadCopy</span>
        }

        <span class="cov0" title="0">if metadata, ok := details["metadata"].(map[string]interface{}); ok &amp;&amp; len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                auditPayload["metadata"] = metadata
        }</span>

        <span class="cov0" title="0">if field, ok := details["field"]; ok </span><span class="cov0" title="0">{
                auditPayload["field"] = field
        }</span>

        <span class="cov0" title="0">actionName := strings.TrimSpace(failureCtx.Action)
        if actionName == "" </span><span class="cov0" title="0">{
                actionName = r.Method
        }</span>

        <span class="cov0" title="0">if err := h.auditLogger.LogError(
                r.Context(),
                failureCtx.TenantID,
                failureCtx.ResourceType,
                failureCtx.ResourceID,
                actionName,
                h.getActorID(r),
                requestID,
                responseCode,
                responseMessage,
                auditPayload,
        ); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Warn("audit log for validation error failed")
        }</span>
}

func (h *OrganizationHandler) refreshHierarchyPaths(ctx context.Context, tenantID uuid.UUID, rootCode string) error <span class="cov0" title="0">{
        if h.hierarchyRepo == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">visited := make(map[string]struct{})
        queue := []string{rootCode}

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                if _, seen := visited[current]; seen </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">visited[current] = struct{}{}

                if err := h.hierarchyRepo.UpdateHierarchyPaths(ctx, current, tenantID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">children, err := h.hierarchyRepo.GetDirectChildren(ctx, current, tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                        queue = append(queue, child.Code)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *OrganizationHandler) toOrganizationResponse(org *types.Organization) *types.OrganizationResponse <span class="cov0" title="0">{
        return &amp;types.OrganizationResponse{
                Code:          org.Code,
                Name:          org.Name,
                UnitType:      org.UnitType,
                Status:        org.Status,
                Level:         org.Level,
                CodePath:      org.CodePath,
                NamePath:      org.NamePath,
                SortOrder:     org.SortOrder,
                Description:   org.Description,
                ParentCode:    org.ParentCode,
                CreatedAt:     org.CreatedAt,
                UpdatedAt:     org.UpdatedAt,
                EffectiveDate: org.EffectiveDate,
                EndDate:       org.EndDate,
                ChangeReason:  org.ChangeReason,
        }
}</span>

func (h *OrganizationHandler) writeErrorResponse(w http.ResponseWriter, r *http.Request, statusCode int, code, message string, details interface{}) <span class="cov0" title="0">{
        errorMsg := message

        // 如果details是error类型，处理错误信息
        if err, ok := details.(error); ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        h.requestLogger(r, "writeErrorResponse", pkglogger.Fields{"status": statusCode, "code": code}).WithFields(pkglogger.Fields{"error": err}).Error("server error while handling response")
                        errorMsg = "Internal server error"
                        details = nil // 不向客户端暴露内部错误详情
                }</span> else<span class="cov0" title="0"> {
                        details = err.Error()
                }</span>
        }

        // 获取请求ID
        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())

        // 使用统一响应构建器
        logger := h.requestLogger(r, "writeErrorResponse", pkglogger.Fields{"status": statusCode, "code": code})
        if err := utils.WriteError(w, statusCode, code, errorMsg, requestID, details); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write error response failed")
        }</span>
}

func (h *OrganizationHandler) getActorID(r *http.Request) string <span class="cov0" title="0">{
        // 从JWT令牌或X-Mock-User头部获取用户ID
        if userID := r.Header.Get("X-Mock-User"); userID != "" </span><span class="cov0" title="0">{
                return userID
        }</span>

        // 从JWT上下文获取
        <span class="cov0" title="0">if userID := r.Context().Value("user_id"); userID != nil </span><span class="cov0" title="0">{
                if uid, ok := userID.(string); ok </span><span class="cov0" title="0">{
                        return uid
                }</span>
        }

        // 如果无法获取用户ID，返回默认值
        <span class="cov0" title="0">return "system"</span>
}

// getIPAddress 从请求中获取客户端IP地址

func (h *OrganizationHandler) getIPAddress(r *http.Request) string <span class="cov0" title="0">{
        // 检查X-Forwarded-For头部（代理情况）
        if forwarded := r.Header.Get("X-Forwarded-For"); forwarded != "" </span><span class="cov0" title="0">{
                // 取第一个IP地址
                if idx := strings.Index(forwarded, ","); idx != -1 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(forwarded[:idx])
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(forwarded)</span>
        }

        // 检查X-Real-IP头部
        <span class="cov0" title="0">if realIP := r.Header.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                return realIP
        }</span>

        // 使用RemoteAddr - 处理IPv6地址
        <span class="cov0" title="0">if ip := r.RemoteAddr; ip != "" </span><span class="cov0" title="0">{
                // 处理IPv6地址格式 [::1]:port
                if strings.HasPrefix(ip, "[") &amp;&amp; strings.Contains(ip, "]:") </span><span class="cov0" title="0">{
                        end := strings.Index(ip, "]:")
                        if end &gt; 0 </span><span class="cov0" title="0">{
                                return ip[1:end] // 去除[]和端口
                        }</span>
                }
                // 处理IPv4地址格式 ip:port
                <span class="cov0" title="0">if idx := strings.LastIndex(ip, ":"); idx != -1 &amp;&amp; !strings.Contains(ip[:idx], ":") </span><span class="cov0" title="0">{
                        return ip[:idx]
                }</span>
                <span class="cov0" title="0">return ip</span>
        }

        <span class="cov0" title="0">return "127.0.0.1"</span> // 默认本地地址
}

// handleRepositoryError 统一处理Repository层错误

func (h *OrganizationHandler) handleRepositoryError(w http.ResponseWriter, r *http.Request, operation string, err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logger := h.requestLogger(r, "handleRepositoryError", pkglogger.Fields{"operation": operation})

        if errors.Is(err, repository.ErrOrganizationHasChildren) </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusConflict, "HAS_CHILD_UNITS", "存在子组织，无法删除", map[string]interface{}{
                        "operation": operation,
                })
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, repository.ErrOrganizationPrecondition) </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "请求的版本信息已过期，请刷新后重试", nil)
                return
        }</span>

        <span class="cov0" title="0">errorStr := err.Error()

        // PostgreSQL错误代码映射
        switch </span>{
        // 数据不存在错误 - 包括应用层和数据库层错误
        case strings.Contains(errorStr, "not found") || strings.Contains(errorStr, "no rows") ||
                strings.Contains(errorStr, "组织不存在") || strings.Contains(errorStr, "组织代码已存在"):<span class="cov0" title="0">

                // 区分不同的错误类型
                if strings.Contains(errorStr, "组织代码已存在") </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusConflict, "DUPLICATE_CODE", "组织代码已存在", map[string]interface{}{
                                "constraint": "unique_code_per_tenant",
                                "operation":  operation,
                        })
                }</span> else<span class="cov0" title="0"> {
                        h.writeErrorResponse(w, r, http.StatusNotFound, "ORGANIZATION_NOT_FOUND", "组织单元不存在", err)
                }</span>

        // 唯一约束违反 - 代码/时间点/当前冲突
        case strings.Contains(errorStr, "duplicate key value"):<span class="cov0" title="0">
                // 细分约束名称
                switch </span>{
                case strings.Contains(errorStr, "uk_org_ver_active_only"):<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusConflict, "TEMPORAL_POINT_CONFLICT", "(tenant_id, code, effective_date) must be unique for non-deleted versions", nil)</span>
                case strings.Contains(errorStr, "uk_org_current_active_only"):<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusConflict, "CURRENT_CONFLICT", "Only one current non-deleted version per (tenant_id, code) is allowed", nil)</span>
                case strings.Contains(errorStr, "organization_units_code_tenant_id_key"):<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusConflict, "DUPLICATE_CODE", "组织代码已存在", map[string]interface{}{
                                "constraint": "unique_code_per_tenant",
                                "operation":  operation,
                        })</span>
                default:<span class="cov0" title="0">
                        h.writeErrorResponse(w, r, http.StatusConflict, "CONSTRAINT_VIOLATION", "数据约束违反", map[string]interface{}{
                                "operation": operation,
                                "type":      "database_constraint",
                        })</span>
                }

        // 单位类型约束违反
        case strings.Contains(errorStr, "organization_units_unit_type_check"):<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_UNIT_TYPE", "无效的组织类型", map[string]interface{}{
                        "allowedTypes": []string{"DEPARTMENT", "ORGANIZATION_UNIT", "PROJECT_TEAM"},
                        "constraint":   "unit_type_check",
                })</span>

        // 字段长度限制
        case strings.Contains(errorStr, "value too long for type"):<span class="cov0" title="0">
                fieldName := "unknown"
                if strings.Contains(errorStr, "character varying(10)") </span><span class="cov0" title="0">{
                        fieldName = "code"
                }</span> else<span class="cov0" title="0"> if strings.Contains(errorStr, "character varying(100)") </span><span class="cov0" title="0">{
                        fieldName = "name"
                }</span>
                <span class="cov0" title="0">h.writeErrorResponse(w, r, http.StatusBadRequest, "FIELD_TOO_LONG", fmt.Sprintf("字段 %s 超出长度限制", fieldName), map[string]interface{}{
                        "field":      fieldName,
                        "constraint": "field_length_limit",
                })</span>

        // 外键约束违反 - 父组织不存在
        case strings.Contains(errorStr, "foreign key constraint") &amp;&amp; strings.Contains(errorStr, "parent_code"):<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_PARENT", "父组织不存在或无效", map[string]interface{}{
                        "constraint": "parent_organization_exists",
                })</span>

        // 业务逻辑错误
        case strings.Contains(errorStr, "already suspended"):<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusConflict, "ALREADY_SUSPENDED", "组织单元已处于停用状态", nil)</span>

        case strings.Contains(errorStr, "already active"):<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusConflict, "ALREADY_ACTIVE", "组织单元已处于激活状态", nil)</span>

        case strings.Contains(errorStr, "has non-deleted child units") || strings.Contains(errorStr, "has children"):<span class="cov0" title="0">
                details := map[string]interface{}{
                        "operation":  operation,
                        "resolution": "Delete or reassign child units first",
                }
                var childErr *repository.OrganizationHasChildrenError
                if errors.As(err, &amp;childErr) &amp;&amp; childErr.Count &gt; 0 </span><span class="cov0" title="0">{
                        details["affectedCount"] = childErr.Count
                }</span>
                <span class="cov0" title="0">h.writeErrorResponse(w, r, http.StatusConflict, "HAS_CHILD_UNITS", "Cannot delete organization unit with child units", details)</span>

        // 数据库连接错误
        case strings.Contains(errorStr, "connection refused") || strings.Contains(errorStr, "timeout"):<span class="cov0" title="0">
                logger.WithFields(pkglogger.Fields{"error": err}).Error("database connection issue")
                h.writeErrorResponse(w, r, http.StatusServiceUnavailable, "DATABASE_UNAVAILABLE", "数据库服务暂时不可用", map[string]interface{}{
                        "operation": operation,
                        "retryable": true,
                })</span>

        // 已删除记录只读
        case strings.Contains(errorStr, "READ_ONLY_DELETED") || strings.Contains(errorStr, "cannot modify deleted record"):<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusConflict, "DELETED_RECORD_READ_ONLY", "已删除记录为只读，禁止修改", nil)</span>

        // 其他数据库约束错误
        case strings.Contains(errorStr, "constraint"):<span class="cov0" title="0">
                h.writeErrorResponse(w, r, http.StatusConflict, "CONSTRAINT_VIOLATION", "数据约束违反", map[string]interface{}{
                        "operation": operation,
                        "type":      "database_constraint",
                })</span>

        // 默认内部服务器错误
        default:<span class="cov0" title="0">
                logger.WithFields(pkglogger.Fields{"error": err}).Error("unhandled repository error")
                h.writeErrorResponse(w, r, http.StatusInternalServerError, fmt.Sprintf("%s_ERROR", operation), fmt.Sprintf("%s操作失败", getOperationName(operation)), map[string]interface{}{
                        "operation": operation,
                        "retryable": false,
                })</span>
        }
}

// getOperationName 获取操作的中文名称

func getOperationName(operation string) string <span class="cov0" title="0">{
        operationNames := map[string]string{
                "CREATE":   "创建",
                "UPDATE":   "更新",
                "DELETE":   "删除",
                "SUSPEND":  "停用",
                "ACTIVATE": "激活",
                "QUERY":    "查询",
        }

        if name, exists := operationNames[operation]; exists </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return operation</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/utils"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
)

func (h *OrganizationHandler) UpdateHistoryRecord(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := h.requestLogger(r, "UpdateHistoryRecord", nil)
        recordId := chi.URLParam(r, "record_id")
        if recordId == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "MISSING_RECORD_ID", "缺少记录ID", nil)
                return
        }</span>

        // 验证UUID格式
        <span class="cov0" title="0">if _, err := uuid.Parse(recordId); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_RECORD_ID", "无效的记录ID格式", err)
                return
        }</span>

        <span class="cov0" title="0">var req types.UpdateOrganizationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">tenantID := h.getTenantID(r)
        parentProvided := req.ParentCode != nil
        req.ParentCode = utils.NormalizeParentCodePointer(req.ParentCode)

        // 先获取当前记录数据用于审计日志
        oldOrg, err := h.repo.GetByRecordId(r.Context(), tenantID, recordId)
        if err != nil </span><span class="cov0" title="0">{
                h.handleRepositoryError(w, r, "GET_OLD_RECORD", err)
                return
        }</span>

        <span class="cov0" title="0">if h.validator != nil </span><span class="cov0" title="0">{
                if result := h.validator.ValidateOrganizationUpdate(r.Context(), oldOrg.Code, &amp;req, tenantID); !result.Valid </span><span class="cov0" title="0">{
                        h.writeValidationErrors(w, r, result, &amp;validationFailureContext{
                                TenantID:     tenantID,
                                ResourceType: audit.ResourceTypeOrganization,
                                ResourceID:   oldOrg.Code,
                                Action:       "ValidateHistoryUpdate",
                                Payload: map[string]interface{}{
                                        "request":  req,
                                        "recordId": recordId,
                                },
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">parentChanged := false
        if parentProvided </span><span class="cov0" title="0">{
                switch </span>{
                case oldOrg.ParentCode == nil &amp;&amp; req.ParentCode != nil:<span class="cov0" title="0">
                        parentChanged = true</span>
                case oldOrg.ParentCode != nil &amp;&amp; req.ParentCode == nil:<span class="cov0" title="0">
                        parentChanged = true</span>
                case oldOrg.ParentCode != nil &amp;&amp; req.ParentCode != nil &amp;&amp; *oldOrg.ParentCode != *req.ParentCode:<span class="cov0" title="0">
                        parentChanged = true</span>
                }
        }

        // 通过UUID更新历史记录
        <span class="cov0" title="0">updatedOrg, err := h.repo.UpdateByRecordId(r.Context(), tenantID, recordId, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusInternalServerError, "UPDATE_ERROR", "更新历史记录失败", err)
                return
        }</span>

        <span class="cov0" title="0">if parentChanged </span><span class="cov0" title="0">{
                if err := h.refreshHierarchyPaths(r.Context(), tenantID, updatedOrg.Code); err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusInternalServerError, "HIERARCHY_UPDATE_FAILED", "层级路径更新失败", err)
                        return
                }</span>
        }

        // 记录完整审计日志（包含变更前数据）
        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        actorID := h.getActorID(r)
        ipAddress := h.getIPAddress(r)
        err = h.auditLogger.LogOrganizationUpdate(r.Context(), updatedOrg.Code, &amp;req, oldOrg, updatedOrg, actorID, requestID, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Warn("history update audit log failed")
        }</span>

        // 构建企业级成功响应
        <span class="cov0" title="0">response := h.toOrganizationResponse(updatedOrg)
        if err := utils.WriteSuccess(w, response, "History record updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write history record update response failed")
        }</span>

        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"recordId": recordId}).Info("history record updated")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handler

import "github.com/go-chi/chi/v5"

func (h *OrganizationHandler) SetupRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Route("/api/v1/organization-units", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", h.CreateOrganization)
                r.Put("/{code}", h.UpdateOrganization)
                r.Post("/{code}/suspend", h.SuspendOrganization)
                r.Post("/{code}/activate", h.ActivateOrganization)
                // 🚀 时态版本管理端点 - 严格遵循API契约
                r.Post("/{code}/versions", h.CreateOrganizationVersion)
                // 注意: 删除版本请使用 POST /{code}/events (DEACTIVATE)
                // 注意: 修改生效日期请使用 PUT /{code}/history/{record_id}
                // 事件处理和历史记录
                r.Post("/{code}/events", h.CreateOrganizationEvent)
                r.Put("/{code}/history/{record_id}", h.UpdateHistoryRecord)
        }</span>)
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/repository"
        "cube-castle/internal/organization/utils"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
)

func (h *OrganizationHandler) UpdateOrganization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := chi.URLParam(r, "code")
        if code == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少组织代码", nil)
                return
        }</span>
        <span class="cov0" title="0">logger := h.requestLogger(r, "UpdateOrganization", pkglogger.Fields{"code": code})

        // 验证组织代码格式
        if err := utils.ValidateOrganizationCode(code); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_CODE_FORMAT", "组织代码格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">var req types.UpdateOrganizationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">tenantID := h.getTenantID(r)
        parentProvided := req.ParentCode != nil
        req.ParentCode = utils.NormalizeParentCodePointer(req.ParentCode)

        if h.validator != nil </span><span class="cov0" title="0">{
                if result := h.validator.ValidateOrganizationUpdate(r.Context(), code, &amp;req, tenantID); !result.Valid </span><span class="cov0" title="0">{
                        h.writeValidationErrors(w, r, result, &amp;validationFailureContext{
                                TenantID:     tenantID,
                                ResourceType: audit.ResourceTypeOrganization,
                                ResourceID:   code,
                                Action:       "ValidateOrganizationUpdate",
                                Payload: map[string]interface{}{
                                        "request": req,
                                },
                        })
                        return
                }</span>
        }

        // 先获取当前组织数据用于审计日志
        <span class="cov0" title="0">oldOrg, err := h.repo.GetByCode(r.Context(), tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                h.handleRepositoryError(w, r, "GET_OLD_DATA", err)
                return
        }</span>

        <span class="cov0" title="0">parentChanged := false
        if parentProvided </span><span class="cov0" title="0">{
                switch </span>{
                case oldOrg.ParentCode == nil &amp;&amp; req.ParentCode != nil:<span class="cov0" title="0">
                        parentChanged = true</span>
                case oldOrg.ParentCode != nil &amp;&amp; req.ParentCode == nil:<span class="cov0" title="0">
                        parentChanged = true</span>
                case oldOrg.ParentCode != nil &amp;&amp; req.ParentCode != nil &amp;&amp; *oldOrg.ParentCode != *req.ParentCode:<span class="cov0" title="0">
                        parentChanged = true</span>
                }
        }

        // 更新组织
        <span class="cov0" title="0">updatedOrg, err := h.repo.Update(r.Context(), tenantID, code, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleRepositoryError(w, r, "UPDATE", err)
                return
        }</span>

        <span class="cov0" title="0">if parentChanged </span><span class="cov0" title="0">{
                if err := h.refreshHierarchyPaths(r.Context(), tenantID, updatedOrg.Code); err != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusInternalServerError, "HIERARCHY_UPDATE_FAILED", "层级路径更新失败", err)
                        return
                }</span>
        }

        // 记录完整审计日志（包含变更前数据）
        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        actorID := h.getActorID(r)
        ipAddress := h.getIPAddress(r)
        err = h.auditLogger.LogOrganizationUpdate(r.Context(), code, &amp;req, oldOrg, updatedOrg, actorID, requestID, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Warn("audit log for organization update failed")
        }</span>

        // 返回企业级成功响应
        <span class="cov0" title="0">response := h.toOrganizationResponse(updatedOrg)
        if err := utils.WriteSuccess(w, response, "Organization updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write organization update response failed")
        }</span>

        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"name": updatedOrg.Name}).Info("organization updated")</span>
}

// SuspendOrganization 暂停组织 - 实现第四大核心场景之暂停
// 使用时态时间轴管理器实现状态变更

func (h *OrganizationHandler) SuspendOrganization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.changeOrganizationStatusWithTimeline(w, r, "INACTIVE", "SUSPEND", "暂停组织")
}</span>

// ActivateOrganization 激活组织 - 实现第四大核心场景之激活
// 使用时态时间轴管理器实现状态变更

func (h *OrganizationHandler) ActivateOrganization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.changeOrganizationStatusWithTimeline(w, r, "ACTIVE", "REACTIVATE", "激活组织")
}</span>

// changeOrganizationStatusWithTimeline 通用的组织状态变更handler - 使用时态时间轴管理器

func (h *OrganizationHandler) changeOrganizationStatusWithTimeline(w http.ResponseWriter, r *http.Request, newStatus, operationType, actionName string) <span class="cov0" title="0">{
        code := chi.URLParam(r, "code")
        if code == "" </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少组织代码", nil)
                return
        }</span>
        <span class="cov0" title="0">logger := h.requestLogger(r, actionName, pkglogger.Fields{
                "code":          code,
                "newStatus":     newStatus,
                "operationType": operationType,
        })

        // 验证组织代码格式
        if len(code) != 7 </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_CODE_FORMAT", "组织代码必须是7位数字", nil)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                EffectiveDate   string  `json:"effectiveDate"`   // 生效日期，格式：2006-01-02
                OperationReason *string `json:"operationReason"` // 操作原因
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov0" title="0">logger = logger.WithFields(pkglogger.Fields{"effectiveDateRaw": req.EffectiveDate})

        // 解析生效日期
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusBadRequest, "INVALID_DATE_FORMAT", "生效日期格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">tenantID := h.getTenantID(r)
        requestID := middleware.GetRequestID(r.Context())
        actorID := h.getActorID(r)

        currentOrg, err := h.repo.GetByCode(r.Context(), tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusNotFound, "ORGANIZATION_NOT_FOUND", "组织单元不存在", err)
                        return
                }</span>
                <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{"error": err}).Error("failed to get current organization")
                h.handleRepositoryError(w, r, "GET_CURRENT_ORG", err)
                return</span>
        }
        <span class="cov0" title="0">if currentOrg == nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, r, http.StatusNotFound, "ORGANIZATION_NOT_FOUND", "组织单元不存在", nil)
                return
        }</span>

        <span class="cov0" title="0">expectedETag := strings.TrimSpace(currentOrg.RecordID)
        if expectedETag == "" </span><span class="cov0" title="0">{
                expectedETag = currentOrg.UpdatedAt.Format(time.RFC3339Nano)
        }</span>

        <span class="cov0" title="0">if rawIfMatch := strings.TrimSpace(r.Header.Get("If-Match")); rawIfMatch != "" </span><span class="cov0" title="0">{
                ifMatch, parseErr := h.getIfMatchValue(r)
                if parseErr != nil </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "缺少或无效的 If-Match 标头", parseErr)
                        return
                }</span>
                <span class="cov0" title="0">if expectedETag == "" </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "无法验证资源版本，请刷新后重试", map[string]interface{}{
                                "provided": ifMatch,
                        })
                        return
                }</span>
                <span class="cov0" title="0">if ifMatch != expectedETag </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "资源已发生变更，请刷新后重试", map[string]interface{}{
                                "expected": expectedETag,
                                "provided": ifMatch,
                        })
                        return
                }</span>
        }

        // 操作原因处理（可选）
        <span class="cov0" title="0">operationReason := ""
        if req.OperationReason != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*req.OperationReason)
                if trimmed != "" </span><span class="cov0" title="0">{
                        operationReason = trimmed
                }</span>
        }

        // 🚀 使用时态时间轴管理器变更组织状态
        <span class="cov0" title="0">var timeline *[]repository.TimelineVersion
        if operationType == "SUSPEND" </span><span class="cov0" title="0">{
                timeline, err = h.timelineManager.SuspendOrganization(r.Context(), tenantID, code, effectiveDate, operationReason)
        }</span> else<span class="cov0" title="0"> {
                timeline, err = h.timelineManager.ActivateOrganization(r.Context(), tenantID, code, effectiveDate, operationReason)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // 记录操作失败的审计日志
                if logErr := h.auditLogger.LogError(
                        r.Context(), tenantID, audit.ResourceTypeOrganization, code,
                        operationType, actorID, requestID, operationType+"_ERROR", err.Error(), map[string]interface{}{
                                "code":            code,
                                "targetStatus":    newStatus,
                                "effectiveDate":   req.EffectiveDate,
                                "operationReason": operationReason,
                        },
                ); logErr != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": logErr}).Warn("audit log for status change failure failed")
                }</span>

                // 检查是否是冲突错误
                <span class="cov0" title="0">if strings.Contains(err.Error(), "TEMPORAL_POINT_CONFLICT") </span><span class="cov0" title="0">{
                        h.writeErrorResponse(w, r, http.StatusConflict, "TEMPORAL_CONFLICT", "生效日期与现有版本冲突", err)
                        return
                }</span>

                <span class="cov0" title="0">h.writeErrorResponse(w, r, http.StatusInternalServerError, operationType+"_FAILED", actionName+"失败", err)
                return</span>
        }

        // 记录成功的审计日志（使用具体版本的 recordId 作为资源ID）
        <span class="cov0" title="0">var resourceRecordID string
        if timeline != nil </span><span class="cov0" title="0">{
                for _, v := range *timeline </span><span class="cov0" title="0">{
                        if v.EffectiveDate.Equal(effectiveDate) &amp;&amp; v.Status == newStatus </span><span class="cov0" title="0">{
                                resourceRecordID = v.RecordID.String()
                                break</span>
                        }
                }
                <span class="cov0" title="0">if resourceRecordID == "" </span><span class="cov0" title="0">{
                        for _, v := range *timeline </span><span class="cov0" title="0">{
                                if v.IsCurrent </span><span class="cov0" title="0">{
                                        resourceRecordID = v.RecordID.String()
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">if resourceRecordID == "" </span><span class="cov0" title="0">{
                // 最后兜底：查询当前版本的 RecordID
                if cur, err := h.repo.GetByCode(r.Context(), tenantID, code); err == nil &amp;&amp; cur != nil </span><span class="cov0" title="0">{
                        resourceRecordID = cur.RecordID
                }</span>
        }

        <span class="cov0" title="0">event := &amp;audit.AuditEvent{
                ID:              uuid.New(),
                TenantID:        tenantID,
                EventType:       audit.EventTypeUpdate,
                ResourceType:    audit.ResourceTypeOrganization,
                ResourceID:      resourceRecordID,
                ActorID:         actorID,
                ActorType:       audit.ActorTypeUser,
                ActionName:      operationType,
                RequestID:       requestID,
                OperationReason: operationReason,
                Timestamp:       time.Now(),
                Success:         true,
                BeforeData: map[string]interface{}{
                        "code": code,
                },
                AfterData: map[string]interface{}{
                        "targetStatus":     newStatus,
                        "effectiveDate":    req.EffectiveDate,
                        "timelineVersions": len(*timeline),
                        "operationReason":  operationReason,
                },
        }

        if err := h.auditLogger.LogEvent(r.Context(), event); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Warn("audit event logging failed")
        }</span>

        // 构造响应 - 返回更新后的时间轴
        <span class="cov0" title="0">timelineResponse := make([]map[string]interface{}, len(*timeline))
        for i, version := range *timeline </span><span class="cov0" title="0">{
                timelineResponse[i] = map[string]interface{}{
                        "recordId":      version.RecordID,
                        "code":          version.Code,
                        "name":          version.Name,
                        "unitType":      version.UnitType,
                        "status":        version.Status,
                        "level":         version.Level,
                        "codePath":      version.CodePath,
                        "namePath":      version.NamePath,
                        "parentCode":    version.ParentCode,
                        "description":   version.Description,
                        "sortOrder":     version.SortOrder,
                        "effectiveDate": version.EffectiveDate.Format("2006-01-02"),
                        "endDate": func() *string </span><span class="cov0" title="0">{
                                if version.EndDate != nil </span><span class="cov0" title="0">{
                                        endDateStr := version.EndDate.Format("2006-01-02")
                                        return &amp;endDateStr
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        "isCurrent": version.IsCurrent,
                        "createdAt": version.CreatedAt,
                        "updatedAt": version.UpdatedAt,
                }
        }

        <span class="cov0" title="0">isImmediate := effectiveDate.Before(time.Now().UTC().Add(24 * time.Hour))
        message := fmt.Sprintf("%s成功（%s生效），时间轴已自动调整", actionName,
                func() string </span><span class="cov0" title="0">{
                        if isImmediate </span><span class="cov0" title="0">{
                                return "即时"
                        }</span>
                        <span class="cov0" title="0">return "计划"</span>
                }())

        <span class="cov0" title="0">response := map[string]interface{}{
                "message":         message,
                "operationType":   operationType,
                "targetStatus":    newStatus,
                "effectiveDate":   req.EffectiveDate,
                "operationReason": operationReason,
                "isImmediate":     isImmediate,
                "timeline":        timelineResponse,
        }

        if resourceRecordID != "" </span><span class="cov0" title="0">{
                w.Header().Set("ETag", fmt.Sprintf("\"%s\"", resourceRecordID))
        }</span>

        <span class="cov0" title="0">if err := utils.WriteSuccess(w, response, actionName+"成功", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write status change response failed")
        }</span>
        <span class="cov0" title="0">logger.WithFields(pkglogger.Fields{
                "newStatus":     newStatus,
                "effectiveDate": req.EffectiveDate,
        }).Info("organization status changed")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/service"
        "cube-castle/internal/organization/utils"
        validator "cube-castle/internal/organization/validator"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
)

type PositionService interface {
        CreatePosition(ctx context.Context, tenantID uuid.UUID, req *types.PositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        ReplacePosition(ctx context.Context, tenantID uuid.UUID, code string, ifMatch *string, req *types.PositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        CreatePositionVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionVersionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        FillPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.FillPositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        VacatePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.VacatePositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        TransferPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.TransferPositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        ApplyEvent(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionEventRequest, operator types.OperatedByInfo) (*types.PositionResponse, error)
        ListAssignments(ctx context.Context, tenantID uuid.UUID, code string, opts types.AssignmentListOptions) ([]types.PositionAssignmentResponse, int, error)
        CreateAssignmentRecord(ctx context.Context, tenantID uuid.UUID, code string, req *types.CreateAssignmentRequest, operator types.OperatedByInfo) (*types.PositionAssignmentResponse, error)
        UpdateAssignmentRecord(ctx context.Context, tenantID uuid.UUID, code string, assignmentID uuid.UUID, req *types.UpdateAssignmentRequest, operator types.OperatedByInfo) (*types.PositionAssignmentResponse, error)
        CloseAssignmentRecord(ctx context.Context, tenantID uuid.UUID, code string, assignmentID uuid.UUID, req *types.CloseAssignmentRequest, operator types.OperatedByInfo) (*types.PositionAssignmentResponse, error)
}

type PositionHandler struct {
        service     PositionService
        logger      pkglogger.Logger
        auditLogger *audit.AuditLogger
}

func NewPositionHandler(service PositionService, auditLogger *audit.AuditLogger, baseLogger pkglogger.Logger) *PositionHandler <span class="cov8" title="1">{
        return &amp;PositionHandler{
                service:     service,
                auditLogger: auditLogger,
                logger: scopedLogger(baseLogger, "position", pkglogger.Fields{
                        "module": "position",
                }),
        }
}</span>

func (h *PositionHandler) requestLogger(r *http.Request, action string, extra pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        return requestScopedLogger(h.logger, r, action, extra)
}</span>

func (h *PositionHandler) SetupRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Route("/api/v1/positions", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", h.CreatePosition)
                r.Put("/{code}", h.ReplacePosition)
                r.Post("/{code}/versions", h.CreatePositionVersion)
                r.Post("/{code}/events", h.ApplyPositionEvent)
                r.Post("/{code}/fill", h.FillPosition)
                r.Post("/{code}/vacate", h.VacatePosition)
                r.Post("/{code}/transfer", h.TransferPosition)
                r.Route("/{code}/assignments", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", h.ListAssignments)
                        r.Post("/", h.CreateAssignment)
                        r.Patch("/{assignmentId}", h.UpdateAssignment)
                        r.Post("/{assignmentId}/close", h.CloseAssignment)
                }</span>)
        })
}

func (h *PositionHandler) CreatePosition(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "CreatePosition", nil)
        var req types.PositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String()})
        operator := getOperatorFromRequest(r)

        response, err := h.service.CreatePosition(r.Context(), tenantID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, response, "Position created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write position create response failed")
        }</span>
}

func (h *PositionHandler) ReplacePosition(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "ReplacePosition", nil)
        var req types.PositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov8" title="1">ifMatch := getIfMatchHeader(r)
        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{
                "tenantId": tenantID.String(),
                "code":     code,
                "ifMatch": func() string </span><span class="cov8" title="1">{
                        if ifMatch != nil </span><span class="cov8" title="1">{
                                return *ifMatch
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        })
        <span class="cov8" title="1">operator := getOperatorFromRequest(r)

        response, err := h.service.ReplacePosition(r.Context(), tenantID, code, ifMatch, &amp;req, operator)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, response, "Position updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write position update response failed")
        }</span>
}

func (h *PositionHandler) CreatePositionVersion(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "CreatePositionVersion", nil)
        var req types.PositionVersionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov8" title="1">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String()})
        operator := getOperatorFromRequest(r)

        response, err := h.service.CreatePositionVersion(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, response, "Position version created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write position version response failed")
        }</span>
}

func (h *PositionHandler) FillPosition(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "FillPosition", nil)
        var req types.FillPositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov8" title="1">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>
        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code})
        operator := getOperatorFromRequest(r)

        response, err := h.service.FillPosition(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, response, "Position filled successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write fill position response failed")
        }</span>
}

func (h *PositionHandler) VacatePosition(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "VacatePosition", nil)
        var req types.VacatePositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov8" title="1">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov8" title="1">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>
        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code})
        operator := getOperatorFromRequest(r)

        response, err := h.service.VacatePosition(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, response, "Position vacated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write vacate position response failed")
        }</span>
}

func (h *PositionHandler) TransferPosition(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "TransferPosition", nil)
        var req types.TransferPositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>
        <span class="cov8" title="1">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>
        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code})
        operator := getOperatorFromRequest(r)

        response, err := h.service.TransferPosition(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, response, "Position transferred successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write transfer position response failed")
        }</span>
}

func (h *PositionHandler) ListAssignments(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "ListAssignments", nil)
        code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov8" title="1">query := r.URL.Query()
        assignmentTypes := make([]string, 0)
        if values, ok := query["assignmentTypes"]; ok </span><span class="cov8" title="1">{
                assignmentTypes = append(assignmentTypes, values...)
        }</span>
        <span class="cov8" title="1">if values, ok := query["assignmentTypes[]"]; ok </span><span class="cov0" title="0">{
                assignmentTypes = append(assignmentTypes, values...)
        }</span>

        <span class="cov8" title="1">assignmentStatus := query.Get("assignmentStatus")
        asOfDateStr := query.Get("asOfDate")
        includeHistorical := true
        if raw := query.Get("includeHistorical"); raw != "" </span><span class="cov8" title="1">{
                val, err := strconv.ParseBool(raw)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, r, http.StatusBadRequest, "INVALID_PARAMETER", "includeHistorical 参数无效", err)
                        return
                }</span>
                <span class="cov8" title="1">includeHistorical = val</span>
        }
        <span class="cov8" title="1">includeActingOnly := false
        if raw := query.Get("includeActingOnly"); raw != "" </span><span class="cov0" title="0">{
                val, err := strconv.ParseBool(raw)
                if err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, r, http.StatusBadRequest, "INVALID_PARAMETER", "includeActingOnly 参数无效", err)
                        return
                }</span>
                <span class="cov0" title="0">includeActingOnly = val</span>
        }

        <span class="cov8" title="1">page := 1
        if raw := query.Get("page"); raw != "" </span><span class="cov8" title="1">{
                if parsed, err := strconv.Atoi(raw); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov8" title="1">{
                        page = parsed
                }</span>
        }

        <span class="cov8" title="1">pageSize := 25
        if raw := query.Get("pageSize"); raw != "" </span><span class="cov8" title="1">{
                if parsed, err := strconv.Atoi(raw); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov8" title="1">{
                        pageSize = parsed
                }</span>
        }

        <span class="cov8" title="1">var asOfDate *time.Time
        if strings.TrimSpace(asOfDateStr) != "" </span><span class="cov8" title="1">{
                parsed, err := time.Parse("2006-01-02", strings.TrimSpace(asOfDateStr))
                if err != nil </span><span class="cov0" title="0">{
                        h.writeError(w, r, http.StatusBadRequest, "INVALID_PARAMETER", "asOfDate 参数格式应为 YYYY-MM-DD", err)
                        return
                }</span>
                <span class="cov8" title="1">asOfDate = &amp;parsed</span>
        }

        <span class="cov8" title="1">filter := types.AssignmentListFilter{
                AssignmentTypes:   assignmentTypes,
                IncludeHistorical: includeHistorical,
                IncludeActingOnly: includeActingOnly,
        }
        if strings.TrimSpace(assignmentStatus) != "" </span><span class="cov8" title="1">{
                status := strings.ToUpper(strings.TrimSpace(assignmentStatus))
                filter.AssignmentStatus = &amp;status
        }</span>
        <span class="cov8" title="1">if asOfDate != nil </span><span class="cov8" title="1">{
                filter.AsOfDate = asOfDate
        }</span>

        <span class="cov8" title="1">opts := types.AssignmentListOptions{
                Filter:   filter,
                Page:     page,
                PageSize: pageSize,
        }

        tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{
                "tenantId":          tenantID.String(),
                "code":              code,
                "page":              page,
                "pageSize":          pageSize,
                "assignmentStatus":  assignmentStatus,
                "includeHistorical": includeHistorical,
                "includeActingOnly": includeActingOnly,
        })
        if asOfDate != nil </span><span class="cov8" title="1">{
                logger = logger.WithFields(pkglogger.Fields{"asOfDate": asOfDate.Format("2006-01-02")})
        }</span>
        <span class="cov8" title="1">assignments, total, err := h.service.ListAssignments(r.Context(), tenantID, code, opts)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">meta := types.PaginationMeta{
                Total:       total,
                Page:        page,
                PageSize:    pageSize,
                HasPrevious: page &gt; 1,
                HasNext:     page*pageSize &lt; total,
        }

        response := types.PositionAssignmentListResponse{
                Data:       assignments,
                Pagination: meta,
                TotalCount: total,
        }

        requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, response, "Assignments retrieved successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write assignment list response failed")
        }</span>
}

func (h *PositionHandler) CreateAssignment(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "CreateAssignment", nil)
        var req types.CreateAssignmentRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov8" title="1">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code})
        operator := getOperatorFromRequest(r)

        assignment, err := h.service.CreateAssignmentRecord(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteCreated(w, assignment, "Assignment created successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write assignment create response failed")
        }</span>
}

func (h *PositionHandler) UpdateAssignment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := h.requestLogger(r, "UpdateAssignment", nil)
        var req types.UpdateAssignmentRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov0" title="0">assignmentIDStr := strings.TrimSpace(chi.URLParam(r, "assignmentId"))
        assignmentID, err := uuid.Parse(assignmentIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_ASSIGNMENT_ID", "任职ID格式必须为UUID", err)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code, "assignmentId": assignmentID.String()})
        operator := getOperatorFromRequest(r)

        assignment, err := h.service.UpdateAssignmentRecord(r.Context(), tenantID, code, assignmentID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, assignment, "Assignment updated successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write assignment update response failed")
        }</span>
}

func (h *PositionHandler) CloseAssignment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := h.requestLogger(r, "CloseAssignment", nil)
        var req types.CloseAssignmentRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov0" title="0">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov0" title="0">assignmentIDStr := strings.TrimSpace(chi.URLParam(r, "assignmentId"))
        assignmentID, err := uuid.Parse(assignmentIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_ASSIGNMENT_ID", "任职ID格式必须为UUID", err)
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code, "assignmentId": assignmentID.String()})
        operator := getOperatorFromRequest(r)

        assignment, err := h.service.CloseAssignmentRecord(r.Context(), tenantID, code, assignmentID, &amp;req, operator)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, assignment, "Assignment closed successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write assignment close response failed")
        }</span>
}

func (h *PositionHandler) ApplyPositionEvent(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "ApplyPositionEvent", nil)
        var req types.PositionEventRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "INVALID_REQUEST", "请求格式无效", err)
                return
        }</span>

        <span class="cov8" title="1">code := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if code == "" </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "MISSING_CODE", "缺少职位代码", nil)
                return
        }</span>

        <span class="cov8" title="1">tenantID := getTenantIDFromRequest(r)
        logger = logger.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "code": code, "eventType": req.EventType})
        operator := getOperatorFromRequest(r)

        response, err := h.service.ApplyEvent(r.Context(), tenantID, code, &amp;req, operator)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteSuccess(w, response, "Position event applied successfully", requestID); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write position event response failed")
        }</span>
}

func (h *PositionHandler) handleServiceError(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "HandlePositionServiceError", pkglogger.Fields{"error": err})
        var validationErr *validator.ValidationFailedError
        if errors.As(err, &amp;validationErr) </span><span class="cov0" title="0">{
                h.writeValidationFailure(w, r, validationErr.Result())
                return
        }</span>
        <span class="cov8" title="1">switch </span>{
        case errors.Is(err, service.ErrOrganizationNotFound):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusNotFound, "ORGANIZATION_NOT_FOUND", "组织不存在", err)</span>
        case errors.Is(err, service.ErrPositionNotFound):<span class="cov8" title="1">
                h.writeError(w, r, http.StatusNotFound, "POSITION_NOT_FOUND", "职位不存在", err)</span>
        case errors.Is(err, service.ErrJobCatalogNotFound):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusBadRequest, "JOB_CATALOG_NOT_FOUND", "职位分类引用不存在", err)</span>
        case errors.Is(err, service.ErrJobCatalogMismatch):<span class="cov8" title="1">
                h.writeError(w, r, http.StatusConflict, "JOB_CATALOG_MISMATCH", "职位分类层级不一致", err)</span>
        case errors.Is(err, service.ErrVersionConflict):<span class="cov8" title="1">
                h.writeError(w, r, http.StatusPreconditionFailed, "PRECONDITION_FAILED", "资源已发生变更，请刷新后重试", err)</span>
        case errors.Is(err, service.ErrInvalidHeadcount):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusBadRequest, "INVALID_HEADCOUNT", "编制或占用人数无效", err)</span>
        case errors.Is(err, service.ErrInvalidTransition):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusBadRequest, "INVALID_TRANSITION", "不支持的职位状态变更", err)</span>
        case errors.Is(err, service.ErrAssignmentNotFound):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusNotFound, "ASSIGNMENT_NOT_FOUND", "任职记录不存在", err)</span>
        case errors.Is(err, service.ErrInvalidAssignmentState):<span class="cov0" title="0">
                h.writeError(w, r, http.StatusConflict, "INVALID_ASSIGNMENT_STATE", "当前任职状态不允许此操作", err)</span>
        case errors.Is(err, service.ErrPositionVersionExists):<span class="cov8" title="1">
                h.writeError(w, r, http.StatusConflict, "POSITION_VERSION_EXISTS", "该生效日期的职位版本已存在", err)</span>
        default:<span class="cov0" title="0">
                logger.Error("unhandled position service error")
                h.writeError(w, r, http.StatusInternalServerError, "INTERNAL_ERROR", "服务器内部错误", err)</span>
        }
}

func (h *PositionHandler) writeError(w http.ResponseWriter, r *http.Request, status int, code, message string, details interface{}) <span class="cov8" title="1">{
        logger := h.requestLogger(r, "writeError", pkglogger.Fields{"status": status, "code": code})
        requestID := middleware.GetRequestID(r.Context())
        if err := utils.WriteError(w, status, code, message, requestID, details); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write position error response failed")
        }</span>
}

func (h *PositionHandler) writeValidationFailure(w http.ResponseWriter, r *http.Request, result *validator.ValidationResult) <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                h.writeError(w, r, http.StatusBadRequest, "BUSINESS_RULE_VIOLATION", "业务规则校验失败", nil)
                return
        }</span>

        <span class="cov0" title="0">status := http.StatusBadRequest
        ruleCode := "BUSINESS_RULE_VIOLATION"
        message := "业务规则校验失败"
        severity := string(validator.SeverityHigh)
        ruleID := ruleCode
        if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                first := result.Errors[0]
                if trimmed := strings.TrimSpace(first.Code); trimmed != "" </span><span class="cov0" title="0">{
                        ruleCode = trimmed
                        ruleID = ruleCode
                }</span>
                <span class="cov0" title="0">if trimmed := strings.TrimSpace(first.Message); trimmed != "" </span><span class="cov0" title="0">{
                        message = trimmed
                }</span>
                <span class="cov0" title="0">if trimmed := strings.TrimSpace(first.Severity); trimmed != "" </span><span class="cov0" title="0">{
                        severity = strings.ToUpper(trimmed)
                }</span>
                <span class="cov0" title="0">mapped := validator.SeverityToHTTPStatus(severity)
                if mapped &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                        status = mapped
                }</span>
                <span class="cov0" title="0">if ctx := first.Context; ctx != nil </span><span class="cov0" title="0">{
                        if val, ok := ctx["ruleId"]; ok </span><span class="cov0" title="0">{
                                if formatted := strings.TrimSpace(fmt.Sprintf("%v", val)); formatted != "" </span><span class="cov0" title="0">{
                                        ruleID = formatted
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">ruleID = strings.TrimSpace(ruleID)
        if ruleID == "" </span><span class="cov0" title="0">{
                ruleID = ruleCode
        }</span>

        <span class="cov0" title="0">details := map[string]interface{}{
                "ruleId":           ruleID,
                "severity":         severity,
                "validationErrors": result.Errors,
                "warnings":         result.Warnings,
                "chainContext":     result.Context,
                "errorCount":       len(result.Errors),
                "warningCount":     len(result.Warnings),
        }

        requestID := middleware.GetRequestID(r.Context())
        logger := h.requestLogger(r, "writeValidationFailure", pkglogger.Fields{
                "status": status,
                "code":   ruleCode,
        })
        if err := utils.WriteError(w, status, ruleCode, message, requestID, details); err != nil </span><span class="cov0" title="0">{
                logger.WithFields(pkglogger.Fields{"error": err}).Error("write validation failure response failed")
        }</span>

        <span class="cov0" title="0">h.logValidationAudit(r, ruleID, severity, status, ruleCode, message, result, details)</span>
}

func (h *PositionHandler) logValidationAudit(r *http.Request, ruleID, severity string, status int, code, message string, result *validator.ValidationResult, details map[string]interface{}) <span class="cov0" title="0">{
        if h.auditLogger == nil || result == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tenantID := getTenantIDFromRequest(r)
        resourceID := strings.ToUpper(strings.TrimSpace(chi.URLParam(r, "code")))
        if resourceID == "" </span><span class="cov0" title="0">{
                if ctx := result.Context; ctx != nil </span><span class="cov0" title="0">{
                        if val, ok := ctx["positionCode"]; ok </span><span class="cov0" title="0">{
                                resourceID = strings.ToUpper(strings.TrimSpace(fmt.Sprintf("%v", val)))
                        }</span>
                }
        }
        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                resourceID = "UNKNOWN"
        }</span>

        <span class="cov0" title="0">payload := map[string]interface{}{
                "ruleId":           ruleID,
                "severity":         severity,
                "httpStatus":       status,
                "errorCount":       len(result.Errors),
                "validationErrors": result.Errors,
        }
        if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                payload["warnings"] = result.Warnings
                payload["warningCount"] = len(result.Warnings)
        }</span>
        <span class="cov0" title="0">if len(result.Context) &gt; 0 </span><span class="cov0" title="0">{
                payload["chainContext"] = result.Context
        }</span>
        <span class="cov0" title="0">for k, v := range details </span><span class="cov0" title="0">{
                switch k </span>{
                case "field", "severity", "ruleId":<span class="cov0" title="0">
                        payload[k] = v</span>
                }
        }

        <span class="cov0" title="0">actionName := strings.TrimSpace(r.Method)
        if actionName == "" </span><span class="cov0" title="0">{
                actionName = "REQUEST"
        }</span>

        <span class="cov0" title="0">if err := h.auditLogger.LogError(
                r.Context(),
                tenantID,
                audit.ResourceTypePosition,
                resourceID,
                actionName,
                getActorID(r),
                middleware.GetRequestID(r.Context()),
                code,
                message,
                payload,
        ); err != nil </span><span class="cov0" title="0">{
                h.logger.WithFields(pkglogger.Fields{"error": err}).Warn("audit log for validation failure failed")
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "net/http"

        pkglogger "cube-castle/pkg/logger"
)

func scopedLogger(base pkglogger.Logger, name string, extra pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        if base == nil </span><span class="cov8" title="1">{
                base = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">fields := pkglogger.Fields{
                "component": "middleware",
        }
        if name != "" </span><span class="cov8" title="1">{
                fields["middleware"] = name
        }</span>
        <span class="cov8" title="1">for k, v := range extra </span><span class="cov8" title="1">{
                fields[k] = v
        }</span>
        <span class="cov8" title="1">return base.WithFields(fields)</span>
}

func withRequestLogger(base pkglogger.Logger, r *http.Request) pkglogger.Logger <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return base
        }</span>
        <span class="cov0" title="0">return base.WithFields(pkglogger.Fields{
                "method":    r.Method,
                "path":      r.URL.Path,
                "requestId": GetRequestID(r.Context()),
        })</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        pkglogger "cube-castle/pkg/logger"
        utilspkg "cube-castle/internal/organization/utils"
        "github.com/go-chi/chi/v5"
)

// PerformanceMiddleware 性能监控中间件
type PerformanceMiddleware struct {
        logger pkglogger.Logger
}

// NewPerformanceMiddleware 创建性能监控中间件
func NewPerformanceMiddleware(logger pkglogger.Logger) *PerformanceMiddleware <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">return &amp;PerformanceMiddleware{
                logger: logger.WithFields(pkglogger.Fields{
                        "component":  "middleware",
                        "middleware": "performance",
                }),
        }</span>
}

// ResponseWriterWrapper 响应包装器，用于记录响应状态和大小
type ResponseWriterWrapper struct {
        http.ResponseWriter
        statusCode int
        size       int
}

func (rw *ResponseWriterWrapper) WriteHeader(statusCode int) <span class="cov8" title="1">{
        rw.statusCode = statusCode
        rw.ResponseWriter.WriteHeader(statusCode)
}</span>

func (rw *ResponseWriterWrapper) Write(data []byte) (int, error) <span class="cov8" title="1">{
        size, err := rw.ResponseWriter.Write(data)
        rw.size += size
        return size, err
}</span>

// Middleware 性能监控中间件
func (p *PerformanceMiddleware) Middleware() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        startTime := time.Now()

                        // 包装响应写入器
                        wrapper := &amp;ResponseWriterWrapper{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK,
                        }

                        // 添加性能监控上下文
                        ctx := context.WithValue(r.Context(), "start_time", startTime)
                        r = r.WithContext(ctx)

                        // 设置性能相关头部
                        wrapper.Header().Set("X-Response-Time", "")
                        wrapper.Header().Set("X-Service", "organization-command-service")

                        // 执行请求处理
                        next.ServeHTTP(wrapper, r)

                        // 计算执行时间
                        duration := time.Since(startTime)

                        // 设置响应时间头部
                        wrapper.Header().Set("X-Response-Time", duration.String())

                        // 记录性能日志
                        p.logPerformance(r, wrapper.statusCode, wrapper.size, duration)

                        // 记录统一 HTTP 指标（使用路由模板，避免基数爆炸）
                        route := ""
                        if rc := chi.RouteContext(r.Context()); rc != nil </span><span class="cov0" title="0">{
                                route = rc.RoutePattern()
                        }</span>
                        <span class="cov8" title="1">if route == "" </span><span class="cov8" title="1">{
                                // 不使用原始 Path，避免时序基数膨胀
                                route = "unknown"
                        }</span>
                        <span class="cov8" title="1">utilspkg.RecordHTTPRequest(r.Method, route, wrapper.statusCode)</span>
                })
        }
}

// logPerformance 记录性能日志
func (p *PerformanceMiddleware) logPerformance(r *http.Request, statusCode, responseSize int, duration time.Duration) <span class="cov8" title="1">{
        // 获取请求ID
        requestID := GetRequestID(r.Context())

        // 分析请求类型
        requestType := "READ"
        if r.Method == "POST" || r.Method == "PUT" || r.Method == "DELETE" </span><span class="cov0" title="0">{
                requestType = "WRITE"
        }</span>

        // 性能等级分析
        <span class="cov8" title="1">level := "NORMAL"
        icon := "✅"

        if duration &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                level = "SLOW"
                icon = "⚠️"
        }</span>
        <span class="cov8" title="1">if duration &gt; 1*time.Second </span><span class="cov0" title="0">{
                level = "VERY_SLOW"
                icon = "🐌"
        }</span>
        <span class="cov8" title="1">if duration &gt; 3*time.Second </span><span class="cov0" title="0">{
                level = "CRITICAL"
                icon = "🚨"
        }</span>

        <span class="cov8" title="1">fields := pkglogger.Fields{
                "requestId":      requestID,
                "method":         r.Method,
                "path":           r.URL.Path,
                "statusCode":     statusCode,
                "responseSize":   responseSize,
                "requestType":    requestType,
                "duration":       duration.String(),
                "durationMillis": duration.Milliseconds(),
                "performance":    level,
                "icon":           icon,
        }
        p.logger.WithFields(fields).Info("http request completed")

        // 记录详细的慢请求信息
        if duration &gt; 1*time.Second </span><span class="cov0" title="0">{
                p.logSlowRequestDetails(r, statusCode, responseSize, duration, requestID)
        }</span>
}

// logSlowRequestDetails 记录慢请求详细信息
func (p *PerformanceMiddleware) logSlowRequestDetails(r *http.Request, statusCode, responseSize int, duration time.Duration, requestID string) <span class="cov0" title="0">{
        suggestions := p.analyzePerformanceIssues(r, duration)
        fields := pkglogger.Fields{
                "requestId":    requestID,
                "method":       r.Method,
                "url":          r.URL.String(),
                "statusCode":   statusCode,
                "responseSize": responseSize,
                "duration":     duration.String(),
                "userAgent":    r.UserAgent(),
                "clientIP":     getClientIP(r),
        }
        if len(suggestions) &gt; 0 </span><span class="cov0" title="0">{
                fields["suggestions"] = suggestions
        }</span>
        <span class="cov0" title="0">p.logger.WithFields(fields).Warn("slow request detected")</span>
}

// analyzePerformanceIssues 分析性能问题
func (p *PerformanceMiddleware) analyzePerformanceIssues(r *http.Request, duration time.Duration) []string <span class="cov0" title="0">{
        suggestions := []string{}

        // 根据请求路径分析
        if r.URL.Path == "/api/v1/organization-units" &amp;&amp; r.Method == "POST" </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "创建组织可能涉及复杂的层级计算")
                suggestions = append(suggestions, "检查数据库索引是否优化")
        }</span>

        <span class="cov0" title="0">if r.URL.Path == "/graphql" </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "GraphQL查询可能包含复杂的关联查询")
                suggestions = append(suggestions, "考虑使用数据加载器(DataLoader)优化N+1问题")
        }</span>

        // 根据执行时间分析
        <span class="cov0" title="0">if duration &gt; 3*time.Second </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "考虑添加缓存机制")
                suggestions = append(suggestions, "检查数据库连接池配置")
                suggestions = append(suggestions, "考虑异步处理非关键操作")
        }</span>

        <span class="cov0" title="0">return suggestions</span>
}

// GetPerformanceMetrics 获取性能指标
func GetPerformanceMetrics(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        startTime, ok := ctx.Value("start_time").(time.Time)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "executionTime": time.Since(startTime).String(),
                "startTime":     startTime.Format(time.RFC3339),
                "endTime":       time.Now().Format(time.RFC3339),
        }</span>
}

// WithPerformanceData 添加性能数据到响应
func WithPerformanceData(ctx context.Context, data map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        metrics := GetPerformanceMetrics(ctx)
        if metrics != nil &amp;&amp; data != nil </span><span class="cov0" title="0">{
                if meta, exists := data["meta"]; exists </span><span class="cov0" title="0">{
                        if metaMap, ok := meta.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for k, v := range metrics </span><span class="cov0" title="0">{
                                        metaMap[k] = v
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        data["meta"] = map[string]interface{}{
                                "performance": metrics,
                        }
                }</span>
        }
        <span class="cov0" title="0">return data</span>
}

// getClientIP 获取客户端IP地址
func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // 检查X-Forwarded-For头部
        if forwarded := r.Header.Get("X-Forwarded-For"); forwarded != "" </span><span class="cov8" title="1">{
                return forwarded
        }</span>

        // 检查X-Real-IP头部
        <span class="cov0" title="0">if realIP := r.Header.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                return realIP
        }</span>

        // 使用RemoteAddr
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

// LogAPICall 记录API调用日志
func (p *PerformanceMiddleware) LogAPICall(method, path string, statusCode int, duration time.Duration, requestID string) <span class="cov0" title="0">{
        p.logger.WithFields(pkglogger.Fields{
                "requestId":  requestID,
                "method":     method,
                "path":       path,
                "statusCode": statusCode,
                "duration":   duration.String(),
                "durationMs": duration.Milliseconds(),
        }).Info("api call completed")
}</span>

// PerformanceAlert 性能告警
type PerformanceAlert struct {
        Threshold time.Duration
        Handler   func(r *http.Request, duration time.Duration)
}

// NewPerformanceAlert 创建性能告警
func NewPerformanceAlert(threshold time.Duration, handler func(r *http.Request, duration time.Duration)) *PerformanceAlert <span class="cov0" title="0">{
        return &amp;PerformanceAlert{
                Threshold: threshold,
                Handler:   handler,
        }
}</span>

// Check 检查性能阈值
func (pa *PerformanceAlert) Check(r *http.Request, duration time.Duration) <span class="cov0" title="0">{
        if duration &gt; pa.Threshold </span><span class="cov0" title="0">{
                pa.Handler(r, duration)
        }</span>
}

// DefaultPerformanceAlertHandler 默认性能告警处理器
func DefaultPerformanceAlertHandler(logger pkglogger.Logger) func(r *http.Request, duration time.Duration) <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov0" title="0">alertLogger := logger.WithFields(pkglogger.Fields{
                "component":  "middleware",
                "middleware": "performanceAlert",
        })
        return func(r *http.Request, duration time.Duration) </span><span class="cov0" title="0">{
                requestID := GetRequestID(r.Context())
                alertLogger.WithFields(pkglogger.Fields{
                        "requestId": requestID,
                        "method":    r.Method,
                        "path":      r.URL.Path,
                        "duration":  duration.String(),
                }).Warn("performance threshold exceeded")

                // 这里可以添加更多告警逻辑，如发送邮件、短信等
                // 例如: sendAlert(r, duration)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strconv"
        "sync"
        "time"

        pkglogger "cube-castle/pkg/logger"
)

// RateLimitConfig 限流配置
type RateLimitConfig struct {
        RequestsPerMinute int           `json:"requestsPerMinute"`
        BurstSize         int           `json:"burstSize"`
        CleanupInterval   time.Duration `json:"cleanupInterval"`
        WhitelistIPs      []string      `json:"whitelistIPs"`
        BlockDuration     time.Duration `json:"blockDuration"`
}

// DefaultRateLimitConfig 默认限流配置
var DefaultRateLimitConfig = &amp;RateLimitConfig{
        RequestsPerMinute: 100, // 每分钟100个请求
        BurstSize:         10,  // 允许10个突发请求
        CleanupInterval:   5 * time.Minute,
        WhitelistIPs:      []string{"127.0.0.1", "::1"},
        BlockDuration:     1 * time.Minute,
}

// ClientInfo 客户端信息
type ClientInfo struct {
        IP           string    `json:"ip"`
        RequestCount int       `json:"requestCount"`
        LastRequest  time.Time `json:"lastRequest"`
        BlockedUntil time.Time `json:"blockedUntil"`
        BurstCount   int       `json:"burstCount"`
        BurstStart   time.Time `json:"burstStart"`
}

// RateLimitMiddleware 限流中间件
type RateLimitMiddleware struct {
        config  *RateLimitConfig
        clients map[string]*ClientInfo
        mutex   sync.RWMutex
        logger  pkglogger.Logger
        stats   *RateLimitStats
}

// RateLimitStats 限流统计
type RateLimitStats struct {
        TotalRequests   int64     `json:"totalRequests"`
        BlockedRequests int64     `json:"blockedRequests"`
        ActiveClients   int       `json:"activeClients"`
        LastReset       time.Time `json:"lastReset"`
        mutex           sync.RWMutex
}

// NewRateLimitMiddleware 创建限流中间件
func NewRateLimitMiddleware(config *RateLimitConfig, baseLogger pkglogger.Logger) *RateLimitMiddleware <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultRateLimitConfig
        }</span>

        <span class="cov8" title="1">rlm := &amp;RateLimitMiddleware{
                config:  config,
                clients: make(map[string]*ClientInfo),
                logger:  scopedLogger(baseLogger, "rateLimit", pkglogger.Fields{"component": "middleware"}),
                stats: &amp;RateLimitStats{
                        LastReset: time.Now(),
                },
        }

        // 启动清理协程
        go rlm.cleanupRoutine()

        return rlm</span>
}

// Middleware 限流中间件
func (rlm *RateLimitMiddleware) Middleware() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        clientIP := getClientIP(r)

                        // 检查白名单
                        if rlm.isWhitelisted(clientIP) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // 检查限流
                        <span class="cov8" title="1">if !rlm.allowRequest(clientIP) </span><span class="cov8" title="1">{
                                rlm.handleRateLimitExceeded(w, r, clientIP)
                                return
                        }</span>

                        // 更新统计信息
                        <span class="cov8" title="1">rlm.updateStats(true)

                        // 添加限流头部信息
                        rlm.addRateLimitHeaders(w, clientIP)

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// allowRequest 检查是否允许请求
func (rlm *RateLimitMiddleware) allowRequest(clientIP string) bool <span class="cov8" title="1">{
        rlm.mutex.Lock()
        defer rlm.mutex.Unlock()

        now := time.Now()
        client, exists := rlm.clients[clientIP]

        if !exists </span><span class="cov8" title="1">{
                // 新客户端
                rlm.clients[clientIP] = &amp;ClientInfo{
                        IP:           clientIP,
                        RequestCount: 1,
                        LastRequest:  now,
                        BurstCount:   1,
                        BurstStart:   now,
                }
                return true
        }</span>

        // 检查是否被阻塞
        <span class="cov8" title="1">if now.Before(client.BlockedUntil) </span><span class="cov0" title="0">{
                return false
        }</span>

        // 重置分钟计数器
        <span class="cov8" title="1">if now.Sub(client.LastRequest) &gt; time.Minute </span><span class="cov0" title="0">{
                client.RequestCount = 0
                client.BurstCount = 0
                client.BurstStart = now
        }</span>

        // 重置突发计数器
        <span class="cov8" title="1">if now.Sub(client.BurstStart) &gt; 10*time.Second </span><span class="cov0" title="0">{
                client.BurstCount = 0
                client.BurstStart = now
        }</span>

        // 检查每分钟限制
        <span class="cov8" title="1">if client.RequestCount &gt;= rlm.config.RequestsPerMinute </span><span class="cov8" title="1">{
                fields := pkglogger.Fields{"ip": clientIP, "limit": rlm.config.RequestsPerMinute}
                client.BlockedUntil = now.Add(rlm.config.BlockDuration)
                rlm.logger.WithFields(fields).Warnf("IP blocked for exceeding per-minute limit (duration=%v)", rlm.config.BlockDuration)
                return false
        }</span>

        // 检查突发限制
        <span class="cov0" title="0">if client.BurstCount &gt;= rlm.config.BurstSize </span><span class="cov0" title="0">{
                fields := pkglogger.Fields{"ip": clientIP, "burst": rlm.config.BurstSize}
                client.BlockedUntil = now.Add(rlm.config.BlockDuration / 2) // 突发阻塞时间较短
                rlm.logger.WithFields(fields).Warnf("IP temporarily blocked for burst limit (duration=%v)", rlm.config.BlockDuration/2)
                return false
        }</span>

        // 更新客户端信息
        <span class="cov0" title="0">client.RequestCount++
        client.BurstCount++
        client.LastRequest = now

        return true</span>
}

// isWhitelisted 检查IP是否在白名单中
func (rlm *RateLimitMiddleware) isWhitelisted(ip string) bool <span class="cov8" title="1">{
        for _, whiteIP := range rlm.config.WhitelistIPs </span><span class="cov0" title="0">{
                if ip == whiteIP </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// handleRateLimitExceeded 处理限流超限
func (rlm *RateLimitMiddleware) handleRateLimitExceeded(w http.ResponseWriter, r *http.Request, clientIP string) <span class="cov8" title="1">{
        rlm.updateStats(false)

        requestID := GetRequestID(r.Context())

        // 设置限流头部
        w.Header().Set("X-RateLimit-Limit", strconv.Itoa(rlm.config.RequestsPerMinute))
        w.Header().Set("X-RateLimit-Remaining", "0")
        w.Header().Set("X-RateLimit-Reset", strconv.FormatInt(time.Now().Add(time.Minute).Unix(), 10))
        w.Header().Set("Retry-After", strconv.Itoa(int(rlm.config.BlockDuration.Seconds())))

        // 返回限流错误
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusTooManyRequests)

        response := fmt.Sprintf(`{
                "success": false,
                "error": {
                        "code": "RATE_LIMIT_EXCEEDED",
                        "message": "请求频率超过限制，请稍后重试"
                },
                "timestamp": "%s",
                "requestId": "%s",
                "meta": {
                        "rateLimit": {
                                "limit": %d,
                                "remaining": 0,
                                "resetTime": "%s",
                                "retryAfter": "%s"
                        }
                }
        }`, time.Now().UTC().Format(time.RFC3339),
                requestID,
                rlm.config.RequestsPerMinute,
                time.Now().Add(time.Minute).Format(time.RFC3339),
                rlm.config.BlockDuration.String())

        if _, err := w.Write([]byte(response)); err != nil </span><span class="cov0" title="0">{
                rlm.logger.WithFields(pkglogger.Fields{"error": err}).Error("write rate limit response failed")
        }</span>

        <span class="cov8" title="1">rLogger := rlm.logger.WithFields(pkglogger.Fields{
                "ip":        clientIP,
                "path":      r.URL.Path,
                "requestId": requestID,
        })
        rLogger.Warn("rate limit exceeded, request blocked")</span>
}

// addRateLimitHeaders 添加限流相关头部
func (rlm *RateLimitMiddleware) addRateLimitHeaders(w http.ResponseWriter, clientIP string) <span class="cov8" title="1">{
        rlm.mutex.RLock()
        client, exists := rlm.clients[clientIP]
        rlm.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">remaining := rlm.config.RequestsPerMinute - client.RequestCount
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        <span class="cov8" title="1">w.Header().Set("X-RateLimit-Limit", strconv.Itoa(rlm.config.RequestsPerMinute))
        w.Header().Set("X-RateLimit-Remaining", strconv.Itoa(remaining))
        w.Header().Set("X-RateLimit-Reset", strconv.FormatInt(client.LastRequest.Add(time.Minute).Unix(), 10))</span>
}

// updateStats 更新统计信息
func (rlm *RateLimitMiddleware) updateStats(allowed bool) <span class="cov8" title="1">{
        rlm.stats.mutex.Lock()
        defer rlm.stats.mutex.Unlock()

        rlm.stats.TotalRequests++
        if !allowed </span><span class="cov8" title="1">{
                rlm.stats.BlockedRequests++
        }</span>

        <span class="cov8" title="1">rlm.mutex.RLock()
        rlm.stats.ActiveClients = len(rlm.clients)
        rlm.mutex.RUnlock()</span>
}

// cleanupRoutine 清理过期客户端
func (rlm *RateLimitMiddleware) cleanupRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(rlm.config.CleanupInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                rlm.cleanupExpiredClients()
        }</span>
}

// cleanupExpiredClients 清理过期客户端
func (rlm *RateLimitMiddleware) cleanupExpiredClients() <span class="cov0" title="0">{
        rlm.mutex.Lock()
        defer rlm.mutex.Unlock()

        now := time.Now()
        expiredCount := 0

        for ip, client := range rlm.clients </span><span class="cov0" title="0">{
                // 清理5分钟内没有请求的客户端
                if now.Sub(client.LastRequest) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                        delete(rlm.clients, ip)
                        expiredCount++
                }</span>
        }

        <span class="cov0" title="0">if expiredCount &gt; 0 </span><span class="cov0" title="0">{
                rlm.logger.WithFields(pkglogger.Fields{"expired": expiredCount, "active": len(rlm.clients)}).
                        Info("rate limit clients cleanup completed")
        }</span>
}

// GetStats 获取限流统计信息
func (rlm *RateLimitMiddleware) GetStats() *RateLimitStats <span class="cov0" title="0">{
        rlm.stats.mutex.RLock()
        defer rlm.stats.mutex.RUnlock()

        // 返回副本避免并发问题
        return &amp;RateLimitStats{
                TotalRequests:   rlm.stats.TotalRequests,
                BlockedRequests: rlm.stats.BlockedRequests,
                ActiveClients:   rlm.stats.ActiveClients,
                LastReset:       rlm.stats.LastReset,
        }
}</span>

// GetClientInfo 获取客户端信息
func (rlm *RateLimitMiddleware) GetClientInfo(ip string) *ClientInfo <span class="cov0" title="0">{
        rlm.mutex.RLock()
        defer rlm.mutex.RUnlock()

        if client, exists := rlm.clients[ip]; exists </span><span class="cov0" title="0">{
                // 返回副本避免并发问题
                return &amp;ClientInfo{
                        IP:           client.IP,
                        RequestCount: client.RequestCount,
                        LastRequest:  client.LastRequest,
                        BlockedUntil: client.BlockedUntil,
                        BurstCount:   client.BurstCount,
                        BurstStart:   client.BurstStart,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ResetStats 重置统计信息
func (rlm *RateLimitMiddleware) ResetStats() <span class="cov0" title="0">{
        rlm.stats.mutex.Lock()
        defer rlm.stats.mutex.Unlock()

        rlm.stats.TotalRequests = 0
        rlm.stats.BlockedRequests = 0
        rlm.stats.LastReset = time.Now()

        rlm.logger.Info("rate limit stats reset")
}</span>

// UpdateConfig 更新限流配置
func (rlm *RateLimitMiddleware) UpdateConfig(config *RateLimitConfig) <span class="cov0" title="0">{
        rlm.mutex.Lock()
        defer rlm.mutex.Unlock()

        rlm.config = config
        rlm.logger.WithFields(pkglogger.Fields{"config": config}).Info("rate limit config updated")
}</span>

// GetActiveClients 获取活跃客户端列表
func (rlm *RateLimitMiddleware) GetActiveClients() map[string]*ClientInfo <span class="cov0" title="0">{
        rlm.mutex.RLock()
        defer rlm.mutex.RUnlock()

        clients := make(map[string]*ClientInfo)
        for ip, client := range rlm.clients </span><span class="cov0" title="0">{
                clients[ip] = &amp;ClientInfo{
                        IP:           client.IP,
                        RequestCount: client.RequestCount,
                        LastRequest:  client.LastRequest,
                        BlockedUntil: client.BlockedUntil,
                        BurstCount:   client.BurstCount,
                        BurstStart:   client.BurstStart,
                }
        }</span>
        <span class="cov0" title="0">return clients</span>
}

// BlockIP 手动阻塞IP
func (rlm *RateLimitMiddleware) BlockIP(ip string, duration time.Duration) <span class="cov0" title="0">{
        rlm.mutex.Lock()
        defer rlm.mutex.Unlock()

        now := time.Now()
        client, exists := rlm.clients[ip]

        if !exists </span><span class="cov0" title="0">{
                rlm.clients[ip] = &amp;ClientInfo{
                        IP:           ip,
                        LastRequest:  now,
                        BlockedUntil: now.Add(duration),
                }
        }</span> else<span class="cov0" title="0"> {
                client.BlockedUntil = now.Add(duration)
        }</span>

        <span class="cov0" title="0">rlm.logger.WithFields(pkglogger.Fields{"ip": ip, "duration": duration}).Warn("manual IP block applied")</span>
}

// UnblockIP 解除IP阻塞
func (rlm *RateLimitMiddleware) UnblockIP(ip string) <span class="cov0" title="0">{
        rlm.mutex.Lock()
        defer rlm.mutex.Unlock()

        if client, exists := rlm.clients[ip]; exists </span><span class="cov0" title="0">{
                client.BlockedUntil = time.Time{}
                rlm.logger.WithFields(pkglogger.Fields{"ip": ip}).Info("manual IP unblock applied")
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"

        "github.com/google/uuid"
)

type ctxKey string

const (
        RequestIDKey         ctxKey = "requestID"
        correlationIDKey     ctxKey = "correlationID"
        correlationSourceKey ctxKey = "correlationSource"
)

// RequestIDMiddleware 添加请求/关联 ID 追踪中间件
func RequestIDMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                requestID := strings.TrimSpace(r.Header.Get("X-Request-ID"))
                if requestID == "" </span><span class="cov8" title="1">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov8" title="1">correlationID := strings.TrimSpace(r.Header.Get("X-Correlation-ID"))
                correlationSource := "request-id"
                if correlationID == "" </span><span class="cov8" title="1">{
                        correlationID = requestID
                }</span> else<span class="cov8" title="1"> {
                        correlationSource = "header"
                }</span>

                <span class="cov8" title="1">w.Header().Set("X-Request-ID", requestID)
                w.Header().Set("X-Correlation-ID", correlationID)

                ctx := context.WithValue(r.Context(), RequestIDKey, requestID)
                ctx = context.WithValue(ctx, correlationIDKey, correlationID)
                ctx = context.WithValue(ctx, correlationSourceKey, correlationSource)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GetRequestID 从上下文中获取请求ID
func GetRequestID(ctx context.Context) string <span class="cov8" title="1">{
        if requestID, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetCorrelationID 从上下文中获取关联 ID
func GetCorrelationID(ctx context.Context) string <span class="cov8" title="1">{
        if correlationID, ok := ctx.Value(correlationIDKey).(string); ok </span><span class="cov8" title="1">{
                return correlationID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetCorrelationSource 返回关联 ID 的来源（header/request-id）
func GetCorrelationSource(ctx context.Context) string <span class="cov8" title="1">{
        if source, ok := ctx.Value(correlationSourceKey).(string); ok </span><span class="cov8" title="1">{
                return source
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package organization

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/dto"
        repositorypkg "cube-castle/internal/organization/repository"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"
)

const (
        defaultAssignmentCacheTTL = 2 * time.Minute
        statsCachePrefix          = "org:assignment:stats"
)

type assignmentRepository interface {
        GetPositionAssignments(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentHistory(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentStats(ctx context.Context, tenantID uuid.UUID, positionCode string, organizationCode string) (*dto.AssignmentStats, error)
}

// AssignmentQueryFacade 封装任职查询与缓存刷新逻辑。
type AssignmentQueryFacade struct {
        repo     assignmentRepository
        redis    *redis.Client
        logger   pkglogger.Logger
        cacheTTL time.Duration
}

// NewAssignmentQueryFacade 创建 AssignmentQueryFacade。
func NewAssignmentQueryFacade(repo assignmentRepository, redisClient *redis.Client, logger pkglogger.Logger, cacheTTL time.Duration) *AssignmentQueryFacade <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">if cacheTTL &lt;= 0 </span><span class="cov8" title="1">{
                cacheTTL = defaultAssignmentCacheTTL
        }</span>
        <span class="cov8" title="1">return &amp;AssignmentQueryFacade{
                repo:     repo,
                redis:    redisClient,
                logger:   logger.WithFields(pkglogger.Fields{"component": "assignment-facade"}),
                cacheTTL: cacheTTL,
        }</span>
}

// GetAssignments 获取职位任职列表（不强制缓存，保持实时读取）。
func (f *AssignmentQueryFacade) GetAssignments(
        ctx context.Context,
        tenantID uuid.UUID,
        positionCode string,
        filter *dto.PositionAssignmentFilterInput,
        pagination *dto.PaginationInput,
        sorting []dto.PositionAssignmentSortInput,
) (*dto.PositionAssignmentConnection, error) <span class="cov8" title="1">{
        if f.repo == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("assignment repository not configured")
        }</span>
        <span class="cov8" title="1">return f.repo.GetPositionAssignments(ctx, tenantID, strings.TrimSpace(positionCode), filter, pagination, sorting)</span>
}

// GetAssignmentHistory 获取职位任职历史记录。
func (f *AssignmentQueryFacade) GetAssignmentHistory(
        ctx context.Context,
        tenantID uuid.UUID,
        positionCode string,
        filter *dto.PositionAssignmentFilterInput,
        pagination *dto.PaginationInput,
        sorting []dto.PositionAssignmentSortInput,
) (*dto.PositionAssignmentConnection, error) <span class="cov8" title="1">{
        if f.repo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignment repository not configured")
        }</span>
        <span class="cov8" title="1">return f.repo.GetAssignmentHistory(ctx, tenantID, strings.TrimSpace(positionCode), filter, pagination, sorting)</span>
}

// GetAssignmentStats 获取任职统计信息，并对单个职位的统计结果启用 Redis 缓存。
func (f *AssignmentQueryFacade) GetAssignmentStats(
        ctx context.Context,
        tenantID uuid.UUID,
        positionCode string,
        organizationCode string,
) (*dto.AssignmentStats, error) <span class="cov8" title="1">{
        if f.repo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignment repository not configured")
        }</span>

        <span class="cov8" title="1">positionCode = strings.TrimSpace(positionCode)
        organizationCode = strings.TrimSpace(organizationCode)
        useCache := f.redis != nil &amp;&amp; positionCode != ""

        cacheKey := ""
        if useCache </span><span class="cov8" title="1">{
                cacheKey = f.statsCacheKey(tenantID, positionCode)
                if cached, err := f.redis.Get(ctx, cacheKey).Result(); err == nil </span><span class="cov8" title="1">{
                        var stats dto.AssignmentStats
                        if json.Unmarshal([]byte(cached), &amp;stats) == nil </span><span class="cov8" title="1">{
                                f.logger.WithFields(pkglogger.Fields{
                                        "tenantId":     tenantID.String(),
                                        "positionCode": positionCode,
                                        "cacheKey":     cacheKey,
                                }).Debug("assignment stats served from cache")
                                return &amp;stats, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">stats, err := f.repo.GetAssignmentStats(ctx, tenantID, positionCode, organizationCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if stats == nil </span><span class="cov8" title="1">{
                stats = &amp;dto.AssignmentStats{}
        }</span>

        <span class="cov8" title="1">if useCache &amp;&amp; stats != nil </span><span class="cov8" title="1">{
                data, err := json.Marshal(stats)
                if err == nil </span><span class="cov8" title="1">{
                        if err := f.redis.Set(ctx, cacheKey, data, f.cacheTTL).Err(); err != nil </span><span class="cov0" title="0">{
                                f.logger.WithFields(pkglogger.Fields{
                                        "cacheKey": cacheKey,
                                        "error":    err,
                                }).Warn("failed to cache assignment stats")
                        }</span>
                }
        }

        <span class="cov8" title="1">return stats, nil</span>
}

// RefreshPositionCache 失效职位相关的任职统计缓存。
func (f *AssignmentQueryFacade) RefreshPositionCache(ctx context.Context, tenantID uuid.UUID, positionCode string) error <span class="cov8" title="1">{
        if f.redis == nil </span><span class="cov8" title="1">{
                f.logger.Debug("redis client not configured, skip cache refresh")
                return nil
        }</span>
        <span class="cov8" title="1">positionCode = strings.TrimSpace(positionCode)
        if positionCode == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("positionCode is required for cache refresh")
        }</span>

        <span class="cov8" title="1">pattern := fmt.Sprintf("%s:%s:%s:*", statsCachePrefix, tenantID.String(), strings.ToUpper(positionCode))
        iter := f.redis.Scan(ctx, 0, pattern, 0).Iterator()
        for iter.Next(ctx) </span><span class="cov8" title="1">{
                key := iter.Val()
                if err := f.redis.Del(ctx, key).Err(); err != nil </span><span class="cov0" title="0">{
                        f.logger.WithFields(pkglogger.Fields{
                                "cacheKey": key,
                                "error":    err,
                        }).Warn("failed to delete assignment cache key")
                }</span> else<span class="cov8" title="1"> {
                        f.logger.WithFields(pkglogger.Fields{
                                "cacheKey": key,
                                "tenantId": tenantID.String(),
                        }).Debug("assignment cache key invalidated")
                }</span>
        }
        <span class="cov8" title="1">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("scan assignment cache keys failed: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *AssignmentQueryFacade) statsCacheKey(tenantID uuid.UUID, positionCode string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s:%s:%s", statsCachePrefix, tenantID.String(), strings.ToUpper(positionCode), "v1")
}</span>

// Ensure repository satisfies interface compile-time.
var _ assignmentRepository = (*repositorypkg.PostgreSQLRepository)(nil)
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// HierarchyRepository 层级管理仓储
type HierarchyRepository struct {
        db     *sql.DB
        logger pkglogger.Logger
}

// OrganizationNode 组织层级节点
type OrganizationNode struct {
        Code          string      `json:"code"`
        ParentCode    *string     `json:"parentCode"`
        Name          string      `json:"name"`
        Level         int         `json:"level"`
        CodePath      string      `json:"codePath"`
        NamePath      string      `json:"namePath"`
        EffectiveDate *types.Date `json:"effectiveDate"`
        EndDate       *types.Date `json:"endDate"`
        IsCurrent     bool        `json:"isCurrent"`
        Depth         int         `json:"depth"`
        Status        string      `json:"status"`
        UnitType      string      `json:"unitType"`
}

func NewHierarchyRepository(db *sql.DB, baseLogger pkglogger.Logger) *HierarchyRepository <span class="cov0" title="0">{
        return &amp;HierarchyRepository{
                db:     db,
                logger: scopedLogger(baseLogger, "organization", "HierarchyRepository", nil),
        }
}</span>

// GetOrganizationHierarchy 获取组织层级结构 (递归CTE查询)
func (h *HierarchyRepository) GetOrganizationHierarchy(ctx context.Context, rootCode string, tenantID uuid.UUID, maxDepth int) ([]OrganizationNode, error) <span class="cov0" title="0">{
        if maxDepth &lt;= 0 || maxDepth &gt; 17 </span><span class="cov0" title="0">{
                maxDepth = 17 // 强制17级深度限制
        }</span>

        // PostgreSQL递归CTE查询 - 激进优化版本
        <span class="cov0" title="0">query := `
        WITH RECURSIVE org_tree AS (
                -- 递归基准: 根组织
                SELECT 
                        code, parent_code, name, level, 
                        COALESCE(code_path, code) as code_path,
                        COALESCE(name_path, name) as name_path,
                        effective_date, end_date, is_current,
                        status, unit_type,
                        0 as depth
                FROM organization_units 
                WHERE code = $1 AND tenant_id = $2 AND is_current = true
                
                UNION ALL
                
                -- 递归部分: 子组织
                SELECT 
                        ou.code, ou.parent_code, ou.name, ou.level,
                        COALESCE(ou.code_path, ot.code_path || '/' || ou.code) as code_path,
                        COALESCE(ou.name_path, ot.name_path || '/' || ou.name) as name_path,
                        ou.effective_date, ou.end_date, ou.is_current,
                        ou.status, ou.unit_type,
                        ot.depth + 1
                FROM organization_units ou
                INNER JOIN org_tree ot ON ou.parent_code = ot.code
                WHERE ou.tenant_id = $2 AND ou.is_current = true AND ot.depth &lt; $3
        )
        SELECT 
                code, parent_code, name, level, code_path, name_path,
                effective_date, end_date, is_current, depth, status, unit_type
        FROM org_tree 
        ORDER BY depth ASC, code ASC;
        `

        start := time.Now()
        rows, err := h.db.QueryContext(ctx, query, rootCode, tenantID.String(), maxDepth)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("递归层级查询失败: %v", err)
                return nil, fmt.Errorf("failed to query organization hierarchy: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var nodes []OrganizationNode
        for rows.Next() </span><span class="cov0" title="0">{
                var node OrganizationNode
                var effectiveDate, endDate sql.NullTime

                err := rows.Scan(
                        &amp;node.Code, &amp;node.ParentCode, &amp;node.Name, &amp;node.Level,
                        &amp;node.CodePath, &amp;node.NamePath, &amp;effectiveDate, &amp;endDate,
                        &amp;node.IsCurrent, &amp;node.Depth, &amp;node.Status, &amp;node.UnitType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Errorf("扫描层级节点失败: %v", err)
                        return nil, fmt.Errorf("failed to scan hierarchy node: %w", err)
                }</span>

                // 转换时态字段
                <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                        node.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        node.EndDate = types.NewDateFromTime(endDate.Time)
                }</span>

                <span class="cov0" title="0">nodes = append(nodes, node)</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        h.logger.Infof("递归CTE查询完成: 根节点=%s, 深度=%d, 节点数=%d, 耗时=%v",
                rootCode, maxDepth, len(nodes), duration)

        return nodes, nil</span>
}

// GetDirectChildren 获取直接子组织
func (h *HierarchyRepository) GetDirectChildren(ctx context.Context, parentCode string, tenantID uuid.UUID) ([]OrganizationNode, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                code, parent_code, name, level, 
                COALESCE(code_path, code) as code_path,
                COALESCE(name_path, name) as name_path,
                effective_date, end_date, is_current, status, unit_type
        FROM organization_units 
        WHERE parent_code = $1 AND tenant_id = $2 AND is_current = true
        ORDER BY sort_order ASC, code ASC;
        `

        rows, err := h.db.QueryContext(ctx, query, parentCode, tenantID.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query direct children: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var children []OrganizationNode
        for rows.Next() </span><span class="cov0" title="0">{
                var child OrganizationNode
                var effectiveDate, endDate sql.NullTime

                err := rows.Scan(
                        &amp;child.Code, &amp;child.ParentCode, &amp;child.Name, &amp;child.Level,
                        &amp;child.CodePath, &amp;child.NamePath, &amp;effectiveDate, &amp;endDate,
                        &amp;child.IsCurrent, &amp;child.Status, &amp;child.UnitType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan child node: %w", err)
                }</span>

                // 转换时态字段
                <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                        child.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        child.EndDate = types.NewDateFromTime(endDate.Time)
                }</span>

                <span class="cov0" title="0">children = append(children, child)</span>
        }

        <span class="cov0" title="0">return children, nil</span>
}

// UpdateHierarchyPaths 更新层级路径 (code_path, name_path)
func (h *HierarchyRepository) UpdateHierarchyPaths(ctx context.Context, parentCode string, tenantID uuid.UUID) error <span class="cov0" title="0">{
        // 获取父组织路径
        var parentCodePath, parentNamePath string
        var parentLevel int

        if parentCode == "" </span><span class="cov0" title="0">{
                // 根组织情况
                parentCodePath = ""
                parentNamePath = ""
                parentLevel = 0
        }</span> else<span class="cov0" title="0"> {
                err := h.db.QueryRowContext(ctx, `
                        SELECT COALESCE(code_path, code), COALESCE(name_path, name), level
                        FROM organization_units 
                        WHERE code = $1 AND tenant_id = $2 AND is_current = true
                `, parentCode, tenantID.String()).Scan(&amp;parentCodePath, &amp;parentNamePath, &amp;parentLevel)

                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("parent organization not found: %s", parentCode)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get parent paths: %w", err)</span>
                }
        }

        // 批量更新子组织路径 - 使用事务确保一致性
        <span class="cov0" title="0">tx, err := h.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        updateQuery := `
        UPDATE organization_units SET
                code_path = CASE 
                        WHEN $1 = '' THEN code
                        ELSE $1 || '/' || code
                END,
                name_path = CASE
                        WHEN $2 = '' THEN name
                        ELSE $2 || '/' || name  
                END,
                level = $3 + 1,
                updated_at = NOW()
        WHERE parent_code = $4 AND tenant_id = $5 AND is_current = true;
        `

        result, err := tx.ExecContext(ctx, updateQuery, parentCodePath, parentNamePath, parentLevel, parentCode, tenantID.String())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update hierarchy paths: %w", err)
        }</span>

        <span class="cov0" title="0">affected, _ := result.RowsAffected()
        h.logger.Infof("层级路径更新: 父节点=%s, 更新子节点数=%d", parentCode, affected)

        return tx.Commit()</span>
}

// GetOrganizationDepth 获取组织深度
func (h *HierarchyRepository) GetOrganizationDepth(ctx context.Context, code string, tenantID uuid.UUID) (int, error) <span class="cov0" title="0">{
        var level int
        err := h.db.QueryRowContext(ctx, `
                SELECT level FROM organization_units 
                WHERE code = $1 AND tenant_id = $2 AND is_current = true
        `, code, tenantID.String()).Scan(&amp;level)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("organization not found: %s", code)
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get organization depth: %w", err)</span>
        }

        <span class="cov0" title="0">return level, nil</span>
}

// GetParentCode 获取父组织代码
func (h *HierarchyRepository) GetParentCode(ctx context.Context, code string, tenantID uuid.UUID) (string, error) <span class="cov0" title="0">{
        var parentCode sql.NullString
        err := h.db.QueryRowContext(ctx, `
                SELECT parent_code FROM organization_units 
                WHERE code = $1 AND tenant_id = $2 AND is_current = true
        `, code, tenantID.String()).Scan(&amp;parentCode)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("organization not found: %s", code)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to get parent code: %w", err)</span>
        }

        <span class="cov0" title="0">return parentCode.String, nil</span>
}

// GetOrganization 获取单个组织信息
func (h *HierarchyRepository) GetOrganization(ctx context.Context, code string, tenantID uuid.UUID) (*types.Organization, error) <span class="cov0" title="0">{
        var org types.Organization
        var effectiveDate, endDate sql.NullTime
        var parentCode sql.NullString

        query := `
        SELECT 
                tenant_id,
                code,
                parent_code,
                name,
                unit_type,
                status,
        level,
        COALESCE(code_path, '/' || code) AS code_path,
        COALESCE(name_path, '/' || name) AS name_path,
                sort_order,
                description,
                effective_date,
                end_date,
                is_current,
                created_at,
                updated_at
        FROM organization_units 
        WHERE code = $1 AND tenant_id = $2 AND is_current = true
        `

        err := h.db.QueryRowContext(ctx, query, code, tenantID.String()).Scan(
                &amp;org.TenantID,
                &amp;org.Code,
                &amp;parentCode,
                &amp;org.Name,
                &amp;org.UnitType,
                &amp;org.Status,
                &amp;org.Level,
                &amp;org.CodePath,
                &amp;org.NamePath,
                &amp;org.SortOrder,
                &amp;org.Description,
                &amp;effectiveDate,
                &amp;endDate,
                &amp;org.IsCurrent,
                &amp;org.CreatedAt,
                &amp;org.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("organization not found: %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get organization: %w", err)</span>
        }

        // 处理可选字段
        <span class="cov0" title="0">if parentCode.Valid </span><span class="cov0" title="0">{
                org.ParentCode = &amp;parentCode.String
        }</span>

        // 转换时态字段
        <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                org.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
        }</span>
        <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                org.EndDate = types.NewDateFromTime(endDate.Time)
        }</span>

        <span class="cov0" title="0">return &amp;org, nil</span>
}

// GetOrganizationAtDate 获取指定日期的组织版本（若不存在返回nil）
func (h *HierarchyRepository) GetOrganizationAtDate(ctx context.Context, code string, tenantID uuid.UUID, targetDate time.Time) (*OrganizationNode, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                code,
                parent_code,
                name,
                level,
                COALESCE(code_path, '/' || code) AS code_path,
                COALESCE(name_path, '/' || name) AS name_path,
                effective_date,
                end_date,
                is_current,
                status,
                unit_type
        FROM organization_units
        WHERE tenant_id = $1
          AND code = $2
          AND status &lt;&gt; 'DELETED'
          AND effective_date &lt;= $3::date
          AND (end_date IS NULL OR end_date &gt; $3::date)
        ORDER BY effective_date DESC, created_at DESC
        LIMIT 1`

        row := h.db.QueryRowContext(ctx, query, tenantID.String(), code, targetDate.Format("2006-01-02"))

        var node OrganizationNode
        var parentCode sql.NullString
        var effectiveDate sql.NullTime
        var endDate sql.NullTime

        if err := row.Scan(
                &amp;node.Code,
                &amp;parentCode,
                &amp;node.Name,
                &amp;node.Level,
                &amp;node.CodePath,
                &amp;node.NamePath,
                &amp;effectiveDate,
                &amp;endDate,
                &amp;node.IsCurrent,
                &amp;node.Status,
                &amp;node.UnitType,
        ); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get organization at date: %w", err)</span>
        }

        <span class="cov0" title="0">if parentCode.Valid </span><span class="cov0" title="0">{
                node.ParentCode = &amp;parentCode.String
        }</span>
        <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                node.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
        }</span>
        <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                node.EndDate = types.NewDateFromTime(endDate.Time)
        }</span>

        // 针对单个节点查询，深度固定为0
        <span class="cov0" title="0">node.Depth = 0

        return &amp;node, nil</span>
}

// CalculateCodePath 计算组织代码路径
func (h *HierarchyRepository) calculateCodePath(ctx context.Context, parentCode *string, tenantID uuid.UUID) (string, error) <span class="cov0" title="0">{
        if parentCode == nil || *parentCode == "" </span><span class="cov0" title="0">{
                return "", nil // 根组织
        }</span>

        <span class="cov0" title="0">var parentPath string
        err := h.db.QueryRowContext(ctx, `
                SELECT COALESCE(code_path, code) FROM organization_units 
                WHERE code = $1 AND tenant_id = $2 AND is_current = true
        `, *parentCode, tenantID.String()).Scan(&amp;parentPath)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("parent organization not found: %s", *parentCode)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to calculate code path: %w", err)</span>
        }

        <span class="cov0" title="0">return parentPath, nil</span>
}

// GetAncestorChain 获取祖先链 (从根到当前节点)
func (h *HierarchyRepository) GetAncestorChain(ctx context.Context, code string, tenantID uuid.UUID) ([]OrganizationNode, error) <span class="cov0" title="0">{
        // 使用递归CTE获取从根节点到目标节点的祖先链
        query := `
        WITH RECURSIVE ancestor_chain AS (
                -- 目标节点
                SELECT 
                        code, parent_code, name, level, 
                        COALESCE(code_path, code) as code_path,
                        COALESCE(name_path, name) as name_path,
                        effective_date, end_date, is_current,
                        status, unit_type, 0 as distance
                FROM organization_units 
                WHERE code = $1 AND tenant_id = $2 AND is_current = true
                
                UNION ALL
                
                -- 向上追溯父节点
                SELECT 
                        ou.code, ou.parent_code, ou.name, ou.level,
                        COALESCE(ou.code_path, ou.code) as code_path,
                        COALESCE(ou.name_path, ou.name) as name_path,
                        ou.effective_date, ou.end_date, ou.is_current,
                        ou.status, ou.unit_type, ac.distance + 1
                FROM organization_units ou
                INNER JOIN ancestor_chain ac ON ou.code = ac.parent_code
                WHERE ou.tenant_id = $2 AND ou.is_current = true
        )
        SELECT 
                code, parent_code, name, level, code_path, name_path,
                effective_date, end_date, is_current, distance, status, unit_type
        FROM ancestor_chain 
        ORDER BY distance DESC; -- 从根节点开始排序
        `

        rows, err := h.db.QueryContext(ctx, query, code, tenantID.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query ancestor chain: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var ancestors []OrganizationNode
        for rows.Next() </span><span class="cov0" title="0">{
                var node OrganizationNode
                var effectiveDate, endDate sql.NullTime
                var distance int

                err := rows.Scan(
                        &amp;node.Code, &amp;node.ParentCode, &amp;node.Name, &amp;node.Level,
                        &amp;node.CodePath, &amp;node.NamePath, &amp;effectiveDate, &amp;endDate,
                        &amp;node.IsCurrent, &amp;distance, &amp;node.Status, &amp;node.UnitType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan ancestor node: %w", err)
                }</span>

                // 转换时态字段
                <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                        node.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        node.EndDate = types.NewDateFromTime(endDate.Time)
                }</span>

                <span class="cov0" title="0">node.Depth = distance
                ancestors = append(ancestors, node)</span>
        }

        <span class="cov0" title="0">h.logger.Infof("祖先链查询: 目标=%s, 层级数=%d", code, len(ancestors))
        return ancestors, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

type JobCatalogRepository struct {
        db     *sql.DB
        logger pkglogger.Logger
}

func NewJobCatalogRepository(db *sql.DB, baseLogger pkglogger.Logger) *JobCatalogRepository <span class="cov8" title="1">{
        return &amp;JobCatalogRepository{
                db:     db,
                logger: scopedLogger(baseLogger, "jobCatalog", "JobCatalogRepository", nil),
        }
}</span>

func (r *JobCatalogRepository) BeginTx(ctx context.Context) (*sql.Tx, error) <span class="cov0" title="0">{
        return r.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
}</span>

type temporalRow struct {
        RecordID      uuid.UUID
        EffectiveDate time.Time
        EndDate       sql.NullTime
        IsCurrent     bool
}

// JobCatalogTimelineEntry 暴露 Job Catalog 各层级的时态版本信息，供验证器使用。
type JobCatalogTimelineEntry struct {
        RecordID      uuid.UUID
        EffectiveDate time.Time
        EndDate       *time.Time
        IsCurrent     bool
        Status        string
}

func normalizeOptionalString(value *string) interface{} <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">trimmed := strings.TrimSpace(*value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return trimmed</span>
}

func marshalOptionalJSON(value interface{}) (interface{}, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">payload, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return json.RawMessage(payload), nil</span>
}

func (r *JobCatalogRepository) queryRows(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.QueryContext(ctx, query, args...)
        }</span>
        <span class="cov8" title="1">return r.db.QueryContext(ctx, query, args...)</span>
}

func (r *JobCatalogRepository) queryRow(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.QueryRowContext(ctx, query, args...)
        }</span>
        <span class="cov8" title="1">return r.db.QueryRowContext(ctx, query, args...)</span>
}

func (r *JobCatalogRepository) exec(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.ExecContext(ctx, query, args...)
        }</span>
        <span class="cov8" title="1">return r.db.ExecContext(ctx, query, args...)</span>
}

func (r *JobCatalogRepository) listTimeline(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) ([]JobCatalogTimelineEntry, error) <span class="cov0" title="0">{
        rows, err := r.queryRows(ctx, tx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        timeline := make([]JobCatalogTimelineEntry, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        entry JobCatalogTimelineEntry
                        end   sql.NullTime
                )
                if err := rows.Scan(&amp;entry.RecordID, &amp;entry.EffectiveDate, &amp;end, &amp;entry.IsCurrent, &amp;entry.Status); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if end.Valid </span><span class="cov0" title="0">{
                        endTime := end.Time
                        entry.EndDate = &amp;endTime
                }</span>
                <span class="cov0" title="0">timeline = append(timeline, entry)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return timeline, nil</span>
}

// ListFamilyGroupTimeline 返回指定职类的所有版本，按生效日期升序排列。
func (r *JobCatalogRepository) ListFamilyGroupTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]JobCatalogTimelineEntry, error) <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current, status
FROM job_family_groups
WHERE tenant_id = $1 AND family_group_code = $2
ORDER BY effective_date ASC`
        return r.listTimeline(ctx, nil, query, tenantID, strings.ToUpper(strings.TrimSpace(code)))
}</span>

// ListJobFamilyTimeline 返回指定职种的所有版本，按生效日期升序排列。
func (r *JobCatalogRepository) ListJobFamilyTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]JobCatalogTimelineEntry, error) <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current, status
FROM job_families
WHERE tenant_id = $1 AND family_code = $2
ORDER BY effective_date ASC`
        return r.listTimeline(ctx, nil, query, tenantID, strings.ToUpper(strings.TrimSpace(code)))
}</span>

// ListJobRoleTimeline 返回指定职务的所有版本，按生效日期升序排列。
func (r *JobCatalogRepository) ListJobRoleTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]JobCatalogTimelineEntry, error) <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current, status
FROM job_roles
WHERE tenant_id = $1 AND role_code = $2
ORDER BY effective_date ASC`
        return r.listTimeline(ctx, nil, query, tenantID, strings.ToUpper(strings.TrimSpace(code)))
}</span>

// ListJobLevelTimeline 返回指定职级的所有版本，按生效日期升序排列。
func (r *JobCatalogRepository) ListJobLevelTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]JobCatalogTimelineEntry, error) <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current, status
FROM job_levels
WHERE tenant_id = $1 AND level_code = $2
ORDER BY effective_date ASC`
        return r.listTimeline(ctx, nil, query, tenantID, strings.ToUpper(strings.TrimSpace(code)))
}</span>

func normalizeTemporal(rows []temporalRow) []temporalRow <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return rows
        }</span>
        <span class="cov8" title="1">normalized := make([]temporalRow, len(rows))
        copy(normalized, rows)

        today := time.Now().UTC().Truncate(24 * time.Hour)
        for i := range normalized </span><span class="cov8" title="1">{
                // end_date 为下一条记录的前一天
                if i &lt; len(normalized)-1 </span><span class="cov0" title="0">{
                        nextStart := normalized[i+1].EffectiveDate
                        end := nextStart.AddDate(0, 0, -1)
                        normalized[i].EndDate = sql.NullTime{Time: end, Valid: true}
                }</span> else<span class="cov8" title="1"> {
                        normalized[i].EndDate = sql.NullTime{Valid: false}
                }</span>

                // is_current 根据有效期与当前日期判定
                <span class="cov8" title="1">isCurrent := !normalized[i].EffectiveDate.After(today)
                if i &lt; len(normalized)-1 &amp;&amp; !normalized[i+1].EffectiveDate.After(today) </span><span class="cov0" title="0">{
                        isCurrent = false
                }</span>
                <span class="cov8" title="1">normalized[i].IsCurrent = isCurrent</span>
        }

        <span class="cov8" title="1">return normalized</span>
}

func (r *JobCatalogRepository) applyTemporalUpdates(ctx context.Context, tx *sql.Tx, table string, updates []temporalRow) error <span class="cov8" title="1">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">query := fmt.Sprintf(`UPDATE %s SET end_date = $2, is_current = $3, updated_at = NOW() WHERE record_id = $1`, table)
        for _, row := range updates </span><span class="cov8" title="1">{
                var endDate interface{}
                if row.EndDate.Valid </span><span class="cov0" title="0">{
                        endDate = row.EndDate.Time
                }</span> else<span class="cov8" title="1"> {
                        endDate = nil
                }</span>
                <span class="cov8" title="1">if _, err := r.exec(ctx, tx, query, row.RecordID, endDate, row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update temporal row in %s: %w", table, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Job Family Group operations

func (r *JobCatalogRepository) GetCurrentFamilyGroup(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current
FROM job_family_groups WHERE tenant_id = $1 AND family_group_code = $2 AND is_current = true LIMIT 1`

        var entry types.JobFamilyGroup
        err := r.queryRow(ctx, tx, query, tenantID, code).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query job family group: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) InsertFamilyGroup(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, req *types.CreateJobFamilyGroupRequest) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        query := `INSERT INTO job_family_groups (
tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,NULL,$7,NOW(),NOW())
RETURNING record_id, tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current`

        var entry types.JobFamilyGroup
        err = r.queryRow(ctx, tx, query,
                tenantID,
                req.Code,
                req.Name,
                req.Description,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job family group already exists for effective date")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job family group: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateFamilyGroupTimeline(ctx, tx, tenantID, req.Code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">r.logger.Infof("Job family group inserted: %s (%s)", req.Code, effectiveDate.Format("2006-01-02"))
        return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) UpdateFamilyGroup(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID uuid.UUID, req *types.UpdateJobFamilyGroupRequest) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">query := `UPDATE job_family_groups
SET name = $1,
    description = $2,
    status = $3,
    effective_date = $4,
    updated_at = NOW()
WHERE tenant_id = $5 AND record_id = $6
RETURNING record_id, tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current`

        var entry types.JobFamilyGroup
        err = r.queryRow(ctx, tx, query,
                req.Name,
                normalizeOptionalString(req.Description),
                req.Status,
                effectiveDate,
                tenantID,
                recordID,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job family group already exists for effective date: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update job family group: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateFamilyGroupTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.GetFamilyGroupByRecordID(ctx, tx, tenantID, recordID)</span>
}

func (r *JobCatalogRepository) recalculateFamilyGroupTimeline(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) error <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current FROM job_family_groups WHERE tenant_id = $1 AND family_group_code = $2 ORDER BY effective_date FOR UPDATE`
        rows, err := r.queryRows(ctx, tx, query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load family group timeline: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var timeline []temporalRow
        for rows.Next() </span><span class="cov0" title="0">{
                var row temporalRow
                if err := rows.Scan(&amp;row.RecordID, &amp;row.EffectiveDate, &amp;row.EndDate, &amp;row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan family group timeline: %w", err)
                }</span>
                <span class="cov0" title="0">timeline = append(timeline, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("family group timeline iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">normalized := normalizeTemporal(timeline)
        return r.applyTemporalUpdates(ctx, tx, "job_family_groups", normalized)</span>
}

// InsertFamilyGroupVersion 插入新的职类版本
func (r *JobCatalogRepository) InsertFamilyGroupVersion(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        query := `INSERT INTO job_family_groups (
tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,NULL,$7,NOW(),NOW())
RETURNING record_id, tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current`

        var entry types.JobFamilyGroup
        err = r.queryRow(ctx, tx, query,
                tenantID,
                code,
                req.Name,
                req.Description,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job family group version already exists for effective date")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job family group version: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateFamilyGroupTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entry, nil</span>
}

// Job family operations

func (r *JobCatalogRepository) GetCurrentJobFamily(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamily, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current
FROM job_families WHERE tenant_id = $1 AND family_code = $2 AND is_current = true LIMIT 1`

        var entry types.JobFamily
        err := r.queryRow(ctx, tx, query, tenantID, code).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyGroupCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query job family: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) InsertJobFamily(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, parentRecord uuid.UUID, req *types.CreateJobFamilyRequest) (*types.JobFamily, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        query := `INSERT INTO job_families (
tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,NULL,$9,NOW(),NOW())
RETURNING record_id, tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current`

        var entry types.JobFamily
        err = r.queryRow(ctx, tx, query,
                tenantID,
                req.Code,
                req.JobFamilyGroupCode,
                parentRecord,
                req.Name,
                req.Description,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyGroupCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job family already exists for effective date")
                        }</span> else<span class="cov0" title="0"> if pqErr.Code == "23503" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parent job family group not found")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job family: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobFamilyTimeline(ctx, tx, tenantID, req.Code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) UpdateJobFamily(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID uuid.UUID, groupCode string, parentRecord uuid.UUID, req *types.UpdateJobFamilyRequest) (*types.JobFamily, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">query := `UPDATE job_families
SET family_group_code = $1,
    parent_record_id = $2,
    name = $3,
    description = $4,
    status = $5,
    effective_date = $6,
    updated_at = NOW()
WHERE tenant_id = $7 AND record_id = $8
RETURNING record_id, tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current`

        var entry types.JobFamily
        err = r.queryRow(ctx, tx, query,
                groupCode,
                parentRecord,
                req.Name,
                normalizeOptionalString(req.Description),
                req.Status,
                effectiveDate,
                tenantID,
                recordID,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyGroupCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("job family already exists for effective date: %w", err)</span>
                        case "23503":<span class="cov0" title="0">
                                return nil, fmt.Errorf("parent job family group not found: %w", err)</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update job family: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobFamilyTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.GetJobFamilyByRecordID(ctx, tx, tenantID, recordID)</span>
}

func (r *JobCatalogRepository) InsertJobFamilyVersion(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, parentRecord uuid.UUID, req *types.JobCatalogVersionRequest) (*types.JobFamily, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        query := `WITH latest AS (
        SELECT record_id, family_group_code, parent_record_id
        FROM job_families
        WHERE tenant_id = $1 AND family_code = $2
        ORDER BY effective_date DESC
        LIMIT 1
)
INSERT INTO job_families (
        tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current, created_at, updated_at
)
SELECT
        $1,
        $2,
        latest.family_group_code,
        latest.parent_record_id,
        $4,
        $5,
        $6,
        $7,
        NULL,
        $8,
        NOW(),
        NOW()
FROM latest
WHERE latest.record_id = $3
RETURNING record_id, tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current`

        var entry types.JobFamily
        err = r.queryRow(ctx, tx, query,
                tenantID,
                code,
                parentRecord,
                req.Name,
                req.Description,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyGroupCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("job family parent record mismatch")
                }</span>
                <span class="cov0" title="0">var pqErr *pq.Error
                if errors.As(err, &amp;pqErr) </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("job family version already exists for effective date")</span>
                        case "23503":<span class="cov0" title="0">
                                return nil, fmt.Errorf("parent job family group not found")</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job family version: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobFamilyTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) recalculateJobFamilyTimeline(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) error <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current FROM job_families WHERE tenant_id = $1 AND family_code = $2 ORDER BY effective_date FOR UPDATE`
        rows, err := r.queryRows(ctx, tx, query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load job family timeline: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var timeline []temporalRow
        for rows.Next() </span><span class="cov0" title="0">{
                var row temporalRow
                if err := rows.Scan(&amp;row.RecordID, &amp;row.EffectiveDate, &amp;row.EndDate, &amp;row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan job family timeline: %w", err)
                }</span>
                <span class="cov0" title="0">timeline = append(timeline, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("job family timeline iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">normalized := normalizeTemporal(timeline)
        return r.applyTemporalUpdates(ctx, tx, "job_families", normalized)</span>
}

// Job role operations

func (r *JobCatalogRepository) GetCurrentJobRole(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobRole, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current
FROM job_roles WHERE tenant_id = $1 AND role_code = $2 AND is_current = true LIMIT 1`

        var entry types.JobRole
        err := r.queryRow(ctx, tx, query, tenantID, code).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Competency,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query job role: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) InsertJobRole(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, parentRecord uuid.UUID, req *types.CreateJobRoleRequest) (*types.JobRole, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        competency, err := marshalOptionalJSON(req.CompetencyModel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid competency model payload: %w", err)
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO job_roles (
tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,NULL,$10,NOW(),NOW())
RETURNING record_id, tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current`

        var entry types.JobRole
        err = r.queryRow(ctx, tx, query,
                tenantID,
                req.Code,
                req.JobFamilyCode,
                parentRecord,
                req.Name,
                normalizeOptionalString(req.Description),
                competency,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Competency,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job role already exists for effective date")
                        }</span> else<span class="cov0" title="0"> if pqErr.Code == "23503" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parent job family not found")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job role: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobRoleTimeline(ctx, tx, tenantID, req.Code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) UpdateJobRole(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID uuid.UUID, familyCode string, parentRecord uuid.UUID, req *types.UpdateJobRoleRequest) (*types.JobRole, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">query := `UPDATE job_roles
SET family_code = $1,
    parent_record_id = $2,
    name = $3,
    description = $4,
    status = $5,
    effective_date = $6,
    updated_at = NOW()
WHERE tenant_id = $7 AND record_id = $8
RETURNING record_id, tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current`

        var entry types.JobRole
        err = r.queryRow(ctx, tx, query,
                familyCode,
                parentRecord,
                req.Name,
                normalizeOptionalString(req.Description),
                req.Status,
                effectiveDate,
                tenantID,
                recordID,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Competency,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("job role already exists for effective date: %w", err)</span>
                        case "23503":<span class="cov0" title="0">
                                return nil, fmt.Errorf("parent job family not found: %w", err)</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update job role: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobRoleTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.GetJobRoleByRecordID(ctx, tx, tenantID, recordID)</span>
}

func (r *JobCatalogRepository) InsertJobRoleVersion(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, parentRecord uuid.UUID, req *types.JobCatalogVersionRequest) (*types.JobRole, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        familyCodeQuery := `SELECT family_code FROM job_roles WHERE tenant_id = $1 AND role_code = $2 ORDER BY effective_date DESC LIMIT 1`
        var familyCode string
        if err := r.queryRow(ctx, tx, familyCodeQuery, tenantID, code).Scan(&amp;familyCode); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("job role not found for code %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to resolve job role family code: %w", err)</span>
        }

        <span class="cov0" title="0">query := `INSERT INTO job_roles (
tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,NULL,$10,NOW(),NOW())
RETURNING record_id, tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current`

        var entry types.JobRole
        err = r.queryRow(ctx, tx, query,
                tenantID,
                code,
                familyCode,
                parentRecord,
                req.Name,
                normalizeOptionalString(req.Description),
                nil,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Competency,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job role version already exists for effective date")
                        }</span> else<span class="cov0" title="0"> if pqErr.Code == "23503" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parent job family not found")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job role version: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobRoleTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) recalculateJobRoleTimeline(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) error <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current FROM job_roles WHERE tenant_id = $1 AND role_code = $2 ORDER BY effective_date FOR UPDATE`
        rows, err := r.queryRows(ctx, tx, query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load job role timeline: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var timeline []temporalRow
        for rows.Next() </span><span class="cov0" title="0">{
                var row temporalRow
                if err := rows.Scan(&amp;row.RecordID, &amp;row.EffectiveDate, &amp;row.EndDate, &amp;row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan job role timeline: %w", err)
                }</span>
                <span class="cov0" title="0">timeline = append(timeline, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("job role timeline iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">normalized := normalizeTemporal(timeline)
        return r.applyTemporalUpdates(ctx, tx, "job_roles", normalized)</span>
}

// Job level operations

func (r *JobCatalogRepository) GetCurrentJobLevel(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobLevel, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current
FROM job_levels WHERE tenant_id = $1 AND level_code = $2 AND is_current = true LIMIT 1`

        var entry types.JobLevel
        err := r.queryRow(ctx, tx, query, tenantID, code).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.RoleCode,
                &amp;entry.ParentRecord,
                &amp;entry.LevelRank,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.SalaryBand,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query job level: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) InsertJobLevel(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, parentRecord uuid.UUID, req *types.CreateJobLevelRequest) (*types.JobLevel, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        salaryBand, err := marshalOptionalJSON(req.SalaryBand)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid salary band payload: %w", err)
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO job_levels (
tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,NULL,$11,NOW(),NOW())
RETURNING record_id, tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current`

        var entry types.JobLevel
        err = r.queryRow(ctx, tx, query,
                tenantID,
                req.Code,
                req.JobRoleCode,
                parentRecord,
                req.LevelRank,
                req.Name,
                normalizeOptionalString(req.Description),
                salaryBand,
                req.Status,
                effectiveDate,
                isCurrent,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.RoleCode,
                &amp;entry.ParentRecord,
                &amp;entry.LevelRank,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.SalaryBand,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job level already exists for effective date")
                        }</span> else<span class="cov0" title="0"> if pqErr.Code == "23503" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parent job role not found")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job level: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobLevelTimeline(ctx, tx, tenantID, req.Code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) UpdateJobLevel(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID uuid.UUID, roleCode string, parentRecord uuid.UUID, levelRank string, req *types.UpdateJobLevelRequest) (*types.JobLevel, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov0" title="0">query := `UPDATE job_levels
SET role_code = $1,
    parent_record_id = $2,
    level_rank = $3,
    name = $4,
    description = $5,
    status = $6,
    effective_date = $7,
    updated_at = NOW()
WHERE tenant_id = $8 AND record_id = $9
RETURNING record_id, tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current`

        var entry types.JobLevel
        err = r.queryRow(ctx, tx, query,
                roleCode,
                parentRecord,
                levelRank,
                req.Name,
                normalizeOptionalString(req.Description),
                req.Status,
                effectiveDate,
                tenantID,
                recordID,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.RoleCode,
                &amp;entry.ParentRecord,
                &amp;entry.LevelRank,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.SalaryBand,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("job level already exists for effective date: %w", err)</span>
                        case "23503":<span class="cov0" title="0">
                                return nil, fmt.Errorf("parent job role not found: %w", err)</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update job level: %w", err)</span>
        }

        <span class="cov0" title="0">if err := r.recalculateJobLevelTimeline(ctx, tx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.GetJobLevelByRecordID(ctx, tx, tenantID, recordID)</span>
}

func (r *JobCatalogRepository) InsertJobLevelVersion(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, parentRecord uuid.UUID, req *types.JobCatalogVersionRequest) (*types.JobLevel, error) <span class="cov8" title="1">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effective date: %w", err)
        }</span>

        <span class="cov8" title="1">parent, err := r.GetJobLevelByRecordID(ctx, tx, tenantID, parentRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load parent job level: %w", err)
        }</span>
        <span class="cov8" title="1">if parent == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("job level parent record not found")
        }</span>

        <span class="cov8" title="1">normalizedCode := strings.ToUpper(strings.TrimSpace(code))
        if !strings.EqualFold(parent.Code, normalizedCode) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("job level parent record mismatch")
        }</span>

        <span class="cov8" title="1">var description interface{}
        if req.Description != nil </span><span class="cov8" title="1">{
                description = normalizeOptionalString(req.Description)
        }</span> else<span class="cov0" title="0"> if parent.Description.Valid </span><span class="cov0" title="0">{
                desc := strings.TrimSpace(parent.Description.String)
                if desc != "" </span><span class="cov0" title="0">{
                        description = desc
                }</span>
        }

        <span class="cov8" title="1">var salaryBand interface{}
        if len(parent.SalaryBand) &gt; 0 </span><span class="cov8" title="1">{
                salaryBand = parent.SalaryBand
        }</span>

        <span class="cov8" title="1">query := `INSERT INTO job_levels (
tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current, created_at, updated_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,NULL,$11,NOW(),NOW())
RETURNING record_id, tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current`

        var entry types.JobLevel
        err = r.queryRow(ctx, tx, query,
                tenantID,
                normalizedCode,
                parent.RoleCode,
                parent.ParentRecord,
                parent.LevelRank,
                req.Name,
                description,
                salaryBand,
                req.Status,
                effectiveDate,
                false,
        ).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.RoleCode,
                &amp;entry.ParentRecord,
                &amp;entry.LevelRank,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.SalaryBand,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("job level version already exists for effective date")
                        }</span> else<span class="cov0" title="0"> if pqErr.Code == "23503" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("parent job role not found")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert job level version: %w", err)</span>
        }

        <span class="cov8" title="1">if err := r.recalculateJobLevelTimeline(ctx, tx, tenantID, normalizedCode); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) recalculateJobLevelTimeline(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) error <span class="cov8" title="1">{
        query := `SELECT record_id, effective_date, end_date, is_current FROM job_levels WHERE tenant_id = $1 AND level_code = $2 ORDER BY effective_date FOR UPDATE`
        rows, err := r.queryRows(ctx, tx, query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load job level timeline: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var timeline []temporalRow
        for rows.Next() </span><span class="cov8" title="1">{
                var row temporalRow
                if err := rows.Scan(&amp;row.RecordID, &amp;row.EffectiveDate, &amp;row.EndDate, &amp;row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan job level timeline: %w", err)
                }</span>
                <span class="cov8" title="1">timeline = append(timeline, row)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("job level timeline iteration error: %w", err)
        }</span>

        <span class="cov8" title="1">normalized := normalizeTemporal(timeline)
        return r.applyTemporalUpdates(ctx, tx, "job_levels", normalized)</span>
}

// Lookup helpers

func (r *JobCatalogRepository) GetFamilyGroupByRecordID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, family_group_code, name, description, status, effective_date, end_date, is_current
FROM job_family_groups WHERE tenant_id = $1 AND record_id = $2 LIMIT 1`
        var entry types.JobFamilyGroup
        err := r.queryRow(ctx, tx, query, tenantID, recordID).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load job family group by record id: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) GetJobFamilyByRecordID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID) (*types.JobFamily, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, family_code, family_group_code, parent_record_id, name, description, status, effective_date, end_date, is_current
FROM job_families WHERE tenant_id = $1 AND record_id = $2 LIMIT 1`
        var entry types.JobFamily
        err := r.queryRow(ctx, tx, query, tenantID, recordID).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyGroupCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load job family by record id: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) GetJobRoleByRecordID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID) (*types.JobRole, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, role_code, family_code, parent_record_id, name, description, competency_model, status, effective_date, end_date, is_current
FROM job_roles WHERE tenant_id = $1 AND record_id = $2 LIMIT 1`
        var entry types.JobRole
        err := r.queryRow(ctx, tx, query, tenantID, recordID).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.FamilyCode,
                &amp;entry.ParentRecord,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.Competency,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load job role by record id: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entry, nil</span>
}

func (r *JobCatalogRepository) GetJobLevelByRecordID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID) (*types.JobLevel, error) <span class="cov8" title="1">{
        query := `SELECT record_id, tenant_id, level_code, role_code, parent_record_id, level_rank, name, description, salary_band, status, effective_date, end_date, is_current
FROM job_levels WHERE tenant_id = $1 AND record_id = $2 LIMIT 1`
        var entry types.JobLevel
        err := r.queryRow(ctx, tx, query, tenantID, recordID).Scan(
                &amp;entry.RecordID,
                &amp;entry.TenantID,
                &amp;entry.Code,
                &amp;entry.RoleCode,
                &amp;entry.ParentRecord,
                &amp;entry.LevelRank,
                &amp;entry.Name,
                &amp;entry.Description,
                &amp;entry.SalaryBand,
                &amp;entry.Status,
                &amp;entry.EffectiveDate,
                &amp;entry.EndDate,
                &amp;entry.IsCurrent,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load job level by record id: %w", err)</span>
        }
        <span class="cov8" title="1">return &amp;entry, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        pkglogger "cube-castle/pkg/logger"
)

func scopedLogger(base pkglogger.Logger, module, name string, extra pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        if base == nil </span><span class="cov8" title="1">{
                base = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov8" title="1">fields := pkglogger.Fields{
                "component": "repository",
        }
        if module != "" </span><span class="cov8" title="1">{
                fields["module"] = module
        }</span>
        <span class="cov8" title="1">if name != "" </span><span class="cov8" title="1">{
                fields["repository"] = name
        }</span>
        <span class="cov8" title="1">for k, v := range extra </span><span class="cov0" title="0">{
                fields[k] = v
        }</span>
        <span class="cov8" title="1">return base.WithFields(fields)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/types"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

func (r *OrganizationRepository) GenerateCode(ctx context.Context, tenantID uuid.UUID) (string, error) <span class="cov0" title="0">{
        for nextCode := 1000000; nextCode &lt;= 9999999; nextCode++ </span><span class="cov0" title="0">{
                candidateCode := fmt.Sprintf("%07d", nextCode)

                var exists bool
                checkQuery := `SELECT EXISTS(SELECT 1 FROM organization_units WHERE tenant_id = $1 AND code = $2)`
                err := r.db.QueryRowContext(ctx, checkQuery, tenantID.String(), candidateCode).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("检查代码唯一性失败: %w", err)
                }</span>

                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return candidateCode, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("生成唯一组织代码失败：7位数编码已用尽")</span>
}

func (r *OrganizationRepository) Create(ctx context.Context, org *types.Organization) (*types.Organization, error) <span class="cov0" title="0">{
        tenantUUID, err := uuid.Parse(org.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效的租户ID: %w", err)
        }</span>

        <span class="cov0" title="0">fields, err := r.ComputeHierarchyForNew(ctx, tenantUUID, org.Code, org.ParentCode, org.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">org.Level = fields.Level
        org.CodePath = fields.CodePath
        org.NamePath = fields.NamePath

        query := `
        INSERT INTO organization_units (
            tenant_id, code, parent_code, name, unit_type, status, 
            level, code_path, name_path, sort_order, description, created_at, updated_at,
            effective_date, end_date, change_reason, is_current
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
        RETURNING record_id, created_at, updated_at
    `

        var createdAt, updatedAt time.Time

        var effectiveDate *types.Date
        if org.EffectiveDate != nil </span><span class="cov0" title="0">{
                effectiveDate = org.EffectiveDate
        }</span> else<span class="cov0" title="0"> {
                now := time.Now()
                effectiveDate = types.NewDate(now.Year(), now.Month(), now.Day())
        }</span>

        <span class="cov0" title="0">isCurrent := shouldMarkOrganizationCurrent(effectiveDate, time.Now())

        err = r.db.QueryRowContext(ctx, query,
                org.TenantID,
                org.Code,
                org.ParentCode,
                org.Name,
                org.UnitType,
                org.Status,
                org.Level,
                org.CodePath,
                org.NamePath,
                org.SortOrder,
                org.Description,
                time.Now(),
                time.Now(),
                effectiveDate,
                org.EndDate,
                org.ChangeReason,
                isCurrent,
        ).Scan(&amp;org.RecordID, &amp;createdAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("组织代码已存在: %s", org.Code)</span>
                        case "23503":<span class="cov0" title="0">
                                parent := ""
                                if org.ParentCode != nil </span><span class="cov0" title="0">{
                                        parent = strings.TrimSpace(*org.ParentCode)
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("父组织不存在: %s", parent)</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("创建组织失败: %w", err)</span>
        }

        <span class="cov0" title="0">org.CreatedAt = createdAt
        org.UpdatedAt = updatedAt
        org.EffectiveDate = effectiveDate

        r.logger.Infof("组织创建成功: %s - %s", org.Code, org.Name)
        return org, nil</span>
}

// shouldMarkOrganizationCurrent 判断组织是否应被标记为当前版本，确保比较在 UTC 日期维度进行。
func shouldMarkOrganizationCurrent(effectiveDate *types.Date, reference time.Time) bool <span class="cov8" title="1">{
        if effectiveDate == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">effectiveDateUTC := effectiveDate.Time.UTC().Truncate(24 * time.Hour)
        referenceUTC := reference.UTC().Truncate(24 * time.Hour)

        return !effectiveDateUTC.After(referenceUTC)</span>
}

func (r *OrganizationRepository) CreateInTransaction(ctx context.Context, tx *sql.Tx, org *types.Organization) (*types.Organization, error) <span class="cov0" title="0">{
        query := `
        INSERT INTO organization_units (
            tenant_id, code, parent_code, name, unit_type, status,
            level, code_path, name_path, sort_order, description, created_at, updated_at,
            effective_date, end_date, change_reason, is_current
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
        RETURNING record_id, created_at, updated_at
    `

        var createdAt, updatedAt time.Time

        var effectiveDate *types.Date
        if org.EffectiveDate != nil </span><span class="cov0" title="0">{
                effectiveDate = org.EffectiveDate
        }</span> else<span class="cov0" title="0"> {
                now := time.Now()
                effectiveDate = types.NewDate(now.Year(), now.Month(), now.Day())
        }</span>

        <span class="cov0" title="0">err := tx.QueryRowContext(ctx, query,
                org.TenantID,
                org.Code,
                org.ParentCode,
                org.Name,
                org.UnitType,
                org.Status,
                org.Level,
                org.CodePath,
                org.NamePath,
                org.SortOrder,
                org.Description,
                time.Now(),
                time.Now(),
                effectiveDate,
                org.EndDate,
                org.ChangeReason,
                org.IsCurrent,
        ).Scan(&amp;org.RecordID, &amp;createdAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("组织代码已存在: %s", org.Code)</span>
                        case "23503":<span class="cov0" title="0">
                                parent := ""
                                if org.ParentCode != nil </span><span class="cov0" title="0">{
                                        parent = strings.TrimSpace(*org.ParentCode)
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("父组织不存在: %s", parent)</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("创建组织失败: %w", err)</span>
        }

        <span class="cov0" title="0">org.CreatedAt = createdAt
        org.UpdatedAt = updatedAt
        org.EffectiveDate = effectiveDate

        r.logger.Infof("时态组织创建成功: %s - %s (生效日期: %v, 当前: %v)",
                org.Code, org.Name,
                org.EffectiveDate.String(),
                org.IsCurrent)
        return org, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "cube-castle/internal/organization/utils"
        "cube-castle/internal/types"
        "github.com/google/uuid"
)

type hierarchyFields struct {
        CodePath string
        NamePath string
        Level    int
        oldLevel int
}

func ensureJoinedPath(base, segment string) string <span class="cov8" title="1">{
        base = strings.TrimSpace(base)
        segment = strings.TrimSpace(segment)
        base = strings.TrimRight(base, "/")
        segment = strings.TrimLeft(segment, "/")
        if base == "" </span><span class="cov8" title="1">{
                return "/" + segment
        }</span>
        <span class="cov8" title="1">return base + "/" + segment</span>
}

func (r *OrganizationRepository) recalculateSelfHierarchy(ctx context.Context, tenantID uuid.UUID, code string, recordID *string, parentCode *string, overrideName *string) (*hierarchyFields, error) <span class="cov0" title="0">{
        var (
                resolvedCode string
                currentName  string
                currentLevel int
        )

        if recordID != nil </span><span class="cov0" title="0">{
                err := r.db.QueryRowContext(ctx, `
                        SELECT code, name, level
                        FROM organization_units
                        WHERE tenant_id = $1 AND record_id = $2 AND status &lt;&gt; 'DELETED'
                        LIMIT 1
                `, tenantID.String(), *recordID).Scan(&amp;resolvedCode, &amp;currentName, &amp;currentLevel)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("记录不存在: %s", *recordID)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("查询组织记录失败: %w", err)</span>
                }
        } else<span class="cov0" title="0"> {
                resolvedCode = code
                err := r.db.QueryRowContext(ctx, `
                        SELECT name, level
                        FROM organization_units
                        WHERE tenant_id = $1 AND code = $2 AND is_current = true AND status &lt;&gt; 'DELETED'
                        LIMIT 1
                `, tenantID.String(), code).Scan(&amp;currentName, &amp;currentLevel)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("组织不存在或已删除不可修改: %s", code)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("查询组织失败: %w", err)</span>
                }
        }

        <span class="cov0" title="0">finalName := currentName
        if overrideName != nil </span><span class="cov0" title="0">{
                finalName = strings.TrimSpace(*overrideName)
        }</span>

        <span class="cov0" title="0">if resolvedCode == "" </span><span class="cov0" title="0">{
                resolvedCode = code
        }</span>

        <span class="cov0" title="0">fields, err := r.calculateHierarchyFields(ctx, tenantID, resolvedCode, parentCode, finalName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields.oldLevel = currentLevel

        r.logger.Infof("recalculateSelfHierarchy: code=%s oldLevel=%d newLevel=%d codePath=%s", resolvedCode, fields.oldLevel, fields.Level, fields.CodePath)
        return fields, nil</span>
}

func (r *OrganizationRepository) calculateHierarchyFields(ctx context.Context, tenantID uuid.UUID, code string, parentCode *string, finalName string) (*hierarchyFields, error) <span class="cov8" title="1">{
        finalName = strings.TrimSpace(finalName)
        if finalName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("组织名称不能为空")
        }</span>

        <span class="cov8" title="1">fields := &amp;hierarchyFields{}

        if parentCode == nil </span><span class="cov8" title="1">{
                fields.Level = 1
                fields.CodePath = ensureJoinedPath("", code)
                fields.NamePath = ensureJoinedPath("", finalName)
                return fields, nil
        }</span>

        <span class="cov8" title="1">trimmedParent := strings.TrimSpace(*parentCode)
        if trimmedParent == "" || trimmedParent == utils.RootParentCode </span><span class="cov0" title="0">{
                fields.Level = 1
                fields.CodePath = ensureJoinedPath("", code)
                fields.NamePath = ensureJoinedPath("", finalName)
                return fields, nil
        }</span>

        <span class="cov8" title="1">var parentCodePath, parentNamePath string
        var parentLevel int
        err := r.db.QueryRowContext(ctx, `
                SELECT COALESCE(NULLIF(code_path, ''), '/' || code),
                       COALESCE(NULLIF(name_path, ''), '/' || name),
                       level
                FROM organization_units
                WHERE tenant_id = $1 AND code = $2 AND is_current = true AND status &lt;&gt; 'DELETED'
                LIMIT 1
        `, tenantID.String(), trimmedParent).Scan(&amp;parentCodePath, &amp;parentNamePath, &amp;parentLevel)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("父组织不存在: %s", trimmedParent)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询父组织失败: %w", err)</span>
        }

        <span class="cov8" title="1">fields.Level = parentLevel + 1
        fields.CodePath = ensureJoinedPath(parentCodePath, code)
        fields.NamePath = ensureJoinedPath(parentNamePath, finalName)

        if fields.Level &gt; types.OrganizationLevelMax </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("层级超过系统允许的最大深度 (%d)", types.OrganizationLevelMax)
        }</span>

        <span class="cov0" title="0">return fields, nil</span>
}

// ComputeHierarchyForNew 计算新建或新版本的层级字段（path/codePath/namePath/level）
func (r *OrganizationRepository) ComputeHierarchyForNew(ctx context.Context, tenantID uuid.UUID, code string, parentCode *string, name string) (*hierarchyFields, error) <span class="cov8" title="1">{
        return r.calculateHierarchyFields(ctx, tenantID, strings.TrimSpace(code), parentCode, name)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

func (r *OrganizationRepository) GetByCode(ctx context.Context, tenantID uuid.UUID, code string) (*types.Organization, error) <span class="cov8" title="1">{
        query := `
        SELECT record_id, tenant_id, code, parent_code, name, unit_type, status,
               level, code_path, name_path, sort_order, description, created_at, updated_at,
               effective_date, end_date, change_reason
        FROM organization_units 
        WHERE tenant_id = $1 AND code = $2 AND is_current = true
        LIMIT 1
    `

        var org types.Organization
        var parentCode sql.NullString
        var effectiveDate, endDate sql.NullTime
        var changeReason sql.NullString

        err := r.db.QueryRowContext(ctx, query, tenantID.String(), code).Scan(
                &amp;org.RecordID, &amp;org.TenantID, &amp;org.Code, &amp;parentCode, &amp;org.Name,
                &amp;org.UnitType, &amp;org.Status, &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder,
                &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                &amp;effectiveDate, &amp;endDate, &amp;changeReason,
        )

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("组织不存在: %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询组织失败: %w", err)</span>
        }

        <span class="cov8" title="1">if parentCode.Valid </span><span class="cov8" title="1">{
                org.ParentCode = &amp;parentCode.String
        }</span>
        <span class="cov8" title="1">if effectiveDate.Valid </span><span class="cov8" title="1">{
                org.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
        }</span>
        <span class="cov8" title="1">if endDate.Valid </span><span class="cov0" title="0">{
                org.EndDate = types.NewDateFromTime(endDate.Time)
        }</span>
        <span class="cov8" title="1">if changeReason.Valid </span><span class="cov8" title="1">{
                org.ChangeReason = &amp;changeReason.String
        }</span>

        <span class="cov8" title="1">return &amp;org, nil</span>
}

func (r *OrganizationRepository) GetByRecordId(ctx context.Context, tenantID uuid.UUID, recordId string) (*types.Organization, error) <span class="cov8" title="1">{
        query := `
        SELECT record_id, tenant_id, code, parent_code, name, unit_type, status,
               level, code_path, name_path, sort_order, description, created_at, updated_at,
               effective_date, end_date, change_reason
        FROM organization_units
        WHERE tenant_id = $1 AND record_id = $2
        LIMIT 1
    `

        var org types.Organization
        var parentCode sql.NullString
        var effectiveDate, endDate sql.NullTime
        var changeReason sql.NullString

        err := r.db.QueryRowContext(ctx, query, tenantID.String(), recordId).Scan(
                &amp;org.RecordID, &amp;org.TenantID, &amp;org.Code, &amp;parentCode, &amp;org.Name,
                &amp;org.UnitType, &amp;org.Status, &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder,
                &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                &amp;effectiveDate, &amp;endDate, &amp;changeReason,
        )

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("记录不存在: %s", recordId)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询组织记录失败: %w", err)</span>
        }

        <span class="cov8" title="1">if parentCode.Valid </span><span class="cov0" title="0">{
                org.ParentCode = &amp;parentCode.String
        }</span>
        <span class="cov8" title="1">if effectiveDate.Valid </span><span class="cov0" title="0">{
                org.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
        }</span>
        <span class="cov8" title="1">if endDate.Valid </span><span class="cov0" title="0">{
                org.EndDate = types.NewDateFromTime(endDate.Time)
        }</span>
        <span class="cov8" title="1">if changeReason.Valid </span><span class="cov0" title="0">{
                org.ChangeReason = &amp;changeReason.String
        }</span>

        <span class="cov8" title="1">return &amp;org, nil</span>
}

func (r *OrganizationRepository) ListVersionsByCode(ctx context.Context, tenantID uuid.UUID, code string) ([]types.Organization, error) <span class="cov0" title="0">{
        query := `
        SELECT record_id, tenant_id, code, parent_code, name, unit_type, status,
               level, code_path, name_path, sort_order, description, created_at, updated_at,
               effective_date, end_date, change_reason
        FROM organization_units
        WHERE tenant_id = $1 AND code = $2
          AND status &lt;&gt; 'DELETED'
        ORDER BY effective_date DESC
    `

        rows, err := r.db.QueryContext(ctx, query, tenantID.String(), code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("查询组织版本失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        versions := make([]types.Organization, 0, 8)
        for rows.Next() </span><span class="cov0" title="0">{
                var org types.Organization
                var parentCode sql.NullString
                var effectiveDate, endDate sql.NullTime
                var changeReason sql.NullString

                if err := rows.Scan(
                        &amp;org.RecordID, &amp;org.TenantID, &amp;org.Code, &amp;parentCode, &amp;org.Name,
                        &amp;org.UnitType, &amp;org.Status, &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder,
                        &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                        &amp;effectiveDate, &amp;endDate, &amp;changeReason,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("扫描组织版本失败: %w", err)
                }</span>

                <span class="cov0" title="0">if parentCode.Valid </span><span class="cov0" title="0">{
                        org.ParentCode = &amp;parentCode.String
                }</span>
                <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                        org.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        org.EndDate = types.NewDateFromTime(endDate.Time)
                }</span>
                <span class="cov0" title="0">if changeReason.Valid </span><span class="cov0" title="0">{
                        org.ChangeReason = &amp;changeReason.String
                }</span>

                <span class="cov0" title="0">versions = append(versions, org)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("遍历组织版本失败: %w", err)
        }</span>

        <span class="cov0" title="0">return versions, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "database/sql"
        "errors"

        pkglogger "cube-castle/pkg/logger"
)

type OrganizationRepository struct {
        db     *sql.DB
        logger pkglogger.Logger
}

func NewOrganizationRepository(db *sql.DB, baseLogger pkglogger.Logger) *OrganizationRepository <span class="cov8" title="1">{
        return &amp;OrganizationRepository{
                db:     db,
                logger: scopedLogger(baseLogger, "organization", "OrganizationRepository", nil),
        }
}</span>

var (
        ErrOrganizationHasChildren  = errors.New("organization has non-deleted child units")
        ErrOrganizationPrecondition = errors.New("organization precondition failed")
)

type OrganizationHasChildrenError struct {
        Count int
}

func (e *OrganizationHasChildrenError) Error() string <span class="cov0" title="0">{
        return ErrOrganizationHasChildren.Error()
}</span>

func (e *OrganizationHasChildrenError) Is(target error) bool <span class="cov0" title="0">{
        return target == ErrOrganizationHasChildren
}</span>

func NewOrganizationHasChildrenError(count int) error <span class="cov0" title="0">{
        return &amp;OrganizationHasChildrenError{Count: count}
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

func (r *OrganizationRepository) Suspend(ctx context.Context, tenantID uuid.UUID, code string, reason string) (*types.Organization, error) <span class="cov0" title="0">{
        query := `
        UPDATE organization_units 
        SET status = 'INACTIVE', updated_at = $3
        WHERE tenant_id = $1 AND code = $2 AND status = 'ACTIVE'
        RETURNING tenant_id, code, parent_code, name, unit_type, status,
                 level, code_path, name_path, sort_order, description, created_at, updated_at,
         effective_date, end_date, change_reason
    `

        var org types.Organization
        var parentCode sql.NullString
        var effectiveDate, endDate sql.NullTime
        var changeReason sql.NullString

        err := r.db.QueryRowContext(ctx, query, tenantID.String(), code, time.Now()).Scan(
                &amp;org.TenantID, &amp;org.Code, &amp;parentCode, &amp;org.Name, &amp;org.UnitType, &amp;org.Status,
                &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder, &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                &amp;effectiveDate, &amp;endDate, &amp;changeReason,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("组织不存在或状态不是ACTIVE: %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("停用组织失败: %w", err)</span>
        }

        <span class="cov0" title="0">if parentCode.Valid </span><span class="cov0" title="0">{
                org.ParentCode = &amp;parentCode.String
        }</span>
        <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                org.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
        }</span>
        <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                org.EndDate = types.NewDateFromTime(endDate.Time)
        }</span>
        <span class="cov0" title="0">if changeReason.Valid </span><span class="cov0" title="0">{
                org.ChangeReason = &amp;changeReason.String
        }</span>

        <span class="cov0" title="0">r.logger.Infof("组织停用成功: %s - %s", org.Code, org.Name)
        return &amp;org, nil</span>
}

func (r *OrganizationRepository) Activate(ctx context.Context, tenantID uuid.UUID, code string, reason string) (*types.Organization, error) <span class="cov0" title="0">{
        query := `
                        UPDATE organization_units 
                        SET status = 'ACTIVE', updated_at = $3
                        WHERE tenant_id = $1 AND code = $2 AND status = 'INACTIVE'
        RETURNING tenant_id, code, parent_code, name, unit_type, status,
                 level, code_path, name_path, sort_order, description, created_at, updated_at,
         effective_date, end_date, change_reason
            `

        var org types.Organization
        var parentCode sql.NullString
        var effectiveDate, endDate sql.NullTime
        var changeReason sql.NullString

        err := r.db.QueryRowContext(ctx, query, tenantID.String(), code, time.Now()).Scan(
                &amp;org.TenantID, &amp;org.Code, &amp;parentCode, &amp;org.Name, &amp;org.UnitType, &amp;org.Status,
                &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder, &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                &amp;effectiveDate, &amp;endDate, &amp;changeReason,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("组织不存在或状态不是INACTIVE: %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("重新启用组织失败: %w", err)</span>
        }

        <span class="cov0" title="0">if parentCode.Valid </span><span class="cov0" title="0">{
                org.ParentCode = &amp;parentCode.String
        }</span>
        <span class="cov0" title="0">if effectiveDate.Valid </span><span class="cov0" title="0">{
                org.EffectiveDate = types.NewDateFromTime(effectiveDate.Time)
        }</span>
        <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                org.EndDate = types.NewDateFromTime(endDate.Time)
        }</span>
        <span class="cov0" title="0">if changeReason.Valid </span><span class="cov0" title="0">{
                org.ChangeReason = &amp;changeReason.String
        }</span>

        <span class="cov0" title="0">r.logger.Infof("组织重新启用成功: %s - %s", org.Code, org.Name)
        return &amp;org, nil</span>
}

func (r *OrganizationRepository) CountNonDeletedChildren(ctx context.Context, tenantID uuid.UUID, code string) (int, error) <span class="cov8" title="1">{
        query := `
                SELECT COUNT(DISTINCT code)
                FROM organization_units
                WHERE tenant_id = $1 AND parent_code = $2 AND status &lt;&gt; 'DELETED'
                  AND (is_current = true OR effective_date &gt;= CURRENT_DATE)
        `

        var count int
        if err := r.db.QueryRowContext(ctx, query, tenantID.String(), code).Scan(&amp;count); err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to count child organizations: %w", err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

func (r *OrganizationRepository) SoftDeleteOrganization(ctx context.Context, tenantID uuid.UUID, code string, deletedAt time.Time, actorID, reason string) error <span class="cov8" title="1">{
        tx, err := r.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelReadCommitted})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        updateQuery := `
                UPDATE organization_units
                SET status = 'DELETED',
                    is_current = false,
                    updated_at = NOW(),
                    deleted_at = $3,
                    deleted_by = $4,
                    deletion_reason = CASE WHEN $5 &lt;&gt; '' THEN $5 ELSE deletion_reason END
                WHERE tenant_id = $1 AND code = $2 AND status &lt;&gt; 'DELETED'
        `

        res, err := tx.ExecContext(ctx, updateQuery, tenantID.String(), code, deletedAt, actorID, strings.TrimSpace(reason))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("soft delete organization failed: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("retrieve delete row count failed: %w", err)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return sql.ErrNoRows
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit soft delete transaction failed: %w", err)
        }</span>

        <span class="cov8" title="1">r.logger.Infof("已软删除组织 %s (tenant=%s, rows=%d)", code, tenantID, rowsAffected)
        return nil</span>
}

func (r *OrganizationRepository) HasOtherNonDeletedVersions(ctx context.Context, tenantID uuid.UUID, code, excludeRecordID string) (bool, error) <span class="cov8" title="1">{
        query := `
                SELECT COUNT(*)
                FROM organization_units
                WHERE tenant_id = $1 AND code = $2 AND status &lt;&gt; 'DELETED' AND record_id &lt;&gt; $3
        `
        var count int
        if err := r.db.QueryRowContext(ctx, query, tenantID.String(), code, excludeRecordID).Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to count remaining versions: %w", err)
        }</span>
        <span class="cov8" title="1">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strconv"
        "strings"
        "time"

        "cube-castle/internal/organization/utils"
        "cube-castle/internal/types"
        "github.com/google/uuid"
)

func (r *OrganizationRepository) Update(ctx context.Context, tenantID uuid.UUID, code string, req *types.UpdateOrganizationRequest) (*types.Organization, error) <span class="cov0" title="0">{
        setParts := make([]string, 0, 8)
        args := []interface{}{tenantID.String(), code}
        argIndex := 3

        addAssignment := func(column string, value interface{}) </span><span class="cov0" title="0">{
                placeholder := "$" + strconv.Itoa(argIndex)
                setParts = append(setParts, column+" = "+placeholder)
                args = append(args, value)
                argIndex++
        }</span>

        <span class="cov0" title="0">var nameOverride *string
        if req.Name != nil </span><span class="cov0" title="0">{
                trimmedName := strings.TrimSpace(*req.Name)
                addAssignment("name", trimmedName)
                nameOverride = &amp;trimmedName
        }</span>

        <span class="cov0" title="0">if req.UnitType != nil </span><span class="cov0" title="0">{
                addAssignment("unit_type", *req.UnitType)
        }</span>

        <span class="cov0" title="0">if req.SortOrder != nil </span><span class="cov0" title="0">{
                addAssignment("sort_order", *req.SortOrder)
        }</span>

        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                addAssignment("description", *req.Description)
        }</span>

        <span class="cov0" title="0">if req.ParentCode != nil </span><span class="cov0" title="0">{
                normalizedParent := utils.NormalizeParentCodePointer(req.ParentCode)
                req.ParentCode = normalizedParent

                fields, err := r.recalculateSelfHierarchy(ctx, tenantID, code, nil, normalizedParent, nameOverride)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if normalizedParent != nil </span><span class="cov0" title="0">{
                        addAssignment("parent_code", *normalizedParent)
                }</span> else<span class="cov0" title="0"> {
                        addAssignment("parent_code", nil)
                }</span>
                <span class="cov0" title="0">addAssignment("level", fields.Level)
                addAssignment("code_path", fields.CodePath)
                addAssignment("name_path", fields.NamePath)</span>
        }

        <span class="cov0" title="0">if req.EffectiveDate != nil </span><span class="cov0" title="0">{
                addAssignment("effective_date", *req.EffectiveDate)
        }</span>

        <span class="cov0" title="0">if req.EndDate != nil </span><span class="cov0" title="0">{
                addAssignment("end_date", *req.EndDate)
        }</span>

        <span class="cov0" title="0">if req.ChangeReason != nil </span><span class="cov0" title="0">{
                addAssignment("change_reason", *req.ChangeReason)
        }</span>

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无字段需要更新，操作被忽略")
        }</span>

        <span class="cov0" title="0">addAssignment("updated_at", time.Now())
        setClause := strings.Join(setParts, ", ")

        query := fmt.Sprintf(`UPDATE organization_units
SET %s
WHERE tenant_id = $1 AND code = $2
  AND status &lt;&gt; 'DELETED'
RETURNING tenant_id, code, parent_code, name, unit_type, status,
          level, code_path, name_path, sort_order, description, created_at, updated_at,
          effective_date, end_date, change_reason`, setClause)

        var org types.Organization
        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;org.TenantID, &amp;org.Code, &amp;org.ParentCode, &amp;org.Name,
                &amp;org.UnitType, &amp;org.Status, &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder,
                &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                &amp;org.EffectiveDate, &amp;org.EndDate, &amp;org.ChangeReason,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("组织不存在或已删除不可修改: %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("更新组织失败: %w", err)</span>
        }

        <span class="cov0" title="0">r.logger.Infof("组织更新成功: %s - %s", org.Code, org.Name)
        return &amp;org, nil</span>
}

func (r *OrganizationRepository) UpdateByRecordId(ctx context.Context, tenantID uuid.UUID, recordId string, req *types.UpdateOrganizationRequest) (*types.Organization, error) <span class="cov0" title="0">{
        setParts := make([]string, 0, 8)
        args := []interface{}{tenantID.String(), recordId}
        argIndex := 3

        addAssignment := func(column string, value interface{}) </span><span class="cov0" title="0">{
                placeholder := "$" + strconv.Itoa(argIndex)
                setParts = append(setParts, column+" = "+placeholder)
                args = append(args, value)
                argIndex++
        }</span>

        <span class="cov0" title="0">var nameOverride *string
        if req.Name != nil </span><span class="cov0" title="0">{
                trimmedName := strings.TrimSpace(*req.Name)
                addAssignment("name", trimmedName)
                nameOverride = &amp;trimmedName
        }</span>

        <span class="cov0" title="0">if req.UnitType != nil </span><span class="cov0" title="0">{
                addAssignment("unit_type", *req.UnitType)
        }</span>

        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                addAssignment("status", *req.Status)
        }</span>

        <span class="cov0" title="0">if req.SortOrder != nil </span><span class="cov0" title="0">{
                addAssignment("sort_order", *req.SortOrder)
        }</span>

        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                addAssignment("description", *req.Description)
        }</span>

        <span class="cov0" title="0">if req.ParentCode != nil </span><span class="cov0" title="0">{
                normalizedParent := utils.NormalizeParentCodePointer(req.ParentCode)
                req.ParentCode = normalizedParent

                fields, err := r.recalculateSelfHierarchy(ctx, tenantID, "", &amp;recordId, normalizedParent, nameOverride)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if normalizedParent != nil </span><span class="cov0" title="0">{
                        addAssignment("parent_code", *normalizedParent)
                }</span> else<span class="cov0" title="0"> {
                        addAssignment("parent_code", nil)
                }</span>
                <span class="cov0" title="0">addAssignment("level", fields.Level)
                addAssignment("code_path", fields.CodePath)
                addAssignment("name_path", fields.NamePath)</span>
        }

        <span class="cov0" title="0">if req.EffectiveDate != nil </span><span class="cov0" title="0">{
                addAssignment("effective_date", *req.EffectiveDate)
        }</span>

        <span class="cov0" title="0">if req.EndDate != nil </span><span class="cov0" title="0">{
                addAssignment("end_date", *req.EndDate)
        }</span>

        <span class="cov0" title="0">if req.ChangeReason != nil </span><span class="cov0" title="0">{
                addAssignment("change_reason", *req.ChangeReason)
        }</span>

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无字段需要更新，操作被忽略")
        }</span>

        <span class="cov0" title="0">addAssignment("updated_at", time.Now())
        setClause := strings.Join(setParts, ", ")

        query := fmt.Sprintf(`UPDATE organization_units
SET %s
WHERE tenant_id = $1 AND record_id = $2
  AND status &lt;&gt; 'DELETED'
RETURNING record_id, tenant_id, code, parent_code, name, unit_type, status,
          level, code_path, name_path, sort_order, description, created_at, updated_at,
          effective_date, end_date, change_reason`, setClause)

        var org types.Organization
        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;org.RecordID, &amp;org.TenantID, &amp;org.Code, &amp;org.ParentCode, &amp;org.Name,
                &amp;org.UnitType, &amp;org.Status, &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder,
                &amp;org.Description, &amp;org.CreatedAt, &amp;org.UpdatedAt,
                &amp;org.EffectiveDate, &amp;org.EndDate, &amp;org.ChangeReason,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("记录不存在或已删除记录为只读: %s", recordId)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("更新历史记录失败: %w", err)</span>
        }

        <span class="cov0" title="0">r.logger.Infof("历史记录更新成功: %s - %s (记录ID: %s)", org.Code, org.Name, recordId)
        return &amp;org, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

type PositionAssignmentRepository struct {
        db     *sql.DB
        logger pkglogger.Logger
}

func NewPositionAssignmentRepository(db *sql.DB, baseLogger pkglogger.Logger) *PositionAssignmentRepository <span class="cov0" title="0">{
        return &amp;PositionAssignmentRepository{
                db:     db,
                logger: scopedLogger(baseLogger, "position", "PositionAssignmentRepository", nil),
        }
}</span>

func (r *PositionAssignmentRepository) queryRow(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.QueryRowContext(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">return r.db.QueryRowContext(ctx, query, args...)</span>
}

func (r *PositionAssignmentRepository) queryRows(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.QueryContext(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">return r.db.QueryContext(ctx, query, args...)</span>
}

func (r *PositionAssignmentRepository) exec(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.ExecContext(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">return r.db.ExecContext(ctx, query, args...)</span>
}

func (r *PositionAssignmentRepository) CreateAssignment(ctx context.Context, tx *sql.Tx, entity *types.PositionAssignment) (*types.PositionAssignment, error) <span class="cov0" title="0">{
        query := `INSERT INTO position_assignments (
tenant_id, position_code, position_record_id, employee_id, employee_name, employee_number,
assignment_type, assignment_status, fte, effective_date, end_date, acting_until, auto_revert, reminder_sent_at, is_current, notes
) VALUES (
$1,$2,$3,$4,$5,$6,
$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
) RETURNING assignment_id, assignment_status, is_current, created_at, updated_at`

        var employeeNumber interface{}
        if entity.EmployeeNumber.Valid </span><span class="cov0" title="0">{
                employeeNumber = entity.EmployeeNumber.String
        }</span> else<span class="cov0" title="0"> {
                employeeNumber = nil
        }</span>

        <span class="cov0" title="0">var endDate interface{}
        if entity.EndDate.Valid </span><span class="cov0" title="0">{
                endDate = entity.EndDate.Time
        }</span> else<span class="cov0" title="0"> {
                endDate = nil
        }</span>

        <span class="cov0" title="0">var actingUntil interface{}
        if entity.ActingUntil.Valid </span><span class="cov0" title="0">{
                actingUntil = entity.ActingUntil.Time
        }</span> else<span class="cov0" title="0"> {
                actingUntil = nil
        }</span>

        <span class="cov0" title="0">var reminderSentAt interface{}
        if entity.ReminderSentAt.Valid </span><span class="cov0" title="0">{
                reminderSentAt = entity.ReminderSentAt.Time
        }</span> else<span class="cov0" title="0"> {
                reminderSentAt = nil
        }</span>

        <span class="cov0" title="0">var notes interface{}
        if entity.Notes.Valid </span><span class="cov0" title="0">{
                notes = entity.Notes.String
        }</span> else<span class="cov0" title="0"> {
                notes = nil
        }</span>

        <span class="cov0" title="0">if err := r.queryRow(ctx, tx, query,
                entity.TenantID,
                entity.PositionCode,
                entity.PositionRecordID,
                entity.EmployeeID,
                entity.EmployeeName,
                employeeNumber,
                entity.AssignmentType,
                entity.AssignmentStatus,
                entity.FTE,
                entity.EffectiveDate,
                endDate,
                actingUntil,
                entity.AutoRevert,
                reminderSentAt,
                entity.IsCurrent,
                notes,
        ).Scan(&amp;entity.AssignmentID, &amp;entity.AssignmentStatus, &amp;entity.IsCurrent, &amp;entity.CreatedAt, &amp;entity.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create position assignment: %w", err)
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (r *PositionAssignmentRepository) GetByID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, assignmentID uuid.UUID) (*types.PositionAssignment, error) <span class="cov0" title="0">{
        query := `SELECT assignment_id, tenant_id, position_code, position_record_id, employee_id, employee_name, employee_number,
assignment_type, assignment_status, fte, effective_date, end_date, acting_until, auto_revert, reminder_sent_at, is_current, notes, created_at, updated_at
FROM position_assignments
WHERE tenant_id = $1 AND assignment_id = $2`

        var entity types.PositionAssignment
        if err := r.queryRow(ctx, tx, query, tenantID, assignmentID).Scan(
                &amp;entity.AssignmentID,
                &amp;entity.TenantID,
                &amp;entity.PositionCode,
                &amp;entity.PositionRecordID,
                &amp;entity.EmployeeID,
                &amp;entity.EmployeeName,
                &amp;entity.EmployeeNumber,
                &amp;entity.AssignmentType,
                &amp;entity.AssignmentStatus,
                &amp;entity.FTE,
                &amp;entity.EffectiveDate,
                &amp;entity.EndDate,
                &amp;entity.ActingUntil,
                &amp;entity.AutoRevert,
                &amp;entity.ReminderSentAt,
                &amp;entity.IsCurrent,
                &amp;entity.Notes,
                &amp;entity.CreatedAt,
                &amp;entity.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load position assignment: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;entity, nil</span>
}

func (r *PositionAssignmentRepository) CloseAssignment(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, assignmentID uuid.UUID, endDate time.Time, notes *string) error <span class="cov0" title="0">{
        query := `UPDATE position_assignments
SET assignment_status = 'ENDED',
    end_date = $3,
    auto_revert = false,
    is_current = false,
    notes = CASE WHEN $4 THEN notes ELSE $5 END,
    updated_at = NOW()
WHERE tenant_id = $1 AND assignment_id = $2`

        preserveNotes := true
        trimmed := ""
        if notes != nil </span><span class="cov0" title="0">{
                trimmed = strings.TrimSpace(*notes)
                if trimmed != "" </span><span class="cov0" title="0">{
                        preserveNotes = false
                }</span>
        }

        <span class="cov0" title="0">var notesVal sql.NullString
        if !preserveNotes </span><span class="cov0" title="0">{
                notesVal = sql.NullString{String: trimmed, Valid: true}
        }</span>

        <span class="cov0" title="0">result, err := r.exec(ctx, tx, query, tenantID, assignmentID, endDate, preserveNotes, notesVal)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close position assignment: %w", err)
        }</span>
        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check affected rows for assignment close: %w", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("assignment not found for closing")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *PositionAssignmentRepository) ListByPosition(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, positionCode string) ([]types.PositionAssignment, error) <span class="cov0" title="0">{
        query := `SELECT assignment_id, tenant_id, position_code, position_record_id, employee_id, employee_name, employee_number,
assignment_type, assignment_status, fte, effective_date, end_date, acting_until, auto_revert, reminder_sent_at, is_current, notes, created_at, updated_at
FROM position_assignments
WHERE tenant_id = $1 AND position_code = $2
ORDER BY effective_date DESC, created_at DESC`

        rows, err := r.queryRows(ctx, tx, query, tenantID, positionCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list position assignments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []types.PositionAssignment
        for rows.Next() </span><span class="cov0" title="0">{
                var entity types.PositionAssignment
                if err := rows.Scan(
                        &amp;entity.AssignmentID,
                        &amp;entity.TenantID,
                        &amp;entity.PositionCode,
                        &amp;entity.PositionRecordID,
                        &amp;entity.EmployeeID,
                        &amp;entity.EmployeeName,
                        &amp;entity.EmployeeNumber,
                        &amp;entity.AssignmentType,
                        &amp;entity.AssignmentStatus,
                        &amp;entity.FTE,
                        &amp;entity.EffectiveDate,
                        &amp;entity.EndDate,
                        &amp;entity.ActingUntil,
                        &amp;entity.AutoRevert,
                        &amp;entity.ReminderSentAt,
                        &amp;entity.IsCurrent,
                        &amp;entity.Notes,
                        &amp;entity.CreatedAt,
                        &amp;entity.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan assignment row: %w", err)
                }</span>
                <span class="cov0" title="0">result = append(result, entity)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignment iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func normalizeAssignmentTypes(values []string) []string <span class="cov0" title="0">{
        result := make([]string, 0, len(values))
        seen := make(map[string]struct{})
        for _, v := range values </span><span class="cov0" title="0">{
                trimmed := strings.ToUpper(strings.TrimSpace(v))
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, exists := seen[trimmed]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[trimmed] = struct{}{}
                result = append(result, trimmed)</span>
        }
        <span class="cov0" title="0">return result</span>
}

func (r *PositionAssignmentRepository) ListWithOptions(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, positionCode string, opts types.AssignmentListOptions) ([]types.PositionAssignment, int, error) <span class="cov0" title="0">{
        page := opts.Page
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">pageSize := opts.PageSize
        if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 25
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 200 </span><span class="cov0" title="0">{
                pageSize = 200
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize

        args := []interface{}{tenantID, positionCode}
        whereParts := []string{"tenant_id = $1", "position_code = $2"}
        argIndex := 3

        if len(opts.Filter.AssignmentTypes) &gt; 0 </span><span class="cov0" title="0">{
                typesNormalized := normalizeAssignmentTypes(opts.Filter.AssignmentTypes)
                if len(typesNormalized) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("assignment_type = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(typesNormalized))
                        argIndex++
                }</span>
        }

        <span class="cov0" title="0">if opts.Filter.IncludeActingOnly </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "assignment_type = 'ACTING'")
        }</span>

        <span class="cov0" title="0">if opts.Filter.AssignmentStatus != nil </span><span class="cov0" title="0">{
                status := strings.ToUpper(strings.TrimSpace(*opts.Filter.AssignmentStatus))
                if status != "" </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("assignment_status = $%d", argIndex))
                        args = append(args, status)
                        argIndex++
                }</span>
        }

        <span class="cov0" title="0">if opts.Filter.AsOfDate != nil </span><span class="cov0" title="0">{
                dateVal := opts.Filter.AsOfDate.Format("2006-01-02")
                whereParts = append(whereParts, fmt.Sprintf("(effective_date &lt;= $%d AND (end_date IS NULL OR end_date &gt;= $%d))", argIndex, argIndex))
                args = append(args, dateVal)
                argIndex++
        }</span>

        <span class="cov0" title="0">if !opts.Filter.IncludeHistorical </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "assignment_status &lt;&gt; 'ENDED'")
        }</span>

        <span class="cov0" title="0">whereClause := ""
        if len(whereParts) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = "WHERE " + strings.Join(whereParts, " AND ")
        }</span>

        <span class="cov0" title="0">countQuery := fmt.Sprintf(`SELECT COUNT(*) FROM position_assignments %s`, whereClause)
        var total int
        if err := r.queryRow(ctx, tx, countQuery, args...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("count position assignments: %w", err)
        }</span>

        <span class="cov0" title="0">selectQuery := fmt.Sprintf(`
SELECT
        assignment_id,
        tenant_id,
        position_code,
        position_record_id,
        employee_id,
        employee_name,
        employee_number,
        assignment_type,
        assignment_status,
        fte,
        effective_date,
        end_date,
        acting_until,
        auto_revert,
        reminder_sent_at,
        is_current,
        notes,
        created_at,
        updated_at
FROM position_assignments
%s
ORDER BY effective_date DESC, created_at DESC
LIMIT $%d OFFSET $%d`, whereClause, argIndex, argIndex+1)

        queryArgs := append([]interface{}{}, args...)
        queryArgs = append(queryArgs, pageSize, offset)

        rows, err := r.queryRows(ctx, tx, selectQuery, queryArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("query position assignments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        assignments := make([]types.PositionAssignment, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var entity types.PositionAssignment
                if err := rows.Scan(
                        &amp;entity.AssignmentID,
                        &amp;entity.TenantID,
                        &amp;entity.PositionCode,
                        &amp;entity.PositionRecordID,
                        &amp;entity.EmployeeID,
                        &amp;entity.EmployeeName,
                        &amp;entity.EmployeeNumber,
                        &amp;entity.AssignmentType,
                        &amp;entity.AssignmentStatus,
                        &amp;entity.FTE,
                        &amp;entity.EffectiveDate,
                        &amp;entity.EndDate,
                        &amp;entity.ActingUntil,
                        &amp;entity.AutoRevert,
                        &amp;entity.ReminderSentAt,
                        &amp;entity.IsCurrent,
                        &amp;entity.Notes,
                        &amp;entity.CreatedAt,
                        &amp;entity.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("scan position assignment row: %w", err)
                }</span>
                <span class="cov0" title="0">assignments = append(assignments, entity)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("iterate position assignments: %w", err)
        }</span>

        <span class="cov0" title="0">return assignments, total, nil</span>
}

func (r *PositionAssignmentRepository) UpdateAssignment(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, assignmentID uuid.UUID, params types.AssignmentUpdateParams) error <span class="cov0" title="0">{
        setParts := make([]string, 0, 6)
        args := []interface{}{tenantID, assignmentID}
        argIndex := 3

        if params.FTE != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, fmt.Sprintf("fte = $%d", argIndex))
                args = append(args, *params.FTE)
                argIndex++
        }</span>

        <span class="cov0" title="0">if params.ActingUntil != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, fmt.Sprintf("acting_until = $%d", argIndex))
                args = append(args, params.ActingUntil)
                argIndex++
        }</span> else<span class="cov0" title="0"> if params.ClearActingUntil </span><span class="cov0" title="0">{
                setParts = append(setParts, "acting_until = NULL")
        }</span>

        <span class="cov0" title="0">if params.AutoRevert != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, fmt.Sprintf("auto_revert = $%d", argIndex))
                args = append(args, *params.AutoRevert)
                argIndex++
        }</span>

        <span class="cov0" title="0">if params.ReminderSentAt != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, fmt.Sprintf("reminder_sent_at = $%d", argIndex))
                args = append(args, *params.ReminderSentAt)
                argIndex++
        }</span> else<span class="cov0" title="0"> if params.ClearReminderSent </span><span class="cov0" title="0">{
                setParts = append(setParts, "reminder_sent_at = NULL")
        }</span>

        <span class="cov0" title="0">if params.Notes != nil </span><span class="cov0" title="0">{
                note := strings.TrimSpace(*params.Notes)
                if note == "" </span><span class="cov0" title="0">{
                        setParts = append(setParts, "notes = NULL")
                }</span> else<span class="cov0" title="0"> {
                        setParts = append(setParts, fmt.Sprintf("notes = $%d", argIndex))
                        args = append(args, note)
                        argIndex++
                }</span>
        }

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">setParts = append(setParts, "updated_at = NOW()")

        query := fmt.Sprintf(`UPDATE position_assignments SET %s WHERE tenant_id = $1 AND assignment_id = $2`, strings.Join(setParts, ", "))

        result, err := r.exec(ctx, tx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update position assignment: %w", err)
        }</span>
        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check affected rows: %w", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("assignment not found for update")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *PositionAssignmentRepository) ListAutoRevertCandidates(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, asOf time.Time, limit int) ([]types.PositionAssignment, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">query := `SELECT assignment_id, tenant_id, position_code, position_record_id, employee_id, employee_name, employee_number,
assignment_type, assignment_status, fte, effective_date, end_date, acting_until, auto_revert, reminder_sent_at, is_current, notes, created_at, updated_at
FROM position_assignments
WHERE tenant_id = $1
  AND assignment_type = 'ACTING'
  AND auto_revert = true
  AND assignment_status = 'ACTIVE'
  AND acting_until IS NOT NULL
  AND acting_until &lt;= $2
ORDER BY acting_until ASC
LIMIT $3`

        rows, err := r.queryRows(ctx, tx, query, tenantID, asOf, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query auto revert assignments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []types.PositionAssignment
        for rows.Next() </span><span class="cov0" title="0">{
                var entity types.PositionAssignment
                if err := rows.Scan(
                        &amp;entity.AssignmentID,
                        &amp;entity.TenantID,
                        &amp;entity.PositionCode,
                        &amp;entity.PositionRecordID,
                        &amp;entity.EmployeeID,
                        &amp;entity.EmployeeName,
                        &amp;entity.EmployeeNumber,
                        &amp;entity.AssignmentType,
                        &amp;entity.AssignmentStatus,
                        &amp;entity.FTE,
                        &amp;entity.EffectiveDate,
                        &amp;entity.EndDate,
                        &amp;entity.ActingUntil,
                        &amp;entity.AutoRevert,
                        &amp;entity.ReminderSentAt,
                        &amp;entity.IsCurrent,
                        &amp;entity.Notes,
                        &amp;entity.CreatedAt,
                        &amp;entity.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan auto revert assignment: %w", err)
                }</span>
                <span class="cov0" title="0">result = append(result, entity)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate auto revert assignments: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *PositionAssignmentRepository) SumActiveFTE(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, positionCode string) (float64, error) <span class="cov0" title="0">{
        query := `SELECT COALESCE(SUM(fte), 0)
FROM position_assignments
WHERE tenant_id = $1 AND position_code = $2
  AND assignment_status = 'ACTIVE'
  AND is_current = true`

        var total sql.NullFloat64
        if err := r.queryRow(ctx, tx, query, tenantID, positionCode).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to sum active assignment FTE: %w", err)
        }</span>
        <span class="cov0" title="0">if total.Valid </span><span class="cov0" title="0">{
                return total.Float64, nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"

        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

type PositionRepository struct {
        db     *sql.DB
        logger pkglogger.Logger
}

func NewPositionRepository(db *sql.DB, baseLogger pkglogger.Logger) *PositionRepository <span class="cov0" title="0">{
        return &amp;PositionRepository{
                db:     db,
                logger: scopedLogger(baseLogger, "position", "PositionRepository", nil),
        }
}</span>

func (r *PositionRepository) BeginTx(ctx context.Context) (*sql.Tx, error) <span class="cov0" title="0">{
        return r.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
}</span>

func (r *PositionRepository) queryRow(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.QueryRowContext(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">return r.db.QueryRowContext(ctx, query, args...)</span>
}

func (r *PositionRepository) queryRows(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.QueryContext(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">return r.db.QueryContext(ctx, query, args...)</span>
}

func (r *PositionRepository) exec(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        if tx != nil </span><span class="cov0" title="0">{
                return tx.ExecContext(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">return r.db.ExecContext(ctx, query, args...)</span>
}

// GetCurrentPosition 返回当前版本的职位
func (r *PositionRepository) GetCurrentPosition(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.Position, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, code, title, job_profile_code, job_profile_name, job_family_group_code, job_family_group_name, job_family_group_record_id,
job_family_code, job_family_name, job_family_record_id, job_role_code, job_role_name, job_role_record_id,
job_level_code, job_level_name, job_level_record_id, organization_code, organization_name, position_type, status, employment_type,
        headcount_capacity, headcount_in_use, grade_level, cost_center_code,
reports_to_position_code, profile, effective_date, end_date, is_current, created_at, updated_at, deleted_at, operation_type, operated_by_id, operated_by_name, operation_reason
FROM positions WHERE tenant_id = $1 AND code = $2 AND is_current = true LIMIT 1`

        var entity types.Position
        err := r.queryRow(ctx, tx, query, tenantID, code).Scan(
                &amp;entity.RecordID,
                &amp;entity.TenantID,
                &amp;entity.Code,
                &amp;entity.Title,
                &amp;entity.JobProfileCode,
                &amp;entity.JobProfileName,
                &amp;entity.JobFamilyGroupCode,
                &amp;entity.JobFamilyGroupName,
                &amp;entity.JobFamilyGroupRecord,
                &amp;entity.JobFamilyCode,
                &amp;entity.JobFamilyName,
                &amp;entity.JobFamilyRecord,
                &amp;entity.JobRoleCode,
                &amp;entity.JobRoleName,
                &amp;entity.JobRoleRecord,
                &amp;entity.JobLevelCode,
                &amp;entity.JobLevelName,
                &amp;entity.JobLevelRecord,
                &amp;entity.OrganizationCode,
                &amp;entity.OrganizationName,
                &amp;entity.PositionType,
                &amp;entity.Status,
                &amp;entity.EmploymentType,
                &amp;entity.HeadcountCapacity,
                &amp;entity.HeadcountInUse,
                &amp;entity.GradeLevel,
                &amp;entity.CostCenterCode,
                &amp;entity.ReportsToPosition,
                &amp;entity.Profile,
                &amp;entity.EffectiveDate,
                &amp;entity.EndDate,
                &amp;entity.IsCurrent,
                &amp;entity.CreatedAt,
                &amp;entity.UpdatedAt,
                &amp;entity.DeletedAt,
                &amp;entity.OperationType,
                &amp;entity.OperatedByID,
                &amp;entity.OperatedByName,
                &amp;entity.OperationReason,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query current position: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

// InsertPositionVersion 插入职位版本（用于创建和新增版本）
func (r *PositionRepository) InsertPositionVersion(ctx context.Context, tx *sql.Tx, entity *types.Position) (*types.Position, error) <span class="cov0" title="0">{
        query := `INSERT INTO positions (
tenant_id, code, title, job_profile_code, job_profile_name,
job_family_group_code, job_family_group_name, job_family_group_record_id,
job_family_code, job_family_name, job_family_record_id,
job_role_code, job_role_name, job_role_record_id,
job_level_code, job_level_name, job_level_record_id,
organization_code, organization_name, position_type, status, employment_type,
headcount_capacity, headcount_in_use, grade_level, cost_center_code,
reports_to_position_code, profile, effective_date, end_date, is_current,
created_at, updated_at, deleted_at, operation_type, operated_by_id, operated_by_name, operation_reason)
VALUES (
$1,$2,$3,$4,$5,
$6,$7,$8,
$9,$10,$11,
$12,$13,$14,
$15,$16,$17,
$18,$19,$20,$21,$22,
$23,$24,$25,$26,
$27,$28,$29,$30,$31,
NOW(),NOW(),NULL,$32,$33,$34,$35)
RETURNING record_id, created_at, updated_at`

        var profilePayload interface{}
        if len(entity.Profile) &gt; 0 </span><span class="cov0" title="0">{
                profilePayload = entity.Profile
        }</span> else<span class="cov0" title="0"> {
                profilePayload = []byte("{}")
        }</span>

        <span class="cov0" title="0">var reportsTo interface{}
        if entity.ReportsToPosition.Valid </span><span class="cov0" title="0">{
                reportsTo = entity.ReportsToPosition.String
        }</span> else<span class="cov0" title="0"> {
                reportsTo = nil
        }</span>

        <span class="cov0" title="0">var organizationName interface{}
        if entity.OrganizationName.Valid </span><span class="cov0" title="0">{
                organizationName = entity.OrganizationName.String
        }</span> else<span class="cov0" title="0"> {
                organizationName = nil
        }</span>

        <span class="cov0" title="0">var jobProfileCode interface{}
        if entity.JobProfileCode.Valid </span><span class="cov0" title="0">{
                jobProfileCode = entity.JobProfileCode.String
        }</span> else<span class="cov0" title="0"> {
                jobProfileCode = nil
        }</span>

        <span class="cov0" title="0">var jobProfileName interface{}
        if entity.JobProfileName.Valid </span><span class="cov0" title="0">{
                jobProfileName = entity.JobProfileName.String
        }</span> else<span class="cov0" title="0"> {
                jobProfileName = nil
        }</span>

        <span class="cov0" title="0">var gradeLevel interface{}
        if entity.GradeLevel.Valid </span><span class="cov0" title="0">{
                gradeLevel = entity.GradeLevel.String
        }</span> else<span class="cov0" title="0"> {
                gradeLevel = nil
        }</span>

        <span class="cov0" title="0">var costCenter interface{}
        if entity.CostCenterCode.Valid </span><span class="cov0" title="0">{
                costCenter = entity.CostCenterCode.String
        }</span> else<span class="cov0" title="0"> {
                costCenter = nil
        }</span>

        <span class="cov0" title="0">var endDate interface{}
        if entity.EndDate.Valid </span><span class="cov0" title="0">{
                endDate = entity.EndDate.Time
        }</span> else<span class="cov0" title="0"> {
                endDate = nil
        }</span>

        <span class="cov0" title="0">var operationReason interface{}
        if entity.OperationReason.Valid </span><span class="cov0" title="0">{
                operationReason = entity.OperationReason.String
        }</span> else<span class="cov0" title="0"> {
                operationReason = nil
        }</span>

        <span class="cov0" title="0">err := r.queryRow(ctx, tx, query,
                entity.TenantID,
                entity.Code,
                entity.Title,
                jobProfileCode,
                jobProfileName,
                entity.JobFamilyGroupCode,
                entity.JobFamilyGroupName,
                entity.JobFamilyGroupRecord,
                entity.JobFamilyCode,
                entity.JobFamilyName,
                entity.JobFamilyRecord,
                entity.JobRoleCode,
                entity.JobRoleName,
                entity.JobRoleRecord,
                entity.JobLevelCode,
                entity.JobLevelName,
                entity.JobLevelRecord,
                entity.OrganizationCode,
                organizationName,
                entity.PositionType,
                entity.Status,
                entity.EmploymentType,
                entity.HeadcountCapacity,
                entity.HeadcountInUse,
                gradeLevel,
                costCenter,
                reportsTo,
                profilePayload,
                entity.EffectiveDate,
                endDate,
                entity.IsCurrent,
                entity.OperationType,
                entity.OperatedByID,
                entity.OperatedByName,
                operationReason,
        ).Scan(&amp;entity.RecordID, &amp;entity.CreatedAt, &amp;entity.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        switch pqErr.Code </span>{
                        case "23505":<span class="cov0" title="0">
                                return nil, fmt.Errorf("position version already exists for effective date")</span>
                        case "23503":<span class="cov0" title="0">
                                return nil, fmt.Errorf("invalid foreign key reference: %s", pqErr.Constraint)</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to insert position: %w", err)</span>
        }

        <span class="cov0" title="0">return entity, nil</span>
}

// RecalculatePositionTimeline 重算职位时间线，确保 end_date 和 is_current 正确
func (r *PositionRepository) RecalculatePositionTimeline(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) error <span class="cov0" title="0">{
        query := `SELECT record_id, effective_date, end_date, is_current FROM positions WHERE tenant_id = $1 AND code = $2 ORDER BY effective_date FOR UPDATE`
        rows, err := r.queryRows(ctx, tx, query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load position timeline: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var timeline []temporalRow
        for rows.Next() </span><span class="cov0" title="0">{
                var row temporalRow
                if err := rows.Scan(&amp;row.RecordID, &amp;row.EffectiveDate, &amp;row.EndDate, &amp;row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan position timeline: %w", err)
                }</span>
                <span class="cov0" title="0">timeline = append(timeline, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("position timeline iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">normalized := normalizeTemporal(timeline)
        return r.applyTemporalUpdates(ctx, tx, "positions", normalized)</span>
}

func (r *PositionRepository) applyTemporalUpdates(ctx context.Context, tx *sql.Tx, table string, updates []temporalRow) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`UPDATE %s SET end_date = $2, is_current = $3, updated_at = NOW() WHERE record_id = $1`, table)
        for _, row := range updates </span><span class="cov0" title="0">{
                var endDate interface{}
                if row.EndDate.Valid </span><span class="cov0" title="0">{
                        endDate = row.EndDate.Time
                }</span> else<span class="cov0" title="0"> {
                        endDate = nil
                }</span>
                <span class="cov0" title="0">if _, err := r.exec(ctx, tx, query, row.RecordID, endDate, row.IsCurrent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update temporal row in %s: %w", table, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdatePositionHeadcount 更新职位的 headcount 占用情况
func (r *PositionRepository) UpdatePositionHeadcount(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID, headcountInUse float64, status string, operationType, operatedByName string, operatedByID uuid.UUID, reason *string) error <span class="cov0" title="0">{
        query := `UPDATE positions SET headcount_in_use = $1,
status = $2, operation_type = $3, operated_by_id = $4, operated_by_name = $5, operation_reason = $6, updated_at = NOW()
WHERE tenant_id = $7 AND record_id = $8`

        var reasonVal interface{}
        if reason != nil </span><span class="cov0" title="0">{
                reasonVal = *reason
        }</span> else<span class="cov0" title="0"> {
                reasonVal = nil
        }</span>

        <span class="cov0" title="0">_, err := r.exec(ctx, tx, query,
                headcountInUse,
                status,
                operationType,
                operatedByID,
                operatedByName,
                reasonVal,
                tenantID,
                recordID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update position headcount: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdatePositionStatus 更新职位状态（用于 Vacate/Suspend/Activate 等事件）
func (r *PositionRepository) UpdatePositionStatus(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID, status string, payload map[string]interface{}, operationType string, operatedByName string, operatedByID uuid.UUID, reason *string) error <span class="cov0" title="0">{
        payloadJSON, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal status payload: %w", err)
        }</span>

        <span class="cov0" title="0">query := `UPDATE positions SET status = $1, profile = COALESCE(profile, '{}'::jsonb) || $2::jsonb, operation_type = $3, operated_by_id = $4, operated_by_name = $5, operation_reason = $6, updated_at = NOW()
WHERE tenant_id = $7 AND record_id = $8`

        var reasonVal interface{}
        if reason != nil </span><span class="cov0" title="0">{
                reasonVal = *reason
        }</span> else<span class="cov0" title="0"> {
                reasonVal = nil
        }</span>

        <span class="cov0" title="0">if _, err := r.exec(ctx, tx, query,
                status,
                payloadJSON,
                operationType,
                operatedByID,
                operatedByName,
                reasonVal,
                tenantID,
                recordID,
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update position status: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeletePositionVersion 标记职位为删除状态
func (r *PositionRepository) DeletePositionVersion(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID, operatedBy uuid.UUID, operatedByName string, reason *string) error <span class="cov0" title="0">{
        query := `UPDATE positions SET status = 'DELETED', deleted_at = NOW(), is_current = false, operation_type = 'DELETE', operated_by_id = $1, operated_by_name = $2, operation_reason = $3, updated_at = NOW() WHERE tenant_id = $4 AND record_id = $5`

        var reasonVal interface{}
        if reason != nil </span><span class="cov0" title="0">{
                reasonVal = *reason
        }</span> else<span class="cov0" title="0"> {
                reasonVal = nil
        }</span>

        <span class="cov0" title="0">if _, err := r.exec(ctx, tx, query, operatedBy, operatedByName, reasonVal, tenantID, recordID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete position version: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdatePositionDetails 更新职位当前版本的核心字段
func (r *PositionRepository) UpdatePositionDetails(ctx context.Context, tx *sql.Tx, entity *types.Position) (*types.Position, error) <span class="cov0" title="0">{
        query := `UPDATE positions SET
title = $1,
job_profile_code = $2,
job_profile_name = $3,
job_family_group_code = $4,
job_family_group_name = $5,
job_family_group_record_id = $6,
job_family_code = $7,
job_family_name = $8,
job_family_record_id = $9,
job_role_code = $10,
job_role_name = $11,
job_role_record_id = $12,
job_level_code = $13,
job_level_name = $14,
job_level_record_id = $15,
organization_code = $16,
organization_name = $17,
position_type = $18,
employment_type = $19,
grade_level = $20,
headcount_capacity = $21,
reports_to_position_code = $22,
operation_type = $23,
operated_by_id = $24,
operated_by_name = $25,
operation_reason = $26,
status = $27,
updated_at = NOW()
WHERE tenant_id = $28 AND record_id = $29
RETURNING updated_at`

        var jobProfileCode interface{}
        if entity.JobProfileCode.Valid </span><span class="cov0" title="0">{
                jobProfileCode = entity.JobProfileCode.String
        }</span>
        <span class="cov0" title="0">var jobProfileName interface{}
        if entity.JobProfileName.Valid </span><span class="cov0" title="0">{
                jobProfileName = entity.JobProfileName.String
        }</span>
        <span class="cov0" title="0">var organizationName interface{}
        if entity.OrganizationName.Valid </span><span class="cov0" title="0">{
                organizationName = entity.OrganizationName.String
        }</span>
        <span class="cov0" title="0">var gradeLevel interface{}
        if entity.GradeLevel.Valid </span><span class="cov0" title="0">{
                gradeLevel = entity.GradeLevel.String
        }</span>
        <span class="cov0" title="0">var reportsTo interface{}
        if entity.ReportsToPosition.Valid </span><span class="cov0" title="0">{
                reportsTo = entity.ReportsToPosition.String
        }</span>
        <span class="cov0" title="0">var operationReason interface{}
        if entity.OperationReason.Valid </span><span class="cov0" title="0">{
                operationReason = entity.OperationReason.String
        }</span>

        <span class="cov0" title="0">err := r.queryRow(ctx, tx, query,
                entity.Title,
                jobProfileCode,
                jobProfileName,
                entity.JobFamilyGroupCode,
                entity.JobFamilyGroupName,
                entity.JobFamilyGroupRecord,
                entity.JobFamilyCode,
                entity.JobFamilyName,
                entity.JobFamilyRecord,
                entity.JobRoleCode,
                entity.JobRoleName,
                entity.JobRoleRecord,
                entity.JobLevelCode,
                entity.JobLevelName,
                entity.JobLevelRecord,
                entity.OrganizationCode,
                organizationName,
                entity.PositionType,
                entity.EmploymentType,
                gradeLevel,
                entity.HeadcountCapacity,
                reportsTo,
                entity.OperationType,
                entity.OperatedByID,
                entity.OperatedByName,
                operationReason,
                entity.Status,
                entity.TenantID,
                entity.RecordID,
        ).Scan(&amp;entity.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok &amp;&amp; pqErr.Code == "23503" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid foreign key reference during position update: %s", pqErr.Constraint)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update position: %w", err)</span>
        }
        <span class="cov0" title="0">return entity, nil</span>
}

// UpdatePositionOrganization 更新职位的组织归属
func (r *PositionRepository) UpdatePositionOrganization(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID, organizationCode string, organizationName *string, status string, operationType string, operatedByID uuid.UUID, operatedByName string, reason *string) error <span class="cov0" title="0">{
        query := `UPDATE positions SET organization_code = $1, organization_name = $2, status = $3, operation_type = $4, operated_by_id = $5, operated_by_name = $6, operation_reason = $7, updated_at = NOW()
WHERE tenant_id = $8 AND record_id = $9`

        var orgName interface{}
        if organizationName != nil &amp;&amp; *organizationName != "" </span><span class="cov0" title="0">{
                orgName = *organizationName
        }</span> else<span class="cov0" title="0"> {
                orgName = nil
        }</span>

        <span class="cov0" title="0">var reasonVal interface{}
        if reason != nil </span><span class="cov0" title="0">{
                reasonVal = *reason
        }</span> else<span class="cov0" title="0"> {
                reasonVal = nil
        }</span>

        <span class="cov0" title="0">if _, err := r.exec(ctx, tx, query,
                organizationCode,
                orgName,
                status,
                operationType,
                operatedByID,
                operatedByName,
                reasonVal,
                tenantID,
                recordID,
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update position organization: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetPositionByRecordID 查询指定版本
func (r *PositionRepository) GetPositionByRecordID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, recordID uuid.UUID) (*types.Position, error) <span class="cov0" title="0">{
        query := `SELECT record_id, tenant_id, code, title, job_profile_code, job_profile_name, job_family_group_code, job_family_group_name, job_family_group_record_id,
job_family_code, job_family_name, job_family_record_id, job_role_code, job_role_name, job_role_record_id,
job_level_code, job_level_name, job_level_record_id, organization_code, organization_name, position_type, status, employment_type,
headcount_capacity, headcount_in_use, grade_level, cost_center_code,
reports_to_position_code, profile, effective_date, end_date, is_current, created_at, updated_at, deleted_at, operation_type, operated_by_id, operated_by_name, operation_reason
FROM positions WHERE tenant_id = $1 AND record_id = $2 LIMIT 1`

        var entity types.Position
        err := r.queryRow(ctx, tx, query, tenantID, recordID).Scan(
                &amp;entity.RecordID,
                &amp;entity.TenantID,
                &amp;entity.Code,
                &amp;entity.Title,
                &amp;entity.JobProfileCode,
                &amp;entity.JobProfileName,
                &amp;entity.JobFamilyGroupCode,
                &amp;entity.JobFamilyGroupName,
                &amp;entity.JobFamilyGroupRecord,
                &amp;entity.JobFamilyCode,
                &amp;entity.JobFamilyName,
                &amp;entity.JobFamilyRecord,
                &amp;entity.JobRoleCode,
                &amp;entity.JobRoleName,
                &amp;entity.JobRoleRecord,
                &amp;entity.JobLevelCode,
                &amp;entity.JobLevelName,
                &amp;entity.JobLevelRecord,
                &amp;entity.OrganizationCode,
                &amp;entity.OrganizationName,
                &amp;entity.PositionType,
                &amp;entity.Status,
                &amp;entity.EmploymentType,
                &amp;entity.HeadcountCapacity,
                &amp;entity.HeadcountInUse,
                &amp;entity.GradeLevel,
                &amp;entity.CostCenterCode,
                &amp;entity.ReportsToPosition,
                &amp;entity.Profile,
                &amp;entity.EffectiveDate,
                &amp;entity.EndDate,
                &amp;entity.IsCurrent,
                &amp;entity.CreatedAt,
                &amp;entity.UpdatedAt,
                &amp;entity.DeletedAt,
                &amp;entity.OperationType,
                &amp;entity.OperatedByID,
                &amp;entity.OperatedByName,
                &amp;entity.OperationReason,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load position by record id: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

// GenerateCode 生成职位编码
func (r *PositionRepository) GenerateCode(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID) (string, error) <span class="cov0" title="0">{
        const minCode = 1000000
        const maxCode = 9999999
        for next := minCode; next &lt;= maxCode; next++ </span><span class="cov0" title="0">{
                candidate := fmt.Sprintf("P%07d", next)
                var exists bool
                query := `SELECT EXISTS(SELECT 1 FROM positions WHERE tenant_id = $1 AND code = $2)`
                if err := r.queryRow(ctx, tx, query, tenantID, candidate).Scan(&amp;exists); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to check position code uniqueness: %w", err)
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return candidate, nil
                }</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("unable to generate unique position code: exhausted available range")</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/dto"
        "github.com/google/uuid"
)

// GetAssignmentHistory 返回指定职位的完整任职历史记录。
func (r *PostgreSQLRepository) GetAssignmentHistory(
        ctx context.Context,
        tenantID uuid.UUID,
        positionCode string,
        filter *dto.PositionAssignmentFilterInput,
        pagination *dto.PaginationInput,
        sorting []dto.PositionAssignmentSortInput,
) (*dto.PositionAssignmentConnection, error) <span class="cov8" title="1">{
        trimmedCode := strings.TrimSpace(positionCode)
        if trimmedCode == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("positionCode is required")
        }</span>

        <span class="cov0" title="0">localFilter := dto.PositionAssignmentFilterInput{}
        if filter != nil </span><span class="cov0" title="0">{
                localFilter = *filter
        }</span>
        <span class="cov0" title="0">localFilter.IncludeHistorical = true

        return r.GetPositionAssignments(ctx, tenantID, trimmedCode, &amp;localFilter, pagination, sorting)</span>
}

// GetAssignmentStats 返回任职统计信息，可按职位或组织筛选。
func (r *PostgreSQLRepository) GetAssignmentStats(
        ctx context.Context,
        tenantID uuid.UUID,
        positionCode string,
        organizationCode string,
) (*dto.AssignmentStats, error) <span class="cov8" title="1">{
        args := []interface{}{tenantID.String()}
        conditions := []string{"pa.tenant_id = $1"}
        argIndex := 2

        trimmedPosition := strings.TrimSpace(positionCode)
        if trimmedPosition != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, fmt.Sprintf("pa.position_code = $%d", argIndex))
                args = append(args, trimmedPosition)
                argIndex++
        }</span>

        <span class="cov8" title="1">trimmedOrg := strings.TrimSpace(organizationCode)
        joinClause := ""
        if trimmedOrg != "" </span><span class="cov0" title="0">{
                joinClause = `
JOIN positions p ON p.tenant_id = pa.tenant_id AND p.code = pa.position_code
`
                conditions = append(conditions, fmt.Sprintf("p.organization_code = $%d", argIndex))
                args = append(args, trimmedOrg)
                argIndex++
        }</span>

        <span class="cov8" title="1">whereClause := strings.Join(conditions, " AND ")
        query := fmt.Sprintf(`
SELECT
    COUNT(*) AS total_count,
    COUNT(*) FILTER (WHERE pa.assignment_status = 'ACTIVE') AS active_count,
    COUNT(*) FILTER (WHERE pa.assignment_status = 'PENDING') AS pending_count,
    COUNT(*) FILTER (WHERE pa.assignment_status = 'ENDED') AS ended_count,
    COUNT(*) FILTER (WHERE pa.assignment_type = 'PRIMARY') AS primary_count,
    COUNT(*) FILTER (WHERE pa.assignment_type = 'SECONDARY') AS secondary_count,
    COUNT(*) FILTER (WHERE pa.assignment_type = 'ACTING') AS acting_count,
    COALESCE(MAX(pa.updated_at), MAX(pa.created_at)) AS last_updated
FROM position_assignments pa
%s
WHERE %s`, joinClause, whereClause)

        var (
                totalCount     sql.NullInt64
                activeCount    sql.NullInt64
                pendingCount   sql.NullInt64
                endedCount     sql.NullInt64
                primaryCount   sql.NullInt64
                secondaryCount sql.NullInt64
                actingCount    sql.NullInt64
                lastUpdated    sql.NullTime
        )

        if err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;totalCount,
                &amp;activeCount,
                &amp;pendingCount,
                &amp;endedCount,
                &amp;primaryCount,
                &amp;secondaryCount,
                &amp;actingCount,
                &amp;lastUpdated,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignment stats query failed: %w", err)
        }</span>

        <span class="cov8" title="1">statsTime := time.Now().UTC()
        if lastUpdated.Valid </span><span class="cov0" title="0">{
                statsTime = lastUpdated.Time
        }</span>

        <span class="cov8" title="1">stats := &amp;dto.AssignmentStats{
                TotalCountField:     int(totalCount.Int64),
                ActiveCountField:    int(activeCount.Int64),
                PendingCountField:   int(pendingCount.Int64),
                EndedCountField:     int(endedCount.Int64),
                PrimaryCountField:   int(primaryCount.Int64),
                SecondaryCountField: int(secondaryCount.Int64),
                ActingCountField:    int(actingCount.Int64),
                LastUpdatedAtField:  statsTime,
        }

        if trimmedPosition != "" </span><span class="cov0" title="0">{
                stats.PositionCodeField = &amp;trimmedPosition
        }</span>
        <span class="cov8" title="1">if trimmedOrg != "" </span><span class="cov0" title="0">{
                stats.OrganizationCodeField = &amp;trimmedOrg
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "cube-castle/internal/auth"
        "cube-castle/internal/organization/dto"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// 审计历史查询 - v4.6.0 基于record_id精确查询 + 租户隔离
func (r *PostgreSQLRepository) GetAuditHistory(ctx context.Context, tenantId uuid.UUID, recordId string, startDate, endDate, operation, userId *string, limit int) ([]dto.AuditRecordData, error) <span class="cov8" title="1">{
        start := time.Now()

        logFields := pkglogger.Fields{
                "tenantId": tenantId.String(),
                "recordId": recordId,
                "limit":    limit,
        }

        addOptional := func(key string, value *string) </span><span class="cov8" title="1">{
                if value != nil </span><span class="cov0" title="0">{
                        if trimmed := strings.TrimSpace(*value); trimmed != "" </span><span class="cov0" title="0">{
                                logFields[key] = trimmed
                        }</span>
                }
        }
        <span class="cov8" title="1">addOptional("startDate", startDate)
        addOptional("endDate", endDate)
        addOptional("operation", operation)
        addOptional("userId", userId)

        log := r.loggerFor("audit.history", logFields)

        recordUUID, err := uuid.Parse(recordId)
        if err != nil </span><span class="cov0" title="0">{
                log.Warn("invalid recordId")
                return nil, fmt.Errorf("INVALID_RECORD_ID")
        }</span>
        <span class="cov8" title="1">recordIDText := recordUUID.String()

        // 构建查询条件 - 基于record_id查询，包含完整变更信息，强制租户隔离
        baseQuery := `
                SELECT
                        id as audit_id,
                        resource_id as record_id,
                        event_type as operation_type,
                        actor_id as operated_by_id,
                        CASE WHEN business_context-&gt;&gt;'actor_name' IS NOT NULL
                                THEN business_context-&gt;&gt;'actor_name'
                                ELSE actor_id
                        END as operated_by_name,
                CASE WHEN changes IS NOT NULL
                        THEN jsonb_build_object(
                                'operationSummary', COALESCE(action_name, event_type, 'UNKNOWN'),
                                'totalChanges', jsonb_array_length(changes),
                                'keyChanges', changes
                        )::text
                        ELSE jsonb_build_object(
                                'operationSummary', COALESCE(action_name, event_type, 'UNKNOWN'),
                                'totalChanges', 0,
                                'keyChanges', jsonb_build_array()
                        )::text
                END as changes_summary,
                COALESCE(operation_reason, business_context-&gt;&gt;'operation_reason', business_context-&gt;&gt;'change_reason') as operation_reason,
                        timestamp,
                        request_data::text as before_data,
                        response_data::text as after_data,
                        CASE WHEN changes IS NOT NULL AND jsonb_typeof(changes) = 'array'
                                THEN (
                                        SELECT jsonb_agg(DISTINCT elem-&gt;&gt;'field')
                                        FROM jsonb_array_elements(changes) AS elem
                                        WHERE elem-&gt;&gt;'field' IS NOT NULL
                                )
                                ELSE '[]'::jsonb
                        END::text as modified_fields,
                        COALESCE(changes, '[]'::jsonb)::text as detailed_changes
                FROM audit_logs
                WHERE tenant_id = $1::uuid 
                  AND (
                        record_id = $2::uuid
                        OR (record_id IS NULL AND LOWER(resource_id) = LOWER($3))
                  )
                  AND resource_type IN ('ORGANIZATION', 'POSITION', 'JOB_CATALOG')`

        args := []interface{}{tenantId, recordUUID, recordIDText}
        argIndex := 4

        // 日期范围过滤
        if startDate != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND timestamp &gt;= $%d::timestamp", argIndex)
                args = append(args, *startDate)
                argIndex++
        }</span>

        <span class="cov8" title="1">if endDate != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND timestamp &lt;= $%d::timestamp", argIndex)
                args = append(args, *endDate)
                argIndex++
        }</span>

        // 操作类型过滤
        <span class="cov8" title="1">if operation != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND event_type = $%d", argIndex)
                args = append(args, strings.ToUpper(*operation))
                argIndex++
        }</span>

        // 操作人过滤
        <span class="cov8" title="1">if userId != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND actor_id = $%d", argIndex)
                args = append(args, *userId)
                argIndex++
        }</span>

        // 排序和限制
        <span class="cov8" title="1">finalQuery := baseQuery + fmt.Sprintf(" ORDER BY timestamp DESC LIMIT $%d", argIndex)
        args = append(args, limit)

        rows, err := r.db.QueryContext(ctx, finalQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("audit history query failed")
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var auditRecords []dto.AuditRecordData
        if r.auditConfig.LegacyMode </span><span class="cov0" title="0">{
                auditRecords, err = r.processAuditRowsLegacy(rows)
        }</span> else<span class="cov8" title="1"> {
                auditRecords, err = r.processAuditRowsStrict(rows)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{
                "result_count": len(auditRecords),
                "duration_ms":  duration.Milliseconds(),
        }).Info("audit history query succeeded")

        return auditRecords, nil</span>
}

func (r *PostgreSQLRepository) processAuditRowsLegacy(rows *sql.Rows) ([]dto.AuditRecordData, error) <span class="cov0" title="0">{
        logger := r.loggerFor("audit.history.legacy", nil)
        var auditRecords []dto.AuditRecordData
        for rows.Next() </span><span class="cov0" title="0">{
                var record dto.AuditRecordData
                var operatedById, operatedByName string
                var beforeData, afterData, modifiedFieldsJSON, detailedChangesJSON sql.NullString

                err := rows.Scan(
                        &amp;record.AuditIDField, &amp;record.RecordIDField, &amp;record.OperationTypeField,
                        &amp;operatedById, &amp;operatedByName,
                        &amp;record.ChangesSummaryField, &amp;record.OperationReasonField, &amp;record.TimestampField,
                        &amp;beforeData, &amp;afterData, &amp;modifiedFieldsJSON, &amp;detailedChangesJSON,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("audit history legacy scan failed")
                        return nil, err
                }</span>

                <span class="cov0" title="0">if beforeData.Valid </span><span class="cov0" title="0">{
                        record.BeforeDataField = &amp;beforeData.String
                }</span>
                <span class="cov0" title="0">if afterData.Valid </span><span class="cov0" title="0">{
                        record.AfterDataField = &amp;afterData.String
                }</span>

                <span class="cov0" title="0">if modifiedFieldsJSON.Valid &amp;&amp; modifiedFieldsJSON.String != "[]" </span><span class="cov0" title="0">{
                        var modifiedFields []string
                        if err := json.Unmarshal([]byte(modifiedFieldsJSON.String), &amp;modifiedFields); err == nil </span><span class="cov0" title="0">{
                                record.ModifiedFieldsField = modifiedFields
                        }</span>
                }

                <span class="cov0" title="0">if detailedChangesJSON.Valid &amp;&amp; detailedChangesJSON.String != "[]" </span><span class="cov0" title="0">{
                        var changesArray []map[string]interface{}
                        if err := json.Unmarshal([]byte(detailedChangesJSON.String), &amp;changesArray); err == nil </span><span class="cov0" title="0">{
                                for _, changeMap := range changesArray </span><span class="cov0" title="0">{
                                        fieldChange := dto.FieldChangeData{
                                                FieldField:    fmt.Sprintf("%v", changeMap["field"]),
                                                OldValueField: changeMap["oldValue"],
                                                NewValueField: changeMap["newValue"],
                                                DataTypeField: fmt.Sprintf("%v", changeMap["dataType"]),
                                        }
                                        record.ChangesField = append(record.ChangesField, fieldChange)
                                }</span>
                        }
                }

                <span class="cov0" title="0">record.OperatedByField = dto.OperatedByData{
                        IDField:   operatedById,
                        NameField: operatedByName,
                }

                auditRecords = append(auditRecords, record)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return auditRecords, nil</span>
}

func (r *PostgreSQLRepository) processAuditRowsStrict(rows *sql.Rows) ([]dto.AuditRecordData, error) <span class="cov8" title="1">{
        logger := r.loggerFor("audit.history.strict", nil)
        var auditRecords []dto.AuditRecordData
        for rows.Next() </span><span class="cov8" title="1">{
                var record dto.AuditRecordData
                var operatedById, operatedByName string
                var beforeData, afterData, modifiedFieldsJSON, detailedChangesJSON sql.NullString

                record.ModifiedFieldsField = make([]string, 0)
                record.ChangesField = make([]dto.FieldChangeData, 0)

                err := rows.Scan(
                        &amp;record.AuditIDField, &amp;record.RecordIDField, &amp;record.OperationTypeField,
                        &amp;operatedById, &amp;operatedByName,
                        &amp;record.ChangesSummaryField, &amp;record.OperationReasonField, &amp;record.TimestampField,
                        &amp;beforeData, &amp;afterData, &amp;modifiedFieldsJSON, &amp;detailedChangesJSON,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{"error": err}).Error("audit history strict scan failed")
                        return nil, err
                }</span>

                <span class="cov8" title="1">if beforeData.Valid </span><span class="cov8" title="1">{
                        record.BeforeDataField = &amp;beforeData.String
                }</span>
                <span class="cov8" title="1">if afterData.Valid </span><span class="cov8" title="1">{
                        record.AfterDataField = &amp;afterData.String
                }</span>

                <span class="cov8" title="1">rawModified := ""
                if modifiedFieldsJSON.Valid </span><span class="cov8" title="1">{
                        rawModified = modifiedFieldsJSON.String
                }</span>
                <span class="cov8" title="1">sanitizedModified, modifiedIssues, modErr := sanitizeModifiedFields(rawModified)
                if modErr == nil </span><span class="cov8" title="1">{
                        record.ModifiedFieldsField = sanitizedModified
                }</span>

                <span class="cov8" title="1">rawChanges := ""
                if detailedChangesJSON.Valid </span><span class="cov8" title="1">{
                        rawChanges = detailedChangesJSON.String
                }</span>
                <span class="cov8" title="1">sanitizedChanges, changeIssues, changeErr := sanitizeChanges(rawChanges)
                if changeErr == nil </span><span class="cov8" title="1">{
                        record.ChangesField = sanitizedChanges
                }</span>

                <span class="cov8" title="1">trimmedChanges := strings.TrimSpace(rawChanges)
                trimmedModified := strings.TrimSpace(rawModified)
                beforeSnapshotEmpty := isEmptySnapshot(record.BeforeDataField)
                afterSnapshotEmpty := isEmptySnapshot(record.AfterDataField)
                noSnapshots := beforeSnapshotEmpty &amp;&amp; afterSnapshotEmpty

                if isEmptyArrayOrNull(trimmedChanges) &amp;&amp; isEmptyArrayOrNull(trimmedModified) &amp;&amp; len(record.ChangesField) == 0 &amp;&amp; len(record.ModifiedFieldsField) == 0 &amp;&amp; noSnapshots </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">issues := make([]string, 0, len(modifiedIssues)+len(changeIssues))
                issues = append(issues, modifiedIssues...)
                issues = append(issues, changeIssues...)

                hasHardError := false
                if modErr != nil </span><span class="cov0" title="0">{
                        hasHardError = true
                        issues = append(issues, fmt.Sprintf("modified_fields JSON 无效: %v", modErr))
                }</span>
                <span class="cov8" title="1">if changeErr != nil </span><span class="cov0" title="0">{
                        hasHardError = true
                        issues = append(issues, fmt.Sprintf("changes JSON 无效: %v", changeErr))
                }</span>

                <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{
                                "auditId": record.AuditIDField,
                                "issues":  strings.Join(issues, "; "),
                        }).Warn("audit record data warnings")
                        if r.auditConfig.StrictValidation </span><span class="cov0" title="0">{
                                if hasHardError &amp;&amp; !r.auditConfig.AllowFallback </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("AUDIT_HISTORY_VALIDATION_FAILED")
                                }</span>
                                <span class="cov0" title="0">if r.registerValidationFailure() </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("AUDIT_HISTORY_CIRCUIT_OPEN")
                                }</span>
                        }
                } else<span class="cov8" title="1"> if r.auditConfig.StrictValidation </span><span class="cov0" title="0">{
                        r.registerValidationSuccess()
                }</span>

                <span class="cov8" title="1">record.OperatedByField = dto.OperatedByData{
                        IDField:   operatedById,
                        NameField: operatedByName,
                }

                auditRecords = append(auditRecords, record)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return auditRecords, nil</span>
}

func (r *PostgreSQLRepository) GetPositionTransfers(ctx context.Context, tenantID uuid.UUID, positionCode *string, organizationCode *string, pagination *dto.PaginationInput) (*dto.PositionTransferConnection, error) <span class="cov0" title="0">{
        page := int32(1)
        pageSize := int32(25)
        if pagination != nil </span><span class="cov0" title="0">{
                if pagination.Page &gt; 0 </span><span class="cov0" title="0">{
                        page = pagination.Page
                }</span>
                <span class="cov0" title="0">if pagination.PageSize &gt; 0 </span><span class="cov0" title="0">{
                        pageSize = pagination.PageSize
                        if pageSize &gt; 200 </span><span class="cov0" title="0">{
                                pageSize = 200
                        }</span>
                }
        }
        <span class="cov0" title="0">offset := int((page - 1) * pageSize)
        limit := int(pageSize)

        baseFilters := []string{
                "a.tenant_id = $1",
                "a.resource_type = 'POSITION'",
                "a.action_name = 'TransferPosition'",
                "a.success = true",
        }
        args := []interface{}{tenantID.String()}
        argIndex := 2

        whereClause := strings.Join(baseFilters, " AND ")

        filterConditions := []string{"1=1"}
        if positionCode != nil &amp;&amp; strings.TrimSpace(*positionCode) != "" </span><span class="cov0" title="0">{
                whereClause += fmt.Sprintf(" AND (a.response_data-&gt;&gt;'code') = $%d", argIndex)
                filterConditions = append(filterConditions, fmt.Sprintf("final.position_code = $%d", argIndex))
                args = append(args, strings.TrimSpace(*positionCode))
                argIndex++
        }</span>
        <span class="cov0" title="0">if organizationCode != nil &amp;&amp; strings.TrimSpace(*organizationCode) != "" </span><span class="cov0" title="0">{
                filterConditions = append(filterConditions, fmt.Sprintf("(final.from_org_code = $%d OR final.to_org_code = $%d)", argIndex, argIndex))
                args = append(args, strings.TrimSpace(*organizationCode))
                argIndex++
        }</span>

        <span class="cov0" title="0">filterClause := strings.Join(filterConditions, " AND ")

        baseCTE := fmt.Sprintf(`
WITH raw AS (
        SELECT
                a.id,
                a.resource_id,
                a.timestamp,
                a.operation_reason,
                a.request_data,
                a.response_data,
                a.changes,
                a.business_context,
                a.actor_id,
                a.actor_type,
                a.response_data-&gt;&gt;'code' AS position_code,
                change_ctx.old_value AS change_old_org,
                change_ctx.new_value AS change_new_org
        FROM audit_logs a
        LEFT JOIN LATERAL (
                SELECT elem-&gt;&gt;'oldValue' AS old_value,
                           elem-&gt;&gt;'newValue' AS new_value
                FROM jsonb_array_elements(a.changes) elem
                WHERE elem-&gt;&gt;'field' IN ('organizationCode', 'organization_code')
                ORDER BY elem-&gt;&gt;'field'
                LIMIT 1
        ) change_ctx ON true
        WHERE %s
),
normalized AS (
        SELECT
                id,
                resource_id,
                position_code,
                COALESCE(change_new_org, response_data-&gt;&gt;'organizationCode') AS to_org_code,
                COALESCE(change_old_org, request_data-&gt;&gt;'organizationCode') AS explicit_from_org,
                timestamp,
                operation_reason,
                actor_id,
                actor_type,
                business_context
        FROM raw
),
with_prev AS (
        SELECT
                id,
                resource_id,
                position_code,
                to_org_code,
                COALESCE(explicit_from_org,
                        LAG(to_org_code) OVER (PARTITION BY resource_id ORDER BY timestamp)
                ) AS from_org_code,
                timestamp,
                operation_reason,
                actor_id,
                actor_type,
                business_context
        FROM normalized
),
final AS (
        SELECT
                id,
                resource_id,
                position_code,
                COALESCE(from_org_code, to_org_code) AS from_org_code,
                COALESCE(to_org_code, from_org_code) AS to_org_code,
                timestamp,
                operation_reason,
                actor_id,
                actor_type,
                business_context
        FROM with_prev
)
`, whereClause)

        countArgs := append([]interface{}{}, args...)
        countQuery := fmt.Sprintf(`%s SELECT COUNT(*) FROM final WHERE %s`, baseCTE, filterClause)

        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count position transfers: %w", err)
        }</span>

        <span class="cov0" title="0">dataArgs := append([]interface{}{}, args...)
        limitIdx := len(dataArgs) + 1
        dataArgs = append(dataArgs, limit)
        offsetIdx := len(dataArgs) + 1
        dataArgs = append(dataArgs, offset)

        dataQuery := fmt.Sprintf(`
%s
SELECT
        final.id::text,
        final.position_code,
        final.from_org_code,
        final.to_org_code,
        CASE 
                WHEN COALESCE(final.business_context-&gt;&gt;'effectiveDate', '') &lt;&gt; '' THEN (final.business_context-&gt;&gt;'effectiveDate')::date
                ELSE DATE(final.timestamp)
        END AS effective_date,
        final.timestamp,
        final.operation_reason,
        final.actor_id,
        COALESCE(
                NULLIF(trim(final.business_context-&gt;&gt;'operatorName'), ''),
                NULLIF(trim(final.business_context-&gt;&gt;'actorName'), ''),
                final.actor_id
        ) AS actor_name
FROM final
WHERE %s
ORDER BY final.timestamp DESC
LIMIT $%d OFFSET $%d
`, baseCTE, filterClause, limitIdx, offsetIdx)

        rows, err := r.db.QueryContext(ctx, dataQuery, dataArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query position transfers: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        transfers := make([]dto.PositionTransfer, 0, limit)
        for rows.Next() </span><span class="cov0" title="0">{
                record, scanErr := scanPositionTransfer(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov0" title="0">transfers = append(transfers, *record)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate position transfers: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := 0
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages = (total + int(pageSize) - 1) / int(pageSize)
        }</span>

        <span class="cov0" title="0">edges := make([]dto.PositionTransferEdge, 0, len(transfers))
        for _, item := range transfers </span><span class="cov0" title="0">{
                edges = append(edges, dto.PositionTransferEdge{
                        CursorField: item.TransferIDField,
                        NodeField:   item,
                })
        }</span>

        <span class="cov0" title="0">connection := &amp;dto.PositionTransferConnection{
                EdgesField: edges,
                DataField:  transfers,
                PaginationField: dto.PaginationInfo{
                        TotalField:       total,
                        PageField:        int(page),
                        PageSizeField:    int(pageSize),
                        HasNextField:     int(page) &lt; totalPages,
                        HasPreviousField: page &gt; 1,
                },
                TotalCountField: total,
        }

        return connection, nil</span>
}

func scanPositionTransfer(scanner rowScanner) (*dto.PositionTransfer, error) <span class="cov0" title="0">{
        var (
                transferID    string
                positionCode  string
                fromOrg       string
                toOrg         string
                effectiveDate time.Time
                createdAt     time.Time
                reason        sql.NullString
                actorID       string
                actorName     string
        )

        if err := scanner.Scan(
                &amp;transferID,
                &amp;positionCode,
                &amp;fromOrg,
                &amp;toOrg,
                &amp;effectiveDate,
                &amp;createdAt,
                &amp;reason,
                &amp;actorID,
                &amp;actorName,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan position transfer: %w", err)
        }</span>

        <span class="cov0" title="0">transfer := &amp;dto.PositionTransfer{
                TransferIDField:           transferID,
                PositionCodeField:         positionCode,
                FromOrganizationCodeField: fromOrg,
                ToOrganizationCodeField:   toOrg,
                EffectiveDateField:        effectiveDate,
                CreatedAtField:            createdAt,
                InitiatedByField: dto.OperatedByData{
                        IDField:   actorID,
                        NameField: actorName,
                },
        }

        if reason.Valid </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(reason.String)
                if trimmed != "" </span><span class="cov0" title="0">{
                        transfer.OperationReasonField = &amp;trimmed
                }</span>
        }

        <span class="cov0" title="0">return transfer, nil</span>
}

func (r *PostgreSQLRepository) registerValidationFailure() bool <span class="cov8" title="1">{
        count := atomic.AddInt32(&amp;r.validationFailureCount, 1)
        if r.auditConfig.CircuitBreakerThreshold &gt; 0 &amp;&amp; count &gt;= r.auditConfig.CircuitBreakerThreshold </span><span class="cov8" title="1">{
                r.loggerFor("audit.history.validation", pkglogger.Fields{
                        "failureCount": count,
                        "threshold":    r.auditConfig.CircuitBreakerThreshold,
                }).Error("audit history validation reached circuit breaker threshold")
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (r *PostgreSQLRepository) registerValidationSuccess() <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;r.validationFailureCount) != 0 </span><span class="cov8" title="1">{
                atomic.StoreInt32(&amp;r.validationFailureCount, 0)
        }</span>
}

// 单条审计记录查询 - v4.6.0
func (r *PostgreSQLRepository) GetAuditLog(ctx context.Context, auditId string) (*dto.AuditRecordData, error) <span class="cov0" title="0">{
        start := time.Now()

        tenantID := auth.GetTenantID(ctx)
        log := r.loggerFor("audit.log", pkglogger.Fields{
                "auditId":  auditId,
                "tenantId": tenantID,
        })

        query := `
        SELECT 
            id as audit_id, 
            resource_id as record_id, 
            event_type as operation_type,
            actor_id as operated_by_id, 
            CASE WHEN business_context-&gt;&gt;'actor_name' IS NOT NULL 
                THEN business_context-&gt;&gt;'actor_name' 
                ELSE actor_id 
            END as operated_by_name,
            CASE WHEN changes IS NOT NULL 
                THEN changes::text 
                ELSE '{"operationSummary":"' || action_name || '","totalChanges":0,"keyChanges":[]}' 
            END as changes_summary,
            COALESCE(operation_reason, business_context-&gt;&gt;'operation_reason', business_context-&gt;&gt;'change_reason') as operation_reason,
            timestamp,
            before_data::text as before_data, 
            after_data::text as after_data
        FROM audit_logs 
        WHERE id = $1::uuid AND resource_type = 'ORGANIZATION' AND tenant_id = $2::uuid
        LIMIT 1`
        if tenantID == "" </span><span class="cov0" title="0">{
                log.Warn("tenant required for audit log query")
                return nil, fmt.Errorf("TENANT_REQUIRED")
        }</span>

        <span class="cov0" title="0">row := r.db.QueryRowContext(ctx, query, auditId, tenantID)

        var record dto.AuditRecordData
        var operatedById, operatedByName string
        var beforeData, afterData sql.NullString

        err := row.Scan(
                &amp;record.AuditIDField, &amp;record.RecordIDField, &amp;record.OperationTypeField,
                &amp;operatedById, &amp;operatedByName,
                &amp;record.ChangesSummaryField, &amp;record.OperationReasonField, &amp;record.TimestampField,
                &amp;beforeData, &amp;afterData,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Debug("audit log not found")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"error": err}).Error("audit log query failed")
                return nil, err</span>
        }

        // 正确处理JSONB字段
        <span class="cov0" title="0">if beforeData.Valid </span><span class="cov0" title="0">{
                record.BeforeDataField = &amp;beforeData.String
        }</span>
        <span class="cov0" title="0">if afterData.Valid </span><span class="cov0" title="0">{
                record.AfterDataField = &amp;afterData.String
        }</span>

        // 构建操作人信息
        <span class="cov0" title="0">record.OperatedByField = dto.OperatedByData{
                IDField:   operatedById,
                NameField: operatedByName,
        }

        duration := time.Since(start)
        log.WithFields(pkglogger.Fields{"duration_ms": duration.Milliseconds()}).Info("audit log query succeeded")

        return &amp;record, nil</span>
}

func sanitizeModifiedFields(raw string) ([]string, []string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(raw)
        if trimmed == "" </span><span class="cov8" title="1">{
                return make([]string, 0), nil, nil
        }</span>
        <span class="cov8" title="1">if trimmed == "null" </span><span class="cov8" title="1">{
                return make([]string, 0), []string{"modified_fields 为 null，已替换为空数组"}, nil
        }</span>

        <span class="cov8" title="1">var rawArray []interface{}
        if err := json.Unmarshal([]byte(trimmed), &amp;rawArray); err != nil </span><span class="cov8" title="1">{
                return make([]string, 0), nil, err
        }</span>

        <span class="cov8" title="1">sanitized := make([]string, 0, len(rawArray))
        issues := make([]string, 0)
        for idx, item := range rawArray </span><span class="cov8" title="1">{
                if item == nil </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("modified_fields[%d] 为 null，已忽略", idx))
                        continue</span>
                }
                <span class="cov8" title="1">switch v := item.(type) </span>{
                case string:<span class="cov8" title="1">
                        sanitized = append(sanitized, v)</span>
                default:<span class="cov8" title="1">
                        sanitized = append(sanitized, fmt.Sprintf("%v", v))
                        issues = append(issues, fmt.Sprintf("modified_fields[%d] 非字符串，已转换", idx))</span>
                }
        }

        <span class="cov8" title="1">return sanitized, issues, nil</span>
}

func sanitizeChanges(raw string) ([]dto.FieldChangeData, []string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(raw)
        if trimmed == "" </span><span class="cov0" title="0">{
                return make([]dto.FieldChangeData, 0), nil, nil
        }</span>
        <span class="cov8" title="1">if trimmed == "null" </span><span class="cov0" title="0">{
                return make([]dto.FieldChangeData, 0), []string{"changes 为 null，已替换为空数组"}, nil
        }</span>

        <span class="cov8" title="1">var rawArray []map[string]interface{}
        if err := json.Unmarshal([]byte(trimmed), &amp;rawArray); err != nil </span><span class="cov8" title="1">{
                return make([]dto.FieldChangeData, 0), nil, err
        }</span>

        <span class="cov8" title="1">sanitized := make([]dto.FieldChangeData, 0, len(rawArray))
        issues := make([]string, 0)
        for idx, entry := range rawArray </span><span class="cov8" title="1">{
                if entry == nil </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("changes[%d] 为空对象，已跳过", idx))
                        continue</span>
                }

                <span class="cov8" title="1">fieldVal, ok := entry["field"]
                if !ok </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("changes[%d] 缺少 field，已跳过", idx))
                        continue</span>
                }
                <span class="cov8" title="1">field := strings.TrimSpace(fmt.Sprintf("%v", fieldVal))
                if field == "" </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("changes[%d] field 为空，已跳过", idx))
                        continue</span>
                }

                <span class="cov8" title="1">oldVal := entry["oldValue"]
                newVal := entry["newValue"]

                dataType := ""
                if dtVal, ok := entry["dataType"]; ok </span><span class="cov8" title="1">{
                        if dtStr, ok := dtVal.(string); ok </span><span class="cov8" title="1">{
                                dataType = strings.TrimSpace(dtStr)
                                if dataType == "" </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("changes[%d] dataType 为空字符串，尝试推断", idx))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                issues = append(issues, fmt.Sprintf("changes[%d] dataType 非字符串，尝试推断", idx))
                        }</span>
                }
                <span class="cov8" title="1">if strings.EqualFold(dataType, "unknown") </span><span class="cov0" title="0">{
                        if inferred := inferFieldDataType(oldVal, newVal); inferred != "unknown" </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("changes[%d] dataType=unknown，推断为 %s", idx, inferred))
                                dataType = inferred
                        }</span>
                }

                <span class="cov8" title="1">if dataType == "" </span><span class="cov8" title="1">{
                        inferred := inferFieldDataType(oldVal, newVal)
                        if inferred == "unknown" </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("changes[%d] 缺少 dataType，使用 unknown", idx))
                        }</span> else<span class="cov8" title="1"> {
                                issues = append(issues, fmt.Sprintf("changes[%d] 缺少 dataType，推断为 %s", idx, inferred))
                        }</span>
                        <span class="cov8" title="1">dataType = inferred</span>
                }

                <span class="cov8" title="1">fieldChange := dto.FieldChangeData{
                        FieldField:    field,
                        DataTypeField: dataType,
                        OldValueField: normalizeChangeValue(oldVal),
                        NewValueField: normalizeChangeValue(newVal),
                }
                sanitized = append(sanitized, fieldChange)</span>
        }

        <span class="cov8" title="1">return sanitized, issues, nil</span>
}

func inferFieldDataType(oldVal, newVal interface{}) string <span class="cov8" title="1">{
        value := firstNonNil(newVal, oldVal)
        if value == nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov8" title="1">switch value.(type) </span>{
        case string:<span class="cov8" title="1">
                return "string"</span>
        case bool:<span class="cov0" title="0">
                return "boolean"</span>
        case float64, json.Number:<span class="cov0" title="0">
                return "number"</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return "object"</span>
        case []interface{}:<span class="cov0" title="0">
                return "array"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func firstNonNil(values ...interface{}) interface{} <span class="cov8" title="1">{
        for _, val := range values </span><span class="cov8" title="1">{
                if val != nil </span><span class="cov8" title="1">{
                        return val
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func isEmptyArrayOrNull(raw string) bool <span class="cov8" title="1">{
        switch raw </span>{
        case "", "[]", "null":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isEmptySnapshot(value *string) bool <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return isEmptyJSONPayload(*value)</span>
}

func isEmptyJSONPayload(raw string) bool <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(raw)
        switch trimmed </span>{
        case "", "{}", "[]", "null":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func normalizeChangeValue(val interface{}) interface{} <span class="cov8" title="1">{
        if val == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch v := val.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case bool:<span class="cov8" title="1">
                if v </span><span class="cov8" title="1">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        case float64:<span class="cov8" title="1">
                return strconv.FormatFloat(v, 'f', -1, 64)</span>
        case json.Number:<span class="cov0" title="0">
                return v.String()</span>
        default:<span class="cov8" title="1">
                bytes, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%v", v)
                }</span>
                <span class="cov8" title="1">return string(bytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "database/sql"

        pkglogger "cube-castle/pkg/logger"
        "github.com/redis/go-redis/v9"
)

type AuditHistoryConfig struct {
        StrictValidation        bool
        AllowFallback           bool
        CircuitBreakerThreshold int32
        LegacyMode              bool
}

// PostgreSQLRepository 提供查询服务的数据访问能力
type PostgreSQLRepository struct {
        db                     *sql.DB
        redisClient            *redis.Client
        logger                 pkglogger.Logger
        auditConfig            AuditHistoryConfig
        validationFailureCount int32
}

func NewPostgreSQLRepository(db *sql.DB, redisClient *redis.Client, logger pkglogger.Logger, auditConfig AuditHistoryConfig) *PostgreSQLRepository <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">return &amp;PostgreSQLRepository{
                db:          db,
                redisClient: redisClient,
                logger: logger.WithFields(pkglogger.Fields{
                        "component": "query-repo",
                }),
                auditConfig: auditConfig,
        }</span>
}

func (r *PostgreSQLRepository) loggerFor(operation string, fields pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        log := r.logger
        if operation != "" </span><span class="cov8" title="1">{
                log = log.WithFields(pkglogger.Fields{"operation": operation})
        }</span>
        <span class="cov8" title="1">if len(fields) == 0 </span><span class="cov8" title="1">{
                return log
        }</span>
        <span class="cov8" title="1">return log.WithFields(fields)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "cube-castle/internal/organization/dto"
        "github.com/google/uuid"
)

func (r *PostgreSQLRepository) GetJobFamilyGroups(ctx context.Context, tenantID uuid.UUID, includeInactive bool, asOfDate *string) ([]dto.JobFamilyGroup, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String()}
        whereParts := []string{"tenant_id = $1"}
        argIndex := 2

        if asOfDate != nil &amp;&amp; strings.TrimSpace(*asOfDate) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("effective_date &lt;= $%d", argIndex))
                whereParts = append(whereParts, fmt.Sprintf("(end_date IS NULL OR end_date &gt; $%d)", argIndex))
                args = append(args, strings.TrimSpace(*asOfDate))
                argIndex++
        }</span> else<span class="cov0" title="0"> {
                whereParts = append(whereParts, "is_current = true")
        }</span>

        <span class="cov0" title="0">if !includeInactive </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "status = 'ACTIVE'")
        }</span>

        <span class="cov0" title="0">whereClause := ""
        if len(whereParts) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = "WHERE " + strings.Join(whereParts, " AND ")
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
SELECT DISTINCT ON (family_group_code)
    record_id::text,
    tenant_id::text,
    family_group_code,
    name,
    description,
    status,
    effective_date,
    end_date,
    is_current
FROM job_family_groups
%s
ORDER BY family_group_code, effective_date DESC, created_at DESC
`, whereClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query job family groups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []dto.JobFamilyGroup
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        item      dto.JobFamilyGroup
                        desc      sql.NullString
                        endDate   sql.NullTime
                        isCurrent bool
                )
                if err := rows.Scan(
                        &amp;item.RecordIDField,
                        &amp;item.TenantIDField,
                        &amp;item.CodeField,
                        &amp;item.NameField,
                        &amp;desc,
                        &amp;item.StatusField,
                        &amp;item.EffectiveDateField,
                        &amp;endDate,
                        &amp;isCurrent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan job family group: %w", err)
                }</span>
                <span class="cov0" title="0">if desc.Valid </span><span class="cov0" title="0">{
                        item.DescriptionField = &amp;desc.String
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        item.EndDateField = &amp;endDate.Time
                }</span>
                <span class="cov0" title="0">item.IsCurrentField = isCurrent
                result = append(result, item)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate job family groups: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *PostgreSQLRepository) GetJobFamilies(ctx context.Context, tenantID uuid.UUID, groupCode string, includeInactive bool, asOfDate *string) ([]dto.JobFamily, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String(), strings.TrimSpace(groupCode)}
        whereParts := []string{"tenant_id = $1", "family_group_code = $2"}
        argIndex := 3

        if asOfDate != nil &amp;&amp; strings.TrimSpace(*asOfDate) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("effective_date &lt;= $%d", argIndex))
                whereParts = append(whereParts, fmt.Sprintf("(end_date IS NULL OR end_date &gt; $%d)", argIndex))
                args = append(args, strings.TrimSpace(*asOfDate))
                argIndex++
        }</span> else<span class="cov0" title="0"> {
                whereParts = append(whereParts, "is_current = true")
        }</span>

        <span class="cov0" title="0">if !includeInactive </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "status = 'ACTIVE'")
        }</span>

        <span class="cov0" title="0">whereClause := "WHERE " + strings.Join(whereParts, " AND ")

        query := fmt.Sprintf(`
SELECT DISTINCT ON (family_code)
    record_id::text,
    tenant_id::text,
    family_code,
    name,
    description,
    status,
    effective_date,
    end_date,
    is_current,
    family_group_code
FROM job_families
%s
ORDER BY family_code, effective_date DESC, created_at DESC
`, whereClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query job families: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []dto.JobFamily
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        item      dto.JobFamily
                        desc      sql.NullString
                        endDate   sql.NullTime
                        isCurrent bool
                )
                if err := rows.Scan(
                        &amp;item.RecordIDField,
                        &amp;item.TenantIDField,
                        &amp;item.CodeField,
                        &amp;item.NameField,
                        &amp;desc,
                        &amp;item.StatusField,
                        &amp;item.EffectiveDateField,
                        &amp;endDate,
                        &amp;isCurrent,
                        &amp;item.FamilyGroupCodeField,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan job family: %w", err)
                }</span>
                <span class="cov0" title="0">if desc.Valid </span><span class="cov0" title="0">{
                        item.DescriptionField = &amp;desc.String
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        item.EndDateField = &amp;endDate.Time
                }</span>
                <span class="cov0" title="0">item.IsCurrentField = isCurrent
                result = append(result, item)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate job families: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *PostgreSQLRepository) GetJobRoles(ctx context.Context, tenantID uuid.UUID, familyCode string, includeInactive bool, asOfDate *string) ([]dto.JobRole, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String(), strings.TrimSpace(familyCode)}
        whereParts := []string{"tenant_id = $1", "family_code = $2"}
        argIndex := 3

        if asOfDate != nil &amp;&amp; strings.TrimSpace(*asOfDate) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("effective_date &lt;= $%d", argIndex))
                whereParts = append(whereParts, fmt.Sprintf("(end_date IS NULL OR end_date &gt; $%d)", argIndex))
                args = append(args, strings.TrimSpace(*asOfDate))
                argIndex++
        }</span> else<span class="cov0" title="0"> {
                whereParts = append(whereParts, "is_current = true")
        }</span>

        <span class="cov0" title="0">if !includeInactive </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "status = 'ACTIVE'")
        }</span>

        <span class="cov0" title="0">whereClause := "WHERE " + strings.Join(whereParts, " AND ")

        query := fmt.Sprintf(`
SELECT DISTINCT ON (role_code)
    record_id::text,
    tenant_id::text,
    role_code,
    name,
    description,
    status,
    effective_date,
    end_date,
    is_current,
    family_code
FROM job_roles
%s
ORDER BY role_code, effective_date DESC, created_at DESC
`, whereClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query job roles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []dto.JobRole
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        item      dto.JobRole
                        desc      sql.NullString
                        endDate   sql.NullTime
                        isCurrent bool
                )
                if err := rows.Scan(
                        &amp;item.RecordIDField,
                        &amp;item.TenantIDField,
                        &amp;item.CodeField,
                        &amp;item.NameField,
                        &amp;desc,
                        &amp;item.StatusField,
                        &amp;item.EffectiveDateField,
                        &amp;endDate,
                        &amp;isCurrent,
                        &amp;item.FamilyCodeField,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan job role: %w", err)
                }</span>
                <span class="cov0" title="0">if desc.Valid </span><span class="cov0" title="0">{
                        item.DescriptionField = &amp;desc.String
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        item.EndDateField = &amp;endDate.Time
                }</span>
                <span class="cov0" title="0">item.IsCurrentField = isCurrent
                result = append(result, item)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate job roles: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *PostgreSQLRepository) GetJobLevels(ctx context.Context, tenantID uuid.UUID, roleCode string, includeInactive bool, asOfDate *string) ([]dto.JobLevel, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String(), strings.TrimSpace(roleCode)}
        whereParts := []string{"tenant_id = $1", "role_code = $2"}
        argIndex := 3

        if asOfDate != nil &amp;&amp; strings.TrimSpace(*asOfDate) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("effective_date &lt;= $%d", argIndex))
                whereParts = append(whereParts, fmt.Sprintf("(end_date IS NULL OR end_date &gt; $%d)", argIndex))
                args = append(args, strings.TrimSpace(*asOfDate))
                argIndex++
        }</span> else<span class="cov0" title="0"> {
                whereParts = append(whereParts, "is_current = true")
        }</span>

        <span class="cov0" title="0">if !includeInactive </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "status = 'ACTIVE'")
        }</span>

        <span class="cov0" title="0">whereClause := "WHERE " + strings.Join(whereParts, " AND ")

        query := fmt.Sprintf(`
SELECT DISTINCT ON (level_code)
    record_id::text,
    tenant_id::text,
    level_code,
    name,
    description,
    status,
    effective_date,
    end_date,
    is_current,
    role_code,
    level_rank
FROM job_levels
%s
ORDER BY level_code, effective_date DESC, created_at DESC
`, whereClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query job levels: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []dto.JobLevel
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        item      dto.JobLevel
                        desc      sql.NullString
                        endDate   sql.NullTime
                        isCurrent bool
                )
                if err := rows.Scan(
                        &amp;item.RecordIDField,
                        &amp;item.TenantIDField,
                        &amp;item.CodeField,
                        &amp;item.NameField,
                        &amp;desc,
                        &amp;item.StatusField,
                        &amp;item.EffectiveDateField,
                        &amp;endDate,
                        &amp;isCurrent,
                        &amp;item.RoleCodeField,
                        &amp;item.LevelRankField,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan job level: %w", err)
                }</span>
                <span class="cov0" title="0">if desc.Valid </span><span class="cov0" title="0">{
                        item.DescriptionField = &amp;desc.String
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        item.EndDateField = &amp;endDate.Time
                }</span>
                <span class="cov0" title="0">item.IsCurrentField = isCurrent
                result = append(result, item)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate job levels: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "context"
        "database/sql"
        "time"

        "cube-castle/internal/organization/dto"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// 单个组织查询 - 超快速索引查询
func (r *PostgreSQLRepository) GetOrganization(ctx context.Context, tenantID uuid.UUID, code string) (*dto.Organization, error) <span class="cov0" title="0">{
        // 使用 idx_current_record_fast 索引
        query := `
        SELECT record_id, tenant_id, code, parent_code, name, unit_type, status, 
               level,
               COALESCE(code_path, '/' || code) AS code_path,
               COALESCE(name_path, '/' || name) AS name_path,
               sort_order, description, profile, created_at, updated_at,
               effective_date, end_date, is_current, change_reason,
               deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason
        FROM organization_units 
        WHERE tenant_id = $1 AND code = $2 AND is_current = true AND status &lt;&gt; 'DELETED'
        LIMIT 1`

        log := r.loggerFor("organization.get", pkglogger.Fields{
                "tenantId": tenantID.String(),
                "code":     code,
        })
        start := time.Now()
        row := r.db.QueryRowContext(ctx, query, tenantID.String(), code)

        var org dto.Organization
        err := row.Scan(
                &amp;org.RecordIDField, &amp;org.TenantIDField, &amp;org.CodeField, &amp;org.ParentCodeField, &amp;org.NameField,
                &amp;org.UnitTypeField, &amp;org.StatusField, &amp;org.LevelField, &amp;org.CodePathField, &amp;org.NamePathField, &amp;org.SortOrderField,
                &amp;org.DescriptionField, &amp;org.ProfileField, &amp;org.CreatedAtField, &amp;org.UpdatedAtField,
                &amp;org.EffectiveDateField, &amp;org.EndDateField, &amp;org.IsCurrentField,
                &amp;org.ChangeReasonField, &amp;org.DeletedAtField, &amp;org.DeletedByField, &amp;org.DeletionReasonField,
                &amp;org.SuspendedAtField, &amp;org.SuspendedByField, &amp;org.SuspensionReasonField,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Debug("organization not found")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"error": err}).Error("organization query failed")
                return nil, err</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{
                "duration_ms": duration.Milliseconds(),
        }).Info("organization query succeeded")

        return &amp;org, nil</span>
}

// 极速时态查询 - 时间点查询（利用时态索引）
func (r *PostgreSQLRepository) GetOrganizationAtDate(ctx context.Context, tenantID uuid.UUID, code, date string) (*dto.Organization, error) <span class="cov0" title="0">{
        // 使用计算的区间终点（computed_end_date），避免依赖物理 end_date 的准确性
        query := `
        WITH hist AS (
            SELECT 
                record_id, tenant_id, code, parent_code, name, unit_type, status,
                level,
                COALESCE(code_path, '/' || code) AS code_path,
                COALESCE(name_path, '/' || name) AS name_path,
                sort_order, description, profile, created_at, updated_at,
                effective_date, end_date, is_current, change_reason,
                deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason,
                LEAD(effective_date) OVER (PARTITION BY tenant_id, code ORDER BY effective_date) AS next_effective
            FROM organization_units 
            WHERE tenant_id = $1 AND code = $2 
              AND status &lt;&gt; 'DELETED'
        ), proj AS (
            SELECT 
                record_id, tenant_id, code, parent_code, name, unit_type, status,
                level, code_path, name_path, sort_order, description, profile, created_at, updated_at,
                effective_date,
                COALESCE(end_date, (next_effective - INTERVAL '1 day')::date) AS computed_end_date,
                is_current, change_reason,
                deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason
            FROM hist
        )
        SELECT 
            record_id, tenant_id, code, parent_code, name, unit_type, status,
            level, code_path, name_path, sort_order, description, profile, created_at, updated_at,
               effective_date, computed_end_date AS end_date, is_current, change_reason,
            deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason
        FROM proj
        WHERE effective_date &lt;= $3::date 
          AND (computed_end_date IS NULL OR computed_end_date &gt;= $3::date)
        ORDER BY effective_date DESC, created_at DESC
        LIMIT 1`

        log := r.loggerFor("organization.atDate", pkglogger.Fields{
                "tenantId": tenantID.String(),
                "code":     code,
                "date":     date,
        })
        start := time.Now()
        row := r.db.QueryRowContext(ctx, query, tenantID.String(), code, date)

        var org dto.Organization
        var isTemporal bool
        err := row.Scan(
                &amp;org.RecordIDField, &amp;org.TenantIDField, &amp;org.CodeField, &amp;org.ParentCodeField, &amp;org.NameField,
                &amp;org.UnitTypeField, &amp;org.StatusField, &amp;org.LevelField, &amp;org.CodePathField, &amp;org.NamePathField, &amp;org.SortOrderField,
                &amp;org.DescriptionField, &amp;org.ProfileField, &amp;org.CreatedAtField, &amp;org.UpdatedAtField,
                &amp;org.EffectiveDateField, &amp;org.EndDateField, &amp;org.IsCurrentField, &amp;isTemporal,
                &amp;org.ChangeReasonField, &amp;org.DeletedAtField, &amp;org.DeletedByField, &amp;org.DeletionReasonField,
                &amp;org.SuspendedAtField, &amp;org.SuspendedByField, &amp;org.SuspensionReasonField,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Debug("organization snapshot not found")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"error": err}).Error("organization temporal query failed")
                return nil, err</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{"duration_ms": duration.Milliseconds()}).Info("organization temporal query succeeded")

        return &amp;org, nil</span>
}

// 历史范围查询 - 窗口函数优化
func (r *PostgreSQLRepository) GetOrganizationHistory(ctx context.Context, tenantID uuid.UUID, code, fromDate, toDate string) ([]dto.Organization, error) <span class="cov0" title="0">{
        // 历史范围查询：使用计算的区间终点（computed_end_date）并基于区间重叠选择
        query := `
        WITH hist AS (
            SELECT 
                record_id, tenant_id, code, parent_code, name, unit_type, status,
                level,
                COALESCE(code_path, '/' || code) AS code_path,
                COALESCE(name_path, '/' || name) AS name_path,
                sort_order, description, profile, created_at, updated_at,
                effective_date, end_date, is_current, is_temporal, change_reason,
                deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason,
                LEAD(effective_date) OVER (PARTITION BY tenant_id, code ORDER BY effective_date) AS next_effective
            FROM organization_units 
            WHERE tenant_id = $1 AND code = $2 
              AND status &lt;&gt; 'DELETED'
        ), proj AS (
            SELECT 
                record_id, tenant_id, code, parent_code, name, unit_type, status,
                level, code_path, name_path, sort_order, description, profile, created_at, updated_at,
                effective_date,
                COALESCE(end_date, (next_effective - INTERVAL '1 day')::date) AS computed_end_date,
                is_current, is_temporal, change_reason,
                deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason
            FROM hist
        )
        SELECT 
            record_id, tenant_id, code, parent_code, name, unit_type, status,
            level, code_path, name_path, sort_order, description, profile, created_at, updated_at,
            effective_date, computed_end_date AS end_date, is_current, is_temporal, change_reason,
            deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason
        FROM proj
        WHERE effective_date &lt;= $4::date
          AND (computed_end_date IS NULL OR computed_end_date &gt;= $3::date)
        ORDER BY effective_date DESC, created_at DESC`

        log := r.loggerFor("organization.history", pkglogger.Fields{
                "tenantId": tenantID.String(),
                "code":     code,
                "fromDate": fromDate,
                "toDate":   toDate,
        })
        start := time.Now()
        rows, err := r.db.QueryContext(ctx, query, tenantID.String(), code, fromDate, toDate)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("organization history query failed")
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var organizations []dto.Organization
        for rows.Next() </span><span class="cov0" title="0">{
                var org dto.Organization
                err := rows.Scan(
                        &amp;org.RecordIDField, &amp;org.TenantIDField, &amp;org.CodeField, &amp;org.ParentCodeField, &amp;org.NameField,
                        &amp;org.UnitTypeField, &amp;org.StatusField, &amp;org.LevelField, &amp;org.CodePathField, &amp;org.NamePathField, &amp;org.SortOrderField,
                        &amp;org.DescriptionField, &amp;org.ProfileField, &amp;org.CreatedAtField, &amp;org.UpdatedAtField,
                        &amp;org.EffectiveDateField, &amp;org.EndDateField, &amp;org.IsCurrentField, new(bool),
                        &amp;org.ChangeReasonField, &amp;org.DeletedAtField, &amp;org.DeletedByField, &amp;org.DeletionReasonField,
                        &amp;org.SuspendedAtField, &amp;org.SuspendedByField, &amp;org.SuspensionReasonField,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Error("organization history scan failed")
                        return nil, err
                }</span>
                <span class="cov0" title="0">organizations = append(organizations, org)</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{
                "result_count": len(organizations),
                "duration_ms":  duration.Milliseconds(),
        }).Info("organization history query succeeded")

        return organizations, nil</span>
}

// 组织版本查询 - 按计划规范实现，返回指定code的全部版本
func (r *PostgreSQLRepository) GetOrganizationVersions(ctx context.Context, tenantID uuid.UUID, code string, includeDeleted bool) ([]dto.Organization, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization.versions", pkglogger.Fields{
                "tenantId":       tenantID.String(),
                "code":           code,
                "includeDeleted": includeDeleted,
        })
        start := time.Now()

        // 构建查询 - 过滤条件：tenant_id = $tenant AND code = $code
        baseQuery := `
                SELECT record_id, tenant_id, code, parent_code, name, unit_type, status,
                       level,
                       COALESCE(code_path, '/' || code) AS code_path,
                       COALESCE(name_path, '/' || name) AS name_path,
                       sort_order, description, profile, created_at, updated_at,
                   effective_date, end_date, is_current, change_reason,
                   deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason,
                   hierarchy_depth
                FROM organization_units
                WHERE tenant_id = $1 AND code = $2`

        args := []interface{}{tenantID.String(), code}

        // includeDeleted=false: status != 'DELETED'
        if !includeDeleted </span><span class="cov0" title="0">{
                baseQuery += " AND status != 'DELETED'"
        }</span>

        // 排序：ORDER BY effective_date ASC (按计划要求)
        <span class="cov0" title="0">finalQuery := baseQuery + " ORDER BY effective_date ASC"

        rows, err := r.db.QueryContext(ctx, finalQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("organization versions query failed")
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var organizations []dto.Organization
        for rows.Next() </span><span class="cov0" title="0">{
                var org dto.Organization
                err := rows.Scan(
                        &amp;org.RecordIDField, &amp;org.TenantIDField, &amp;org.CodeField, &amp;org.ParentCodeField, &amp;org.NameField,
                        &amp;org.UnitTypeField, &amp;org.StatusField, &amp;org.LevelField, &amp;org.CodePathField, &amp;org.NamePathField, &amp;org.SortOrderField,
                        &amp;org.DescriptionField, &amp;org.ProfileField, &amp;org.CreatedAtField, &amp;org.UpdatedAtField,
                        &amp;org.EffectiveDateField, &amp;org.EndDateField, &amp;org.IsCurrentField,
                        &amp;org.ChangeReasonField, &amp;org.DeletedAtField, &amp;org.DeletedByField, &amp;org.DeletionReasonField,
                        &amp;org.SuspendedAtField, &amp;org.SuspendedByField, &amp;org.SuspensionReasonField,
                        &amp;org.HierarchyDepthField,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Error("organization versions scan failed")
                        return nil, err
                }</span>
                <span class="cov0" title="0">organizations = append(organizations, org)</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{
                "result_count": len(organizations),
                "duration_ms":  duration.Milliseconds(),
        }).Info("organization versions query succeeded")

        return organizations, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "strings"
        "time"

        "cube-castle/internal/organization/dto"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

// 高级统计查询 - 利用PostgreSQL聚合优化
func (r *PostgreSQLRepository) GetOrganizationStats(ctx context.Context, tenantID uuid.UUID) (*dto.OrganizationStats, error) <span class="cov8" title="1">{
        start := time.Now()
        log := r.loggerFor("organization.stats", pkglogger.Fields{
                "tenantId": tenantID.String(),
        })

        // 使用单个复杂查询获取所有统计信息
        query := `
        WITH status_stats AS (
            SELECT 
                COUNT(*) FILTER (WHERE status &lt;&gt; 'DELETED' AND is_current = true)::int as total_count,
                COUNT(*) FILTER (WHERE status = 'ACTIVE' AND is_current = true)::int as active_count,
                COUNT(*) FILTER (WHERE status = 'INACTIVE' AND is_current = true)::int as inactive_count,
                COUNT(*) FILTER (WHERE status = 'PLANNED' AND is_current = true)::int as planned_count,
                COUNT(*) FILTER (WHERE status = 'DELETED')::int as deleted_count
            FROM organization_units WHERE tenant_id = $1
        ),
        type_stats AS (
            SELECT unit_type, COUNT(*) as count
            FROM organization_units 
            WHERE tenant_id = $1 AND is_current = true AND status &lt;&gt; 'DELETED'
            GROUP BY unit_type
        ),
        status_detail_stats AS (
            SELECT status, COUNT(*) as count
            FROM organization_units 
            WHERE tenant_id = $1 AND is_current = true AND status &lt;&gt; 'DELETED'
            GROUP BY status
        ),
        level_stats AS (
            SELECT level, COUNT(*) as count
            FROM organization_units 
            WHERE tenant_id = $1 AND is_current = true AND status &lt;&gt; 'DELETED'
            GROUP BY level
        ),
        temporal_stats AS (
            SELECT 
                COUNT(*) as total_versions,
                COUNT(DISTINCT code) as unique_orgs,
                COALESCE(MIN(effective_date), DATE '1970-01-01') as oldest_date,
                COALESCE(MAX(effective_date), DATE '1970-01-01') as newest_date
            FROM organization_units WHERE tenant_id = $1 AND status &lt;&gt; 'DELETED'
        )
                SELECT 
                        s.total_count, s.active_count, s.inactive_count, s.planned_count, s.deleted_count,
                        ts.total_versions, ts.unique_orgs, ts.oldest_date, ts.newest_date,
                        COALESCE(json_agg(DISTINCT jsonb_build_object('unitType', t.unit_type, 'count', t.count)) FILTER (WHERE t.unit_type IS NOT NULL), '[]'),
                        COALESCE(json_agg(DISTINCT jsonb_build_object('status', sd.status, 'count', sd.count)) FILTER (WHERE sd.status IS NOT NULL), '[]'),
                        COALESCE(json_agg(DISTINCT jsonb_build_object('level', l.level, 'count', l.count)) FILTER (WHERE l.level IS NOT NULL), '[]')
                FROM status_stats s
                CROSS JOIN temporal_stats ts
                LEFT JOIN type_stats t ON true
                LEFT JOIN status_detail_stats sd ON true
                LEFT JOIN level_stats l ON true
                GROUP BY s.total_count, s.active_count, s.inactive_count, s.planned_count, s.deleted_count,
                         ts.total_versions, ts.unique_orgs, ts.oldest_date, ts.newest_date`

        row := r.db.QueryRowContext(ctx, query, tenantID.String())

        var stats dto.OrganizationStats
        var totalVersions, uniqueOrgs int
        var oldestDate, newestDate time.Time
        var typeStatsJSON, statusStatsJSON, levelStatsJSON string

        err := row.Scan(
                &amp;stats.TotalCountField, &amp;stats.ActiveCountField, &amp;stats.InactiveCountField,
                &amp;stats.PlannedCountField, &amp;stats.DeletedCountField,
                &amp;totalVersions, &amp;uniqueOrgs, &amp;oldestDate, &amp;newestDate,
                &amp;typeStatsJSON, &amp;statusStatsJSON, &amp;levelStatsJSON,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("organization stats query failed")
                return nil, err
        }</span>

        // 解析JSON统计数据
        <span class="cov8" title="1">var typeStats []dto.TypeCount
        if typeStatsJSON != "" </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(typeStatsJSON), &amp;typeStats); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Warn("failed to parse typeStats")
                }</span>
        }
        <span class="cov8" title="1">stats.ByTypeField = typeStats

        var statusStats []dto.StatusCount
        if statusStatsJSON != "" </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(statusStatsJSON), &amp;statusStats); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Warn("failed to parse statusStats")
                }</span>
        }
        <span class="cov8" title="1">stats.ByStatusField = statusStats

        var levelStats []dto.LevelCount
        if levelStatsJSON != "" </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(levelStatsJSON), &amp;levelStats); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Warn("failed to parse levelStats")
                }</span>
        }
        <span class="cov8" title="1">stats.ByLevelField = levelStats

        // 时态统计
        avgPerOrg := 0.0
        if uniqueOrgs &gt; 0 </span><span class="cov8" title="1">{
                avgPerOrg = float64(totalVersions) / float64(uniqueOrgs)
        }</span>

        <span class="cov8" title="1">stats.TemporalStatsField = dto.TemporalStats{
                TotalVersionsField:         totalVersions,
                AverageVersionsPerOrgField: avgPerOrg,
                OldestEffectiveDateField:   oldestDate.Format("2006-01-02"),
                NewestEffectiveDateField:   newestDate.Format("2006-01-02"),
        }

        duration := time.Since(start)
        log.WithFields(pkglogger.Fields{"duration_ms": duration.Milliseconds()}).Info("organization stats query succeeded")

        return &amp;stats, nil</span>
}

// 高级层级结构查询 - 严格遵循API规范v4.2.1
func (r *PostgreSQLRepository) GetOrganizationHierarchy(ctx context.Context, tenantID uuid.UUID, code string) (*dto.OrganizationHierarchyData, error) <span class="cov0" title="0">{
        start := time.Now()
        log := r.loggerFor("organization.hierarchy", pkglogger.Fields{
                "tenantId": tenantID.String(),
                "code":     code,
        })

        // 使用PostgreSQL递归CTE查询完整层级信息
        query := `
        WITH RECURSIVE hierarchy_info AS (
            -- 获取目标组织
            SELECT
                code,
                name,
                level,
                parent_code,
                1 AS hierarchy_depth
            FROM organization_units
            WHERE tenant_id = $1
              AND code = $2
              AND is_current = true
              AND status &lt;&gt; 'DELETED'

            UNION ALL

            -- 递归获取父级信息
            SELECT
                o.code,
                o.name,
                o.level,
                o.parent_code,
                h.hierarchy_depth + 1
            FROM organization_units o
            INNER JOIN hierarchy_info h ON o.code = h.parent_code
            WHERE o.tenant_id = $1
              AND o.is_current = true
              AND o.status &lt;&gt; 'DELETED'
        ),
        aggregated_paths AS (
            SELECT
                '/' || string_agg(code, '/' ORDER BY hierarchy_depth DESC) AS full_code_path,
                '/' || string_agg(name, '/' ORDER BY hierarchy_depth DESC) AS full_name_path,
                COALESCE(
                    array_agg(code ORDER BY hierarchy_depth DESC) FILTER (WHERE hierarchy_depth &gt; 1),
                    ARRAY[]::text[]
                ) AS parent_chain
            FROM hierarchy_info
        ),
        target_info AS (
            SELECT *
            FROM hierarchy_info
            WHERE code = $2
            LIMIT 1
        ),
        children_count AS (
            SELECT COUNT(*) AS count
            FROM organization_units
            WHERE tenant_id = $1
              AND parent_code = $2
              AND is_current = true
              AND status &lt;&gt; 'DELETED'
        )
        SELECT
            t.code,
            t.name,
            t.level,
            t.hierarchy_depth,
            ap.full_code_path,
            ap.full_name_path,
            ap.parent_chain,
            c.count AS children_count,
            (t.parent_code IS NULL) AS is_root,
            (c.count = 0) AS is_leaf
        FROM target_info t
        CROSS JOIN aggregated_paths ap
        CROSS JOIN children_count c
        LIMIT 1`

        row := r.db.QueryRowContext(ctx, query, tenantID.String(), code)

        var hierarchy dto.OrganizationHierarchyData
        var parentChain []string

        err := row.Scan(
                &amp;hierarchy.CodeField,
                &amp;hierarchy.NameField,
                &amp;hierarchy.LevelField,
                &amp;hierarchy.HierarchyDepthField,
                &amp;hierarchy.CodePathField,
                &amp;hierarchy.NamePathField,
                pq.Array(&amp;parentChain),
                &amp;hierarchy.ChildrenCountField,
                &amp;hierarchy.IsRootField,
                &amp;hierarchy.IsLeafField,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Debug("organization hierarchy not found")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"error": err}).Error("organization hierarchy query failed")
                return nil, err</span>
        }

        <span class="cov0" title="0">hierarchy.ParentChainField = parentChain

        duration := time.Since(start)
        log.WithFields(pkglogger.Fields{"duration_ms": duration.Milliseconds()}).Info("organization hierarchy query succeeded")

        return &amp;hierarchy, nil</span>
}

// 组织子树查询 - 严格遵循API规范v4.2.1
func (r *PostgreSQLRepository) GetOrganizationSubtree(ctx context.Context, tenantID uuid.UUID, code string, maxDepth int) (*dto.OrganizationHierarchyData, error) <span class="cov8" title="1">{
        start := time.Now()
        log := r.loggerFor("organization.subtree", pkglogger.Fields{
                "tenantId": tenantID.String(),
                "code":     code,
                "maxDepth": maxDepth,
        })

        // 使用PostgreSQL递归CTE查询子树结构，限制深度
        query := `
        WITH RECURSIVE subtree AS (
            -- 根节点
            SELECT 
                code, name, level, 
                COALESCE(hierarchy_depth, level) as hierarchy_depth,
                COALESCE(code_path, '/' || code) as code_path,
                COALESCE(name_path, '/' || name) as name_path,
                parent_code,
                0 as depth_from_root
            FROM organization_units 
            WHERE tenant_id = $1 AND code = $2 AND is_current = true AND status &lt;&gt; 'DELETED'
            
            UNION ALL
            
            -- 递归查询子节点
            SELECT 
                o.code, o.name, o.level,
                o.hierarchy_depth, o.code_path, o.name_path, o.parent_code,
                s.depth_from_root + 1
            FROM organization_units o
            INNER JOIN subtree s ON o.parent_code = s.code
            WHERE o.tenant_id = $1 AND o.is_current = true AND o.status &lt;&gt; 'DELETED'
              AND s.depth_from_root &lt; $3
        )
                SELECT code, name, level, hierarchy_depth, code_path, name_path, parent_code
                FROM subtree 
                ORDER BY level, code`

        rows, err := r.db.QueryContext(ctx, query, tenantID.String(), code, maxDepth)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("organization subtree query failed")
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        // 构建树形结构
        nodeMap := make(map[string]*dto.OrganizationSubtreeData)
        var root *dto.OrganizationSubtreeData

        for rows.Next() </span><span class="cov8" title="1">{
                node := &amp;dto.OrganizationSubtreeData{}
                var parentCode *string

                err := rows.Scan(
                        &amp;node.CodeField, &amp;node.NameField, &amp;node.LevelField, &amp;node.HierarchyDepthField,
                        &amp;node.CodePathField, &amp;node.NamePathField, &amp;parentCode,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Error("organization subtree scan failed")
                        return nil, err
                }</span>

                <span class="cov8" title="1">node.ChildrenField = []dto.OrganizationSubtreeData{}
                node.IsRootField = node.CodeField == code
                node.ParentChainField = buildParentChain(node.CodePathField)
                nodeMap[node.CodeField] = node

                if node.CodeField == code </span><span class="cov8" title="1">{
                        root = node
                }</span>
        }

        // 构建父子关系
        <span class="cov8" title="1">for _, node := range nodeMap </span><span class="cov8" title="1">{
                if root != nil &amp;&amp; node.CodeField != code </span><span class="cov8" title="1">{
                        for _, parent := range nodeMap </span><span class="cov8" title="1">{
                                if node.CodeField == parent.CodeField </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if node.CodePathField == nil || parent.CodePathField == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">nodePath := *node.CodePathField
                                parentPath := *parent.CodePathField
                                if strings.HasPrefix(nodePath, parentPath+"/") </span><span class="cov8" title="1">{
                                        parentDepth := strings.Count(parentPath, "/")
                                        nodeDepth := strings.Count(nodePath, "/")
                                        if nodeDepth == parentDepth+1 </span><span class="cov8" title="1">{
                                                parent.ChildrenField = append(parent.ChildrenField, *node)
                                                break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{
                "node_count":  len(nodeMap),
                "duration_ms": duration.Milliseconds(),
        }).Info("organization subtree query succeeded")

        converted := convertSubtreeToHierarchy(root)
        return converted, nil</span>
}

func buildParentChain(codePath *string) []string <span class="cov8" title="1">{
        if codePath == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">trimmed := strings.Trim(*codePath, "/")
        if trimmed == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">parts := strings.Split(trimmed, "/")
        if len(parts) &lt;= 1 </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return parts[:len(parts)-1]</span>
}

func convertSubtreeToHierarchy(node *dto.OrganizationSubtreeData) *dto.OrganizationHierarchyData <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">children := make([]dto.OrganizationHierarchyData, 0, len(node.ChildrenField))
        for i := range node.ChildrenField </span><span class="cov8" title="1">{
                child := convertSubtreeToHierarchy(&amp;node.ChildrenField[i])
                if child != nil </span><span class="cov8" title="1">{
                        children = append(children, *child)
                }</span>
        }

        <span class="cov8" title="1">isLeaf := len(children) == 0
        hybrid := &amp;dto.OrganizationHierarchyData{
                CodeField:           node.CodeField,
                NameField:           node.NameField,
                LevelField:          node.LevelField,
                HierarchyDepthField: node.HierarchyDepthField,
                CodePathField:       node.CodePathField,
                NamePathField:       node.NamePathField,
                ParentChainField:    node.ParentChainField,
                ChildrenCountField:  len(children),
                IsRootField:         node.IsRootField,
                IsLeafField:         isLeaf,
                ChildrenField:       children,
        }

        return hybrid</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/dto"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

// 极速当前组织查询 - 利用部分索引 idx_current_organizations_list (API契约v4.2.1)
func (r *PostgreSQLRepository) GetOrganizations(ctx context.Context, tenantID uuid.UUID, filter *dto.OrganizationFilter, pagination *dto.PaginationInput) (*dto.OrganizationConnection, error) <span class="cov8" title="1">{
        start := time.Now()

        // 解析分页参数 - 使用契约默认值
        page := int32(1)
        pageSize := int32(50)
        if pagination != nil </span><span class="cov8" title="1">{
                if pagination.Page &gt; 0 </span><span class="cov8" title="1">{
                        page = pagination.Page
                }</span>
                <span class="cov8" title="1">if pagination.PageSize &gt; 0 </span><span class="cov8" title="1">{
                        pageSize = pagination.PageSize
                }</span>
        }

        <span class="cov8" title="1">logFields := pkglogger.Fields{
                "tenantId": tenantID.String(),
                "page":     page,
                "pageSize": pageSize,
        }

        offset := (page - 1) * pageSize
        limit := pageSize

        includeDisabledAncestors := false

        var (
                status, searchText, unitType, parentCode string
                includeCodes, excludeCodes               []string
                asOfDateParam                            sql.NullString
                excludeDescendantsParam                  sql.NullString
        )

        if filter != nil </span><span class="cov0" title="0">{
                includeDisabledAncestors = filter.IncludeDisabledAncestors
                logFields["includeDisabledAncestors"] = includeDisabledAncestors
                if filter.Status != nil </span><span class="cov0" title="0">{
                        status = strings.TrimSpace(*filter.Status)
                        if status != "" </span><span class="cov0" title="0">{
                                logFields["status"] = status
                        }</span>
                }
                <span class="cov0" title="0">if filter.SearchText != nil </span><span class="cov0" title="0">{
                        searchText = strings.TrimSpace(*filter.SearchText)
                        if searchText != "" </span><span class="cov0" title="0">{
                                logFields["searchText"] = true
                        }</span>
                }
                <span class="cov0" title="0">if filter.UnitType != nil </span><span class="cov0" title="0">{
                        unitType = strings.TrimSpace(*filter.UnitType)
                        if unitType != "" </span><span class="cov0" title="0">{
                                logFields["unitType"] = unitType
                        }</span>
                }
                <span class="cov0" title="0">if filter.ParentCode != nil </span><span class="cov0" title="0">{
                        parentCode = strings.TrimSpace(*filter.ParentCode)
                        if parentCode != "" </span><span class="cov0" title="0">{
                                logFields["parentCode"] = parentCode
                        }</span>
                }
                <span class="cov0" title="0">if filter.AsOfDate != nil </span><span class="cov0" title="0">{
                        if trimmed := strings.TrimSpace(*filter.AsOfDate); trimmed != "" </span><span class="cov0" title="0">{
                                asOfDateParam = sql.NullString{String: trimmed, Valid: true}
                                logFields["asOfDate"] = trimmed
                        }</span>
                }
                <span class="cov0" title="0">if filter.ExcludeDescendantsOf != nil </span><span class="cov0" title="0">{
                        if trimmed := strings.TrimSpace(*filter.ExcludeDescendantsOf); trimmed != "" </span><span class="cov0" title="0">{
                                excludeDescendantsParam = sql.NullString{String: trimmed, Valid: true}
                        }</span>
                }
                <span class="cov0" title="0">if filter.ExcludeCodes != nil </span><span class="cov0" title="0">{
                        for _, code := range *filter.ExcludeCodes </span><span class="cov0" title="0">{
                                if trimmed := strings.TrimSpace(code); trimmed != "" </span><span class="cov0" title="0">{
                                        excludeCodes = append(excludeCodes, trimmed)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(excludeCodes) &gt; 0 </span><span class="cov0" title="0">{
                                logFields["excludeCodes"] = len(excludeCodes)
                        }</span>
                }
                <span class="cov0" title="0">if filter.Codes != nil </span><span class="cov0" title="0">{
                        for _, code := range *filter.Codes </span><span class="cov0" title="0">{
                                if trimmed := strings.TrimSpace(code); trimmed != "" </span><span class="cov0" title="0">{
                                        includeCodes = append(includeCodes, trimmed)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(includeCodes) &gt; 0 </span><span class="cov0" title="0">{
                                logFields["includeCodes"] = len(includeCodes)
                        }</span>
                }
        }

        <span class="cov8" title="1">log := r.loggerFor("organization.list", logFields)

        cte := `
WITH parent_path AS (
    SELECT DISTINCT ON (code)
        code,
        COALESCE(code_path, '/' || code) AS code_path
    FROM organization_units
    WHERE tenant_id = $1
      AND $3::text IS NOT NULL
      AND code = $3::text
      AND status &lt;&gt; 'DELETED'
      AND (
        $2::text IS NULL OR (
          effective_date &lt;= $2::date AND (end_date IS NULL OR end_date &gt; $2::date)
        )
      )
    ORDER BY code, effective_date DESC, created_at DESC
),
latest_versions AS (
    SELECT DISTINCT ON (code)
        record_id, tenant_id, code, parent_code, name, unit_type, status,
        level, sort_order, description, profile, created_at, updated_at,
        effective_date, end_date, is_current, change_reason,
        deleted_at, deleted_by, deletion_reason, suspended_at, suspended_by, suspension_reason,
        COALESCE(code_path, '/' || code) AS code_path,
        COALESCE(name_path, '/' || name) AS name_path
    FROM organization_units
    WHERE tenant_id = $1
      AND status &lt;&gt; 'DELETED'
      AND (
        $2::text IS NULL OR (
          effective_date &lt;= $2::date AND (end_date IS NULL OR end_date &gt; $2::date)
        )
      )
    ORDER BY code, effective_date DESC, created_at DESC
)
`

        baseSelect := `
SELECT lv.record_id, lv.tenant_id, lv.code, lv.parent_code, lv.name, lv.unit_type, lv.status,
       lv.level, lv.code_path, lv.name_path, lv.sort_order, lv.description, lv.profile, lv.created_at, lv.updated_at,
       lv.effective_date, lv.end_date, lv.is_current, lv.change_reason,
       lv.deleted_at, lv.deleted_by, lv.deletion_reason, lv.suspended_at, lv.suspended_by, lv.suspension_reason,
       COALESCE(child_stats.child_count, 0) AS children_count
FROM latest_versions lv
LEFT JOIN parent_path pp ON TRUE
LEFT JOIN LATERAL (
    SELECT COUNT(*) AS child_count
    FROM organization_units child
    WHERE child.tenant_id = lv.tenant_id
      AND child.parent_code = lv.code
      AND child.status &lt;&gt; 'DELETED'
      AND (
        $2::text IS NULL OR (
          child.effective_date &lt;= $2::date AND (child.end_date IS NULL OR child.end_date &gt; $2::date)
        )
      )
) child_stats ON TRUE
WHERE 1=1`

        countSelect := `
SELECT COUNT(*)
FROM latest_versions lv
LEFT JOIN parent_path pp ON TRUE
WHERE 1=1`

        args := []interface{}{tenantID.String(), asOfDateParam, excludeDescendantsParam}
        argIndex := 4
        whereConditions := ""

        if status != "" </span><span class="cov0" title="0">{
                if includeDisabledAncestors &amp;&amp; parentCode != "" </span><span class="cov0" title="0">{
                        whereConditions += fmt.Sprintf(" AND (lv.status = $%d OR (lv.parent_code = $%d AND lv.status &lt;&gt; 'DELETED'))", argIndex, argIndex+1)
                        args = append(args, status, parentCode)
                        argIndex += 2
                }</span> else<span class="cov0" title="0"> {
                        whereConditions += fmt.Sprintf(" AND lv.status = $%d", argIndex)
                        args = append(args, status)
                        argIndex++
                }</span>
        } else<span class="cov8" title="1"> {
                whereConditions += " AND lv.status &lt;&gt; 'DELETED'"
        }</span>

        <span class="cov8" title="1">if unitType != "" </span><span class="cov0" title="0">{
                whereConditions += fmt.Sprintf(" AND lv.unit_type = $%d", argIndex)
                args = append(args, unitType)
                argIndex++
        }</span>

        <span class="cov8" title="1">if parentCode != "" </span><span class="cov0" title="0">{
                whereConditions += fmt.Sprintf(" AND lv.parent_code = $%d", argIndex)
                args = append(args, parentCode)
                argIndex++
        }</span>

        <span class="cov8" title="1">if len(includeCodes) &gt; 0 </span><span class="cov0" title="0">{
                whereConditions += fmt.Sprintf(" AND lv.code = ANY($%d)", argIndex)
                args = append(args, pq.StringArray(includeCodes))
                argIndex++
        }</span>

        <span class="cov8" title="1">if len(excludeCodes) &gt; 0 </span><span class="cov0" title="0">{
                whereConditions += fmt.Sprintf(" AND NOT (lv.code = ANY($%d))", argIndex)
                args = append(args, pq.StringArray(excludeCodes))
                argIndex++
        }</span>

        <span class="cov8" title="1">whereConditions += ` AND (
    $3::text IS NULL OR (
        lv.code &lt;&gt; $3::text AND (
            pp.code_path IS NULL OR lv.code_path NOT LIKE pp.code_path || '/%'
        )
    )
)`

        if searchText != "" </span><span class="cov0" title="0">{
                whereConditions += fmt.Sprintf(" AND (lv.name ILIKE $%d OR lv.code ILIKE $%d)", argIndex, argIndex)
                pattern := "%" + searchText + "%"
                args = append(args, pattern)
                argIndex++
        }</span>

        <span class="cov8" title="1">countQuery := cte + countSelect + whereConditions
        countArgs := append([]interface{}{}, args...)

        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("organization list count query failed")
                return nil, err
        }</span>

        <span class="cov8" title="1">orderClause := fmt.Sprintf(" ORDER BY COALESCE(lv.sort_order, 0) NULLS LAST, lv.code LIMIT $%d OFFSET $%d", argIndex, argIndex+1)
        dataQuery := cte + baseSelect + whereConditions + orderClause
        args = append(args, limit, offset)

        rows, err := r.db.QueryContext(ctx, dataQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Error("organization list query failed")
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var organizations []dto.Organization
        for rows.Next() </span><span class="cov8" title="1">{
                var org dto.Organization
                if err := rows.Scan(
                        &amp;org.RecordIDField, &amp;org.TenantIDField, &amp;org.CodeField, &amp;org.ParentCodeField, &amp;org.NameField,
                        &amp;org.UnitTypeField, &amp;org.StatusField, &amp;org.LevelField, &amp;org.CodePathField, &amp;org.NamePathField, &amp;org.SortOrderField,
                        &amp;org.DescriptionField, &amp;org.ProfileField, &amp;org.CreatedAtField, &amp;org.UpdatedAtField,
                        &amp;org.EffectiveDateField, &amp;org.EndDateField, &amp;org.IsCurrentField,
                        &amp;org.ChangeReasonField, &amp;org.DeletedAtField, &amp;org.DeletedByField, &amp;org.DeletionReasonField,
                        &amp;org.SuspendedAtField, &amp;org.SuspendedByField, &amp;org.SuspensionReasonField, &amp;org.ChildrenCountField,
                ); err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"error": err}).Error("organization list scan failed")
                        return nil, err
                }</span>
                <span class="cov8" title="1">organizations = append(organizations, org)</span>
        }

        <span class="cov8" title="1">duration := time.Since(start)
        log.WithFields(pkglogger.Fields{
                "result_count": len(organizations),
                "total_count":  total,
                "duration_ms":  duration.Milliseconds(),
        }).Info("organization list query succeeded")

        totalPages := (total + int(pageSize) - 1) / int(pageSize)
        asOfDateValue := time.Now().Format("2006-01-02")
        if asOfDateParam.Valid </span><span class="cov0" title="0">{
                asOfDateValue = asOfDateParam.String
        }</span>

        <span class="cov8" title="1">response := &amp;dto.OrganizationConnection{
                DataField: organizations,
                PaginationField: dto.PaginationInfo{
                        TotalField:       total,
                        PageField:        int(page),
                        PageSizeField:    int(pageSize),
                        HasNextField:     int(page) &lt; totalPages,
                        HasPreviousField: page &gt; 1,
                },
                TemporalField: dto.TemporalInfo{
                        AsOfDateField:        asOfDateValue,
                        CurrentCountField:    len(organizations),
                        FutureCountField:     0,
                        HistoricalCountField: 0,
                },
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/dto"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

func toStringSlice[T ~string](values []T) []string <span class="cov0" title="0">{
        result := make([]string, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                result[i] = string(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

type rowScanner interface {
        Scan(dest ...interface{}) error
}

func (r *PostgreSQLRepository) GetPositions(ctx context.Context, tenantID uuid.UUID, filter *dto.PositionFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionSortInput) (*dto.PositionConnection, error) <span class="cov8" title="1">{
        page := int32(1)
        pageSize := int32(25)
        if pagination != nil </span><span class="cov8" title="1">{
                if pagination.Page &gt; 0 </span><span class="cov8" title="1">{
                        page = pagination.Page
                }</span>
                <span class="cov8" title="1">if pagination.PageSize &gt; 0 </span><span class="cov8" title="1">{
                        pageSize = pagination.PageSize
                        if pageSize &gt; 200 </span><span class="cov0" title="0">{
                                pageSize = 200
                        }</span>
                }
        }

        <span class="cov8" title="1">offset := int((page - 1) * pageSize)
        limit := int(pageSize)

        args := []interface{}{tenantID.String()}
        argIndex := 2

        whereParts := []string{"p.tenant_id = $1", "p.is_current = true", "p.status &lt;&gt; 'DELETED'"}

        if filter != nil </span><span class="cov0" title="0">{
                if organizationCode := filter.OrganizationCode; organizationCode != nil </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.organization_code = $%d", argIndex))
                        args = append(args, strings.TrimSpace(*organizationCode))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if positionCodes := filter.PositionCodes; positionCodes != nil &amp;&amp; len(*positionCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*positionCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if status := filter.Status; status != nil &amp;&amp; strings.TrimSpace(*status) != "" </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.status = $%d", argIndex))
                        args = append(args, strings.ToUpper(strings.TrimSpace(*status)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobFamilyGroupCodes := filter.JobFamilyGroupCodes; jobFamilyGroupCodes != nil &amp;&amp; len(*jobFamilyGroupCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_family_group_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobFamilyGroupCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobFamilyCodes := filter.JobFamilyCodes; jobFamilyCodes != nil &amp;&amp; len(*jobFamilyCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_family_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobFamilyCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobRoleCodes := filter.JobRoleCodes; jobRoleCodes != nil &amp;&amp; len(*jobRoleCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_role_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobRoleCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobLevelCodes := filter.JobLevelCodes; jobLevelCodes != nil &amp;&amp; len(*jobLevelCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_level_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobLevelCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if positionTypes := filter.PositionTypes; positionTypes != nil &amp;&amp; len(*positionTypes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.position_type = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(*positionTypes))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if employmentTypes := filter.EmploymentTypes; employmentTypes != nil &amp;&amp; len(*employmentTypes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.employment_type = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(*employmentTypes))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if rangeInput := filter.EffectiveRange; rangeInput != nil </span><span class="cov0" title="0">{
                        if rangeInput.From != nil &amp;&amp; strings.TrimSpace(*rangeInput.From) != "" </span><span class="cov0" title="0">{
                                whereParts = append(whereParts, fmt.Sprintf("p.effective_date &gt;= $%d", argIndex))
                                args = append(args, strings.TrimSpace(*rangeInput.From))
                                argIndex++
                        }</span>
                        <span class="cov0" title="0">if rangeInput.To != nil &amp;&amp; strings.TrimSpace(*rangeInput.To) != "" </span><span class="cov0" title="0">{
                                whereParts = append(whereParts, fmt.Sprintf("p.effective_date &lt;= $%d", argIndex))
                                args = append(args, strings.TrimSpace(*rangeInput.To))
                                argIndex++
                        }</span>
                }
        }

        <span class="cov8" title="1">whereClause := ""
        if len(whereParts) &gt; 0 </span><span class="cov8" title="1">{
                whereClause = "WHERE " + strings.Join(whereParts, " AND ")
        }</span>

        <span class="cov8" title="1">orderClause := "ORDER BY p.effective_date DESC, p.code ASC"
        if len(sorting) &gt; 0 </span><span class="cov0" title="0">{
                orderParts := make([]string, 0, len(sorting))
                for _, sort := range sorting </span><span class="cov0" title="0">{
                        field := strings.ToUpper(strings.TrimSpace(sort.Field))
                        var column string
                        switch field </span>{
                        case "CODE":<span class="cov0" title="0">
                                column = "p.code"</span>
                        case "TITLE":<span class="cov0" title="0">
                                column = "p.title"</span>
                        case "EFFECTIVE_DATE":<span class="cov0" title="0">
                                column = "p.effective_date"</span>
                        case "STATUS":<span class="cov0" title="0">
                                column = "p.status"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                        <span class="cov0" title="0">dir := strings.ToUpper(strings.TrimSpace(sort.Direction))
                        if dir != "DESC" </span><span class="cov0" title="0">{
                                dir = "ASC"
                        }</span>
                        <span class="cov0" title="0">orderParts = append(orderParts, fmt.Sprintf("%s %s", column, dir))</span>
                }
                <span class="cov0" title="0">if len(orderParts) &gt; 0 </span><span class="cov0" title="0">{
                        orderClause = "ORDER BY " + strings.Join(orderParts, ", ")
                }</span>
        }

        <span class="cov8" title="1">countQuery := fmt.Sprintf(`SELECT COUNT(*) FROM positions p %s`, whereClause)
        countArgs := append([]interface{}{}, args...)

        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count positions: %w", err)
        }</span>

        <span class="cov8" title="1">selectQuery := fmt.Sprintf(`
SELECT
    p.record_id::text,
    p.tenant_id::text,
    p.code,
    p.title,
    p.job_profile_code,
    p.job_profile_name,
    p.job_family_group_code,
    p.job_family_code,
    p.job_role_code,
    p.job_level_code,
    p.organization_code,
    p.position_type,
    p.employment_type,
    p.grade_level,
    p.headcount_capacity,
    p.headcount_in_use,
    p.reports_to_position_code,
    p.status,
    p.effective_date,
    p.end_date,
    p.is_current,
    p.created_at,
    p.updated_at,
    p.job_family_group_name,
    p.job_family_name,
    p.job_role_name,
    p.job_level_name,
    p.organization_name
FROM positions p
%s
%s
LIMIT $%d OFFSET $%d`, whereClause, orderClause, argIndex, argIndex+1)

        queryArgs := append([]interface{}{}, args...)
        queryArgs = append(queryArgs, limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, queryArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query positions: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        positions := make([]dto.Position, 0, len(queryArgs))
        for rows.Next() </span><span class="cov8" title="1">{
                pos, scanErr := scanPosition(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov8" title="1">positions = append(positions, *pos)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate positions: %w", err)
        }</span>

        <span class="cov8" title="1">totalPages := (total + int(pageSize) - 1) / int(pageSize)
        edges := make([]dto.PositionEdge, 0, len(positions))
        for _, pos := range positions </span><span class="cov8" title="1">{
                edges = append(edges, dto.PositionEdge{
                        CursorField: pos.RecordIDField,
                        NodeField:   pos,
                })
        }</span>

        <span class="cov8" title="1">connection := &amp;dto.PositionConnection{
                EdgesField: edges,
                DataField:  positions,
                PaginationField: dto.PaginationInfo{
                        TotalField:       total,
                        PageField:        int(page),
                        PageSizeField:    int(pageSize),
                        HasNextField:     int(page) &lt; totalPages,
                        HasPreviousField: page &gt; 1,
                },
                TotalCountField: total,
        }

        return connection, nil</span>
}

func (r *PostgreSQLRepository) GetPositionByCode(ctx context.Context, tenantID uuid.UUID, code string, asOfDate *string) (*dto.Position, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String(), strings.TrimSpace(code)}
        argIndex := 3

        where := "WHERE p.tenant_id = $1 AND p.code = $2"
        if asOfDate != nil &amp;&amp; strings.TrimSpace(*asOfDate) != "" </span><span class="cov0" title="0">{
                where += fmt.Sprintf(" AND p.effective_date &lt;= $%d AND (p.end_date IS NULL OR p.end_date &gt; $%d)", argIndex, argIndex)
                args = append(args, strings.TrimSpace(*asOfDate))
                argIndex++
        }</span> else<span class="cov0" title="0"> {
                where += " AND p.is_current = true"
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
SELECT
    p.record_id::text,
    p.tenant_id::text,
    p.code,
    p.title,
    p.job_profile_code,
    p.job_profile_name,
    p.job_family_group_code,
    p.job_family_code,
    p.job_role_code,
    p.job_level_code,
    p.organization_code,
    p.position_type,
    p.employment_type,
    p.grade_level,
    p.headcount_capacity,
    p.headcount_in_use,
    p.reports_to_position_code,
    p.status,
    p.effective_date,
    p.end_date,
    p.is_current,
    p.created_at,
    p.updated_at,
    p.job_family_group_name,
    p.job_family_name,
    p.job_role_name,
    p.job_level_name,
    p.organization_name
FROM positions p
%s
ORDER BY p.effective_date DESC, p.created_at DESC
LIMIT 1
`, where)

        row := r.db.QueryRowContext(ctx, query, args...)
        pos, err := scanPosition(row)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if err := r.populatePositionAssignments(ctx, tenantID, pos); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load position assignments: %w", err)
        }</span>
        <span class="cov0" title="0">return pos, nil</span>
}

func (r *PostgreSQLRepository) GetPositionTimeline(ctx context.Context, tenantID uuid.UUID, code string, startDate, endDate *string) ([]dto.PositionTimelineEntry, error) <span class="cov8" title="1">{
        args := []interface{}{tenantID.String(), strings.TrimSpace(code)}
        argIndex := 3
        whereParts := []string{"p.tenant_id = $1", "p.code = $2"}
        assignmentWhereParts := []string{"pa.tenant_id = $1", "pa.position_code = $2"}

        if startDate != nil &amp;&amp; strings.TrimSpace(*startDate) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("p.effective_date &gt;= $%d", argIndex))
                assignmentWhereParts = append(assignmentWhereParts, fmt.Sprintf("pa.effective_date &gt;= $%d", argIndex))
                args = append(args, strings.TrimSpace(*startDate))
                argIndex++
        }</span>
        <span class="cov8" title="1">if endDate != nil &amp;&amp; strings.TrimSpace(*endDate) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("p.effective_date &lt;= $%d", argIndex))
                assignmentWhereParts = append(assignmentWhereParts, fmt.Sprintf("pa.effective_date &lt;= $%d", argIndex))
                args = append(args, strings.TrimSpace(*endDate))
                argIndex++
        }</span>

        <span class="cov8" title="1">whereClause := "WHERE " + strings.Join(whereParts, " AND ")
        assignmentClause := "WHERE " + strings.Join(assignmentWhereParts, " AND ")

        query := fmt.Sprintf(`
WITH timeline AS (
    SELECT
        p.record_id::text AS record_id,
        p.status,
        p.title,
        p.effective_date,
        p.end_date,
        p.is_current,
        p.operation_reason AS change_reason,
        'POSITION_VERSION'::text AS timeline_category,
        NULL::text AS assignment_type,
        NULL::text AS assignment_status
    FROM positions p
    %s
    UNION ALL
    SELECT
        pa.assignment_id::text AS record_id,
        pa.assignment_status AS status,
        pa.employee_name AS title,
        pa.effective_date,
        COALESCE(pa.end_date, pa.acting_until) AS end_date,
        pa.is_current,
        pa.notes AS change_reason,
        'POSITION_ASSIGNMENT'::text AS timeline_category,
        pa.assignment_type,
        pa.assignment_status
    FROM position_assignments pa
    %s
)
SELECT
    record_id,
    status,
    title,
    effective_date,
    end_date,
    is_current,
    change_reason,
    timeline_category,
    assignment_type,
    assignment_status
FROM timeline
ORDER BY effective_date ASC, record_id ASC
`, whereClause, assignmentClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query position timeline: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        result := make([]dto.PositionTimelineEntry, 0)
        for rows.Next() </span><span class="cov8" title="1">{
                var entry dto.PositionTimelineEntry
                var endDate sql.NullTime
                var changeReason sql.NullString
                var assignmentType sql.NullString
                var assignmentStatus sql.NullString
                if err := rows.Scan(
                        &amp;entry.RecordIDField,
                        &amp;entry.StatusField,
                        &amp;entry.TitleField,
                        &amp;entry.EffectiveDateField,
                        &amp;endDate,
                        &amp;entry.IsCurrentField,
                        &amp;changeReason,
                        &amp;entry.TimelineCategoryField,
                        &amp;assignmentType,
                        &amp;assignmentStatus,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan timeline entry: %w", err)
                }</span>
                <span class="cov8" title="1">if endDate.Valid </span><span class="cov0" title="0">{
                        entry.EndDateField = &amp;endDate.Time
                }</span>
                <span class="cov8" title="1">if changeReason.Valid </span><span class="cov8" title="1">{
                        entry.ChangeReasonField = &amp;changeReason.String
                }</span>
                <span class="cov8" title="1">if assignmentType.Valid </span><span class="cov8" title="1">{
                        val := strings.ToUpper(strings.TrimSpace(assignmentType.String))
                        entry.AssignmentTypeField = &amp;val
                }</span>
                <span class="cov8" title="1">if assignmentStatus.Valid </span><span class="cov8" title="1">{
                        val := strings.ToUpper(strings.TrimSpace(assignmentStatus.String))
                        entry.AssignmentStatusField = &amp;val
                }</span>
                <span class="cov8" title="1">if strings.TrimSpace(entry.TimelineCategoryField) == "" </span><span class="cov0" title="0">{
                        entry.TimelineCategoryField = "POSITION_VERSION"
                }</span>
                <span class="cov8" title="1">result = append(result, entry)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate timeline: %w", err)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (r *PostgreSQLRepository) GetVacantPositions(ctx context.Context, tenantID uuid.UUID, organizationCode *string, positionType *string, includeSubordinates bool) ([]dto.Position, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String()}
        argIndex := 2

        whereParts := []string{"p.tenant_id = $1", "p.is_current = true", "(p.status = 'VACANT' OR p.headcount_capacity &gt; p.headcount_in_use)", "p.status &lt;&gt; 'DELETED'"}
        joins := ""

        if organizationCode != nil &amp;&amp; strings.TrimSpace(*organizationCode) != "" </span><span class="cov0" title="0">{
                orgCode := strings.TrimSpace(*organizationCode)
                if includeSubordinates </span><span class="cov0" title="0">{
                        joins = `
WITH org_scope AS (
    SELECT DISTINCT ON (code)
        code,
        COALESCE(code_path, '/' || code) AS code_path
    FROM organization_units
    WHERE tenant_id = $1
      AND code = $2
      AND is_current = true
    ORDER BY code, effective_date DESC, created_at DESC
)
SELECT
    p.record_id::text,
    p.tenant_id::text,
    p.code,
    p.title,
    p.job_profile_code,
    p.job_profile_name,
    p.job_family_group_code,
    p.job_family_code,
    p.job_role_code,
    p.job_level_code,
    p.organization_code,
    p.position_type,
    p.employment_type,
    p.grade_level,
    p.headcount_capacity,
    p.headcount_in_use,
    p.reports_to_position_code,
    p.status,
    p.effective_date,
    p.end_date,
    p.is_current,
    p.created_at,
    p.updated_at,
    p.job_family_group_name,
    p.job_family_name,
    p.job_role_name,
    p.job_level_name,
    p.organization_name
FROM positions p
JOIN organization_units ou ON ou.tenant_id = p.tenant_id AND ou.code = p.organization_code AND ou.is_current = true
CROSS JOIN org_scope scope
WHERE p.tenant_id = $1
  AND p.is_current = true
  AND p.status &lt;&gt; 'DELETED'
  AND (p.status = 'VACANT' OR p.headcount_capacity &gt; p.headcount_in_use)
  AND (
      ou.code = scope.code OR ou.code_path LIKE scope.code_path || '/%'
  )`
                        // when includeSubordinates with org scope, we build entire query directly
                        args = append(args, orgCode)
                        if positionType != nil &amp;&amp; strings.TrimSpace(*positionType) != "" </span><span class="cov0" title="0">{
                                joins += fmt.Sprintf(" AND p.position_type = $%d", argIndex+1)
                                args = append(args, strings.ToUpper(strings.TrimSpace(*positionType)))
                        }</span>
                        <span class="cov0" title="0">joins += "\nORDER BY p.code"
                        rows, err := r.db.QueryContext(ctx, joins, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("query vacant positions: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer rows.Close()

                        result := make([]dto.Position, 0)
                        for rows.Next() </span><span class="cov0" title="0">{
                                pos, scanErr := scanPosition(rows)
                                if scanErr != nil </span><span class="cov0" title="0">{
                                        return nil, scanErr
                                }</span>
                                <span class="cov0" title="0">result = append(result, *pos)</span>
                        }
                        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("iterate vacant positions: %w", err)
                        }</span>
                        <span class="cov0" title="0">return result, nil</span>
                }

                <span class="cov0" title="0">whereParts = append(whereParts, fmt.Sprintf("p.organization_code = $%d", argIndex))
                args = append(args, orgCode)
                argIndex++</span>
        }

        <span class="cov0" title="0">if positionType != nil &amp;&amp; strings.TrimSpace(*positionType) != "" &amp;&amp; includeSubordinates </span>{<span class="cov0" title="0">
                // already handled above when building custom query
        }</span> else<span class="cov0" title="0"> if positionType != nil &amp;&amp; strings.TrimSpace(*positionType) != "" </span><span class="cov0" title="0">{
                whereParts = append(whereParts, fmt.Sprintf("p.position_type = $%d", argIndex))
                args = append(args, strings.ToUpper(strings.TrimSpace(*positionType)))
                argIndex++
        }</span>

        <span class="cov0" title="0">if includeSubordinates &amp;&amp; (organizationCode == nil || strings.TrimSpace(*organizationCode) == "") </span><span class="cov0" title="0">{
                // no organization code provided; includeSubordinates irrelevant
                includeSubordinates = false
        }</span>

        <span class="cov0" title="0">if includeSubordinates </span>{<span class="cov0" title="0">
                // already handled via custom query above, so skip here
        }</span>

        <span class="cov0" title="0">whereClause := ""
        if len(whereParts) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = "WHERE " + strings.Join(whereParts, " AND ")
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
SELECT
    p.record_id::text,
    p.tenant_id::text,
    p.code,
    p.title,
    p.job_profile_code,
    p.job_profile_name,
    p.job_family_group_code,
    p.job_family_code,
    p.job_role_code,
    p.job_level_code,
    p.organization_code,
    p.position_type,
    p.employment_type,
    p.grade_level,
    p.headcount_capacity,
    p.headcount_in_use,
    p.reports_to_position_code,
    p.status,
    p.effective_date,
    p.end_date,
    p.is_current,
    p.created_at,
    p.updated_at,
    p.job_family_group_name,
    p.job_family_name,
    p.job_role_name,
    p.job_level_name,
    p.organization_name
FROM positions p
%s
ORDER BY p.code
`, whereClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query vacant positions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        result := make([]dto.Position, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                pos, scanErr := scanPosition(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov0" title="0">result = append(result, *pos)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate vacant positions: %w", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *PostgreSQLRepository) GetPositionHeadcountStats(ctx context.Context, tenantID uuid.UUID, organizationCode string, includeSubordinates bool) (*dto.HeadcountStats, error) <span class="cov0" title="0">{
        var (
                orgName  string
                codePath string
        )

        scopeQuery := `
SELECT name, COALESCE(code_path, '/' || code) AS code_path
FROM organization_units
WHERE tenant_id = $1 AND code = $2 AND is_current = true
ORDER BY effective_date DESC, created_at DESC
LIMIT 1`

        if err := r.db.QueryRowContext(ctx, scopeQuery, tenantID.String(), organizationCode).Scan(&amp;orgName, &amp;codePath); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return &amp;dto.HeadcountStats{
                                OrganizationCodeField: organizationCode,
                                OrganizationNameField: "",
                                TotalCapacityField:    0,
                                TotalFilledField:      0,
                                TotalAvailableField:   0,
                                LevelBreakdownField:   []dto.LevelHeadcount{},
                                TypeBreakdownField:    []dto.TypeHeadcount{},
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("lookup organization scope: %w", err)</span>
        }

        <span class="cov0" title="0">args := []interface{}{tenantID.String(), organizationCode}

        condition := "ou.code = $2"
        if includeSubordinates </span><span class="cov0" title="0">{
                condition = "(ou.code = $2 OR ou.code_path LIKE $3)"
                args = append(args, codePath+"/%")
        }</span>

        <span class="cov0" title="0">statsQuery := fmt.Sprintf(`
SELECT
    COALESCE(SUM(p.headcount_capacity), 0) AS capacity,
    COALESCE(SUM(p.headcount_in_use), 0) AS filled
FROM positions p
JOIN organization_units ou ON ou.tenant_id = p.tenant_id AND ou.code = p.organization_code AND ou.is_current = true
WHERE p.tenant_id = $1
  AND p.is_current = true
  AND p.status &lt;&gt; 'DELETED'
  AND %s
`, condition)

        var totalCapacity, totalFilled float64
        if err := r.db.QueryRowContext(ctx, statsQuery, args...).Scan(&amp;totalCapacity, &amp;totalFilled); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query headcount totals: %w", err)
        }</span>

        <span class="cov0" title="0">levelQuery := fmt.Sprintf(`
SELECT
    p.job_level_code,
    COALESCE(SUM(p.headcount_capacity), 0) AS capacity,
    COALESCE(SUM(p.headcount_in_use), 0) AS utilized,
    COALESCE(SUM(p.headcount_capacity - p.headcount_in_use), 0) AS available
FROM positions p
JOIN organization_units ou ON ou.tenant_id = p.tenant_id AND ou.code = p.organization_code AND ou.is_current = true
WHERE p.tenant_id = $1
  AND p.is_current = true
  AND p.status &lt;&gt; 'DELETED'
  AND %s
GROUP BY p.job_level_code
ORDER BY p.job_level_code
`, condition)

        levelRows, err := r.db.QueryContext(ctx, levelQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query level headcount: %w", err)
        }</span>
        <span class="cov0" title="0">defer levelRows.Close()

        levelBreakdown := make([]dto.LevelHeadcount, 0)
        for levelRows.Next() </span><span class="cov0" title="0">{
                var item dto.LevelHeadcount
                if err := levelRows.Scan(&amp;item.JobLevelCodeField, &amp;item.CapacityField, &amp;item.UtilizedField, &amp;item.AvailableField); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan level headcount: %w", err)
                }</span>
                <span class="cov0" title="0">levelBreakdown = append(levelBreakdown, item)</span>
        }
        <span class="cov0" title="0">if err := levelRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate level headcount: %w", err)
        }</span>

        <span class="cov0" title="0">typeQuery := fmt.Sprintf(`
SELECT
    p.position_type,
    COALESCE(SUM(p.headcount_capacity), 0) AS capacity,
    COALESCE(SUM(p.headcount_in_use), 0) AS filled,
    COALESCE(SUM(p.headcount_capacity - p.headcount_in_use), 0) AS available
FROM positions p
JOIN organization_units ou ON ou.tenant_id = p.tenant_id AND ou.code = p.organization_code AND ou.is_current = true
WHERE p.tenant_id = $1
  AND p.is_current = true
  AND p.status &lt;&gt; 'DELETED'
  AND %s
GROUP BY p.position_type
ORDER BY p.position_type
`, condition)

        typeRows, err := r.db.QueryContext(ctx, typeQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query type headcount: %w", err)
        }</span>
        <span class="cov0" title="0">defer typeRows.Close()

        typeBreakdown := make([]dto.TypeHeadcount, 0)
        for typeRows.Next() </span><span class="cov0" title="0">{
                var item dto.TypeHeadcount
                if err := typeRows.Scan(&amp;item.PositionTypeField, &amp;item.CapacityField, &amp;item.FilledField, &amp;item.AvailableField); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan type headcount: %w", err)
                }</span>
                <span class="cov0" title="0">typeBreakdown = append(typeBreakdown, item)</span>
        }
        <span class="cov0" title="0">if err := typeRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate type headcount: %w", err)
        }</span>

        <span class="cov0" title="0">familyQuery := fmt.Sprintf(`
SELECT
    p.job_family_code,
    MAX(p.job_family_name) AS job_family_name,
    COALESCE(SUM(p.headcount_capacity), 0) AS capacity,
    COALESCE(SUM(p.headcount_in_use), 0) AS utilized,
    COALESCE(SUM(p.headcount_capacity - p.headcount_in_use), 0) AS available
FROM positions p
JOIN organization_units ou ON ou.tenant_id = p.tenant_id AND ou.code = p.organization_code AND ou.is_current = true
WHERE p.tenant_id = $1
  AND p.is_current = true
  AND p.status &lt;&gt; 'DELETED'
  AND %s
GROUP BY p.job_family_code
ORDER BY p.job_family_code
`, condition)

        familyRows, err := r.db.QueryContext(ctx, familyQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query family headcount: %w", err)
        }</span>
        <span class="cov0" title="0">defer familyRows.Close()

        familyBreakdown := make([]dto.FamilyHeadcount, 0)
        for familyRows.Next() </span><span class="cov0" title="0">{
                var item dto.FamilyHeadcount
                if err := familyRows.Scan(&amp;item.JobFamilyCodeField, &amp;item.JobFamilyNameField, &amp;item.CapacityField, &amp;item.UtilizedField, &amp;item.AvailableField); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan family headcount: %w", err)
                }</span>
                <span class="cov0" title="0">familyBreakdown = append(familyBreakdown, item)</span>
        }
        <span class="cov0" title="0">if err := familyRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate family headcount: %w", err)
        }</span>

        <span class="cov0" title="0">stats := &amp;dto.HeadcountStats{
                OrganizationCodeField: organizationCode,
                OrganizationNameField: orgName,
                TotalCapacityField:    totalCapacity,
                TotalFilledField:      totalFilled,
                TotalAvailableField:   totalCapacity - totalFilled,
                LevelBreakdownField:   levelBreakdown,
                TypeBreakdownField:    typeBreakdown,
                FamilyBreakdownField:  familyBreakdown,
        }

        return stats, nil</span>
}

func (r *PostgreSQLRepository) GetPositionVersions(ctx context.Context, tenantID uuid.UUID, code string, includeDeleted bool) ([]dto.Position, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String(), strings.TrimSpace(code)}
        whereParts := []string{"p.tenant_id = $1", "p.code = $2"}
        if !includeDeleted </span><span class="cov0" title="0">{
                whereParts = append(whereParts, "p.status &lt;&gt; 'DELETED'")
        }</span>

        <span class="cov0" title="0">whereClause := "WHERE " + strings.Join(whereParts, " AND ")

        query := fmt.Sprintf(`
SELECT
    p.record_id::text,
    p.tenant_id::text,
    p.code,
    p.title,
    p.job_profile_code,
    p.job_profile_name,
    p.job_family_group_code,
    p.job_family_code,
    p.job_role_code,
    p.job_level_code,
    p.organization_code,
    p.position_type,
    p.employment_type,
    p.grade_level,
    p.headcount_capacity,
    p.headcount_in_use,
    p.reports_to_position_code,
    p.status,
    p.effective_date,
    p.end_date,
    p.is_current,
    p.created_at,
    p.updated_at,
    p.job_family_group_name,
    p.job_family_name,
    p.job_role_name,
    p.job_level_name,
    p.organization_name
FROM positions p
%s
ORDER BY p.effective_date DESC, p.created_at DESC
`, whereClause)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query position versions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        versions := make([]dto.Position, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                pos, scanErr := scanPosition(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov0" title="0">versions = append(versions, *pos)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate position versions: %w", err)
        }</span>

        <span class="cov0" title="0">return versions, nil</span>
}

func (r *PostgreSQLRepository) GetVacantPositionConnection(ctx context.Context, tenantID uuid.UUID, filter *dto.VacantPositionFilterInput, pagination *dto.PaginationInput, sorting []dto.VacantPositionSortInput) (*dto.VacantPositionConnection, error) <span class="cov0" title="0">{
        args := []interface{}{tenantID.String()}
        argIndex := 2
        whereParts := []string{
                "p.tenant_id = $1",
                "p.is_current = true",
                "p.status &lt;&gt; 'DELETED'",
        }

        if filter != nil </span><span class="cov0" title="0">{
                if orgCodes := filter.OrganizationCodes; orgCodes != nil &amp;&amp; len(*orgCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.organization_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*orgCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobFamilyCodes := filter.JobFamilyCodes; jobFamilyCodes != nil &amp;&amp; len(*jobFamilyCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_family_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobFamilyCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobRoleCodes := filter.JobRoleCodes; jobRoleCodes != nil &amp;&amp; len(*jobRoleCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_role_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobRoleCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if jobLevelCodes := filter.JobLevelCodes; jobLevelCodes != nil &amp;&amp; len(*jobLevelCodes) &gt; 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("p.job_level_code = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(toStringSlice(*jobLevelCodes)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if positionTypes := filter.PositionTypes; positionTypes != nil &amp;&amp; len(*positionTypes) &gt; 0 </span><span class="cov0" title="0">{
                        values := make([]string, 0, len(*positionTypes))
                        for _, v := range *positionTypes </span><span class="cov0" title="0">{
                                values = append(values, strings.ToUpper(strings.TrimSpace(v)))
                        }</span>
                        <span class="cov0" title="0">whereParts = append(whereParts, fmt.Sprintf("p.position_type = ANY($%d)", argIndex))
                        args = append(args, pq.StringArray(values))
                        argIndex++</span>
                }
        }

        <span class="cov0" title="0">whereClause := ""
        if len(whereParts) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = "WHERE " + strings.Join(whereParts, " AND ")
        }</span>

        <span class="cov0" title="0">asOfDate := time.Now().UTC().Format("2006-01-02")
        if filter != nil &amp;&amp; filter.AsOfDate != nil &amp;&amp; strings.TrimSpace(*filter.AsOfDate) != "" </span><span class="cov0" title="0">{
                asOfDate = strings.TrimSpace(*filter.AsOfDate)
        }</span>
        <span class="cov0" title="0">args = append(args, asOfDate)
        asOfIdx := len(args)

        minVacantIdx := 0
        if filter != nil &amp;&amp; filter.MinimumVacantDays != nil &amp;&amp; *filter.MinimumVacantDays &gt;= 0 </span><span class="cov0" title="0">{
                args = append(args, *filter.MinimumVacantDays)
                minVacantIdx = len(args)
        }</span>

        <span class="cov0" title="0">page := int32(1)
        pageSize := int32(25)
        if pagination != nil </span><span class="cov0" title="0">{
                if pagination.Page &gt; 0 </span><span class="cov0" title="0">{
                        page = pagination.Page
                }</span>
                <span class="cov0" title="0">if pagination.PageSize &gt; 0 </span><span class="cov0" title="0">{
                        pageSize = pagination.PageSize
                        if pageSize &gt; 200 </span><span class="cov0" title="0">{
                                pageSize = 200
                        }</span>
                }
        }

        <span class="cov0" title="0">offset := int((page - 1) * pageSize)
        limit := int(pageSize)

        selectionConditions := []string{"comp.headcount_available &gt; 0"}
        if minVacantIdx &gt; 0 </span><span class="cov0" title="0">{
                selectionConditions = append(selectionConditions, fmt.Sprintf("comp.vacant_days &gt;= $%d", minVacantIdx))
        }</span>
        <span class="cov0" title="0">selectionWhere := strings.Join(selectionConditions, " AND ")

        baseCTE := fmt.Sprintf(`
WITH filtered_positions AS (
    SELECT
        p.code,
        p.organization_code,
        p.organization_name,
        p.job_family_code,
        p.job_role_code,
        p.job_level_code,
        p.headcount_capacity,
        p.effective_date
    FROM positions p
    %s
),
assignment_snapshot AS (
    SELECT
        pa.position_code,
        COALESCE(SUM(CASE WHEN pa.assignment_status &lt;&gt; 'ENDED'
            AND pa.effective_date &lt;= $%d
            AND (pa.end_date IS NULL OR pa.end_date &gt; $%d)
            THEN pa.fte ELSE 0 END), 0) AS active_fte,
        MAX(CASE WHEN pa.assignment_status = 'ENDED' AND pa.end_date &lt;= $%d THEN pa.end_date END) AS last_vacated,
        COUNT(*) AS total_assignments
    FROM position_assignments pa
    JOIN filtered_positions fp ON fp.code = pa.position_code
    WHERE pa.tenant_id = $1
    GROUP BY pa.position_code
),
computed AS (
    SELECT
        fp.code AS position_code,
        fp.organization_code,
        fp.organization_name,
        fp.job_family_code,
        fp.job_role_code,
        fp.job_level_code,
        fp.headcount_capacity,
        COALESCE(asnap.active_fte, 0) AS active_fte,
        COALESCE(asnap.last_vacated, fp.effective_date) AS vacant_since,
        COALESCE(asnap.total_assignments, 0) AS total_assignments,
        GREATEST(fp.headcount_capacity - COALESCE(asnap.active_fte, 0), 0) AS headcount_available,
        DATE_PART('day', $%d::date - COALESCE(asnap.last_vacated, fp.effective_date))::int AS vacant_days
    FROM filtered_positions fp
    LEFT JOIN assignment_snapshot asnap ON asnap.position_code = fp.code
)
`, whereClause, asOfIdx, asOfIdx, asOfIdx, asOfIdx)

        countArgs := append([]interface{}{}, args...)
        countQuery := fmt.Sprintf(`%s SELECT COUNT(*) FROM computed comp WHERE %s`, baseCTE, selectionWhere)

        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count vacant positions: %w", err)
        }</span>

        <span class="cov0" title="0">orderClause := "ORDER BY comp.vacant_since ASC, comp.position_code ASC"
        if len(sorting) &gt; 0 </span><span class="cov0" title="0">{
                orderParts := make([]string, 0, len(sorting))
                for _, sort := range sorting </span><span class="cov0" title="0">{
                        field := strings.ToUpper(strings.TrimSpace(sort.Field))
                        column := ""
                        switch field </span>{
                        case "VACANT_SINCE":<span class="cov0" title="0">
                                column = "comp.vacant_since"</span>
                        case "HEADCOUNT_AVAILABLE":<span class="cov0" title="0">
                                column = "comp.headcount_available"</span>
                        case "HEADCOUNT_CAPACITY":<span class="cov0" title="0">
                                column = "comp.headcount_capacity"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                        <span class="cov0" title="0">direction := strings.ToUpper(strings.TrimSpace(sort.Direction))
                        if direction != "ASC" </span><span class="cov0" title="0">{
                                direction = "DESC"
                        }</span>
                        <span class="cov0" title="0">orderParts = append(orderParts, fmt.Sprintf("%s %s", column, direction))</span>
                }
                <span class="cov0" title="0">if len(orderParts) &gt; 0 </span><span class="cov0" title="0">{
                        orderParts = append(orderParts, "comp.position_code ASC")
                        orderClause = "ORDER BY " + strings.Join(orderParts, ", ")
                }</span>
        }

        <span class="cov0" title="0">dataArgs := append([]interface{}{}, args...)
        limitIdx := len(dataArgs) + 1
        dataArgs = append(dataArgs, limit)
        offsetIdx := len(dataArgs) + 1
        dataArgs = append(dataArgs, offset)

        dataQuery := fmt.Sprintf(`
%s
SELECT
    comp.position_code,
    comp.organization_code,
    comp.organization_name,
    comp.job_family_code,
    comp.job_role_code,
    comp.job_level_code,
    comp.vacant_since,
    comp.headcount_capacity,
    comp.headcount_available,
    comp.total_assignments
FROM computed comp
WHERE %s
%s
LIMIT $%d OFFSET $%d
`, baseCTE, selectionWhere, orderClause, limitIdx, offsetIdx)

        rows, err := r.db.QueryContext(ctx, dataQuery, dataArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query vacant positions connection: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        vacants := make([]dto.VacantPosition, 0, limit)
        for rows.Next() </span><span class="cov0" title="0">{
                record, scanErr := scanVacantPosition(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov0" title="0">vacants = append(vacants, *record)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate vacant positions: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := 0
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages = (total + int(pageSize) - 1) / int(pageSize)
        }</span>

        <span class="cov0" title="0">edges := make([]dto.VacantPositionEdge, 0, len(vacants))
        for _, item := range vacants </span><span class="cov0" title="0">{
                edges = append(edges, dto.VacantPositionEdge{
                        CursorField: item.PositionCodeField,
                        NodeField:   item,
                })
        }</span>

        <span class="cov0" title="0">connection := &amp;dto.VacantPositionConnection{
                EdgesField: edges,
                DataField:  vacants,
                PaginationField: dto.PaginationInfo{
                        TotalField:       total,
                        PageField:        int(page),
                        PageSizeField:    int(pageSize),
                        HasNextField:     int(page) &lt; totalPages,
                        HasPreviousField: page &gt; 1,
                },
                TotalCountField: total,
        }

        return connection, nil</span>
}

func (r *PostgreSQLRepository) GetPositionAssignments(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error) <span class="cov0" title="0">{
        page := int32(1)
        pageSize := int32(25)
        if pagination != nil </span><span class="cov0" title="0">{
                if pagination.Page &gt; 0 </span><span class="cov0" title="0">{
                        page = pagination.Page
                }</span>
                <span class="cov0" title="0">if pagination.PageSize &gt; 0 </span><span class="cov0" title="0">{
                        pageSize = pagination.PageSize
                        if pageSize &gt; 200 </span><span class="cov0" title="0">{
                                pageSize = 200
                        }</span>
                }
        }

        <span class="cov0" title="0">offset := int((page - 1) * pageSize)
        limit := int(pageSize)

        args := []interface{}{tenantID.String(), strings.TrimSpace(positionCode)}
        argIndex := 3
        whereParts := []string{"tenant_id = $1", "position_code = $2"}

        if filter != nil </span><span class="cov0" title="0">{
                if filter.EmployeeID != nil &amp;&amp; strings.TrimSpace(*filter.EmployeeID) != "" </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("employee_id = $%d", argIndex))
                        args = append(args, strings.TrimSpace(*filter.EmployeeID))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if filter.Status != nil &amp;&amp; strings.TrimSpace(*filter.Status) != "" </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("assignment_status = $%d", argIndex))
                        args = append(args, strings.ToUpper(strings.TrimSpace(*filter.Status)))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if filter.AssignmentTypes != nil &amp;&amp; len(*filter.AssignmentTypes) &gt; 0 </span><span class="cov0" title="0">{
                        normalized := make([]string, 0, len(*filter.AssignmentTypes))
                        for _, item := range *filter.AssignmentTypes </span><span class="cov0" title="0">{
                                trimmed := strings.ToUpper(strings.TrimSpace(item))
                                if trimmed == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">normalized = append(normalized, trimmed)</span>
                        }
                        <span class="cov0" title="0">if len(normalized) &gt; 0 </span><span class="cov0" title="0">{
                                whereParts = append(whereParts, fmt.Sprintf("assignment_type = ANY($%d)", argIndex))
                                args = append(args, pq.StringArray(normalized))
                                argIndex++
                        }</span>
                }
                <span class="cov0" title="0">if filter.AsOfDate != nil &amp;&amp; strings.TrimSpace(*filter.AsOfDate) != "" </span><span class="cov0" title="0">{
                        whereParts = append(whereParts,
                                fmt.Sprintf("(effective_date &lt;= $%d AND (end_date IS NULL OR end_date &gt;= $%d))", argIndex, argIndex))
                        args = append(args, strings.TrimSpace(*filter.AsOfDate))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if filter.DateRange != nil </span><span class="cov0" title="0">{
                        if filter.DateRange.From != nil &amp;&amp; strings.TrimSpace(*filter.DateRange.From) != "" </span><span class="cov0" title="0">{
                                whereParts = append(whereParts, fmt.Sprintf("effective_date &gt;= $%d", argIndex))
                                args = append(args, strings.TrimSpace(*filter.DateRange.From))
                                argIndex++
                        }</span>
                        <span class="cov0" title="0">if filter.DateRange.To != nil &amp;&amp; strings.TrimSpace(*filter.DateRange.To) != "" </span><span class="cov0" title="0">{
                                whereParts = append(whereParts, fmt.Sprintf("effective_date &lt;= $%d", argIndex))
                                args = append(args, strings.TrimSpace(*filter.DateRange.To))
                                argIndex++
                        }</span>
                }
                <span class="cov0" title="0">if filter.IncludeActingOnly </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, "assignment_type = 'ACTING'")
                }</span>
                <span class="cov0" title="0">if !filter.IncludeHistorical </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, "assignment_status &lt;&gt; 'ENDED'")
                }</span>
        }

        <span class="cov0" title="0">whereClause := ""
        if len(whereParts) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = "WHERE " + strings.Join(whereParts, " AND ")
        }</span>

        <span class="cov0" title="0">orderClause := "ORDER BY effective_date DESC, created_at DESC"
        if len(sorting) &gt; 0 </span><span class="cov0" title="0">{
                orderParts := make([]string, 0, len(sorting))
                for _, sort := range sorting </span><span class="cov0" title="0">{
                        field := strings.ToUpper(strings.TrimSpace(sort.Field))
                        column := ""
                        switch field </span>{
                        case "START_DATE", "EFFECTIVE_DATE":<span class="cov0" title="0">
                                column = "effective_date"</span>
                        case "END_DATE":<span class="cov0" title="0">
                                column = "end_date"</span>
                        case "CREATED_AT":<span class="cov0" title="0">
                                column = "created_at"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                        <span class="cov0" title="0">direction := strings.ToUpper(strings.TrimSpace(sort.Direction))
                        if direction != "ASC" </span><span class="cov0" title="0">{
                                direction = "DESC"
                        }</span>
                        <span class="cov0" title="0">orderParts = append(orderParts, fmt.Sprintf("%s %s", column, direction))</span>
                }
                <span class="cov0" title="0">if len(orderParts) &gt; 0 </span><span class="cov0" title="0">{
                        orderClause = "ORDER BY " + strings.Join(orderParts, ", ")
                }</span>
        }

        <span class="cov0" title="0">countQuery := fmt.Sprintf(`SELECT COUNT(*) FROM position_assignments %s`, whereClause)
        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count position assignments: %w", err)
        }</span>

        <span class="cov0" title="0">selectQuery := fmt.Sprintf(`
SELECT
    assignment_id::text,
    tenant_id::text,
    position_code,
    position_record_id::text,
    employee_id::text,
    employee_name,
    employee_number,
    assignment_type,
    assignment_status,
    fte,
    effective_date,
    end_date,
    acting_until,
    auto_revert,
    reminder_sent_at,
    is_current,
    notes,
    created_at,
    updated_at
FROM position_assignments
%s
%s
LIMIT $%d OFFSET $%d`, whereClause, orderClause, argIndex, argIndex+1)

        queryArgs := append([]interface{}{}, args...)
        queryArgs = append(queryArgs, limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, queryArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query position assignments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        assignments := make([]dto.PositionAssignment, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                assignment, scanErr := scanPositionAssignment(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov0" title="0">assignments = append(assignments, *assignment)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate position assignments: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := 0
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages = (total + int(pageSize) - 1) / int(pageSize)
        }</span>

        <span class="cov0" title="0">edges := make([]dto.PositionAssignmentEdge, 0, len(assignments))
        for _, assignment := range assignments </span><span class="cov0" title="0">{
                edges = append(edges, dto.PositionAssignmentEdge{
                        CursorField: assignment.AssignmentIDField,
                        NodeField:   assignment,
                })
        }</span>

        <span class="cov0" title="0">connection := &amp;dto.PositionAssignmentConnection{
                EdgesField: edges,
                DataField:  assignments,
                PaginationField: dto.PaginationInfo{
                        TotalField:       total,
                        PageField:        int(page),
                        PageSizeField:    int(pageSize),
                        HasNextField:     int(page) &lt; totalPages,
                        HasPreviousField: page &gt; 1,
                },
                TotalCountField: total,
        }

        return connection, nil</span>
}

func (r *PostgreSQLRepository) GetPositionAssignmentAudit(ctx context.Context, tenantID uuid.UUID, positionCode string, assignmentID *string, dateRange *dto.DateRangeInput, pagination *dto.PaginationInput) (*dto.PositionAssignmentAuditConnection, error) <span class="cov0" title="0">{
        page := int32(1)
        pageSize := int32(25)
        if pagination != nil </span><span class="cov0" title="0">{
                if pagination.Page &gt; 0 </span><span class="cov0" title="0">{
                        page = pagination.Page
                }</span>
                <span class="cov0" title="0">if pagination.PageSize &gt; 0 </span><span class="cov0" title="0">{
                        pageSize = pagination.PageSize
                        if pageSize &gt; 500 </span><span class="cov0" title="0">{
                                pageSize = 500
                        }</span>
                }
        }

        <span class="cov0" title="0">limit := int(pageSize)
        offset := int((page - 1) * pageSize)

        args := []interface{}{tenantID.String(), strings.TrimSpace(positionCode)}
        conditions := []string{
                "al.tenant_id = $1",
                "p.code = $2",
                "al.resource_type = 'POSITION'",
                "al.response_data ? 'assignmentId'",
                "NULLIF(al.response_data-&gt;&gt;'assignmentId', '') IS NOT NULL",
        }
        argIndex := 3

        if assignmentID != nil &amp;&amp; strings.TrimSpace(*assignmentID) != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, fmt.Sprintf("al.response_data-&gt;&gt;'assignmentId' = $%d", argIndex))
                args = append(args, strings.TrimSpace(*assignmentID))
                argIndex++
        }</span>

        <span class="cov0" title="0">if dateRange != nil </span><span class="cov0" title="0">{
                if dateRange.From != nil &amp;&amp; strings.TrimSpace(*dateRange.From) != "" </span><span class="cov0" title="0">{
                        conditions = append(conditions, fmt.Sprintf("al.timestamp &gt;= $%d", argIndex))
                        args = append(args, strings.TrimSpace(*dateRange.From))
                        argIndex++
                }</span>
                <span class="cov0" title="0">if dateRange.To != nil &amp;&amp; strings.TrimSpace(*dateRange.To) != "" </span><span class="cov0" title="0">{
                        conditions = append(conditions, fmt.Sprintf("al.timestamp &lt;= $%d", argIndex))
                        args = append(args, strings.TrimSpace(*dateRange.To))
                        argIndex++
                }</span>
        }

        <span class="cov0" title="0">whereClause := strings.Join(conditions, " AND ")

        countQuery := fmt.Sprintf(`
SELECT COUNT(*)
FROM audit_logs al
JOIN positions p ON p.tenant_id = al.tenant_id AND p.record_id = al.resource_id::uuid
WHERE %s
`, whereClause)

        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count position assignment audit: %w", err)
        }</span>

        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return &amp;dto.PositionAssignmentAuditConnection{
                        DataField: []dto.PositionAssignmentAudit{},
                        PaginationField: dto.PaginationInfo{
                                TotalField:       0,
                                PageField:        int(page),
                                PageSizeField:    int(pageSize),
                                HasNextField:     false,
                                HasPreviousField: page &gt; 1,
                        },
                        TotalCountField: 0,
                }, nil
        }</span>

        <span class="cov0" title="0">selectQuery := fmt.Sprintf(`
SELECT
    al.response_data-&gt;&gt;'assignmentId' AS assignment_id,
    COALESCE(NULLIF(al.action_name, ''), al.event_type) AS event_type,
    COALESCE(pa.effective_date, NULLIF(al.response_data-&gt;&gt;'assignmentEffective', '')::date, al.timestamp::date) AS effective_date,
    COALESCE(pa.end_date, pa.acting_until, NULLIF(al.response_data-&gt;&gt;'assignmentEndDate', '')::date) AS end_date,
    COALESCE(al.business_context-&gt;&gt;'actor_name', al.actor_id) AS actor_name,
    COALESCE(al.changes, '[]'::jsonb)::text AS changes_json,
    al.timestamp
FROM audit_logs al
JOIN positions p ON p.tenant_id = al.tenant_id AND p.record_id = al.resource_id::uuid
LEFT JOIN position_assignments pa ON pa.tenant_id = al.tenant_id AND pa.assignment_id::text = al.response_data-&gt;&gt;'assignmentId'
WHERE %s
ORDER BY al.timestamp DESC
LIMIT $%d OFFSET $%d
`, whereClause, argIndex, argIndex+1)

        queryArgs := append([]interface{}{}, args...)
        queryArgs = append(queryArgs, limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, queryArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query position assignment audit: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        records := make([]dto.PositionAssignmentAudit, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var assignID sql.NullString
                var eventType sql.NullString
                var effectiveDate sql.NullTime
                var endDate sql.NullTime
                var actorName sql.NullString
                var changesJSON sql.NullString
                var timestamp time.Time

                if err := rows.Scan(&amp;assignID, &amp;eventType, &amp;effectiveDate, &amp;endDate, &amp;actorName, &amp;changesJSON, &amp;timestamp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan assignment audit row: %w", err)
                }</span>

                <span class="cov0" title="0">if !assignID.Valid || strings.TrimSpace(assignID.String) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">eventTypeValue := ""
                if eventType.Valid </span><span class="cov0" title="0">{
                        eventTypeValue = strings.TrimSpace(eventType.String)
                }</span>
                <span class="cov0" title="0">record := dto.PositionAssignmentAudit{
                        AssignmentIDField: assignID.String,
                        EventTypeField:    strings.ToUpper(eventTypeValue),
                        CreatedAtField:    timestamp,
                        ActorField:        strings.TrimSpace(actorName.String),
                }

                if effectiveDate.Valid </span><span class="cov0" title="0">{
                        record.EffectiveDateField = effectiveDate.Time
                }</span> else<span class="cov0" title="0"> {
                        record.EffectiveDateField = timestamp
                }</span>
                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        record.EndDateField = &amp;endDate.Time
                }</span>

                <span class="cov0" title="0">if changesJSON.Valid &amp;&amp; strings.TrimSpace(changesJSON.String) != "" &amp;&amp; strings.TrimSpace(changesJSON.String) != "[]" </span><span class="cov0" title="0">{
                        var parsed interface{}
                        if err := json.Unmarshal([]byte(changesJSON.String), &amp;parsed); err == nil </span><span class="cov0" title="0">{
                                switch val := parsed.(type) </span>{
                                case map[string]interface{}:<span class="cov0" title="0">
                                        record.ChangesField = val</span>
                                case []interface{}:<span class="cov0" title="0">
                                        record.ChangesField = map[string]interface{}{"items": val}</span>
                                }
                        }
                }

                <span class="cov0" title="0">if record.ActorField == "" </span><span class="cov0" title="0">{
                        record.ActorField = "system"
                }</span>

                <span class="cov0" title="0">records = append(records, record)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate position assignment audit: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := 0
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages = (total + int(pageSize) - 1) / int(pageSize)
        }</span>

        <span class="cov0" title="0">connection := &amp;dto.PositionAssignmentAuditConnection{
                DataField: records,
                PaginationField: dto.PaginationInfo{
                        TotalField:       total,
                        PageField:        int(page),
                        PageSizeField:    int(pageSize),
                        HasNextField:     int(page) &lt; totalPages,
                        HasPreviousField: page &gt; 1,
                },
                TotalCountField: total,
        }

        return connection, nil</span>
}

func scanPositionAssignment(scanner rowScanner) (*dto.PositionAssignment, error) <span class="cov0" title="0">{
        var (
                assignmentID,
                tenantID,
                positionCode,
                positionRecordID,
                employeeID,
                employeeName,
                assignmentType,
                assignmentStatus string
                employeeNumber sql.NullString
                fte            float64
                effectiveDate  time.Time
                endDate        sql.NullTime
                actingUntil    sql.NullTime
                autoRevert     bool
                reminderSentAt sql.NullTime
                isCurrent      bool
                notes          sql.NullString
                createdAt      time.Time
                updatedAt      time.Time
        )

        if err := scanner.Scan(
                &amp;assignmentID,
                &amp;tenantID,
                &amp;positionCode,
                &amp;positionRecordID,
                &amp;employeeID,
                &amp;employeeName,
                &amp;employeeNumber,
                &amp;assignmentType,
                &amp;assignmentStatus,
                &amp;fte,
                &amp;effectiveDate,
                &amp;endDate,
                &amp;actingUntil,
                &amp;autoRevert,
                &amp;reminderSentAt,
                &amp;isCurrent,
                &amp;notes,
                &amp;createdAt,
                &amp;updatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan position assignment: %w", err)
        }</span>

        <span class="cov0" title="0">assignment := &amp;dto.PositionAssignment{
                AssignmentIDField:     assignmentID,
                TenantIDField:         tenantID,
                PositionCodeField:     positionCode,
                PositionRecordIDField: positionRecordID,
                EmployeeIDField:       employeeID,
                EmployeeNameField:     employeeName,
                AssignmentTypeField:   assignmentType,
                AssignmentStatusField: assignmentStatus,
                FTEField:              fte,
                EffectiveDateField:    effectiveDate,
                AutoRevertField:       autoRevert,
                IsCurrentField:        isCurrent,
                CreatedAtField:        createdAt,
                UpdatedAtField:        updatedAt,
        }

        if employeeNumber.Valid </span><span class="cov0" title="0">{
                assignment.EmployeeNumberField = &amp;employeeNumber.String
        }</span>
        <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                assignment.EndDateField = &amp;endDate.Time
        }</span>
        <span class="cov0" title="0">if actingUntil.Valid </span><span class="cov0" title="0">{
                assignment.ActingUntilField = &amp;actingUntil.Time
        }</span>
        <span class="cov0" title="0">if reminderSentAt.Valid </span><span class="cov0" title="0">{
                assignment.ReminderSentAtField = &amp;reminderSentAt.Time
        }</span>
        <span class="cov0" title="0">if notes.Valid </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(notes.String)
                if trimmed != "" </span><span class="cov0" title="0">{
                        assignment.NotesField = &amp;trimmed
                }</span>
        }

        <span class="cov0" title="0">return assignment, nil</span>
}

func scanVacantPosition(scanner rowScanner) (*dto.VacantPosition, error) <span class="cov0" title="0">{
        var (
                positionCode       string
                organizationCode   string
                organizationName   sql.NullString
                jobFamilyCode      string
                jobRoleCode        string
                jobLevelCode       string
                vacantSince        time.Time
                headcountCapacity  float64
                headcountAvailable float64
                totalAssignments   int
        )

        if err := scanner.Scan(
                &amp;positionCode,
                &amp;organizationCode,
                &amp;organizationName,
                &amp;jobFamilyCode,
                &amp;jobRoleCode,
                &amp;jobLevelCode,
                &amp;vacantSince,
                &amp;headcountCapacity,
                &amp;headcountAvailable,
                &amp;totalAssignments,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan vacant position: %w", err)
        }</span>

        <span class="cov0" title="0">record := &amp;dto.VacantPosition{
                PositionCodeField:       positionCode,
                OrganizationCodeField:   organizationCode,
                JobFamilyCodeField:      jobFamilyCode,
                JobRoleCodeField:        jobRoleCode,
                JobLevelCodeField:       jobLevelCode,
                VacantSinceField:        vacantSince,
                HeadcountCapacityField:  headcountCapacity,
                HeadcountAvailableField: headcountAvailable,
                TotalAssignmentsField:   totalAssignments,
        }

        if organizationName.Valid </span><span class="cov0" title="0">{
                name := strings.TrimSpace(organizationName.String)
                if name != "" </span><span class="cov0" title="0">{
                        record.OrganizationNameField = &amp;name
                }</span>
        }

        <span class="cov0" title="0">return record, nil</span>
}

func scanPosition(scanner rowScanner) (*dto.Position, error) <span class="cov8" title="1">{
        var (
                recordID,
                tenantID,
                code,
                title string
                jobProfileCode,
                jobProfileName,
                gradeLevel,
                reportsTo,
                jobFamilyGroupName,
                jobFamilyName,
                jobRoleName,
                jobLevelName,
                organizationName sql.NullString
                jobFamilyGroupCode,
                jobFamilyCode,
                jobRoleCode,
                jobLevelCode,
                organizationCode,
                positionType,
                employmentType,
                status string
                headcountCapacity,
                headcountInUse float64
                effectiveDate time.Time
                endDate       sql.NullTime
                isCurrent     bool
                createdAt     time.Time
                updatedAt     time.Time
        )

        if err := scanner.Scan(
                &amp;recordID,
                &amp;tenantID,
                &amp;code,
                &amp;title,
                &amp;jobProfileCode,
                &amp;jobProfileName,
                &amp;jobFamilyGroupCode,
                &amp;jobFamilyCode,
                &amp;jobRoleCode,
                &amp;jobLevelCode,
                &amp;organizationCode,
                &amp;positionType,
                &amp;employmentType,
                &amp;gradeLevel,
                &amp;headcountCapacity,
                &amp;headcountInUse,
                &amp;reportsTo,
                &amp;status,
                &amp;effectiveDate,
                &amp;endDate,
                &amp;isCurrent,
                &amp;createdAt,
                &amp;updatedAt,
                &amp;jobFamilyGroupName,
                &amp;jobFamilyName,
                &amp;jobRoleName,
                &amp;jobLevelName,
                &amp;organizationName,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">normalizedStatus := normalizePositionStatus(status, effectiveDate, endDate, isCurrent)

        position := &amp;dto.Position{
                CodeField:               code,
                RecordIDField:           recordID,
                TenantIDField:           tenantID,
                TitleField:              title,
                JobFamilyGroupCodeField: jobFamilyGroupCode,
                JobFamilyCodeField:      jobFamilyCode,
                JobRoleCodeField:        jobRoleCode,
                JobLevelCodeField:       jobLevelCode,
                OrganizationCodeField:   organizationCode,
                PositionTypeField:       positionType,
                EmploymentTypeField:     employmentType,
                HeadcountCapacityField:  headcountCapacity,
                HeadcountInUseField:     headcountInUse,
                StatusField:             normalizedStatus,
                EffectiveDateField:      effectiveDate,
                IsCurrentField:          isCurrent,
                CreatedAtField:          createdAt,
                UpdatedAtField:          updatedAt,
        }

        if jobProfileCode.Valid </span><span class="cov0" title="0">{
                position.JobProfileCodeField = &amp;jobProfileCode.String
        }</span>
        <span class="cov8" title="1">if jobProfileName.Valid </span><span class="cov0" title="0">{
                position.JobProfileNameField = &amp;jobProfileName.String
        }</span>
        <span class="cov8" title="1">if gradeLevel.Valid </span><span class="cov0" title="0">{
                position.GradeLevelField = &amp;gradeLevel.String
        }</span>
        <span class="cov8" title="1">if reportsTo.Valid </span><span class="cov0" title="0">{
                position.ReportsToPositionField = &amp;reportsTo.String
        }</span>
        <span class="cov8" title="1">if endDate.Valid </span><span class="cov0" title="0">{
                position.EndDateField = &amp;endDate.Time
        }</span>
        <span class="cov8" title="1">if jobFamilyGroupName.Valid </span><span class="cov0" title="0">{
                position.JobFamilyGroupNameField = &amp;jobFamilyGroupName.String
        }</span>
        <span class="cov8" title="1">if jobFamilyName.Valid </span><span class="cov0" title="0">{
                position.JobFamilyNameField = &amp;jobFamilyName.String
        }</span>
        <span class="cov8" title="1">if jobRoleName.Valid </span><span class="cov0" title="0">{
                position.JobRoleNameField = &amp;jobRoleName.String
        }</span>
        <span class="cov8" title="1">if jobLevelName.Valid </span><span class="cov0" title="0">{
                position.JobLevelNameField = &amp;jobLevelName.String
        }</span>
        <span class="cov8" title="1">if organizationName.Valid </span><span class="cov8" title="1">{
                position.OrganizationNameField = &amp;organizationName.String
        }</span>

        <span class="cov8" title="1">return position, nil</span>
}

func normalizePositionStatus(status string, effectiveDate time.Time, endDate sql.NullTime, isCurrent bool) string <span class="cov8" title="1">{
        normalized := strings.ToUpper(strings.TrimSpace(status))
        if normalized != "PLANNED" </span><span class="cov8" title="1">{
                return normalized
        }</span>

        <span class="cov0" title="0">today := cnTodayUTC()
        if effectiveDate.After(today) </span><span class="cov0" title="0">{
                return normalized
        }</span>

        <span class="cov0" title="0">if isCurrent &amp;&amp; (!endDate.Valid || endDate.Time.After(today)) </span><span class="cov0" title="0">{
                return "ACTIVE"
        }</span>

        <span class="cov0" title="0">return "INACTIVE"</span>
}

func cnTodayUTC() time.Time <span class="cov0" title="0">{
        loc, err := time.LoadLocation("Asia/Shanghai")
        if err != nil </span><span class="cov0" title="0">{
                return time.Now().UTC().Truncate(24 * time.Hour)
        }</span>
        <span class="cov0" title="0">now := time.Now().In(loc)
        return time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc)</span>
}

func (r *PostgreSQLRepository) populatePositionAssignments(ctx context.Context, tenantID uuid.UUID, position *dto.Position) error <span class="cov0" title="0">{
        if position == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">assignments, err := r.fetchAssignmentsForPosition(ctx, tenantID, position.CodeField)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(assignments) == 0 </span><span class="cov0" title="0">{
                position.AssignmentHistoryField = []dto.PositionAssignment{}
                position.CurrentAssignmentField = nil
                return nil
        }</span>

        <span class="cov0" title="0">position.AssignmentHistoryField = assignments
        position.CurrentAssignmentField = nil

        for i := range position.AssignmentHistoryField </span><span class="cov0" title="0">{
                if position.AssignmentHistoryField[i].IsCurrent() </span><span class="cov0" title="0">{
                        position.CurrentAssignmentField = &amp;position.AssignmentHistoryField[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *PostgreSQLRepository) fetchAssignmentsForPosition(ctx context.Context, tenantID uuid.UUID, positionCode string) ([]dto.PositionAssignment, error) <span class="cov0" title="0">{
        code := strings.TrimSpace(positionCode)
        if code == "" </span><span class="cov0" title="0">{
                return []dto.PositionAssignment{}, nil
        }</span>

        <span class="cov0" title="0">query := `
SELECT
    assignment_id::text,
    tenant_id::text,
    position_code,
    position_record_id::text,
    employee_id::text,
    employee_name,
    employee_number,
    assignment_type,
    assignment_status,
    fte,
    effective_date,
    end_date,
    acting_until,
    auto_revert,
    reminder_sent_at,
    is_current,
    notes,
    created_at,
    updated_at
FROM position_assignments
WHERE tenant_id = $1 AND position_code = $2
ORDER BY effective_date DESC, created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, tenantID.String(), code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetch position assignments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        assignments := make([]dto.PositionAssignment, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                item, scanErr := scanPositionAssignment(rows)
                if scanErr != nil </span><span class="cov0" title="0">{
                        return nil, scanErr
                }</span>
                <span class="cov0" title="0">assignments = append(assignments, *item)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate position assignments: %w", err)
        }</span>

        <span class="cov0" title="0">return assignments, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/google/uuid"
)

func (tm *TemporalTimelineManager) DeleteVersion(ctx context.Context, tenantID uuid.UUID, recordID uuid.UUID) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        tx, err := tm.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelReadCommitted})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tm.logger.Infof("删除版本: RecordID=%s", recordID)

        var code string
        versionQuery := `
                SELECT code FROM organization_units 
                WHERE record_id = $1 AND tenant_id = $2`
        if err := tx.QueryRowContext(ctx, versionQuery, recordID, tenantID).Scan(&amp;code); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("查询版本信息失败: %w", err)
        }</span>

        <span class="cov0" title="0">deleteQuery := `
                UPDATE organization_units 
                SET status = 'DELETED',
                        deleted_at = NOW(),
                        is_current = false,
                        updated_at = NOW()
                WHERE record_id = $1 AND tenant_id = $2`
        if _, err := tx.ExecContext(ctx, deleteQuery, recordID, tenantID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("软删除版本失败: %w", err)
        }</span>

        <span class="cov0" title="0">timeline, err := tm.RecalculateTimelineInTx(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("全链重算失败: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Infof("版本删除成功，剩余版本: %d", len(*timeline))
        return timeline, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

func (tm *TemporalTimelineManager) InsertVersion(ctx context.Context, org *types.Organization) (*TimelineVersion, error) <span class="cov0" title="0">{
        tx, err := tm.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelReadCommitted})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tenantID, err := uuid.Parse(org.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效的租户ID: %w", err)
        }</span>

        <span class="cov0" title="0">effectiveDate := time.Date(org.EffectiveDate.Year(), org.EffectiveDate.Month(), org.EffectiveDate.Day(), 0, 0, 0, 0, time.UTC)

        tm.logger.Infof("插入版本: %s, 生效日期: %s", org.Code, effectiveDate.Format("2006-01-02"))

        adjacentQuery := `
                SELECT record_id, effective_date, end_date, is_current
                FROM organization_units 
                WHERE tenant_id = $1 
                  AND code = $2
                  AND status != 'DELETED' 
                ORDER BY effective_date
                FOR UPDATE`

        rows, err := tx.QueryContext(ctx, adjacentQuery, tenantID, org.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("查询相邻版本失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var recordID uuid.UUID
                var existingEffective time.Time
                var existingEnd *time.Time
                var existingCurrent bool

                if err := rows.Scan(&amp;recordID, &amp;existingEffective, &amp;existingEnd, &amp;existingCurrent); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("扫描相邻版本失败: %w", err)
                }</span>

                <span class="cov0" title="0">if existingEffective.Equal(effectiveDate) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("TEMPORAL_POINT_CONFLICT: 生效日期 %s 已存在", effectiveDate.Format("2006-01-02"))
                }</span>
        }

        <span class="cov0" title="0">insertQuery := `
        INSERT INTO organization_units (
                tenant_id, code, parent_code, name, unit_type, status,
                level, code_path, name_path, sort_order, description, effective_date,
                is_current, change_reason, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, false, $13, NOW(), NOW())
        RETURNING record_id, created_at`

        var newRecordID uuid.UUID
        var createdAt time.Time

        if err := tx.QueryRowContext(ctx, insertQuery,
                tenantID, org.Code, org.ParentCode, org.Name, org.UnitType, "ACTIVE",
                org.Level, org.CodePath, org.NamePath, org.SortOrder, org.Description, effectiveDate,
                org.ChangeReason,
        ).Scan(&amp;newRecordID, &amp;createdAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("插入新版本失败: %w", err)
        }</span>

        <span class="cov0" title="0">if _, err := tm.RecalculateTimelineInTx(ctx, tx, tenantID, org.Code); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("全链重算失败: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Infof("版本插入成功: RecordID=%s", newRecordID)
        return &amp;TimelineVersion{
                RecordID:   newRecordID,
                Code:       org.Code,
                Name:       org.Name,
                UnitType:   org.UnitType,
                Status:     "ACTIVE",
                Level:      org.Level,
                CodePath:   org.CodePath,
                NamePath:   org.NamePath,
                ParentCode: org.ParentCode,
                Description: func() *string </span><span class="cov0" title="0">{
                        if org.Description == "" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">desc := org.Description
                        return &amp;desc</span>
                }(),
                SortOrder: func() *int <span class="cov0" title="0">{
                        value := org.SortOrder
                        return &amp;value
                }</span>(),
                EffectiveDate: effectiveDate,
                CreatedAt:     createdAt,
                UpdatedAt:     createdAt,
        }, nil
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

type TemporalTimelineManager struct {
        db     *sql.DB
        logger pkglogger.Logger
}

func NewTemporalTimelineManager(db *sql.DB, baseLogger pkglogger.Logger) *TemporalTimelineManager <span class="cov0" title="0">{
        return &amp;TemporalTimelineManager{
                db:     db,
                logger: scopedLogger(baseLogger, "organization", "TemporalTimelineManager", nil),
        }
}</span>

type TimelineVersion struct {
        RecordID      uuid.UUID  `json:"recordId"`
        Code          string     `json:"code"`
        Name          string     `json:"name"`
        UnitType      string     `json:"unitType"`
        Status        string     `json:"status"`
        Level         int        `json:"level"`
        CodePath      string     `json:"codePath"`
        NamePath      string     `json:"namePath"`
        ParentCode    *string    `json:"parentCode"`
        Description   *string    `json:"description"`
        SortOrder     *int       `json:"sortOrder"`
        EffectiveDate time.Time  `json:"effectiveDate"`
        EndDate       *time.Time `json:"endDate"`
        IsCurrent     bool       `json:"isCurrent"`
        CreatedAt     time.Time  `json:"createdAt"`
        UpdatedAt     time.Time  `json:"updatedAt"`
}

func (tm *TemporalTimelineManager) RecalculateTimeline(ctx context.Context, tenantID uuid.UUID, code string) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        tx, err := tm.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelReadCommitted})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tm.logger.Infof("开始全链重算: tenant=%s, code=%s", tenantID, code)

        versions, err := tm.RecalculateTimelineInTx(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Infof("全链重算完成: %s, 版本数=%d", code, len(*versions))
        return versions, nil</span>
}

func (tm *TemporalTimelineManager) RecalculateTimelineInTx(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        record_id, code, name, unit_type, status, level, code_path, name_path,
                        parent_code, description, sort_order, effective_date, end_date, is_current,
                        created_at, updated_at
                FROM organization_units 
                WHERE tenant_id = $1 
                  AND code = $2 
                  AND status != 'DELETED' 
                ORDER BY effective_date ASC`

        rows, err := tx.QueryContext(ctx, query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("查询版本列表失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var versions []TimelineVersion
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        v           TimelineVersion
                        parentCode  sql.NullString
                        description sql.NullString
                        sortOrder   sql.NullInt64
                        endDate     sql.NullTime
                )

                if err := rows.Scan(
                        &amp;v.RecordID,
                        &amp;v.Code,
                        &amp;v.Name,
                        &amp;v.UnitType,
                        &amp;v.Status,
                        &amp;v.Level,
                        &amp;v.CodePath,
                        &amp;v.NamePath,
                        &amp;parentCode,
                        &amp;description,
                        &amp;sortOrder,
                        &amp;v.EffectiveDate,
                        &amp;endDate,
                        &amp;v.IsCurrent,
                        &amp;v.CreatedAt,
                        &amp;v.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("扫描版本记录失败: %w", err)
                }</span>

                <span class="cov0" title="0">if endDate.Valid </span><span class="cov0" title="0">{
                        ed := endDate.Time
                        v.EndDate = &amp;ed
                }</span>
                <span class="cov0" title="0">if parentCode.Valid </span><span class="cov0" title="0">{
                        pc := parentCode.String
                        v.ParentCode = &amp;pc
                }</span>
                <span class="cov0" title="0">if description.Valid </span><span class="cov0" title="0">{
                        desc := description.String
                        v.Description = &amp;desc
                }</span>
                <span class="cov0" title="0">if sortOrder.Valid </span><span class="cov0" title="0">{
                        value := int(sortOrder.Int64)
                        v.SortOrder = &amp;value
                }</span>

                <span class="cov0" title="0">versions = append(versions, v)</span>
        }

        <span class="cov0" title="0">if len(versions) == 0 </span><span class="cov0" title="0">{
                return &amp;[]TimelineVersion{}, nil
        }</span>

        <span class="cov0" title="0">clearCurrentQuery := `
                UPDATE organization_units 
                SET is_current = false, updated_at = NOW()
                WHERE tenant_id = $1 AND code = $2 
                  AND status != 'DELETED'`
        if _, err := tx.ExecContext(ctx, clearCurrentQuery, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("清除当前状态标记失败: %w", err)
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        var currentVersionRecordID *uuid.UUID
        var latestEffectiveDate time.Time
        var hasLatest bool

        for i := range versions </span><span class="cov0" title="0">{
                effectiveUTC := versions[i].EffectiveDate.In(time.UTC)
                versions[i].EffectiveDate = effectiveUTC
                var endDate *time.Time
                if i &lt; len(versions)-1 </span><span class="cov0" title="0">{
                        nextEffectiveDateUTC := versions[i+1].EffectiveDate.In(time.UTC)
                        calculatedEnd := nextEffectiveDateUTC.AddDate(0, 0, -1)
                        endDate = &amp;calculatedEnd
                }</span>

                <span class="cov0" title="0">updateQuery := `
                        UPDATE organization_units 
                        SET end_date = $3,
                                updated_at = NOW()
                        WHERE record_id = $1 AND tenant_id = $2`
                if _, err := tx.ExecContext(ctx, updateQuery, versions[i].RecordID, tenantID, endDate); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("更新版本边界失败: %w", err)
                }</span>

                <span class="cov0" title="0">versions[i].EndDate = endDate

                if !versions[i].EffectiveDate.After(today) </span><span class="cov0" title="0">{
                        if !hasLatest || versions[i].EffectiveDate.After(latestEffectiveDate) </span><span class="cov0" title="0">{
                                latestEffectiveDate = versions[i].EffectiveDate
                                recordID := versions[i].RecordID
                                currentVersionRecordID = &amp;recordID
                                hasLatest = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if currentVersionRecordID != nil </span><span class="cov0" title="0">{
                setCurrentQuery := `
                        UPDATE organization_units 
                        SET is_current = true, updated_at = NOW()
                        WHERE record_id = $1 AND tenant_id = $2`
                if _, err := tx.ExecContext(ctx, setCurrentQuery, *currentVersionRecordID, tenantID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("设置当前版本标记失败: %w", err)
                }</span>

                <span class="cov0" title="0">for i := range versions </span><span class="cov0" title="0">{
                        versions[i].IsCurrent = versions[i].RecordID == *currentVersionRecordID
                }</span>
        }

        <span class="cov0" title="0">return &amp;versions, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/google/uuid"
)

func (tm *TemporalTimelineManager) SuspendOrganization(ctx context.Context, tenantID uuid.UUID, code string, effectiveDate time.Time, operationReason string) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        return tm.changeOrganizationStatus(ctx, tenantID, code, "INACTIVE", "SUSPEND", effectiveDate, operationReason)
}</span>

func (tm *TemporalTimelineManager) ActivateOrganization(ctx context.Context, tenantID uuid.UUID, code string, effectiveDate time.Time, operationReason string) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        return tm.changeOrganizationStatus(ctx, tenantID, code, "ACTIVE", "REACTIVATE", effectiveDate, operationReason)
}</span>

func (tm *TemporalTimelineManager) changeOrganizationStatus(ctx context.Context, tenantID uuid.UUID, code, newStatus, operationType string, effectiveDate time.Time, operationReason string) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        tx, err := tm.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelReadCommitted})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tm.logger.Infof("开始%s组织: Code=%s, 生效日期=%s, 新状态=%s", operationType, code, effectiveDate.Format("2006-01-02"), newStatus)

        var currentOrg struct {
                RecordID      string
                TenantID      uuid.UUID
                Code          string
                ParentCode    *string
                Name          string
                UnitType      string
                Status        string
                Level         int
                CodePath      string
                NamePath      string
                SortOrder     int
                Description   string
                EffectiveDate time.Time
                IsCurrent     bool
                ChangeReason  *string
                CreatedAt     time.Time
                UpdatedAt     time.Time
        }

        row := tx.QueryRowContext(ctx, `
        SELECT record_id, tenant_id, code, parent_code, name, unit_type, status, level,
               code_path, name_path, sort_order, description, effective_date, is_current, change_reason,
               created_at, updated_at
                FROM organization_units 
                WHERE tenant_id = $1 AND code = $2 AND is_current = true 
                  AND status != 'DELETED'
                FOR UPDATE`, tenantID, code)

        if err := row.Scan(
                &amp;currentOrg.RecordID, &amp;currentOrg.TenantID, &amp;currentOrg.Code, &amp;currentOrg.ParentCode, &amp;currentOrg.Name,
                &amp;currentOrg.UnitType, &amp;currentOrg.Status, &amp;currentOrg.Level, &amp;currentOrg.CodePath,
                &amp;currentOrg.NamePath, &amp;currentOrg.SortOrder,
                &amp;currentOrg.Description, &amp;currentOrg.EffectiveDate, &amp;currentOrg.IsCurrent,
                &amp;currentOrg.ChangeReason, &amp;currentOrg.CreatedAt, &amp;currentOrg.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("组织不存在或无当前版本: %s", code)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询组织当前版本失败: %w", err)</span>
        }

        <span class="cov0" title="0">if currentOrg.Status == newStatus </span><span class="cov0" title="0">{
                tm.logger.Infof("组织%s状态已经是%s，幂等操作跳过", code, newStatus)
                return tm.RecalculateTimelineInTx(ctx, tx, tenantID, code)
        }</span>

        <span class="cov0" title="0">var conflictCount int
        conflictQuery := `
                SELECT COUNT(*) 
                FROM organization_units 
                WHERE tenant_id = $1 AND code = $2 AND effective_date = $3 
                  AND status != 'DELETED'`
        effectiveDateUTC := effectiveDate.In(time.UTC)
        if err := tx.QueryRowContext(ctx, conflictQuery, tenantID, code, effectiveDateUTC).Scan(&amp;conflictCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("冲突校验查询失败: %w", err)
        }</span>
        <span class="cov0" title="0">nowUTC := time.Now().UTC()
        isFuture := effectiveDateUTC.After(nowUTC.Truncate(24 * time.Hour))

        if conflictCount &gt; 0 </span><span class="cov0" title="0">{
                tm.logger.Warnf("检测到相同生效日期版本，改为更新现有记录: code=%s date=%s", code, effectiveDateUTC.Format("2006-01-02"))
                _, err := tx.ExecContext(ctx, `
            UPDATE organization_units
            SET status = $3,
                change_reason = CASE WHEN $4 &lt;&gt; '' THEN $4 ELSE change_reason END,
                updated_at = NOW()
            WHERE tenant_id = $1 AND code = $2 AND effective_date = $5 AND status &lt;&gt; 'DELETED'
        `, tenantID, code, newStatus, operationReason, effectiveDateUTC)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("更新现有状态版本失败: %w", err)
                }</span>

                <span class="cov0" title="0">timeline, err := tm.RecalculateTimelineInTx(ctx, tx, tenantID, code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("时间轴重算失败: %w", err)
                }</span>

                <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("事务提交失败: %w", err)
                }</span>

                <span class="cov0" title="0">action := "暂停"
                if operationType == "REACTIVATE" </span><span class="cov0" title="0">{
                        action = "激活"
                }</span>

                <span class="cov0" title="0">if isFuture </span><span class="cov0" title="0">{
                        tm.logger.Infof("组织%s成功（计划生效，更新现有版本）: %s → %s, 生效日期=%s", action, code, newStatus, effectiveDateUTC.Format("2006-01-02"))
                }</span> else<span class="cov0" title="0"> {
                        tm.logger.Infof("组织%s成功（即时生效，更新现有版本）: %s → %s", action, code, newStatus)
                }</span>

                <span class="cov0" title="0">return timeline, nil</span>
        }

        <span class="cov0" title="0">newRecordID := uuid.New()

        if _, err := tx.ExecContext(ctx, `
                INSERT INTO organization_units (
                        record_id, tenant_id, code, parent_code, name, unit_type, status,
                        level, code_path, name_path, sort_order, description, effective_date, end_date,
                        is_current, change_reason, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NULL,
                        false, $14, $15, $16
                )`,
                newRecordID,
                currentOrg.TenantID,
                currentOrg.Code,
                currentOrg.ParentCode,
                currentOrg.Name,
                currentOrg.UnitType,
                newStatus,
                currentOrg.Level,
                currentOrg.CodePath,
                currentOrg.NamePath,
                currentOrg.SortOrder,
                currentOrg.Description,
                effectiveDateUTC,
                operationReason,
                nowUTC,
                nowUTC,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("插入%s版本失败: %w", operationType, err)
        }</span>

        <span class="cov0" title="0">timeline, err := tm.RecalculateTimelineInTx(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("时间轴重算失败: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("事务提交失败: %w", err)
        }</span>

        <span class="cov0" title="0">action := "暂停"
        if operationType == "REACTIVATE" </span><span class="cov0" title="0">{
                action = "激活"
        }</span>

        <span class="cov0" title="0">if isFuture </span><span class="cov0" title="0">{
                tm.logger.Infof("组织%s成功（计划生效）: %s → %s, 生效日期=%s", action, code, newStatus, effectiveDateUTC.Format("2006-01-02"))
        }</span> else<span class="cov0" title="0"> {
                tm.logger.Infof("组织%s成功（即时生效）: %s → %s, 时间轴已重算", action, code, newStatus)
        }</span>

        <span class="cov0" title="0">return timeline, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

func (tm *TemporalTimelineManager) UpdateVersionEffectiveDate(ctx context.Context, tenantID uuid.UUID, recordID uuid.UUID, newEffectiveDate time.Time, operationReason string) (*[]TimelineVersion, error) <span class="cov0" title="0">{
        tx, err := tm.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelReadCommitted})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tm.logger.Infof("开始修改版本生效日期: RecordID=%s, 新日期=%s", recordID.String(), newEffectiveDate.Format("2006-01-02"))

        var org types.Organization
        row := tx.QueryRowContext(ctx, `
        SELECT tenant_id, code, parent_code, name, unit_type, status, level, code_path, name_path, sort_order,
               description, effective_date, is_current, change_reason, created_at, updated_at
        FROM organization_units 
        WHERE record_id = $1 AND status != 'DELETED'
        FOR UPDATE`, recordID)

        if err := row.Scan(
                &amp;org.TenantID, &amp;org.Code, &amp;org.ParentCode, &amp;org.Name, &amp;org.UnitType,
                &amp;org.Status, &amp;org.Level, &amp;org.CodePath, &amp;org.NamePath, &amp;org.SortOrder, &amp;org.Description,
                &amp;org.EffectiveDate, &amp;org.IsCurrent, &amp;org.ChangeReason,
                &amp;org.CreatedAt, &amp;org.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("版本不存在或已被删除: %s", recordID.String())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询版本信息失败: %w", err)</span>
        }

        <span class="cov0" title="0">parsedTenant, err := uuid.Parse(org.TenantID)
        if err != nil || parsedTenant != tenantID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("版本不属于指定租户")
        }</span>

        <span class="cov0" title="0">var conflictCount int
        conflictQuery := `
                SELECT COUNT(*) 
                FROM organization_units 
                WHERE tenant_id = $1 AND code = $2 AND effective_date = $3 
                  AND record_id != $4 AND status != 'DELETED'`
        if err := tx.QueryRowContext(ctx, conflictQuery, tenantID, org.Code, newEffectiveDate, recordID).Scan(&amp;conflictCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("冲突校验查询失败: %w", err)
        }</span>
        <span class="cov0" title="0">if conflictCount &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TEMPORAL_POINT_CONFLICT: 新生效日期 %s 与现有版本冲突", newEffectiveDate.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if _, err := tx.ExecContext(ctx, `
                UPDATE organization_units 
                SET status = 'DELETED', deleted_at = $3, updated_at = $3
                WHERE record_id = $1 AND tenant_id = $2`, recordID, tenantID, now); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("删除旧版本失败: %w", err)
        }</span>

        <span class="cov0" title="0">newRecordID := uuid.New()
        org.RecordID = newRecordID.String()
        org.EffectiveDate = types.NewDateFromTime(newEffectiveDate)
        org.ChangeReason = &amp;operationReason
        org.CreatedAt = now
        org.UpdatedAt = now
        org.IsCurrent = false

        if _, err := tx.ExecContext(ctx, `
                INSERT INTO organization_units (
                        record_id, tenant_id, code, parent_code, name, unit_type, status,
                        level, code_path, name_path, sort_order, description, effective_date, end_date,
                        is_current, change_reason, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NULL,
                        false, $14, $15, $15
                )`, newRecordID, org.TenantID, org.Code, org.ParentCode, org.Name, org.UnitType,
                org.Status, org.Level, org.CodePath, org.NamePath, org.SortOrder, org.Description,
                newEffectiveDate, operationReason, now); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("插入新版本失败: %w", err)
        }</span>

        <span class="cov0" title="0">timeline, err := tm.RecalculateTimelineInTx(ctx, tx, tenantID, org.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("时间轴重算失败: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("事务提交失败: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Infof("版本生效日期修改成功: %s → %s", recordID.String(), newEffectiveDate.Format("2006-01-02"))
        return timeline, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package resolver

import (
        "context"
        "fmt"
        "strings"

        "cube-castle/internal/auth"
        "cube-castle/internal/organization/dto"
        pkglogger "cube-castle/pkg/logger"
        sharedconfig "cube-castle/shared/config"
        "github.com/google/uuid"
)

type QueryRepository interface {
        GetOrganizations(ctx context.Context, tenantID uuid.UUID, filter *dto.OrganizationFilter, pagination *dto.PaginationInput) (*dto.OrganizationConnection, error)
        GetOrganization(ctx context.Context, tenantID uuid.UUID, code string) (*dto.Organization, error)
        GetOrganizationAtDate(ctx context.Context, tenantID uuid.UUID, code string, date string) (*dto.Organization, error)
        GetOrganizationHistory(ctx context.Context, tenantID uuid.UUID, code string, fromDate string, toDate string) ([]dto.Organization, error)
        GetOrganizationVersions(ctx context.Context, tenantID uuid.UUID, code string, includeDeleted bool) ([]dto.Organization, error)
        GetOrganizationStats(ctx context.Context, tenantID uuid.UUID) (*dto.OrganizationStats, error)
        GetOrganizationHierarchy(ctx context.Context, tenantID uuid.UUID, code string) (*dto.OrganizationHierarchyData, error)
        GetOrganizationSubtree(ctx context.Context, tenantID uuid.UUID, code string, maxDepth int) (*dto.OrganizationHierarchyData, error)
        GetPositions(ctx context.Context, tenantID uuid.UUID, filter *dto.PositionFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionSortInput) (*dto.PositionConnection, error)
        GetPositionByCode(ctx context.Context, tenantID uuid.UUID, code string, asOfDate *string) (*dto.Position, error)
        GetPositionAssignments(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetPositionAssignmentAudit(ctx context.Context, tenantID uuid.UUID, positionCode string, assignmentID *string, dateRange *dto.DateRangeInput, pagination *dto.PaginationInput) (*dto.PositionAssignmentAuditConnection, error)
        GetPositionTimeline(ctx context.Context, tenantID uuid.UUID, code string, startDate, endDate *string) ([]dto.PositionTimelineEntry, error)
        GetPositionVersions(ctx context.Context, tenantID uuid.UUID, code string, includeDeleted bool) ([]dto.Position, error)
        GetVacantPositionConnection(ctx context.Context, tenantID uuid.UUID, filter *dto.VacantPositionFilterInput, pagination *dto.PaginationInput, sorting []dto.VacantPositionSortInput) (*dto.VacantPositionConnection, error)
        GetPositionTransfers(ctx context.Context, tenantID uuid.UUID, positionCode *string, organizationCode *string, pagination *dto.PaginationInput) (*dto.PositionTransferConnection, error)
        GetPositionHeadcountStats(ctx context.Context, tenantID uuid.UUID, organizationCode string, includeSubordinates bool) (*dto.HeadcountStats, error)
        GetJobFamilyGroups(ctx context.Context, tenantID uuid.UUID, includeInactive bool, asOfDate *string) ([]dto.JobFamilyGroup, error)
        GetJobFamilies(ctx context.Context, tenantID uuid.UUID, groupCode string, includeInactive bool, asOfDate *string) ([]dto.JobFamily, error)
        GetJobRoles(ctx context.Context, tenantID uuid.UUID, familyCode string, includeInactive bool, asOfDate *string) ([]dto.JobRole, error)
        GetJobLevels(ctx context.Context, tenantID uuid.UUID, roleCode string, includeInactive bool, asOfDate *string) ([]dto.JobLevel, error)
        GetAuditHistory(ctx context.Context, tenantID uuid.UUID, recordID string, startDate, endDate, operation, userID *string, limit int) ([]dto.AuditRecordData, error)
        GetAuditLog(ctx context.Context, auditID string) (*dto.AuditRecordData, error)
        GetAssignmentHistory(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentStats(ctx context.Context, tenantID uuid.UUID, positionCode string, organizationCode string) (*dto.AssignmentStats, error)
}

type AssignmentProvider interface {
        GetAssignments(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentHistory(ctx context.Context, tenantID uuid.UUID, positionCode string, filter *dto.PositionAssignmentFilterInput, pagination *dto.PaginationInput, sorting []dto.PositionAssignmentSortInput) (*dto.PositionAssignmentConnection, error)
        GetAssignmentStats(ctx context.Context, tenantID uuid.UUID, positionCode string, organizationCode string) (*dto.AssignmentStats, error)
}

type PermissionChecker interface {
        CheckQueryPermission(ctx context.Context, queryName string) error
}

type Resolver struct {
        repo         QueryRepository
        logger       pkglogger.Logger
        permissions  PermissionChecker
        assignFacade AssignmentProvider
}

func NewResolver(repo QueryRepository, logger pkglogger.Logger, permissions PermissionChecker) *Resolver <span class="cov8" title="1">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov8" title="1">return &amp;Resolver{
                repo: repo,
                logger: logger.WithFields(pkglogger.Fields{
                        "component": "query-resolver",
                }),
                permissions: permissions,
        }</span>
}

func NewResolverWithAssignments(repo QueryRepository, assignments AssignmentProvider, logger pkglogger.Logger, permissions PermissionChecker) *Resolver <span class="cov8" title="1">{
        res := NewResolver(repo, logger, permissions)
        res.assignFacade = assignments
        return res
}</span>

func (r *Resolver) loggerFor(resolverName, operation string, fields pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        log := r.logger
        if resolverName != "" </span><span class="cov8" title="1">{
                log = log.WithFields(pkglogger.Fields{"resolver": resolverName})
        }</span>
        <span class="cov8" title="1">if operation != "" </span><span class="cov8" title="1">{
                log = log.WithFields(pkglogger.Fields{"operation": operation})
        }</span>
        <span class="cov8" title="1">if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                log = log.WithFields(fields)
        }</span>
        <span class="cov8" title="1">return log</span>
}

func (r *Resolver) authorize(ctx context.Context, queryName string, log pkglogger.Logger) error <span class="cov8" title="1">{
        if err := r.permissions.CheckQueryPermission(ctx, queryName); err != nil </span><span class="cov8" title="1">{
                log.WithFields(pkglogger.Fields{"error": err}).Warn("permission denied")
                return fmt.Errorf("INSUFFICIENT_PERMISSIONS")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 当前组织列表查询 - 符合API契约v4.2.1 (camelCase方法名)
func (r *Resolver) Organizations(ctx context.Context, args struct {
        Filter     *dto.OrganizationFilter
        Pagination *dto.PaginationInput
}) (*dto.OrganizationConnection, error) <span class="cov0" title="0">{
        log := r.loggerFor("organizations", "list", pkglogger.Fields{
                "tenantId": sharedconfig.DefaultTenantID.String(),
        })
        if err := r.authorize(ctx, "organizations", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("处理组织列表查询")

        if args.Filter != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"filter": args.Filter}).Info("附带过滤参数")
        }</span>
        <span class="cov0" title="0">if args.Pagination != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"pagination": args.Pagination}).Info("附带分页参数")
        }</span>

        <span class="cov0" title="0">return r.repo.GetOrganizations(ctx, sharedconfig.DefaultTenantID, args.Filter, args.Pagination)</span>
}

// 单个组织查询
func (r *Resolver) Organization(ctx context.Context, args struct {
        Code     string
        AsOfDate *string
}) (*dto.Organization, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "get", pkglogger.Fields{
                "tenantId": sharedconfig.DefaultTenantID.String(),
                "code":     args.Code,
        })
        if err := r.authorize(ctx, "organization", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("查询单个组织")
        return r.repo.GetOrganization(ctx, sharedconfig.DefaultTenantID, args.Code)</span>
}

// 时态查询 - 时间点
func (r *Resolver) OrganizationAtDate(ctx context.Context, args struct {
        Code string
        Date string
}) (*dto.Organization, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "temporal", pkglogger.Fields{
                "tenantId": sharedconfig.DefaultTenantID.String(),
                "code":     args.Code,
                "date":     args.Date,
        })
        if err := r.authorize(ctx, "organizationAtDate", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("执行组织时态查询")
        return r.repo.GetOrganizationAtDate(ctx, sharedconfig.DefaultTenantID, args.Code, args.Date)</span>
}

// 时态查询 - 历史范围
func (r *Resolver) OrganizationHistory(ctx context.Context, args struct {
        Code     string
        FromDate string
        ToDate   string
}) ([]dto.Organization, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "history", pkglogger.Fields{
                "tenantId": sharedconfig.DefaultTenantID.String(),
                "code":     args.Code,
                "from":     args.FromDate,
                "to":       args.ToDate,
        })
        if err := r.authorize(ctx, "organizationHistory", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("执行组织历史查询")
        return r.repo.GetOrganizationHistory(ctx, sharedconfig.DefaultTenantID, args.Code, args.FromDate, args.ToDate)</span>
}

// 组织版本查询 - 按计划实现，支持includeDeleted参数
func (r *Resolver) OrganizationVersions(ctx context.Context, args struct {
        Code           string
        IncludeDeleted *bool
}) ([]dto.Organization, error) <span class="cov0" title="0">{
        includeDeleted := false
        if args.IncludeDeleted != nil </span><span class="cov0" title="0">{
                includeDeleted = *args.IncludeDeleted
        }</span>
        <span class="cov0" title="0">log := r.loggerFor("organization", "versions", pkglogger.Fields{
                "tenantId":       sharedconfig.DefaultTenantID.String(),
                "code":           args.Code,
                "includeDeleted": includeDeleted,
        })
        if err := r.authorize(ctx, "organizationVersions", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("执行组织版本查询")
        return r.repo.GetOrganizationVersions(ctx, sharedconfig.DefaultTenantID, args.Code, includeDeleted)</span>
}

// 组织统计 (camelCase方法名)
func (r *Resolver) OrganizationStats(ctx context.Context, args struct {
        AsOfDate          *string
        IncludeHistorical bool
}) (*dto.OrganizationStats, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "stats", pkglogger.Fields{
                "tenantId": sharedconfig.DefaultTenantID.String(),
        })
        if err := r.authorize(ctx, "organizationStats", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("执行组织统计查询")
        return r.repo.GetOrganizationStats(ctx, sharedconfig.DefaultTenantID)</span>
}

// 高级层级结构查询 - 严格遵循API规范v4.2.1
func (r *Resolver) OrganizationHierarchy(ctx context.Context, args struct {
        Code     string
        TenantId string
}) (*dto.OrganizationHierarchyData, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "hierarchy", pkglogger.Fields{
                "code": args.Code,
        })
        if err := r.authorize(ctx, "organizationHierarchy", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"tenantId": args.TenantId}).Info("执行组织层级查询")

        tenantID, err := uuid.Parse(args.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Warn("invalid tenant ID")
                return nil, fmt.Errorf("invalid tenant ID: %w", err)
        }</span>

        <span class="cov0" title="0">return r.repo.GetOrganizationHierarchy(ctx, tenantID, args.Code)</span>
}

func (r *Resolver) OrganizationSubtree(ctx context.Context, args struct {
        Code            string
        TenantId        string
        MaxDepth        int32
        IncludeInactive bool
}) ([]dto.OrganizationHierarchyData, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "subtree", pkglogger.Fields{
                "code":     args.Code,
                "maxDepth": args.MaxDepth,
        })
        if err := r.authorize(ctx, "organizationSubtree", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"tenantId": args.TenantId, "includeInactive": args.IncludeInactive}).Info("执行组织子树查询")

        tenantID, err := uuid.Parse(args.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"error": err}).Warn("invalid tenant ID")
                return nil, fmt.Errorf("invalid tenant ID: %w", err)
        }</span>

        <span class="cov0" title="0">maxDepth := 10 // 默认深度
        if args.MaxDepth &gt; 0 </span><span class="cov0" title="0">{
                maxDepth = int(args.MaxDepth)
        }</span>

        <span class="cov0" title="0">subtree, err := r.repo.GetOrganizationSubtree(ctx, tenantID, args.Code, maxDepth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 将单个子树转换为数组（Schema期望数组返回）
        <span class="cov0" title="0">if subtree == nil </span><span class="cov0" title="0">{
                return []dto.OrganizationHierarchyData{}, nil
        }</span>

        // 先转换根节点
        <span class="cov0" title="0">root := dto.OrganizationHierarchyData{
                CodeField:           subtree.CodeField,
                NameField:           subtree.NameField,
                LevelField:          subtree.LevelField,
                HierarchyDepthField: subtree.HierarchyDepthField,
                CodePathField:       subtree.CodePathField,
                NamePathField:       subtree.NamePathField,
                ParentChainField:    []string{}, // 根节点没有父级链
                ChildrenCountField:  len(subtree.ChildrenField),
                IsRootField:         subtree.LevelField == 1,
                IsLeafField:         len(subtree.ChildrenField) == 0,
                ChildrenField:       []dto.OrganizationHierarchyData{}, // 简化实现，先不递归转换
        }

        return []dto.OrganizationHierarchyData{root}, nil</span>
}

// 层级统计查询
func (r *Resolver) HierarchyStatistics(ctx context.Context, args struct {
        TenantId              string
        IncludeIntegrityCheck bool
}) (*dto.HierarchyStatistics, error) <span class="cov0" title="0">{
        log := r.loggerFor("organization", "hierarchyStats", pkglogger.Fields{"tenantId": args.TenantId, "includeIntegrityCheck": args.IncludeIntegrityCheck})
        if err := r.authorize(ctx, "hierarchyStatistics", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: 实现实际的层级统计逻辑
        <span class="cov0" title="0">return &amp;dto.HierarchyStatistics{
                TenantIdField:           args.TenantId,
                TotalOrganizationsField: 0,
                MaxDepthField:           0,
                AvgDepthField:           0.0,
                DepthDistributionField:  []dto.DepthDistribution{},
                RootOrganizationsField:  0,
                LeafOrganizationsField:  0,
                IntegrityIssuesField:    []dto.IntegrityIssue{},
                LastAnalyzedField:       "",
        }, nil</span>
}

// Positions 查询
func (r *Resolver) Positions(ctx context.Context, args struct {
        Filter     *dto.PositionFilterInput
        Pagination *dto.PaginationInput
        Sorting    *[]dto.PositionSortInput
}) (*dto.PositionConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "list", pkglogger.Fields{"tenantId": sharedconfig.DefaultTenantID.String()})
        if err := r.authorize(ctx, "positions", log); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var sorting []dto.PositionSortInput
        if args.Sorting != nil </span><span class="cov8" title="1">{
                sorting = *args.Sorting
        }</span>
        <span class="cov8" title="1">log.WithFields(pkglogger.Fields{
                "filter":     args.Filter,
                "pagination": args.Pagination,
                "sortCount":  len(sorting),
        }).Info("查询职位列表")

        return r.repo.GetPositions(ctx, sharedconfig.DefaultTenantID, args.Filter, args.Pagination, sorting)</span>
}

// Position 查询单个职位
func (r *Resolver) Position(ctx context.Context, args struct {
        Code     string
        AsOfDate *string
}) (*dto.Position, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "get", pkglogger.Fields{
                "tenantId": sharedconfig.DefaultTenantID.String(),
                "code":     args.Code,
                "asOfDate": args.AsOfDate,
        })
        if err := r.authorize(ctx, "position", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Info("查询职位详情")

        return r.repo.GetPositionByCode(ctx, sharedconfig.DefaultTenantID, args.Code, args.AsOfDate)</span>
}

// PositionAssignments 查询职位任职记录
func (r *Resolver) PositionAssignments(ctx context.Context, args struct {
        PositionCode string
        Filter       *dto.PositionAssignmentFilterInput
        Pagination   *dto.PaginationInput
        Sorting      *[]dto.PositionAssignmentSortInput
}) (*dto.PositionAssignmentConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "assignments", pkglogger.Fields{
                "positionCode": args.PositionCode,
        })
        if err := r.authorize(ctx, "positionAssignments", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tenantID := sharedconfig.DefaultTenantID
        if tenantStr := auth.GetTenantID(ctx); tenantStr != "" </span><span class="cov0" title="0">{
                parsed, err := uuid.Parse(tenantStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("invalid tenant id")
                        return nil, fmt.Errorf("INVALID_TENANT")
                }</span>
                <span class="cov0" title="0">tenantID = parsed</span>
        }

        <span class="cov8" title="1">var sorting []dto.PositionAssignmentSortInput
        if args.Sorting != nil </span><span class="cov8" title="1">{
                sorting = *args.Sorting
        }</span>

        <span class="cov8" title="1">log.WithFields(pkglogger.Fields{
                "tenantId":   tenantID.String(),
                "filter":     args.Filter,
                "pagination": args.Pagination,
                "sortCount":  len(sorting),
        }).Info("查询职位任职记录")

        return r.repo.GetPositionAssignments(ctx, tenantID, args.PositionCode, args.Filter, args.Pagination, sorting)</span>
}

// Assignments 查询多职位任职记录，兼容组织维度过滤
func (r *Resolver) Assignments(ctx context.Context, args struct {
        OrganizationCode *string
        PositionCode     *string
        Filter           *dto.PositionAssignmentFilterInput
        Pagination       *dto.PaginationInput
        Sorting          *[]dto.PositionAssignmentSortInput
}) (*dto.PositionAssignmentConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("assignments", "list", nil)
        if err := r.authorize(ctx, "assignments", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if r.assignFacade == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ASSIGNMENT_QUERY_FACADE_NOT_CONFIGURED")
        }</span>

        <span class="cov8" title="1">positionCode := ""
        if args.PositionCode != nil </span><span class="cov8" title="1">{
                positionCode = strings.TrimSpace(*args.PositionCode)
        }</span>
        <span class="cov8" title="1">if positionCode == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("POSITION_CODE_REQUIRED")
        }</span>

        <span class="cov8" title="1">tenantID := r.resolveTenant(ctx, log)
        var sorting []dto.PositionAssignmentSortInput
        if args.Sorting != nil </span><span class="cov8" title="1">{
                sorting = *args.Sorting
        }</span>
        <span class="cov8" title="1">return r.assignFacade.GetAssignments(ctx, tenantID, positionCode, args.Filter, args.Pagination, sorting)</span>
}

// AssignmentHistory 查询职位任职历史
func (r *Resolver) AssignmentHistory(ctx context.Context, args struct {
        PositionCode string
        Filter       *dto.PositionAssignmentFilterInput
        Pagination   *dto.PaginationInput
        Sorting      *[]dto.PositionAssignmentSortInput
}) (*dto.PositionAssignmentConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("assignments", "history", pkglogger.Fields{"positionCode": args.PositionCode})
        if err := r.authorize(ctx, "assignmentHistory", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if r.assignFacade == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ASSIGNMENT_QUERY_FACADE_NOT_CONFIGURED")
        }</span>
        <span class="cov8" title="1">tenantID := r.resolveTenant(ctx, log)
        var sorting []dto.PositionAssignmentSortInput
        if args.Sorting != nil </span><span class="cov0" title="0">{
                sorting = *args.Sorting
        }</span>
        <span class="cov8" title="1">return r.assignFacade.GetAssignmentHistory(ctx, tenantID, args.PositionCode, args.Filter, args.Pagination, sorting)</span>
}

// AssignmentStats 查询职位或组织的任职统计
func (r *Resolver) AssignmentStats(ctx context.Context, args struct {
        OrganizationCode *string
        PositionCode     *string
}) (*dto.AssignmentStats, error) <span class="cov8" title="1">{
        log := r.loggerFor("assignments", "stats", pkglogger.Fields{
                "positionCode":     args.PositionCode,
                "organizationCode": args.OrganizationCode,
        })
        if err := r.authorize(ctx, "assignmentStats", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if r.assignFacade == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ASSIGNMENT_QUERY_FACADE_NOT_CONFIGURED")
        }</span>
        <span class="cov8" title="1">positionCode := ""
        if args.PositionCode != nil </span><span class="cov8" title="1">{
                positionCode = strings.TrimSpace(*args.PositionCode)
        }</span>
        <span class="cov8" title="1">orgCode := ""
        if args.OrganizationCode != nil </span><span class="cov8" title="1">{
                orgCode = strings.TrimSpace(*args.OrganizationCode)
        }</span>
        <span class="cov8" title="1">if positionCode == "" &amp;&amp; orgCode == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("POSITION_OR_ORGANIZATION_REQUIRED")
        }</span>
        <span class="cov8" title="1">tenantID := r.resolveTenant(ctx, log)
        return r.assignFacade.GetAssignmentStats(ctx, tenantID, positionCode, orgCode)</span>
}

func (r *Resolver) PositionAssignmentAudit(ctx context.Context, args struct {
        PositionCode string
        AssignmentId *string
        DateRange    *dto.DateRangeInput
        Pagination   *dto.PaginationInput
}) (*dto.PositionAssignmentAuditConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "assignmentAudit", pkglogger.Fields{
                "positionCode": args.PositionCode,
                "assignmentId": args.AssignmentId,
        })
        if err := r.authorize(ctx, "positionAssignmentAudit", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tenantID := sharedconfig.DefaultTenantID
        if tenantStr := auth.GetTenantID(ctx); tenantStr != "" </span><span class="cov0" title="0">{
                parsed, err := uuid.Parse(tenantStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("invalid tenant id")
                        return nil, fmt.Errorf("INVALID_TENANT")
                }</span>
                <span class="cov0" title="0">tenantID = parsed</span>
        }

        <span class="cov8" title="1">log.WithFields(pkglogger.Fields{"tenantId": tenantID.String(), "dateRange": args.DateRange}).Info("查询任职审计记录")
        return r.repo.GetPositionAssignmentAudit(ctx, tenantID, args.PositionCode, args.AssignmentId, args.DateRange, args.Pagination)</span>
}

// PositionTimeline 查询职位时间线
func (r *Resolver) PositionTimeline(ctx context.Context, args struct {
        Code      string
        StartDate *string
        EndDate   *string
}) ([]dto.PositionTimelineEntry, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "timeline", pkglogger.Fields{
                "code":      args.Code,
                "startDate": args.StartDate,
                "endDate":   args.EndDate,
        })
        if err := r.authorize(ctx, "positionTimeline", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Info("查询职位时间线")

        return r.repo.GetPositionTimeline(ctx, sharedconfig.DefaultTenantID, args.Code, args.StartDate, args.EndDate)</span>
}

func (r *Resolver) resolveTenant(ctx context.Context, log pkglogger.Logger) uuid.UUID <span class="cov8" title="1">{
        tenantID := sharedconfig.DefaultTenantID
        if tenantStr := auth.GetTenantID(ctx); tenantStr != "" </span><span class="cov0" title="0">{
                parsed, err := uuid.Parse(tenantStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("invalid tenant id")
                        return sharedconfig.DefaultTenantID
                }</span>
                <span class="cov0" title="0">return parsed</span>
        }
        <span class="cov8" title="1">return tenantID</span>
}

// PositionVersions 查询职位版本列表
func (r *Resolver) PositionVersions(ctx context.Context, args struct {
        Code           string
        IncludeDeleted *bool
}) ([]dto.Position, error) <span class="cov8" title="1">{
        includeDeleted := false
        if args.IncludeDeleted != nil </span><span class="cov8" title="1">{
                includeDeleted = *args.IncludeDeleted
        }</span>
        <span class="cov8" title="1">log := r.loggerFor("position", "versions", pkglogger.Fields{
                "code":           args.Code,
                "includeDeleted": includeDeleted,
                "tenantId":       sharedconfig.DefaultTenantID.String(),
        })
        if err := r.authorize(ctx, "positionVersions", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Info("查询职位版本列表")

        return r.repo.GetPositionVersions(ctx, sharedconfig.DefaultTenantID, args.Code, includeDeleted)</span>
}

// VacantPositions 查询空缺职位
func (r *Resolver) VacantPositions(ctx context.Context, args struct {
        Filter     *dto.VacantPositionFilterInput
        Pagination *dto.PaginationInput
        Sorting    *[]dto.VacantPositionSortInput
}) (*dto.VacantPositionConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "vacant", nil)
        if err := r.authorize(ctx, "vacantPositions", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tenantID := sharedconfig.DefaultTenantID
        if tenantStr := auth.GetTenantID(ctx); tenantStr != "" </span><span class="cov0" title="0">{
                parsed, err := uuid.Parse(tenantStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("invalid tenant id")
                        return nil, fmt.Errorf("INVALID_TENANT")
                }</span>
                <span class="cov0" title="0">tenantID = parsed</span>
        }

        <span class="cov8" title="1">var sorting []dto.VacantPositionSortInput
        if args.Sorting != nil </span><span class="cov8" title="1">{
                sorting = *args.Sorting
        }</span>

        <span class="cov8" title="1">log.WithFields(pkglogger.Fields{
                "tenantId":   tenantID.String(),
                "filter":     args.Filter,
                "pagination": args.Pagination,
                "sortCount":  len(sorting),
        }).Info("查询空缺职位")

        return r.repo.GetVacantPositionConnection(ctx, tenantID, args.Filter, args.Pagination, sorting)</span>
}

// PositionTransfers 查询职位转移记录
func (r *Resolver) PositionTransfers(ctx context.Context, args struct {
        PositionCode     *string
        OrganizationCode *string
        Pagination       *dto.PaginationInput
}) (*dto.PositionTransferConnection, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "transfers", pkglogger.Fields{
                "positionCode":     args.PositionCode,
                "organizationCode": args.OrganizationCode,
        })
        if err := r.authorize(ctx, "positionTransfers", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tenantID := sharedconfig.DefaultTenantID
        if tenantStr := auth.GetTenantID(ctx); tenantStr != "" </span><span class="cov0" title="0">{
                parsed, err := uuid.Parse(tenantStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("invalid tenant id")
                        return nil, fmt.Errorf("INVALID_TENANT")
                }</span>
                <span class="cov0" title="0">tenantID = parsed</span>
        }

        <span class="cov8" title="1">log.WithFields(pkglogger.Fields{
                "tenantId":   tenantID.String(),
                "pagination": args.Pagination,
        }).Info("查询职位转移记录")

        return r.repo.GetPositionTransfers(ctx, tenantID, args.PositionCode, args.OrganizationCode, args.Pagination)</span>
}

// PositionHeadcountStats 查询编制统计
func (r *Resolver) PositionHeadcountStats(ctx context.Context, args struct {
        OrganizationCode    string
        IncludeSubordinates *bool
}) (*dto.HeadcountStats, error) <span class="cov8" title="1">{
        log := r.loggerFor("position", "headcountStats", pkglogger.Fields{"organizationCode": args.OrganizationCode})
        if err := r.authorize(ctx, "positionHeadcountStats", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">includeSubordinates := true
        if args.IncludeSubordinates != nil </span><span class="cov8" title="1">{
                includeSubordinates = *args.IncludeSubordinates
        }</span>
        <span class="cov8" title="1">tenantID := sharedconfig.DefaultTenantID
        if tenantStr := auth.GetTenantID(ctx); tenantStr != "" </span><span class="cov8" title="1">{
                parsed, err := uuid.Parse(tenantStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("invalid tenant id")
                        return nil, fmt.Errorf("INVALID_TENANT")
                }</span>
                <span class="cov8" title="1">tenantID = parsed</span>
        }
        <span class="cov8" title="1">log.WithFields(pkglogger.Fields{
                "tenantId":           tenantID.String(),
                "includeSubordinate": includeSubordinates,
        }).Info("查询职位编制统计")

        return r.repo.GetPositionHeadcountStats(ctx, tenantID, args.OrganizationCode, includeSubordinates)</span>
}

// JobFamilyGroups 查询职类
func (r *Resolver) JobFamilyGroups(ctx context.Context, args struct {
        IncludeInactive *bool
        AsOfDate        *string
}) ([]dto.JobFamilyGroup, error) <span class="cov0" title="0">{
        log := r.loggerFor("jobCatalog", "familyGroups", nil)
        if err := r.authorize(ctx, "jobFamilyGroups", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">includeInactive := false
        if args.IncludeInactive != nil </span><span class="cov0" title="0">{
                includeInactive = *args.IncludeInactive
        }</span>
        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"includeInactive": includeInactive, "asOfDate": args.AsOfDate}).Info("查询职类")

        return r.repo.GetJobFamilyGroups(ctx, sharedconfig.DefaultTenantID, includeInactive, args.AsOfDate)</span>
}

// JobFamilies 查询职种
func (r *Resolver) JobFamilies(ctx context.Context, args struct {
        GroupCode       string
        IncludeInactive *bool
        AsOfDate        *string
}) ([]dto.JobFamily, error) <span class="cov0" title="0">{
        log := r.loggerFor("jobCatalog", "families", pkglogger.Fields{"groupCode": args.GroupCode})
        if err := r.authorize(ctx, "jobFamilies", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">includeInactive := false
        if args.IncludeInactive != nil </span><span class="cov0" title="0">{
                includeInactive = *args.IncludeInactive
        }</span>
        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"includeInactive": includeInactive, "asOfDate": args.AsOfDate}).Info("查询职种")

        return r.repo.GetJobFamilies(ctx, sharedconfig.DefaultTenantID, args.GroupCode, includeInactive, args.AsOfDate)</span>
}

// JobRoles 查询职务
func (r *Resolver) JobRoles(ctx context.Context, args struct {
        FamilyCode      string
        IncludeInactive *bool
        AsOfDate        *string
}) ([]dto.JobRole, error) <span class="cov0" title="0">{
        log := r.loggerFor("jobCatalog", "roles", pkglogger.Fields{"familyCode": args.FamilyCode})
        if err := r.authorize(ctx, "jobRoles", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">includeInactive := false
        if args.IncludeInactive != nil </span><span class="cov0" title="0">{
                includeInactive = *args.IncludeInactive
        }</span>
        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"includeInactive": includeInactive, "asOfDate": args.AsOfDate}).Info("查询职务")

        return r.repo.GetJobRoles(ctx, sharedconfig.DefaultTenantID, args.FamilyCode, includeInactive, args.AsOfDate)</span>
}

// JobLevels 查询职级
func (r *Resolver) JobLevels(ctx context.Context, args struct {
        RoleCode        string
        IncludeInactive *bool
        AsOfDate        *string
}) ([]dto.JobLevel, error) <span class="cov0" title="0">{
        log := r.loggerFor("jobCatalog", "levels", pkglogger.Fields{"roleCode": args.RoleCode})
        if err := r.authorize(ctx, "jobLevels", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">includeInactive := false
        if args.IncludeInactive != nil </span><span class="cov0" title="0">{
                includeInactive = *args.IncludeInactive
        }</span>
        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{"includeInactive": includeInactive, "asOfDate": args.AsOfDate}).Info("查询职级")

        return r.repo.GetJobLevels(ctx, sharedconfig.DefaultTenantID, args.RoleCode, includeInactive, args.AsOfDate)</span>
}

// 审计历史查询 - v4.6.0 基于record_id
func (r *Resolver) AuditHistory(ctx context.Context, args struct {
        RecordId  string
        StartDate *string
        EndDate   *string
        Operation *string
        UserId    *string
        Limit     int32
}) ([]dto.AuditRecordData, error) <span class="cov0" title="0">{
        log := r.loggerFor("audit", "history", pkglogger.Fields{
                "recordId": args.RecordId,
                "limit":    args.Limit,
        })
        if err := r.authorize(ctx, "auditHistory", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">limit := int32(50) // 默认限制
        if args.Limit &gt; 0 </span><span class="cov0" title="0">{
                limit = args.Limit
                if limit &gt; 200 </span><span class="cov0" title="0">{ // API规范限制最大200
                        limit = 200
                }</span>
        }

        <span class="cov0" title="0">tenantStr := auth.GetTenantID(ctx)
        if tenantStr == "" </span><span class="cov0" title="0">{
                log.Warn("缺少租户ID，拒绝审计历史查询")
                return nil, fmt.Errorf("TENANT_REQUIRED")
        }</span>
        <span class="cov0" title="0">tenantUUID, err := uuid.Parse(tenantStr)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(pkglogger.Fields{"tenantId": tenantStr, "error": err}).Warn("无效租户ID")
                return nil, fmt.Errorf("INVALID_TENANT")
        }</span>

        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{
                "tenantId":  tenantUUID.String(),
                "startDate": args.StartDate,
                "endDate":   args.EndDate,
                "operation": args.Operation,
                "userId":    args.UserId,
                "limit":     limit,
        }).Info("执行审计历史查询")

        return r.repo.GetAuditHistory(ctx, tenantUUID, args.RecordId, args.StartDate, args.EndDate, args.Operation, args.UserId, int(limit))</span>
}

// 单条审计记录查询 - v4.6.0
func (r *Resolver) AuditLog(ctx context.Context, args struct {
        AuditId string
}) (*dto.AuditRecordData, error) <span class="cov0" title="0">{
        log := r.loggerFor("audit", "log", pkglogger.Fields{"auditId": args.AuditId})
        if err := r.authorize(ctx, "auditLog", log); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Info("单条审计记录查询")
        return r.repo.GetAuditLog(ctx, args.AuditId)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package scheduler

import (
        pkglogger "cube-castle/pkg/logger"
)

func scopedLogger(base pkglogger.Logger, name string, extra pkglogger.Fields) pkglogger.Logger <span class="cov8" title="1">{
        if base == nil </span><span class="cov0" title="0">{
                base = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov8" title="1">fields := pkglogger.Fields{
                "component": "scheduler",
        }
        if name != "" </span><span class="cov8" title="1">{
                fields["service"] = name
        }</span>
        <span class="cov8" title="1">if extra != nil </span><span class="cov0" title="0">{
                for k, v := range extra </span><span class="cov0" title="0">{
                        fields[k] = v
                }</span>
        }

        <span class="cov8" title="1">return base.WithFields(fields)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package scheduler

import (
        "context"
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        configpkg "cube-castle/internal/config"
        "cube-castle/internal/organization/service"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        cron "github.com/robfig/cron/v3"
)

// OperationalScheduler 根据集中化配置调度后台维护任务。
type OperationalScheduler struct {
        db              *sql.DB
        logger          pkglogger.Logger
        monitor         *TemporalMonitor
        positions       *service.PositionService
        scriptsPath     string
        config          *configpkg.SchedulerConfig
        tasks           map[string]*ScheduledTask
        tickInterval    time.Duration
        stopCh          chan struct{}
        running         bool
        monitorEnabled  bool
        monitorInterval time.Duration
        mu              sync.RWMutex
}

// ScheduledTask 描述单个任务的运行时状态。
type ScheduledTask struct {
        Name             string        `json:"name"`
        Description      string        `json:"description"`
        CronExpr         string        `json:"cron"`
        Enabled          bool          `json:"enabled"`
        ScriptFile       string        `json:"scriptFile"`
        InitialDelay     time.Duration `json:"initialDelay"`
        Timeout          time.Duration `json:"timeout"`
        LastRun          *time.Time    `json:"lastRun,omitempty"`
        NextRun          time.Time     `json:"nextRun"`
        usesInitialDelay bool
        cronSchedule     cron.Schedule
        Running          bool `json:"running"`
        mu               sync.Mutex
}

// NewOperationalScheduler 创建运维任务调度器。
func NewOperationalScheduler(
        db *sql.DB,
        baseLogger pkglogger.Logger,
        monitor *TemporalMonitor,
        positions *service.PositionService,
        cfg *configpkg.SchedulerConfig,
) *OperationalScheduler <span class="cov8" title="1">{
        logger := scopedLogger(baseLogger, "operationalScheduler", nil)

        if cfg == nil </span><span class="cov0" title="0">{
                cfg = configpkg.GetSchedulerConfig().Config
        }</span>

        <span class="cov8" title="1">scriptsPath := cfg.Scripts.Root
        if scriptsPath == "" </span><span class="cov8" title="1">{
                scriptsPath = "./scripts"
        }</span>
        <span class="cov8" title="1">if !filepath.IsAbs(scriptsPath) </span><span class="cov8" title="1">{
                if pwd := os.Getenv("PWD"); pwd != "" </span><span class="cov8" title="1">{
                        scriptsPath = filepath.Join(pwd, scriptsPath)
                }</span>
        }

        <span class="cov8" title="1">tick := cfg.Cron.CheckInterval
        if tick &lt;= 0 </span><span class="cov0" title="0">{
                tick = time.Minute
        }</span>

        <span class="cov8" title="1">taskMap := buildScheduledTasks(cfg, logger)

        return &amp;OperationalScheduler{
                db:              db,
                logger:          logger,
                monitor:         monitor,
                positions:       positions,
                scriptsPath:     scriptsPath,
                config:          cfg,
                tasks:           taskMap,
                tickInterval:    tick,
                stopCh:          make(chan struct{}),
                monitorEnabled:  cfg.Monitor.Enabled,
                monitorInterval: cfg.Monitor.CheckInterval,
        }</span>
}

func buildScheduledTasks(cfg *configpkg.SchedulerConfig, logger pkglogger.Logger) map[string]*ScheduledTask <span class="cov8" title="1">{
        parser := cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)
        result := make(map[string]*ScheduledTask, len(cfg.Cron.Tasks))
        now := time.Now()

        for name, def := range cfg.Cron.Tasks </span><span class="cov8" title="1">{
                cronExpr := strings.TrimSpace(def.CronExpr)
                if cronExpr == "" </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{
                                "task": name,
                        }).Warn("跳过任务：缺少 cron 表达式")
                        continue</span>
                }

                <span class="cov8" title="1">schedule, err := parser.Parse(cronExpr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(pkglogger.Fields{
                                "task": name,
                                "cron": cronExpr,
                                "err":  err,
                        }).Error("解析 cron 表达式失败，任务将被跳过")
                        continue</span>
                }

                <span class="cov8" title="1">taskName := def.Name
                if taskName == "" </span><span class="cov0" title="0">{
                        taskName = name
                }</span>

                <span class="cov8" title="1">task := &amp;ScheduledTask{
                        Name:             taskName,
                        Description:      def.Description,
                        CronExpr:         cronExpr,
                        Enabled:          def.Enabled,
                        ScriptFile:       def.Script,
                        InitialDelay:     def.InitialDelay,
                        Timeout:          def.Timeout,
                        cronSchedule:     schedule,
                        usesInitialDelay: def.InitialDelay &gt; 0,
                }

                if task.Enabled </span><span class="cov8" title="1">{
                        if def.InitialDelay &gt; 0 </span><span class="cov0" title="0">{
                                task.NextRun = now.Add(def.InitialDelay)
                        }</span> else<span class="cov8" title="1"> {
                                task.NextRun = schedule.Next(now)
                        }</span>
                } else<span class="cov0" title="0"> {
                        task.NextRun = schedule.Next(now)
                }</span>

                <span class="cov8" title="1">result[name] = task</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Start 按配置启动调度器。
func (s *OperationalScheduler) Start(ctx context.Context) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.mu.Lock()
        if s.config != nil &amp;&amp; !s.config.Enabled </span><span class="cov0" title="0">{
                s.mu.Unlock()
                s.logger.Info("运维任务调度器未启动（配置禁用）")
                return
        }</span>
        <span class="cov0" title="0">if s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                s.logger.Warn("运维任务调度器已在运行中")
                return
        }</span>
        <span class="cov0" title="0">if len(s.tasks) == 0 </span><span class="cov0" title="0">{
                s.mu.Unlock()
                s.logger.Warn("无任务配置，跳过运维任务调度器启动")
                return
        }</span>

        <span class="cov0" title="0">s.logger.Infof("启动运维任务调度器 (tick=%v, tasks=%d)", s.tickInterval, len(s.tasks))

        if s.monitor != nil &amp;&amp; s.monitorEnabled </span><span class="cov0" title="0">{
                interval := s.monitorInterval
                if interval &lt;= 0 </span><span class="cov0" title="0">{
                        interval = 5 * time.Minute
                }</span>
                <span class="cov0" title="0">s.monitor.StartPeriodicMonitoring(ctx, interval)
                s.logger.Infof("时态监控已启用 (interval=%v)", interval)</span>
        } else<span class="cov0" title="0"> {
                s.logger.Info("时态监控已禁用或未配置")
        }</span>

        <span class="cov0" title="0">s.stopCh = make(chan struct{})
        s.running = true
        s.mu.Unlock()

        go s.schedulingLoop(ctx)</span>
}

// Stop 停止调度器。
func (s *OperationalScheduler) Stop() <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>

        <span class="cov0" title="0">s.logger.Warn("正在停止运维任务调度器...")
        close(s.stopCh)
        s.running = false
        s.mu.Unlock()
        s.logger.Info("运维任务调度器已停止")</span>
}

func (s *OperationalScheduler) schedulingLoop(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(s.tickInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("接收到上游上下文取消，停止调度循环")
                        return</span>
                case &lt;-s.stopCh:<span class="cov0" title="0">
                        s.logger.Info("收到停止信号，结束调度循环")
                        return</span>
                case now := &lt;-ticker.C:<span class="cov0" title="0">
                        for _, task := range s.tasks </span><span class="cov0" title="0">{
                                task.mu.Lock()
                                if !task.Enabled </span><span class="cov0" title="0">{
                                        task.mu.Unlock()
                                        continue</span>
                                }

                                <span class="cov0" title="0">nextRun := task.NextRun
                                if nextRun.IsZero() </span><span class="cov0" title="0">{
                                        nextRun = task.cronSchedule.Next(now)
                                        task.NextRun = nextRun
                                }</span>
                                <span class="cov0" title="0">if now.Before(nextRun) || task.Running </span><span class="cov0" title="0">{
                                        task.mu.Unlock()
                                        continue</span>
                                }

                                <span class="cov0" title="0">scheduledAt := nextRun
                                task.NextRun = task.cronSchedule.Next(now)
                                if task.usesInitialDelay </span><span class="cov0" title="0">{
                                        task.usesInitialDelay = false
                                }</span>
                                <span class="cov0" title="0">task.Running = true
                                task.mu.Unlock()

                                go s.executeTask(ctx, task, scheduledAt)</span>
                        }
                }
        }
}

func (s *OperationalScheduler) executeTask(ctx context.Context, task *ScheduledTask, scheduledAt time.Time) <span class="cov8" title="1">{
        startTime := time.Now()
        s.logger.WithFields(pkglogger.Fields{
                "task":      task.Name,
                "cron":      task.CronExpr,
                "scheduled": scheduledAt.Format(time.RFC3339),
        }).Info("开始执行任务")

        var err error

        switch task.Name </span>{
        case "acting_assignment_auto_revert":<span class="cov0" title="0">
                err = s.runActingAssignmentAutoRevert(ctx)</span>
        case "system_monitoring":<span class="cov0" title="0">
                err = s.executeMonitoring(ctx)</span>
        default:<span class="cov8" title="1">
                if task.ScriptFile != "" </span><span class="cov8" title="1">{
                        err = s.executeScript(ctx, task.ScriptFile)
                }</span> else<span class="cov0" title="0"> {
                        err = fmt.Errorf("任务 %s 缺少脚本或实现", task.Name)
                }</span>
        }

        <span class="cov8" title="1">completed := time.Now()
        task.mu.Lock()
        if task.LastRun == nil </span><span class="cov8" title="1">{
                task.LastRun = &amp;completed
        }</span> else<span class="cov0" title="0"> {
                *task.LastRun = completed
        }</span>
        <span class="cov8" title="1">task.Running = false
        task.mu.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{
                        "task": task.Name,
                        "err":  err,
                }).Errorf("任务执行失败，耗时: %v", time.Since(startTime))
                s.recordTaskExecution(task, "FAILED", err.Error(), time.Since(startTime))
        }</span> else<span class="cov8" title="1"> {
                s.logger.WithFields(pkglogger.Fields{
                        "task": task.Name,
                }).Infof("任务执行成功，耗时: %v", time.Since(startTime))
                s.recordTaskExecution(task, "SUCCESS", "", time.Since(startTime))
        }</span>
}

// RunTask 手动触发指定任务。
func (s *OperationalScheduler) RunTask(ctx context.Context, name string) error <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("scheduler 已禁用")
        }</span>
        <span class="cov8" title="1">s.mu.RLock()
        cfgEnabled := s.config == nil || s.config.Enabled
        task, ok := s.tasks[name]
        s.mu.RUnlock()
        if !cfgEnabled </span><span class="cov8" title="1">{
                return fmt.Errorf("scheduler 已禁用")
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("任务 %s 未配置", name)
        }</span>

        <span class="cov8" title="1">task.mu.Lock()
        if task.Running </span><span class="cov0" title="0">{
                task.mu.Unlock()
                return fmt.Errorf("任务 %s 正在执行中", name)
        }</span>
        <span class="cov8" title="1">scheduledAt := time.Now()
        task.NextRun = task.cronSchedule.Next(scheduledAt)
        task.usesInitialDelay = false
        task.Running = true
        task.mu.Unlock()

        s.executeTask(ctx, task, scheduledAt)

        return nil</span>
}
func (s *OperationalScheduler) executeScript(ctx context.Context, scriptFile string) error <span class="cov8" title="1">{
        basePath, err := filepath.Abs(s.scriptsPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("解析脚本目录失败: %w", err)
        }</span>

        <span class="cov8" title="1">cleanFile := filepath.Clean(scriptFile)
        target := filepath.Join(basePath, cleanFile)

        if !strings.HasPrefix(target, basePath) </span><span class="cov0" title="0">{
                return fmt.Errorf("拒绝执行目录外脚本: %s", scriptFile)
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(target); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("脚本文件不存在: %s", target)
        }</span>

        <span class="cov8" title="1">sqlContent, err := os.ReadFile(target) // #nosec G304
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("读取脚本文件失败: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := s.db.ExecContext(ctx, string(sqlContent)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("执行SQL脚本失败: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *OperationalScheduler) executeMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        if s.monitor == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("monitor 未配置")
        }</span>
        <span class="cov0" title="0">alerts, err := s.monitor.CheckAlerts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("监控检查失败: %w", err)
        }</span>
        <span class="cov0" title="0">if len(alerts) &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Warnf("监控发现 %d 个告警", len(alerts))
                for _, alert := range alerts </span><span class="cov0" title="0">{
                        s.logger.Warnf("告警详情: %s", alert)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *OperationalScheduler) recordTaskExecution(task *ScheduledTask, status, message string, duration time.Duration) <span class="cov8" title="1">{
        fields := pkglogger.Fields{
                "task":     task.Name,
                "status":   status,
                "duration": duration.String(),
        }
        if message != "" </span><span class="cov0" title="0">{
                fields["error"] = message
        }</span>
        <span class="cov8" title="1">s.logger.WithFields(fields).Info("任务执行完成")</span>
}

// ListTasks 返回当前任务状态副本。
func (s *OperationalScheduler) ListTasks() []ScheduledTask <span class="cov0" title="0">{
        results := make([]ScheduledTask, 0, len(s.tasks))
        for _, task := range s.tasks </span><span class="cov0" title="0">{
                task.mu.Lock()
                clone := *task
                task.mu.Unlock()
                results = append(results, clone)
        }</span>

        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].Name &lt; results[j].Name
        }</span>)

        <span class="cov0" title="0">return results</span>
}

// IsRunning 返回调度器运行状态。
func (s *OperationalScheduler) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

func (s *OperationalScheduler) runActingAssignmentAutoRevert(ctx context.Context) error <span class="cov0" title="0">{
        if s.positions == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("position service 未配置")
        }</span>

        <span class="cov0" title="0">operator := types.OperatedByInfo{ID: "", Name: "auto-revert-scheduler"}
        processed, err := s.positions.ProcessAutoReverts(ctx, types.DefaultTenantID, time.Now().UTC(), 200, operator)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(processed) &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Infof("[AUTO-REVERT] 成功自动结束 %d 条代理任职", len(processed))
        }</span> else<span class="cov0" title="0"> {
                s.logger.Info("[AUTO-REVERT] 无代理任职需要自动结束")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package scheduler

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/audit"
        orgmiddleware "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/repository"
        "cube-castle/internal/organization/utils"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// OrganizationTemporalService 组织时态服务 - 按06文档要求实现
// 聚合 TemporalTimelineManager + AuditLogger，单事务维护时间轴与审计
type OrganizationTemporalService struct {
        db              *sql.DB
        timelineManager *repository.TemporalTimelineManager
        auditLogger     *audit.AuditLogger
        logger          pkglogger.Logger
        orgRepo         *repository.OrganizationRepository
}

func NewOrganizationTemporalService(db *sql.DB, baseLogger pkglogger.Logger) *OrganizationTemporalService <span class="cov0" title="0">{
        return &amp;OrganizationTemporalService{
                db:              db,
                timelineManager: repository.NewTemporalTimelineManager(db, baseLogger),
                auditLogger:     audit.NewAuditLogger(db, baseLogger),
                logger:          scopedLogger(baseLogger, "organizationTemporal", nil),
                orgRepo:         repository.NewOrganizationRepository(db, baseLogger),
        }
}</span>

// TemporalCreateVersionRequest 创建版本请求
type TemporalCreateVersionRequest struct {
        TenantID        string    `json:"tenantId" validate:"required,uuid"`
        Code            string    `json:"code" validate:"required,max=10"`
        Name            string    `json:"name" validate:"required,max=255"`
        UnitType        string    `json:"unitType" validate:"required"`
        Status          string    `json:"status" validate:"required"`
        ParentCode      *string   `json:"parentCode,omitempty"`
        Level           int       `json:"level" validate:"min=1,max=17"`
        SortOrder       int       `json:"sortOrder"`
        Description     string    `json:"description,omitempty"`
        EffectiveDate   time.Time `json:"effectiveDate" validate:"required"`
        OperationReason string    `json:"operationReason" validate:"omitempty,max=500"`
}

// TemporalUpdateVersionRequest 更新版本请求
type TemporalUpdateVersionRequest struct {
        TenantID         string    `json:"tenantId" validate:"required,uuid"`
        RecordID         string    `json:"recordId" validate:"required,uuid"`
        NewEffectiveDate time.Time `json:"newEffectiveDate" validate:"required"`
        OperationReason  string    `json:"operationReason" validate:"omitempty,max=500"`
}

// TemporalDeleteVersionRequest 删除版本请求
type TemporalDeleteVersionRequest struct {
        TenantID        string `json:"tenantId" validate:"required,uuid"`
        RecordID        string `json:"recordId" validate:"required,uuid"`
        OperationReason string `json:"operationReason" validate:"omitempty,max=500"`
}

// TemporalStatusChangeRequest 状态变更请求
type TemporalStatusChangeRequest struct {
        TenantID        string    `json:"tenantId" validate:"required,uuid"`
        Code            string    `json:"code" validate:"required,max=10"`
        NewStatus       string    `json:"newStatus" validate:"required"`
        EffectiveDate   time.Time `json:"effectiveDate" validate:"required"`
        OperationReason string    `json:"operationReason" validate:"omitempty,max=500"`
}

// CreateVersion 创建新版本 - 单事务维护时间轴与审计
func (s *OrganizationTemporalService) CreateVersion(ctx context.Context, req *TemporalCreateVersionRequest, actorID, requestID string) (result *repository.TimelineVersion, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                utils.RecordTemporalOperation(utils.OperationCreate, err)
        }</span>()

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: sql.LevelReadCommitted,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        s.logger.Infof("创建组织版本: Code=%s, 生效日期=%s", req.Code, req.EffectiveDate.Format("2006-01-02"))

        // 并发互斥：对同一 tenantId+code 使用咨询锁
        tenantID, err := uuid.Parse(req.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效租户ID: %w", err)
        }</span>

        <span class="cov0" title="0">lockKey := fmt.Sprintf("%s:%s", req.TenantID, req.Code)
        _, err = tx.ExecContext(ctx, "SELECT pg_advisory_xact_lock(hashtext($1))", lockKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("获取咨询锁失败: %w", err)
        }</span>

        <span class="cov0" title="0">var normalizedParent *string
        if req.ParentCode != nil </span><span class="cov0" title="0">{
                normalizedParent = utils.NormalizeParentCodePointer(req.ParentCode)
        }</span>

        <span class="cov0" title="0">normalizedReason := strings.TrimSpace(req.OperationReason)

        org := &amp;types.Organization{
                TenantID:      req.TenantID,
                Code:          req.Code,
                Name:          req.Name,
                UnitType:      req.UnitType,
                Status:        req.Status,
                ParentCode:    normalizedParent,
                SortOrder:     req.SortOrder,
                Description:   req.Description,
                EffectiveDate: types.NewDateFromTime(req.EffectiveDate),
                ChangeReason: func() *string </span><span class="cov0" title="0">{
                        if normalizedReason == "" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">reason := normalizedReason
                        return &amp;reason</span>
                }(),
        }

        <span class="cov0" title="0">fields, calcErr := s.orgRepo.ComputeHierarchyForNew(ctx, tenantID, req.Code, normalizedParent, req.Name)
        if calcErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("计算组织层级失败: %w", calcErr)
        }</span>
        <span class="cov0" title="0">org.Level = fields.Level
        org.CodePath = fields.CodePath
        org.NamePath = fields.NamePath

        // 1. 执行时态操作
        result, err = s.timelineManager.InsertVersion(ctx, org)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("插入版本失败: %w", err)
        }</span>

        // 2. 写入审计日志
        <span class="cov0" title="0">afterData := map[string]interface{}{
                "code":           req.Code,
                "name":           req.Name,
                "unit_type":      req.UnitType,
                "status":         req.Status,
                "parent_code":    req.ParentCode,
                "level":          req.Level,
                "sort_order":     req.SortOrder,
                "description":    req.Description,
                "effective_date": req.EffectiveDate,
        }

        event := s.newAuditEvent(ctx, tenantID, actorID, "CreateOrganizationVersion", audit.EventTypeCreate, result.RecordID, req.Code, requestID, normalizedReason)
        event.AfterData = afterData
        event.ContextPayload = afterData

        if err := s.auditLogger.LogEventInTransaction(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("审计写入失败: %w", err)
        }</span>

        // 提交事务
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Infof("组织版本创建完成: RecordID=%s", result.RecordID)
        return result, nil</span>
}

// UpdateVersionEffectiveDate 修改版本生效日期 - 单事务维护时间轴与审计
func (s *OrganizationTemporalService) UpdateVersionEffectiveDate(ctx context.Context, req *TemporalUpdateVersionRequest, actorID, requestID string) (timeline *[]repository.TimelineVersion, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                utils.RecordTemporalOperation(utils.OperationUpdate, err)
        }</span>()

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: sql.LevelReadCommitted,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tenantID, err := uuid.Parse(req.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效租户ID: %w", err)
        }</span>

        <span class="cov0" title="0">recordID, err := uuid.Parse(req.RecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效记录ID: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Infof("修改版本生效日期: RecordID=%s, 新日期=%s", recordID, req.NewEffectiveDate.Format("2006-01-02"))

        // 获取原版本数据用于审计
        var oldData map[string]interface{}
        var code string
        row := tx.QueryRowContext(ctx, `
                SELECT code, name, unit_type, status, parent_code, level, sort_order, description, effective_date
                FROM organization_units
                WHERE record_id = $1 AND tenant_id = $2 AND status != 'DELETED'
        `, recordID, tenantID)

        var name, unitType, status string
        var parentCode *string
        var level, sortOrder int
        var description string
        var effectiveDate time.Time

        err = row.Scan(&amp;code, &amp;name, &amp;unitType, &amp;status, &amp;parentCode, &amp;level, &amp;sortOrder, &amp;description, &amp;effectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("版本不存在: %s", recordID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询版本数据失败: %w", err)</span>
        }

        <span class="cov0" title="0">oldData = map[string]interface{}{
                "code":           code,
                "name":           name,
                "unit_type":      unitType,
                "status":         status,
                "parent_code":    parentCode,
                "level":          level,
                "sort_order":     sortOrder,
                "description":    description,
                "effective_date": effectiveDate,
        }

        // 并发互斥锁
        lockKey := fmt.Sprintf("%s:%s", req.TenantID, code)
        _, err = tx.ExecContext(ctx, "SELECT pg_advisory_xact_lock(hashtext($1))", lockKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("获取咨询锁失败: %w", err)
        }</span>

        // 1. 执行时态操作
        <span class="cov0" title="0">normalizedReason := strings.TrimSpace(req.OperationReason)
        timeline, err = s.timelineManager.UpdateVersionEffectiveDate(ctx, tenantID, recordID, req.NewEffectiveDate, normalizedReason)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("更新版本生效日期失败: %w", err)
        }</span>

        // 2. 写入审计日志
        <span class="cov0" title="0">newData := make(map[string]interface{})
        for k, v := range oldData </span><span class="cov0" title="0">{
                newData[k] = v
        }</span>
        <span class="cov0" title="0">newData["effective_date"] = req.NewEffectiveDate

        event := s.newAuditEvent(ctx, tenantID, actorID, "UpdateOrganizationVersionEffectiveDate", audit.EventTypeUpdate, recordID, code, requestID, normalizedReason)
        event.BeforeData = oldData
        event.AfterData = newData
        event.ContextPayload = newData
        event.ModifiedFields = []string{"effective_date"}
        event.Changes = []audit.FieldChange{
                {
                        Field:    "effective_date",
                        OldValue: oldData["effective_date"],
                        NewValue: req.NewEffectiveDate,
                        DataType: "timestamp",
                },
        }

        if err := s.auditLogger.LogEventInTransaction(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("审计写入失败: %w", err)
        }</span>

        // 提交事务
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("版本生效日期修改完成")
        return timeline, nil</span>
}

// DeleteVersion 删除版本 - 单事务维护时间轴与审计
func (s *OrganizationTemporalService) DeleteVersion(ctx context.Context, req *TemporalDeleteVersionRequest, actorID, requestID string) (timeline *[]repository.TimelineVersion, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                utils.RecordTemporalOperation(utils.OperationDelete, err)
        }</span>()

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: sql.LevelReadCommitted,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tenantID, err := uuid.Parse(req.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效租户ID: %w", err)
        }</span>

        <span class="cov0" title="0">recordID, err := uuid.Parse(req.RecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效记录ID: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Infof("删除组织版本: RecordID=%s", recordID)

        // 获取版本数据用于审计和锁定
        var beforeData map[string]interface{}
        var code string
        row := tx.QueryRowContext(ctx, `
                SELECT code, name, unit_type, status, parent_code, level, sort_order, description, effective_date
                FROM organization_units
                WHERE record_id = $1 AND tenant_id = $2 AND status != 'DELETED'
                FOR UPDATE
        `, recordID, tenantID)

        var name, unitType, status string
        var parentCode *string
        var level, sortOrder int
        var description string
        var effectiveDate time.Time

        err = row.Scan(&amp;code, &amp;name, &amp;unitType, &amp;status, &amp;parentCode, &amp;level, &amp;sortOrder, &amp;description, &amp;effectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("版本不存在或已删除: %s", recordID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("查询版本数据失败: %w", err)</span>
        }

        <span class="cov0" title="0">beforeData = map[string]interface{}{
                "code":           code,
                "name":           name,
                "unit_type":      unitType,
                "status":         status,
                "parent_code":    parentCode,
                "level":          level,
                "sort_order":     sortOrder,
                "description":    description,
                "effective_date": effectiveDate,
        }

        // 并发互斥锁
        lockKey := fmt.Sprintf("%s:%s", req.TenantID, code)
        _, err = tx.ExecContext(ctx, "SELECT pg_advisory_xact_lock(hashtext($1))", lockKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("获取咨询锁失败: %w", err)
        }</span>

        // 1. 执行时态操作
        <span class="cov0" title="0">normalizedReason := strings.TrimSpace(req.OperationReason)
        timeline, err = s.timelineManager.DeleteVersion(ctx, tenantID, recordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("删除版本失败: %w", err)
        }</span>

        // 2. 写入审计日志
        <span class="cov0" title="0">event := s.newAuditEvent(ctx, tenantID, actorID, "DeleteOrganizationVersion", audit.EventTypeDelete, recordID, code, requestID, normalizedReason)
        event.BeforeData = beforeData
        event.ContextPayload = beforeData
        event.Success = true

        if err := s.auditLogger.LogEventInTransaction(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("审计写入失败: %w", err)
        }</span>

        // 提交事务
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("版本删除完成")
        return timeline, nil</span>
}

// SuspendOrganization 暂停组织 - 单事务维护时间轴与审计
func (s *OrganizationTemporalService) SuspendOrganization(ctx context.Context, req *TemporalStatusChangeRequest, actorID, requestID string) (timeline *[]repository.TimelineVersion, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                utils.RecordTemporalOperation(utils.OperationSuspend, err)
        }</span>()
        <span class="cov0" title="0">timeline, err = s.changeOrganizationStatus(ctx, req, "INACTIVE", "SUSPEND", actorID, requestID)
        return</span>
}

// ActivateOrganization 激活组织 - 单事务维护时间轴与审计
func (s *OrganizationTemporalService) ActivateOrganization(ctx context.Context, req *TemporalStatusChangeRequest, actorID, requestID string) (timeline *[]repository.TimelineVersion, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                utils.RecordTemporalOperation(utils.OperationReactivate, err)
        }</span>()
        <span class="cov0" title="0">timeline, err = s.changeOrganizationStatus(ctx, req, "ACTIVE", "REACTIVATE", actorID, requestID)
        return</span>
}

// changeOrganizationStatus 通用状态变更逻辑
func (s *OrganizationTemporalService) changeOrganizationStatus(ctx context.Context, req *TemporalStatusChangeRequest, targetStatus, operationType, actorID, requestID string) (*[]repository.TimelineVersion, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: sql.LevelReadCommitted,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("开始事务失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        tenantID, err := uuid.Parse(req.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("无效租户ID: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Infof("%s 组织: Code=%s, 生效日期=%s", operationType, req.Code, req.EffectiveDate.Format("2006-01-02"))

        // 并发互斥锁
        lockKey := fmt.Sprintf("%s:%s", req.TenantID, req.Code)
        _, err = tx.ExecContext(ctx, "SELECT pg_advisory_xact_lock(hashtext($1))", lockKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("获取咨询锁失败: %w", err)
        }</span>

        // 1. 执行时态操作
        <span class="cov0" title="0">var timeline *[]repository.TimelineVersion
        normalizedReason := strings.TrimSpace(req.OperationReason)
        if operationType == "SUSPEND" </span><span class="cov0" title="0">{
                timeline, err = s.timelineManager.SuspendOrganization(ctx, tenantID, req.Code, req.EffectiveDate, normalizedReason)
        }</span> else<span class="cov0" title="0"> {
                timeline, err = s.timelineManager.ActivateOrganization(ctx, tenantID, req.Code, req.EffectiveDate, normalizedReason)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s组织失败: %w", operationType, err)
        }</span>

        // 2. 写入审计日志（状态变更类型）
        <span class="cov0" title="0">var newRecordID uuid.UUID
        for _, version := range *timeline </span><span class="cov0" title="0">{
                if version.IsCurrent &amp;&amp; version.Status == targetStatus </span><span class="cov0" title="0">{
                        newRecordID = version.RecordID
                        break</span>
                }
        }

        <span class="cov0" title="0">if newRecordID == uuid.Nil </span><span class="cov0" title="0">{
                s.logger.Warnf("未找到新创建的%s版本，跳过审计", operationType)
        }</span> else<span class="cov0" title="0"> {
                prevStatus := getOppositeStatus(targetStatus)
                afterData := map[string]interface{}{"status": targetStatus}
                actionName := fmt.Sprintf("%s_ORGANIZATION", operationType)
                event := s.newAuditEvent(ctx, tenantID, actorID, actionName, audit.EventTypeUpdate, newRecordID, req.Code, requestID, normalizedReason)
                event.BeforeData = map[string]interface{}{"status": prevStatus}
                event.AfterData = afterData
                event.ContextPayload = map[string]interface{}{
                        "status":        targetStatus,
                        "operationType": operationType,
                }
                event.ModifiedFields = []string{"status"}
                event.Changes = []audit.FieldChange{
                        {Field: "status", OldValue: prevStatus, NewValue: targetStatus, DataType: "string"},
                }

                if err := s.auditLogger.LogEventInTransaction(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("审计写入失败: %w", err)
                }</span>
        }

        // 提交事务
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("提交事务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Infof("组织%s完成", operationType)
        return timeline, nil</span>
}

func (s *OrganizationTemporalService) newAuditEvent(ctx context.Context, tenantID uuid.UUID, actorID, actionName string, eventType string, resourceID uuid.UUID, entityCode, requestID, operationReason string) *audit.AuditEvent <span class="cov0" title="0">{
        trimmedActorID := strings.TrimSpace(actorID)
        actorType := audit.ActorTypeUser
        if trimmedActorID == "" </span><span class="cov0" title="0">{
                trimmedActorID = "system"
                actorType = audit.ActorTypeSystem
        }</span>
        <span class="cov0" title="0">actorName := trimmedActorID

        correlationID := orgmiddleware.GetCorrelationID(ctx)
        if correlationID == "" &amp;&amp; requestID != "" </span><span class="cov0" title="0">{
                correlationID = requestID
        }</span>
        <span class="cov0" title="0">sourceCorrelation := ""
        if orgmiddleware.GetCorrelationSource(ctx) == "header" </span><span class="cov0" title="0">{
                sourceCorrelation = "header"
        }</span>

        <span class="cov0" title="0">return &amp;audit.AuditEvent{
                TenantID:          tenantID,
                EventType:         eventType,
                ResourceType:      audit.ResourceTypeOrganization,
                ResourceID:        resourceID.String(),
                RecordID:          resourceID,
                EntityCode:        entityCode,
                ActorID:           trimmedActorID,
                ActorType:         actorType,
                ActorName:         actorName,
                ActionName:        actionName,
                RequestID:         requestID,
                CorrelationID:     correlationID,
                SourceCorrelation: sourceCorrelation,
                OperationReason:   strings.TrimSpace(operationReason),
                Success:           true,
        }</span>
}

// getOppositeStatus 获取状态的相反状态
func getOppositeStatus(status string) string <span class="cov0" title="0">{
        if status == "ACTIVE" </span><span class="cov0" title="0">{
                return "INACTIVE"
        }</span>
        <span class="cov0" title="0">return "ACTIVE"</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package scheduler

import (
        "context"
        "database/sql"

        configpkg "cube-castle/internal/config"
        "cube-castle/internal/organization/repository"
        servicepkg "cube-castle/internal/organization/service"
        pkglogger "cube-castle/pkg/logger"
)

// Service 聚合调度与 Temporal 能力，为命令模块提供统一入口。
type Service struct {
        temporal    *TemporalService
        monitor     *TemporalMonitor
        operational *OperationalScheduler
        orgTemporal *OrganizationTemporalService
        logger      pkglogger.Logger
        config      *configpkg.SchedulerConfig
}

// Dependencies 构建 Service 所需依赖。
type Dependencies struct {
        DB                     *sql.DB
        Logger                 pkglogger.Logger
        OrganizationRepository *repository.OrganizationRepository
        PositionService        *servicepkg.PositionService
        Config                 *configpkg.SchedulerConfig
}

// NewService 创建调度聚合服务。
func NewService(deps Dependencies) *Service <span class="cov0" title="0">{
        logger := deps.Logger
        if logger == nil </span><span class="cov0" title="0">{
                logger = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov0" title="0">cfg := deps.Config
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = configpkg.GetSchedulerConfig().Config
        }</span>

        <span class="cov0" title="0">temporal := NewTemporalService(deps.DB, logger, deps.OrganizationRepository)
        monitor := NewTemporalMonitor(deps.DB, logger)
        operational := NewOperationalScheduler(deps.DB, logger, monitor, deps.PositionService, cfg)
        orgTemporal := NewOrganizationTemporalService(deps.DB, logger)

        return &amp;Service{
                temporal:    temporal,
                monitor:     monitor,
                operational: operational,
                orgTemporal: orgTemporal,
                logger:      logger,
                config:      cfg,
        }</span>
}

// Temporal 返回 TemporalService。
func (s *Service) Temporal() *TemporalService <span class="cov0" title="0">{
        return s.temporal
}</span>

// Monitor 返回 TemporalMonitor。
func (s *Service) Monitor() *TemporalMonitor <span class="cov0" title="0">{
        return s.monitor
}</span>

// Operational 返回 OperationalScheduler。
func (s *Service) Operational() *OperationalScheduler <span class="cov0" title="0">{
        return s.operational
}</span>

// OrganizationTemporal 返回 OrganizationTemporalService。
func (s *Service) OrganizationTemporal() *OrganizationTemporalService <span class="cov0" title="0">{
        return s.orgTemporal
}</span>

// Start 启动调度相关后台任务。
func (s *Service) Start(ctx context.Context) <span class="cov0" title="0">{
        if s.operational != nil &amp;&amp; (s.config == nil || s.config.Enabled) </span><span class="cov0" title="0">{
                s.operational.Start(ctx)
        }</span> else<span class="cov0" title="0"> if s.config != nil &amp;&amp; !s.config.Enabled </span><span class="cov0" title="0">{
                s.logger.Info("Scheduler 配置为禁用状态，跳过后台任务启动")
        }</span>
}

// Stop 停止调度后台任务。
func (s *Service) Stop() <span class="cov0" title="0">{
        if s.operational != nil </span><span class="cov0" title="0">{
                s.operational.Stop()
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package scheduler

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        auth "cube-castle/internal/auth"
        pkglogger "cube-castle/pkg/logger"
)

// TemporalMonitor 时态数据监控服务
type TemporalMonitor struct {
        db     *sql.DB
        logger pkglogger.Logger
}

// NewTemporalMonitor 创建时态监控服务
func NewTemporalMonitor(db *sql.DB, baseLogger pkglogger.Logger) *TemporalMonitor <span class="cov8" title="1">{
        return &amp;TemporalMonitor{
                db:     db,
                logger: scopedLogger(baseLogger, "temporalMonitor", nil),
        }
}</span>

// MonitoringMetrics 监控指标
type MonitoringMetrics struct {
        TotalOrganizations    int       `json:"totalOrganizations"`
        CurrentRecords        int       `json:"currentRecords"`
        FutureRecords         int       `json:"futureRecords"`
        HistoricalRecords     int       `json:"historicalRecords"`
        DuplicateCurrentCount int       `json:"duplicateCurrentCount"`
        MissingCurrentCount   int       `json:"missingCurrentCount"`
        TimelineOverlapCount  int       `json:"timelineOverlapCount"`
        InconsistentFlagCount int       `json:"inconsistentFlagCount"`
        OrphanRecordCount     int       `json:"orphanRecordCount"`
        HealthScore           float64   `json:"healthScore"` // 0-100
        LastCheckTime         time.Time `json:"lastCheckTime"`
        AlertLevel            string    `json:"alertLevel"` // HEALTHY, WARNING, CRITICAL
}

// AlertRule 告警规则
type AlertRule struct {
        Name        string `json:"name"`
        Description string `json:"description"`
        Threshold   int    `json:"threshold"`
        AlertLevel  string `json:"alertLevel"`
}

// GetDefaultAlertRules 获取默认告警规则
func (m *TemporalMonitor) GetDefaultAlertRules() []AlertRule <span class="cov8" title="1">{
        return []AlertRule{
                {
                        Name:        "DUPLICATE_CURRENT_RECORDS",
                        Description: "重复的当前记录数量超过阈值",
                        Threshold:   0, // 任何重复都是严重问题
                        AlertLevel:  "CRITICAL",
                },
                {
                        Name:        "MISSING_CURRENT_RECORDS",
                        Description: "缺失当前记录的组织数量超过阈值",
                        Threshold:   0, // 任何缺失都是严重问题
                        AlertLevel:  "CRITICAL",
                },
                {
                        Name:        "TIMELINE_OVERLAPS",
                        Description: "时间线重叠记录数量超过阈值",
                        Threshold:   0, // 任何重叠都是严重问题
                        AlertLevel:  "CRITICAL",
                },
                {
                        Name:        "INCONSISTENT_FLAGS",
                        Description: "is_current/is_future标志不一致记录数量超过阈值",
                        Threshold:   5, // 少量不一致可能是时间差导致
                        AlertLevel:  "WARNING",
                },
                {
                        Name:        "ORPHAN_RECORDS",
                        Description: "孤立记录（父级不存在）数量超过阈值",
                        Threshold:   10, // 少量孤立记录可以接受
                        AlertLevel:  "WARNING",
                },
                {
                        Name:        "HEALTH_SCORE",
                        Description: "系统健康分数低于阈值",
                        Threshold:   85, // 健康分数低于85%告警
                        AlertLevel:  "WARNING",
                },
        }
}</span>

// CollectMetrics 收集监控指标
func (m *TemporalMonitor) CollectMetrics(ctx context.Context) (*MonitoringMetrics, error) <span class="cov8" title="1">{
        // 多租户隔离：默认按请求上下文租户计算；若无租户（例如后台周期任务），则计算全局汇总，仅用于内部日志
        tenantID := auth.GetTenantID(ctx)
        metrics := &amp;MonitoringMetrics{
                LastCheckTime: time.Now(),
                AlertLevel:    "HEALTHY",
        }

        // 1. 基础统计
        err := m.collectBasicStats(ctx, metrics, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to collect basic stats: %w", err)
        }</span>

        // 2. 数据一致性检查
        <span class="cov8" title="1">err = m.collectConsistencyStats(ctx, metrics, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to collect consistency stats: %w", err)
        }</span>

        // 3. 计算健康分数和告警级别
        <span class="cov8" title="1">m.calculateHealthScore(metrics)

        return metrics, nil</span>
}

func (m *TemporalMonitor) collectBasicStats(ctx context.Context, metrics *MonitoringMetrics, tenantID string) error <span class="cov8" title="1">{
        // 统计总组织数
        var err error
        if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(DISTINCT code) FROM organization_units WHERE status &lt;&gt; 'DELETED' AND tenant_id = $1",
                        tenantID,
                ).Scan(&amp;metrics.TotalOrganizations)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(DISTINCT code) FROM organization_units WHERE status &lt;&gt; 'DELETED'",
                ).Scan(&amp;metrics.TotalOrganizations)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count total organizations: %w", err)
        }</span>

        // 统计当前记录数
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(*) FROM organization_units WHERE is_current = true AND status &lt;&gt; 'DELETED' AND tenant_id = $1",
                        tenantID,
                ).Scan(&amp;metrics.CurrentRecords)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(*) FROM organization_units WHERE is_current = true AND status &lt;&gt; 'DELETED'",
                ).Scan(&amp;metrics.CurrentRecords)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count current records: %w", err)
        }</span>

        // 统计未来记录数（派生条件）
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(*) FROM organization_units WHERE effective_date &gt; CURRENT_DATE AND status &lt;&gt; 'DELETED' AND tenant_id = $1",
                        tenantID,
                ).Scan(&amp;metrics.FutureRecords)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(*) FROM organization_units WHERE effective_date &gt; CURRENT_DATE AND status &lt;&gt; 'DELETED'",
                ).Scan(&amp;metrics.FutureRecords)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count future records: %w", err)
        }</span>

        // 统计历史记录数（派生条件：已结束）
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(*) FROM organization_units WHERE end_date IS NOT NULL AND end_date &lt;= CURRENT_DATE AND status &lt;&gt; 'DELETED' AND tenant_id = $1",
                        tenantID,
                ).Scan(&amp;metrics.HistoricalRecords)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx,
                        "SELECT COUNT(*) FROM organization_units WHERE end_date IS NOT NULL AND end_date &lt;= CURRENT_DATE AND status &lt;&gt; 'DELETED'",
                ).Scan(&amp;metrics.HistoricalRecords)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count historical records: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *TemporalMonitor) collectConsistencyStats(ctx context.Context, metrics *MonitoringMetrics, tenantID string) error <span class="cov8" title="1">{
        // 检查重复当前记录
        var err error
        if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM (
            SELECT tenant_id, code
            FROM organization_units 
            WHERE is_current = true AND status &lt;&gt; 'DELETED' AND tenant_id = $1
            GROUP BY tenant_id, code
            HAVING COUNT(*) &gt; 1
        ) duplicates
    `, tenantID).Scan(&amp;metrics.DuplicateCurrentCount)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM (
            SELECT tenant_id, code
            FROM organization_units 
            WHERE is_current = true AND status &lt;&gt; 'DELETED'
            GROUP BY tenant_id, code
            HAVING COUNT(*) &gt; 1
        ) duplicates
    `).Scan(&amp;metrics.DuplicateCurrentCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count duplicate current records: %w", err)
        }</span>

        // 检查缺失当前记录
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM (
            SELECT DISTINCT tenant_id, code
            FROM organization_units
            WHERE tenant_id = $1
              AND (tenant_id, code) NOT IN (
                SELECT tenant_id, code 
                FROM organization_units 
                WHERE is_current = true AND status &lt;&gt; 'DELETED' AND tenant_id = $1
              )
              AND (tenant_id, code) NOT IN (
                SELECT tenant_id, code
                FROM organization_units
                WHERE tenant_id = $1
                GROUP BY tenant_id, code
                HAVING MIN(CASE WHEN status &lt;&gt; 'DELETED' THEN effective_date ELSE NULL END) &gt; CURRENT_DATE
              )
              AND EXISTS (
                SELECT 1 FROM organization_units u
                WHERE u.tenant_id = organization_units.tenant_id
                  AND u.code = organization_units.code
                  AND u.status &lt;&gt; 'DELETED'
              )
        ) missing
    `, tenantID).Scan(&amp;metrics.MissingCurrentCount)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM (
            SELECT DISTINCT tenant_id, code
            FROM organization_units
            WHERE (tenant_id, code) NOT IN (
                SELECT tenant_id, code 
                FROM organization_units 
                WHERE is_current = true AND status &lt;&gt; 'DELETED'
            )
            AND (tenant_id, code) NOT IN (
                SELECT tenant_id, code
                FROM organization_units
                GROUP BY tenant_id, code
                HAVING MIN(CASE WHEN status &lt;&gt; 'DELETED' THEN effective_date ELSE NULL END) &gt; CURRENT_DATE
            )
            AND EXISTS (
                SELECT 1 FROM organization_units u
                WHERE u.tenant_id = organization_units.tenant_id
                  AND u.code = organization_units.code
                  AND u.status &lt;&gt; 'DELETED'
            )
        ) missing
    `).Scan(&amp;metrics.MissingCurrentCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count missing current records: %w", err)
        }</span>

        // 检查时间线重叠
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM (
            SELECT DISTINCT o1.tenant_id, o1.code
            FROM organization_units o1
            JOIN organization_units o2 ON (
                o1.tenant_id = o2.tenant_id 
                AND o1.code = o2.code 
                AND o1.record_id != o2.record_id
            )
            WHERE 
                o1.status &lt;&gt; 'DELETED'
                AND o2.status &lt;&gt; 'DELETED'
                AND o1.tenant_id = $1
                AND o1.effective_date &lt; COALESCE(o2.end_date, '9999-12-31'::date)
                AND o2.effective_date &lt; COALESCE(o1.end_date, '9999-12-31'::date)
        ) AS timeline_overlaps
    `, tenantID).Scan(&amp;metrics.TimelineOverlapCount)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM (
            SELECT DISTINCT o1.tenant_id, o1.code
            FROM organization_units o1
            JOIN organization_units o2 ON (
                o1.tenant_id = o2.tenant_id 
                AND o1.code = o2.code 
                AND o1.record_id != o2.record_id
            )
            WHERE 
                o1.status &lt;&gt; 'DELETED'
                AND o2.status &lt;&gt; 'DELETED'
                AND o1.effective_date &lt; COALESCE(o2.end_date, '9999-12-31'::date)
                AND o2.effective_date &lt; COALESCE(o1.end_date, '9999-12-31'::date)
        ) AS timeline_overlaps
    `).Scan(&amp;metrics.TimelineOverlapCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count timeline overlaps: %w", err)
        }</span>

        // 检查标志不一致记录（仅校验 is_current；is_future 已移除，使用派生值但不与列比较）
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM organization_units
        WHERE is_current != (
            effective_date &lt;= CURRENT_DATE 
            AND (end_date IS NULL OR end_date &gt; CURRENT_DATE)
        )
        AND status &lt;&gt; 'DELETED'
        AND tenant_id = $1
    `, tenantID).Scan(&amp;metrics.InconsistentFlagCount)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM organization_units
        WHERE is_current != (
            effective_date &lt;= CURRENT_DATE 
            AND (end_date IS NULL OR end_date &gt; CURRENT_DATE)
        )
        AND status &lt;&gt; 'DELETED'
    `).Scan(&amp;metrics.InconsistentFlagCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count inconsistent flags: %w", err)
        }</span>

        // 检查孤立记录
        <span class="cov8" title="1">if tenantID != "" </span><span class="cov0" title="0">{
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM organization_units o1
        WHERE 
            parent_code IS NOT NULL
            AND o1.status &lt;&gt; 'DELETED'
            AND o1.tenant_id = $1
            AND NOT EXISTS (
                SELECT 1 FROM organization_units o2 
                WHERE o2.tenant_id = o1.tenant_id 
                    AND o2.code = o1.parent_code 
                    AND o2.is_current = true
                    AND o2.status &lt;&gt; 'DELETED'
            )
    `, tenantID).Scan(&amp;metrics.OrphanRecordCount)
        }</span> else<span class="cov8" title="1"> {
                err = m.db.QueryRowContext(ctx, `
        SELECT COUNT(*) FROM organization_units o1
        WHERE 
            parent_code IS NOT NULL
            AND o1.status &lt;&gt; 'DELETED'
            AND NOT EXISTS (
                SELECT 1 FROM organization_units o2 
                WHERE o2.tenant_id = o1.tenant_id 
                    AND o2.code = o1.parent_code 
                    AND o2.is_current = true
                    AND o2.status &lt;&gt; 'DELETED'
            )
    `).Scan(&amp;metrics.OrphanRecordCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count orphan records: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *TemporalMonitor) calculateHealthScore(metrics *MonitoringMetrics) <span class="cov8" title="1">{
        // 健康分数计算逻辑
        score := 100.0

        // 严重问题直接大幅扣分
        if metrics.DuplicateCurrentCount &gt; 0 </span><span class="cov8" title="1">{
                score -= 40.0 // 重复当前记录是严重问题
        }</span>
        <span class="cov8" title="1">if metrics.MissingCurrentCount &gt; 0 </span><span class="cov0" title="0">{
                score -= 40.0 // 缺失当前记录是严重问题
        }</span>
        <span class="cov8" title="1">if metrics.TimelineOverlapCount &gt; 0 </span><span class="cov0" title="0">{
                score -= 30.0 // 时间线重叠是严重问题
        }</span>

        // 轻微问题按比例扣分
        <span class="cov8" title="1">if metrics.InconsistentFlagCount &gt; 0 </span><span class="cov0" title="0">{
                score -= float64(metrics.InconsistentFlagCount) * 2.0 // 每个不一致记录扣2分
        }</span>
        <span class="cov8" title="1">if metrics.OrphanRecordCount &gt; 0 </span><span class="cov0" title="0">{
                score -= float64(metrics.OrphanRecordCount) * 1.0 // 每个孤立记录扣1分
        }</span>

        // 确保分数不低于0
        <span class="cov8" title="1">if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span>

        <span class="cov8" title="1">metrics.HealthScore = score

        // 确定告警级别
        if score &lt; 50 || metrics.DuplicateCurrentCount &gt; 0 || metrics.MissingCurrentCount &gt; 0 || metrics.TimelineOverlapCount &gt; 0 </span><span class="cov8" title="1">{
                metrics.AlertLevel = "CRITICAL"
        }</span> else<span class="cov8" title="1"> if score &lt; 85 || metrics.InconsistentFlagCount &gt; 5 || metrics.OrphanRecordCount &gt; 10 </span><span class="cov0" title="0">{
                metrics.AlertLevel = "WARNING"
        }</span> else<span class="cov8" title="1"> {
                metrics.AlertLevel = "HEALTHY"
        }</span>
}

// CheckAlerts 检查告警条件
func (m *TemporalMonitor) CheckAlerts(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        metrics, err := m.CollectMetrics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to collect metrics: %w", err)
        }</span>

        <span class="cov8" title="1">var alerts []string
        rules := m.GetDefaultAlertRules()

        for _, rule := range rules </span><span class="cov8" title="1">{
                var currentValue int
                var triggered bool

                switch rule.Name </span>{
                case "DUPLICATE_CURRENT_RECORDS":<span class="cov8" title="1">
                        currentValue = metrics.DuplicateCurrentCount
                        triggered = currentValue &gt; rule.Threshold</span>
                case "MISSING_CURRENT_RECORDS":<span class="cov8" title="1">
                        currentValue = metrics.MissingCurrentCount
                        triggered = currentValue &gt; rule.Threshold</span>
                case "TIMELINE_OVERLAPS":<span class="cov8" title="1">
                        currentValue = metrics.TimelineOverlapCount
                        triggered = currentValue &gt; rule.Threshold</span>
                case "INCONSISTENT_FLAGS":<span class="cov8" title="1">
                        currentValue = metrics.InconsistentFlagCount
                        triggered = currentValue &gt; rule.Threshold</span>
                case "ORPHAN_RECORDS":<span class="cov8" title="1">
                        currentValue = metrics.OrphanRecordCount
                        triggered = currentValue &gt; rule.Threshold</span>
                case "HEALTH_SCORE":<span class="cov8" title="1">
                        currentValue = int(metrics.HealthScore)
                        triggered = currentValue &lt; rule.Threshold</span>
                }

                <span class="cov8" title="1">if triggered </span><span class="cov8" title="1">{
                        alertMsg := fmt.Sprintf("[%s] %s: 当前值=%d, 阈值=%d",
                                rule.AlertLevel, rule.Description, currentValue, rule.Threshold)
                        alerts = append(alerts, alertMsg)
                }</span>
        }

        // 记录监控结果到审计日志（使用新的标准化审计系统）
        // 注释掉旧的审计代码，等待统一重构时一起处理
        // metricsJSON, _ := json.Marshal(metrics)
        //
        // 系统健康监控结果可以单独记录，不必强制写入操作审计表
        // 可考虑使用专门的监控日志表或改为应用日志记录
        <span class="cov8" title="1">if len(alerts) &gt; 0 </span><span class="cov8" title="1">{
                m.logger.Infof("监控结果: 健康分数=%.1f, 告警=%d个", metrics.HealthScore, len(alerts))
        }</span>

        <span class="cov8" title="1">return alerts, nil</span>
}

// GetMetricsHandler 获取监控指标的HTTP处理器函数
func (m *TemporalMonitor) GetMetricsHandler() func(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return m.CollectMetrics(ctx)
        }</span>
}

// StartPeriodicMonitoring 启动定期监控
func (m *TemporalMonitor) StartPeriodicMonitoring(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        go func() </span><span class="cov0" title="0">{
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                m.logger.Warn("停止时态数据监控服务")
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                alerts, err := m.CheckAlerts(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        m.logger.Errorf("监控检查失败: %v", err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">if len(alerts) &gt; 0 </span><span class="cov0" title="0">{
                                        m.logger.Warnf("发现 %d 个告警:", len(alerts))
                                        for _, alert := range alerts </span><span class="cov0" title="0">{
                                                m.logger.Warnf("告警详情: %s", alert)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        m.logger.Info("时态数据监控: 系统健康")
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">m.logger.Infof("时态数据监控服务已启动 (检查间隔: %v)", interval)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package scheduler

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/repository"
        "cube-castle/internal/organization/utils"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// TemporalService 时态管理服务
type TemporalService struct {
        db      *sql.DB
        orgRepo *repository.OrganizationRepository
        logger  pkglogger.Logger
}

// NewTemporalService 创建新的时态服务
func NewTemporalService(db *sql.DB, baseLogger pkglogger.Logger, orgRepo *repository.OrganizationRepository) *TemporalService <span class="cov0" title="0">{
        if baseLogger == nil </span><span class="cov0" title="0">{
                baseLogger = pkglogger.NewNoopLogger()
        }</span>
        <span class="cov0" title="0">if orgRepo == nil </span><span class="cov0" title="0">{
                orgRepo = repository.NewOrganizationRepository(db, baseLogger)
        }</span>
        <span class="cov0" title="0">return &amp;TemporalService{
                db:      db,
                orgRepo: orgRepo,
                logger:  scopedLogger(baseLogger, "temporal", pkglogger.Fields{"module": "organization"}),
        }</span>
}

// InsertVersionRequest 插入版本请求
type InsertVersionRequest struct {
        TenantID      uuid.UUID
        Code          string
        EffectiveDate time.Time
        Data          *OrganizationData
}

// OrganizationData 组织数据
type OrganizationData struct {
        Name            string
        UnitType        string
        Status          string
        ParentCode      *string
        SortOrder       int
        Description     string
        OperationType   string
        OperationReason string
}

// DeleteVersionRequest 删除版本请求
type DeleteVersionRequest struct {
        TenantID        uuid.UUID
        Code            string
        EffectiveDate   time.Time
        OperationReason string
}

// ChangeEffectiveDateRequest 变更生效日期请求
type ChangeEffectiveDateRequest struct {
        TenantID         uuid.UUID
        Code             string
        OldEffectiveDate time.Time
        NewEffectiveDate time.Time
        UpdatedData      *OrganizationData
        OperationReason  string
}

// SuspendActivateRequest 停用/启用请求
type SuspendActivateRequest struct {
        TenantID        uuid.UUID
        Code            string
        TargetStatus    string // "ACTIVE" 或 "INACTIVE"
        OperationType   string // "SUSPEND" 或 "REACTIVATE"
        EffectiveDate   time.Time
        OperationReason string
}

// VersionResponse 版本操作响应
type VersionResponse struct {
        RecordID      string     `json:"recordId"`
        Code          string     `json:"code"`
        EffectiveDate time.Time  `json:"effectiveDate"`
        EndDate       *time.Time `json:"endDate,omitempty"`
        IsCurrent     bool       `json:"isCurrent"`
        Status        string     `json:"status"`
        Message       string     `json:"message"`
}

// InsertIntermediateVersion 插入中间版本
func (s *TemporalService) InsertIntermediateVersion(ctx context.Context, req *InsertVersionRequest) (*VersionResponse, error) <span class="cov0" title="0">{
        log := s.logger.WithFields(pkglogger.Fields{
                "tenantId":      req.TenantID.String(),
                "code":          req.Code,
                "effectiveDate": req.EffectiveDate.Format("2006-01-02"),
                "operation":     "insertIntermediate",
        })
        log.Info("接收到插入中间版本请求")

        result, err := s.withTransaction(ctx, func(tx *sql.Tx) (*VersionResponse, error) </span><span class="cov0" title="0">{
                // 1. 读取相邻版本并锁定
                prev, next, err := s.getAdjacentVersionsForUpdate(tx, req.TenantID, req.Code, req.EffectiveDate)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get adjacent versions: %w", err)
                }</span>

                // 2. 预检冲突
                <span class="cov0" title="0">if err := s.validateNonOverlapping(req.EffectiveDate, prev, next); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. 回填边界
                <span class="cov0" title="0">if prev != nil </span><span class="cov0" title="0">{
                        endDate := req.EffectiveDate.AddDate(0, 0, -1)
                        if err := s.updateEndDate(tx, prev.RecordID, &amp;endDate); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update end date for previous version: %w", err)
                        }</span>
                }

                // 4. 插入新版本
                <span class="cov0" title="0">newVersion, err := s.insertVersion(ctx, tx, &amp;insertVersionData{
                        TenantID:      req.TenantID,
                        Code:          req.Code,
                        EffectiveDate: req.EffectiveDate,
                        Data:          req.Data,
                        IsCurrent:     s.isCurrentEffectiveDate(req.EffectiveDate),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to insert new version: %w", err)
                }</span>

                // 5. 更新当前态标记
                <span class="cov0" title="0">if newVersion.IsCurrent &amp;&amp; prev != nil </span><span class="cov0" title="0">{
                        if err := s.updateCurrentFlag(tx, prev.RecordID, false); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update current flag for previous version: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return newVersion, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("插入中间版本失败: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{
                "recordId": result.RecordID,
        }).Info("插入中间版本成功")
        return result, nil</span>
}

// DeleteIntermediateVersion 删除中间版本
func (s *TemporalService) DeleteIntermediateVersion(ctx context.Context, req *DeleteVersionRequest) error <span class="cov0" title="0">{
        log := s.logger.WithFields(pkglogger.Fields{
                "tenantId":      req.TenantID.String(),
                "code":          req.Code,
                "effectiveDate": req.EffectiveDate.Format("2006-01-02"),
                "operation":     "deleteIntermediate",
        })
        log.Info("接收到删除中间版本请求")

        err := s.withTransactionNoReturn(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // 1. 读取相邻版本并锁定
                prev, next, err := s.getAdjacentVersionsForUpdate(tx, req.TenantID, req.Code, req.EffectiveDate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get adjacent versions: %w", err)
                }</span>

                // 2. 删除目标版本
                <span class="cov0" title="0">if err := s.deleteVersionByDate(tx, req.TenantID, req.Code, req.EffectiveDate); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete version: %w", err)
                }</span>

                // 3. 桥接相邻版本
                <span class="cov0" title="0">if prev != nil &amp;&amp; next != nil </span><span class="cov0" title="0">{
                        endDate := next.EffectiveDate.AddDate(0, 0, -1)
                        if err := s.updateEndDate(tx, prev.RecordID, &amp;endDate); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to bridge adjacent versions: %w", err)
                        }</span>
                }

                // 4. 重算整个时间线，确保末尾回写与当前态标记正确
                <span class="cov0" title="0">if err := s.recomputeTimelineInTx(tx, req.TenantID, req.Code); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to recompute timeline after delete: %w", err)
                }</span>

                // 5. 写入审计日志
                <span class="cov0" title="0">return s.writeTimelineEvent(tx, req.TenantID, req.Code, "DELETE", req.OperationReason)</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("删除中间版本失败: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Info("删除中间版本成功")
        return nil</span>
}

// ChangeEffectiveDate 变更生效日期
func (s *TemporalService) ChangeEffectiveDate(ctx context.Context, req *ChangeEffectiveDateRequest) (*VersionResponse, error) <span class="cov0" title="0">{
        log := s.logger.WithFields(pkglogger.Fields{
                "tenantId":         req.TenantID.String(),
                "code":             req.Code,
                "oldEffectiveDate": req.OldEffectiveDate.Format("2006-01-02"),
                "newEffectiveDate": req.NewEffectiveDate.Format("2006-01-02"),
                "operation":        "changeEffectiveDate",
        })
        log.Info("接收到变更生效日期请求")

        result, err := s.withTransaction(ctx, func(tx *sql.Tx) (*VersionResponse, error) </span><span class="cov0" title="0">{
                // 1. 预检新日期是否冲突
                if err := s.validateEffectiveDateAvailable(tx, req.TenantID, req.Code, req.NewEffectiveDate); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. 删除旧版本
                <span class="cov0" title="0">if err := s.deleteVersionByDate(tx, req.TenantID, req.Code, req.OldEffectiveDate); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to delete old version: %w", err)
                }</span>

                // 3. 插入新版本
                <span class="cov0" title="0">insertReq := &amp;InsertVersionRequest{
                        TenantID:      req.TenantID,
                        Code:          req.Code,
                        EffectiveDate: req.NewEffectiveDate,
                        Data:          req.UpdatedData,
                }

                result, err := s.insertIntermediateVersionInTx(ctx, tx, insertReq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 4. 写入时间线事件
                <span class="cov0" title="0">if err := s.writeTimelineEvent(tx, req.TenantID, req.Code, "UPDATE", req.OperationReason); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write timeline event: %w", err)
                }</span>

                <span class="cov0" title="0">return result, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("变更生效日期失败: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">log.WithFields(pkglogger.Fields{
                "recordId": result.RecordID,
        }).Info("变更生效日期成功")
        return result, nil</span>
}

// SuspendActivate 停用/启用操作
func (s *TemporalService) SuspendActivate(ctx context.Context, req *SuspendActivateRequest) (*VersionResponse, error) <span class="cov0" title="0">{
        return s.withTransaction(ctx, func(tx *sql.Tx) (*VersionResponse, error) </span><span class="cov0" title="0">{
                // 1. 幂等性检查
                currentStatus, err := s.getCurrentStatus(tx, req.TenantID, req.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get current status: %w", err)
                }</span>

                <span class="cov0" title="0">if currentStatus == req.TargetStatus </span><span class="cov0" title="0">{
                        // 幂等返回
                        return s.getCurrentVersion(tx, req.TenantID, req.Code), nil
                }</span>

                // 2. 创建状态变更版本
                <span class="cov0" title="0">newVersion, err := s.insertVersion(ctx, tx, &amp;insertVersionData{
                        TenantID:      req.TenantID,
                        Code:          req.Code,
                        EffectiveDate: req.EffectiveDate,
                        Data: &amp;OrganizationData{
                                Status:          req.TargetStatus,
                                OperationType:   req.OperationType,
                                OperationReason: req.OperationReason,
                        },
                        IsCurrent: s.isCurrentEffectiveDate(req.EffectiveDate),
                        IsFuture:  req.EffectiveDate.After(time.Now().UTC()),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to insert status change version: %w", err)
                }</span>

                <span class="cov0" title="0">return newVersion, nil</span>
        })
}

// 辅助方法和内部类型定义

type versionData struct {
        RecordID      string
        EffectiveDate time.Time
        EndDate       *time.Time
        IsCurrent     bool
        Status        string
}

type insertVersionData struct {
        TenantID      uuid.UUID
        Code          string
        EffectiveDate time.Time
        Data          *OrganizationData
        IsCurrent     bool
        IsFuture      bool
}

// withTransaction 事务包装器
func (s *TemporalService) withTransaction(ctx context.Context, fn func(*sql.Tx) (*VersionResponse, error)) (*VersionResponse, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        result, err := fn(tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// withTransactionNoReturn 无返回值事务包装器
func (s *TemporalService) withTransactionNoReturn(ctx context.Context, fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getAdjacentVersionsForUpdate 获取相邻版本并锁定
func (s *TemporalService) getAdjacentVersionsForUpdate(tx *sql.Tx, tenantID uuid.UUID, code string, effectiveDate time.Time) (*versionData, *versionData, error) <span class="cov0" title="0">{
        // 获取前一版本
        var prev *versionData
        query := `
        SELECT record_id, effective_date, end_date, is_current, status 
        FROM organization_units 
        WHERE tenant_id = $1 AND code = $2 AND effective_date &lt; $3 
          AND status &lt;&gt; 'DELETED'
        ORDER BY effective_date DESC 
        LIMIT 1 
        FOR UPDATE
    `
        row := tx.QueryRow(query, tenantID, code, effectiveDate)
        var p versionData
        var endDate sql.NullTime
        err := row.Scan(&amp;p.RecordID, &amp;p.EffectiveDate, &amp;endDate, &amp;p.IsCurrent, &amp;p.Status)
        if err == nil </span><span class="cov0" title="0">{
                if endDate.Valid </span><span class="cov0" title="0">{
                        p.EndDate = &amp;endDate.Time
                }</span>
                <span class="cov0" title="0">prev = &amp;p</span>
        } else<span class="cov0" title="0"> if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get previous version: %w", err)
        }</span>

        // 获取后一版本
        <span class="cov0" title="0">var next *versionData
        query = `
        SELECT record_id, effective_date, end_date, is_current, status 
        FROM organization_units 
        WHERE tenant_id = $1 AND code = $2 AND effective_date &gt; $3 
          AND status &lt;&gt; 'DELETED'
        ORDER BY effective_date ASC 
        LIMIT 1 
        FOR UPDATE
    `
        row = tx.QueryRow(query, tenantID, code, effectiveDate)
        var n versionData
        err = row.Scan(&amp;n.RecordID, &amp;n.EffectiveDate, &amp;endDate, &amp;n.IsCurrent, &amp;n.Status)
        if err == nil </span><span class="cov0" title="0">{
                if endDate.Valid </span><span class="cov0" title="0">{
                        n.EndDate = &amp;endDate.Time
                }</span>
                <span class="cov0" title="0">next = &amp;n</span>
        } else<span class="cov0" title="0"> if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get next version: %w", err)
        }</span>

        <span class="cov0" title="0">return prev, next, nil</span>
}

// validateNonOverlapping 验证非重叠
func (s *TemporalService) validateNonOverlapping(effectiveDate time.Time, prev, next *versionData) error <span class="cov0" title="0">{
        // 检查是否存在相同时间点
        if prev != nil &amp;&amp; prev.EffectiveDate.Equal(effectiveDate) </span><span class="cov0" title="0">{
                return fmt.Errorf("TEMPORAL_POINT_CONFLICT: effective date %v already exists", effectiveDate.Format("2006-01-02"))
        }</span>

        // 检查与后一版本是否重叠
        <span class="cov0" title="0">if next != nil &amp;&amp; !effectiveDate.Before(next.EffectiveDate) </span><span class="cov0" title="0">{
                return fmt.Errorf("TEMPORAL_OVERLAP_CONFLICT: effective date %v overlaps with next version starting %v",
                        effectiveDate.Format("2006-01-02"), next.EffectiveDate.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isCurrentEffectiveDate 判断是否为当前生效日期
func (s *TemporalService) isCurrentEffectiveDate(effectiveDate time.Time) bool <span class="cov0" title="0">{
        today := time.Now().UTC().Truncate(24 * time.Hour)
        return !effectiveDate.After(today)
}</span>

// 其他辅助方法的存根实现（待完善）

func (s *TemporalService) updateEndDate(tx *sql.Tx, recordID string, endDate *time.Time) error <span class="cov0" title="0">{
        query := `UPDATE organization_units SET end_date = $1, updated_at = NOW() WHERE record_id = $2 AND status &lt;&gt; 'DELETED'`
        _, err := tx.Exec(query, endDate, recordID)
        return err
}</span>

// RepairTimelineAfterSoftDelete 在软删除某个版本后，修复其相邻版本的时间边界
// 基本策略：
// - 查找被删除版本的前后相邻（忽略已删除记录）；
// - 若同时存在前后相邻，则把前一条的 end_date 回填为 后一条.effective_date - 1 天；
// - 若不存在后一条（删除的是末尾版本），则将前一条的 end_date 置为 NULL，并标记为当前态；
// - 若不存在前一条（删除的是首条），不需要处理（由后一条成为首条）。
func (s *TemporalService) RepairTimelineAfterSoftDelete(ctx context.Context, tenantID uuid.UUID, code string, deletedEffectiveDate time.Time) error <span class="cov0" title="0">{
        return s.withTransactionNoReturn(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                prev, next, err := s.getAdjacentVersionsForUpdate(tx, tenantID, code, deletedEffectiveDate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get adjacent versions for repair: %w", err)
                }</span>

                // 没有前一条，无需修复（由后一条自然成为首条）
                <span class="cov0" title="0">if prev == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if next != nil </span><span class="cov0" title="0">{
                        // 存在前后相邻：桥接
                        endDate := next.EffectiveDate.AddDate(0, 0, -1)
                        if err := s.updateEndDate(tx, prev.RecordID, &amp;endDate); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to bridge previous end_date: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // 删除的是最后一个版本：前一条成为最后一条，清除其 end_date 并置为当前
                <span class="cov0" title="0">if err := s.updateEndDate(tx, prev.RecordID, nil); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear end_date for tail repair: %w", err)
                }</span>
                <span class="cov0" title="0">if err := s.updateCurrentFlag(tx, prev.RecordID, true); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set previous as current after tail repair: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

func (s *TemporalService) updateCurrentFlag(tx *sql.Tx, recordID string, isCurrent bool) error <span class="cov0" title="0">{
        query := `UPDATE organization_units SET is_current = $1, updated_at = NOW() WHERE record_id = $2 AND status &lt;&gt; 'DELETED'`
        _, err := tx.Exec(query, isCurrent, recordID)
        return err
}</span>

// recomputeTimelineInTx 重新计算整个时间线的 end_date 与 is_current
func (s *TemporalService) recomputeTimelineInTx(tx *sql.Tx, tenantID uuid.UUID, code string) error <span class="cov0" title="0">{
        // 读取该组织的全部非删除版本并加锁
        query := `
        SELECT record_id, effective_date
        FROM organization_units
        WHERE tenant_id = $1 AND code = $2
          AND status &lt;&gt; 'DELETED'
        ORDER BY effective_date ASC
        FOR UPDATE
    `
        rows, err := tx.Query(query, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load versions for recompute: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        type vrow struct {
                id  string
                eff time.Time
        }
        var versions []vrow
        for rows.Next() </span><span class="cov0" title="0">{
                var r vrow
                if err := rows.Scan(&amp;r.id, &amp;r.eff); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan version row: %w", err)
                }</span>
                <span class="cov0" title="0">versions = append(versions, r)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("row iteration error: %w", err)
        }</span>

        // 依次回填 end_date
        <span class="cov0" title="0">for i := 0; i &lt; len(versions); i++ </span><span class="cov0" title="0">{
                var newEnd *time.Time
                if i+1 &lt; len(versions) </span><span class="cov0" title="0">{
                        d := versions[i+1].eff.AddDate(0, 0, -1)
                        newEnd = &amp;d
                }</span> else<span class="cov0" title="0"> {
                        // 最后一条开放结束
                        newEnd = nil
                }</span>
                <span class="cov0" title="0">if err := s.updateEndDate(tx, versions[i].id, newEnd); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update end_date in recompute: %w", err)
                }</span>
        }

        // 重算 is_current：最后一条有效期 &lt;= 今天 的那条为当前
        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        currentIndex := -1
        for i := 0; i &lt; len(versions); i++ </span><span class="cov0" title="0">{
                if !versions[i].eff.After(today) </span><span class="cov0" title="0">{
                        currentIndex = i
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        // 清空所有当前标记（必须包含已删除记录，避免遗留的 is_current=true 导致唯一索引冲突）
        <span class="cov0" title="0">if _, err := tx.Exec(`UPDATE organization_units SET is_current = false, updated_at = NOW() WHERE tenant_id = $1 AND code = $2`, tenantID, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear current flags: %w", err)
        }</span>
        <span class="cov0" title="0">if currentIndex &gt;= 0 </span><span class="cov0" title="0">{
                if err := s.updateCurrentFlag(tx, versions[currentIndex].id, true); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set current flag: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RecomputeTimelineForCode 对单个组织代码执行完整时间线重算（公开方法）
func (s *TemporalService) RecomputeTimelineForCode(ctx context.Context, tenantID uuid.UUID, code string) error <span class="cov0" title="0">{
        return s.withTransactionNoReturn(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                return s.recomputeTimelineInTx(tx, tenantID, code)
        }</span>)
}

// RecomputeAllForTenant 对某个租户的所有组织执行时间线重算
func (s *TemporalService) RecomputeAllForTenant(ctx context.Context, tenantID uuid.UUID) (int, error) <span class="cov0" title="0">{
        // 查询该租户下存在的组织代码（至少有一条未删除记录）
        query := `
        SELECT DISTINCT code
        FROM organization_units
        WHERE tenant_id = $1
          AND status &lt;&gt; 'DELETED'
    `
        rows, err := s.db.QueryContext(ctx, query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to list codes for tenant: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var codes []string
        for rows.Next() </span><span class="cov0" title="0">{
                var code string
                if err := rows.Scan(&amp;code); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("scan code failed: %w", err)
                }</span>
                <span class="cov0" title="0">codes = append(codes, code)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("iterate codes failed: %w", err)
        }</span>

        <span class="cov0" title="0">count := 0
        for _, code := range codes </span><span class="cov0" title="0">{
                if err := s.RecomputeTimelineForCode(ctx, tenantID, code); err != nil </span><span class="cov0" title="0">{
                        return count, fmt.Errorf("recompute failed for code %s: %w", code, err)
                }</span>
                <span class="cov0" title="0">count++</span>
        }
        <span class="cov0" title="0">return count, nil</span>
}

// RecomputeAllTimelines 对全库所有租户的所有组织执行时间线重算
func (s *TemporalService) RecomputeAllTimelines(ctx context.Context) (int, error) <span class="cov0" title="0">{
        // 列出所有 (tenant_id, code) 去重，限定非删除记录
        query := `
        SELECT DISTINCT tenant_id, code
        FROM organization_units
        WHERE status &lt;&gt; 'DELETED'
    `
        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to list all tenant codes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        type pair struct {
                tenant uuid.UUID
                code   string
        }
        var pairs []pair
        for rows.Next() </span><span class="cov0" title="0">{
                var t uuid.UUID
                var c string
                if err := rows.Scan(&amp;t, &amp;c); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("scan pair failed: %w", err)
                }</span>
                <span class="cov0" title="0">pairs = append(pairs, pair{tenant: t, code: c})</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("iterate pairs failed: %w", err)
        }</span>

        <span class="cov0" title="0">count := 0
        for _, p := range pairs </span><span class="cov0" title="0">{
                if err := s.RecomputeTimelineForCode(ctx, p.tenant, p.code); err != nil </span><span class="cov0" title="0">{
                        return count, fmt.Errorf("recompute failed for %s/%s: %w", p.tenant, p.code, err)
                }</span>
                <span class="cov0" title="0">count++</span>
        }
        <span class="cov0" title="0">return count, nil</span>
}

type orgSnapshot struct {
        Name        string
        UnitType    string
        Status      string
        ParentCode  *string
        SortOrder   int
        Description string
}

func (s *TemporalService) loadLatestSnapshot(tx *sql.Tx, tenantID uuid.UUID, code string) (*orgSnapshot, error) <span class="cov0" title="0">{
        query := `
                SELECT name, unit_type, status, parent_code, sort_order, description
                FROM organization_units
                WHERE tenant_id = $1 AND code = $2 AND status &lt;&gt; 'DELETED'
                ORDER BY effective_date DESC
                LIMIT 1
        `

        var snap orgSnapshot
        var parent sql.NullString
        var sortOrder sql.NullInt64
        var description sql.NullString

        err := tx.QueryRow(query, tenantID, code).Scan(&amp;snap.Name, &amp;snap.UnitType, &amp;snap.Status, &amp;parent, &amp;sortOrder, &amp;description)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load existing organization snapshot: %w", err)</span>
        }

        <span class="cov0" title="0">if parent.Valid </span><span class="cov0" title="0">{
                value := parent.String
                snap.ParentCode = &amp;value
        }</span>
        <span class="cov0" title="0">if sortOrder.Valid </span><span class="cov0" title="0">{
                snap.SortOrder = int(sortOrder.Int64)
        }</span>
        <span class="cov0" title="0">if description.Valid </span><span class="cov0" title="0">{
                snap.Description = description.String
        }</span>

        <span class="cov0" title="0">return &amp;snap, nil</span>
}

func (s *TemporalService) insertVersion(ctx context.Context, tx *sql.Tx, data *insertVersionData) (*VersionResponse, error) <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insertVersion: missing insert data")
        }</span>

        <span class="cov0" title="0">payload := data.Data
        if payload == nil </span><span class="cov0" title="0">{
                payload = &amp;OrganizationData{}
        }</span>

        <span class="cov0" title="0">snapshot, err := s.loadLatestSnapshot(tx, data.TenantID, data.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">finalName := strings.TrimSpace(payload.Name)
        if finalName == "" &amp;&amp; snapshot != nil </span><span class="cov0" title="0">{
                finalName = strings.TrimSpace(snapshot.Name)
        }</span>
        <span class="cov0" title="0">if finalName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing organization name for temporal version")
        }</span>

        <span class="cov0" title="0">finalUnitType := strings.TrimSpace(payload.UnitType)
        if finalUnitType == "" &amp;&amp; snapshot != nil </span><span class="cov0" title="0">{
                finalUnitType = snapshot.UnitType
        }</span>
        <span class="cov0" title="0">if finalUnitType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing unit type for temporal version")
        }</span>

        <span class="cov0" title="0">finalStatus := strings.TrimSpace(payload.Status)
        if finalStatus == "" </span><span class="cov0" title="0">{
                if snapshot != nil &amp;&amp; snapshot.Status != "" </span><span class="cov0" title="0">{
                        finalStatus = snapshot.Status
                }</span> else<span class="cov0" title="0"> {
                        finalStatus = "ACTIVE"
                }</span>
        }

        <span class="cov0" title="0">var parentCode *string
        if payload.ParentCode != nil </span><span class="cov0" title="0">{
                parentCode = utils.NormalizeParentCodePointer(payload.ParentCode)
        }</span> else<span class="cov0" title="0"> if snapshot != nil &amp;&amp; snapshot.ParentCode != nil </span><span class="cov0" title="0">{
                parentCode = utils.NormalizeParentCodePointer(snapshot.ParentCode)
        }</span>

        <span class="cov0" title="0">finalSortOrder := payload.SortOrder
        if data.Data == nil &amp;&amp; snapshot != nil </span><span class="cov0" title="0">{
                finalSortOrder = snapshot.SortOrder
        }</span>

        <span class="cov0" title="0">finalDescription := payload.Description
        if data.Data == nil &amp;&amp; snapshot != nil </span><span class="cov0" title="0">{
                finalDescription = snapshot.Description
        }</span>

        <span class="cov0" title="0">fields, calcErr := s.orgRepo.ComputeHierarchyForNew(ctx, data.TenantID, data.Code, parentCode, finalName)
        if calcErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compute hierarchy fields: %w", calcErr)
        }</span>

        <span class="cov0" title="0">recordID := uuid.New().String()

        query := `
                INSERT INTO organization_units (
                        record_id, tenant_id, code, effective_date, end_date, is_current,
                        status, name, unit_type, parent_code, level, code_path, name_path,
                        sort_order, description, change_reason, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW(), NOW())
        `

        changeReason := strings.TrimSpace(payload.OperationReason)

        _, err = tx.Exec(query,
                recordID, data.TenantID, data.Code, data.EffectiveDate, nil, data.IsCurrent,
                finalStatus, finalName, finalUnitType, parentCode, fields.Level, fields.CodePath, fields.NamePath,
                finalSortOrder, finalDescription, changeReason,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;VersionResponse{
                RecordID:      recordID,
                Code:          data.Code,
                EffectiveDate: data.EffectiveDate,
                IsCurrent:     data.IsCurrent,
                Status:        finalStatus,
                Message:       "Version inserted successfully",
        }, nil</span>
}

func (s *TemporalService) deleteVersionByDate(tx *sql.Tx, tenantID uuid.UUID, code string, effectiveDate time.Time) error <span class="cov0" title="0">{
        query := `DELETE FROM organization_units WHERE tenant_id = $1 AND code = $2 AND effective_date = $3 AND status &lt;&gt; 'DELETED'`
        _, err := tx.Exec(query, tenantID, code, effectiveDate)
        return err
}</span>

func (s *TemporalService) validateEffectiveDateAvailable(tx *sql.Tx, tenantID uuid.UUID, code string, effectiveDate time.Time) error <span class="cov0" title="0">{
        var count int
        query := `SELECT COUNT(*) FROM organization_units WHERE tenant_id = $1 AND code = $2 AND effective_date = $3 AND status &lt;&gt; 'DELETED'`
        err := tx.QueryRow(query, tenantID, code, effectiveDate).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("TEMPORAL_POINT_CONFLICT: effective date %v already exists", effectiveDate.Format("2006-01-02"))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *TemporalService) getCurrentStatus(tx *sql.Tx, tenantID uuid.UUID, code string) (string, error) <span class="cov0" title="0">{
        var status string
        query := `SELECT status FROM organization_units WHERE tenant_id = $1 AND code = $2 AND is_current = true AND status &lt;&gt; 'DELETED'`
        err := tx.QueryRow(query, tenantID, code).Scan(&amp;status)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return status, nil</span>
}

func (s *TemporalService) getCurrentVersion(tx *sql.Tx, tenantID uuid.UUID, code string) *VersionResponse <span class="cov0" title="0">{
        // 简化实现 - 返回基本信息
        return &amp;VersionResponse{
                Code:    code,
                Status:  "ACTIVE", // 简化
                Message: "Current version returned",
        }
}</span>

func (s *TemporalService) insertIntermediateVersionInTx(ctx context.Context, tx *sql.Tx, req *InsertVersionRequest) (*VersionResponse, error) <span class="cov0" title="0">{
        // 复用事务内的插入逻辑
        return s.insertVersion(ctx, tx, &amp;insertVersionData{
                TenantID:      req.TenantID,
                Code:          req.Code,
                EffectiveDate: req.EffectiveDate,
                Data:          req.Data,
                IsCurrent:     s.isCurrentEffectiveDate(req.EffectiveDate),
        })
}</span>

func (s *TemporalService) writeTimelineEvent(tx *sql.Tx, tenantID uuid.UUID, code, operationType, reason string) error <span class="cov0" title="0">{
        // 简化实现 - 写入审计日志
        // 这里可以扩展为完整的时间线事件记录
        return nil
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package service

import (
        "context"
        "fmt"
        "sync"
        "time"

        "cube-castle/internal/organization/repository"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// CascadeUpdateService 异步级联更新服务
type CascadeUpdateService struct {
        hierarchyRepo *repository.HierarchyRepository
        taskQueue     chan CascadeTask
        workers       int
        logger        pkglogger.Logger
        wg            sync.WaitGroup
        shutdown      chan struct{}
        running       bool
        mu            sync.RWMutex
}

// CascadeTask 级联任务
type CascadeTask struct {
        Type      string    `json:"type"`
        Code      string    `json:"code"`
        TenantID  uuid.UUID `json:"tenantId"`
        UserID    string    `json:"userId"`
        Context   context.Context
        Timestamp time.Time `json:"timestamp"`
        Priority  int       `json:"priority"` // 1=高优先级, 2=中优先级, 3=低优先级
}

// 任务类型常量
const (
        TaskTypeUpdateHierarchy = "UPDATE_HIERARCHY"
        TaskTypeUpdatePaths     = "UPDATE_PATHS"
        TaskTypeUpdateStatus    = "UPDATE_STATUS"
        TaskTypeValidateRules   = "VALIDATE_RULES"
)

func NewCascadeUpdateService(hierarchyRepo *repository.HierarchyRepository, workers int, baseLogger pkglogger.Logger) *CascadeUpdateService <span class="cov0" title="0">{
        if workers &lt;= 0 </span><span class="cov0" title="0">{
                workers = 4 // 默认4个工作协程
        }</span>

        <span class="cov0" title="0">service := &amp;CascadeUpdateService{
                hierarchyRepo: hierarchyRepo,
                taskQueue:     make(chan CascadeTask, 1000), // 任务队列缓冲区
                workers:       workers,
                logger:        scopedLogger(baseLogger, "cascadeUpdate", nil),
                shutdown:      make(chan struct{}),
                running:       false,
        }

        return service</span>
}

// Start 启动级联更新服务
func (c *CascadeUpdateService) Start() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.running </span><span class="cov0" title="0">{
                c.logger.Warn("级联更新服务已在运行")
                return
        }</span>

        <span class="cov0" title="0">c.running = true
        c.logger.Infof("启动级联更新服务，工作协程数: %d", c.workers)

        // 启动工作协程池
        for i := 0; i &lt; c.workers; i++ </span><span class="cov0" title="0">{
                c.wg.Add(1)
                go c.worker(i)
        }</span>
}

// Stop 停止级联更新服务
func (c *CascadeUpdateService) Stop() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if !c.running </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">c.logger.Warn("正在停止级联更新服务...")
        c.running = false
        close(c.shutdown)
        close(c.taskQueue)

        c.wg.Wait()
        c.logger.Info("级联更新服务已停止")</span>
}

// worker 工作协程
func (c *CascadeUpdateService) worker(workerID int) <span class="cov0" title="0">{
        defer c.wg.Done()

        c.logger.Infof("工作协程 %d 已启动", workerID)

        for </span><span class="cov0" title="0">{
                select </span>{
                case task, ok := &lt;-c.taskQueue:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                c.logger.Infof("工作协程 %d 退出 (任务队列已关闭)", workerID)
                                return
                        }</span>
                        <span class="cov0" title="0">c.processTask(workerID, task)</span>

                case &lt;-c.shutdown:<span class="cov0" title="0">
                        c.logger.Infof("工作协程 %d 退出 (收到停止信号)", workerID)
                        return</span>
                }
        }
}

// processTask 处理任务
func (c *CascadeUpdateService) processTask(workerID int, task CascadeTask) <span class="cov0" title="0">{
        start := time.Now()
        c.logger.Debugf("工作协程 %d 开始处理任务: %s (组织: %s, 优先级: %d)",
                workerID, task.Type, task.Code, task.Priority)

        var err error
        switch task.Type </span>{
        case TaskTypeUpdateHierarchy:<span class="cov0" title="0">
                err = c.processHierarchyUpdate(task)</span>
        case TaskTypeUpdatePaths:<span class="cov0" title="0">
                err = c.processPathUpdate(task)</span>
        case TaskTypeUpdateStatus:<span class="cov0" title="0">
                err = c.processStatusUpdate(task)</span>
        case TaskTypeValidateRules:<span class="cov0" title="0">
                err = c.processValidateRules(task)</span>
        default:<span class="cov0" title="0">
                c.logger.Warnf("未知任务类型: %s", task.Type)
                return</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Errorf("工作协程 %d 任务处理失败: %s (组织: %s, 耗时: %v, 错误: %v)",
                        workerID, task.Type, task.Code, duration, err)
        }</span> else<span class="cov0" title="0"> {
                c.logger.Infof("工作协程 %d 任务处理成功: %s (组织: %s, 耗时: %v)",
                        workerID, task.Type, task.Code, duration)
        }</span>
}

// processHierarchyUpdate 处理层级结构更新
func (c *CascadeUpdateService) processHierarchyUpdate(task CascadeTask) error <span class="cov0" title="0">{
        ctx := task.Context
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // 获取所有直接子组织
        <span class="cov0" title="0">children, err := c.hierarchyRepo.GetDirectChildren(ctx, task.Code, task.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取子组织失败: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Infof("层级更新: 组织 %s 有 %d 个直接子组织", task.Code, len(children))

        // 更新路径信息
        err = c.hierarchyRepo.UpdateHierarchyPaths(ctx, task.Code, task.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("更新层级路径失败: %w", err)
        }</span>

        // 为每个子组织调度路径更新任务
        <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                childTask := CascadeTask{
                        Type:      TaskTypeUpdatePaths,
                        Code:      child.Code,
                        TenantID:  task.TenantID,
                        UserID:    task.UserID,
                        Context:   ctx,
                        Timestamp: time.Now(),
                        Priority:  task.Priority + 1, // 子任务优先级递减
                }

                // 异步调度子任务
                go c.ScheduleTask(childTask)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processPathUpdate 处理路径更新
func (c *CascadeUpdateService) processPathUpdate(task CascadeTask) error <span class="cov0" title="0">{
        ctx := task.Context
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // 更新当前组织的路径
        <span class="cov0" title="0">err := c.hierarchyRepo.UpdateHierarchyPaths(ctx, task.Code, task.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("更新路径失败: %w", err)
        }</span>

        // 检查是否有子组织需要继续级联更新
        <span class="cov0" title="0">children, err := c.hierarchyRepo.GetDirectChildren(ctx, task.Code, task.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("检查子组织失败: %w", err)
        }</span>

        // 为每个子组织继续调度更新任务
        <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                if task.Priority &lt; 5 </span><span class="cov0" title="0">{ // 限制递归深度，防止无限循环
                        childTask := CascadeTask{
                                Type:      TaskTypeUpdatePaths,
                                Code:      child.Code,
                                TenantID:  task.TenantID,
                                UserID:    task.UserID,
                                Context:   ctx,
                                Timestamp: time.Now(),
                                Priority:  task.Priority + 1,
                        }
                        go c.ScheduleTask(childTask)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// processStatusUpdate 处理状态更新级联
func (c *CascadeUpdateService) processStatusUpdate(task CascadeTask) error <span class="cov0" title="0">{
        ctx := task.Context
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // 获取组织当前状态
        <span class="cov0" title="0">org, err := c.hierarchyRepo.GetOrganization(ctx, task.Code, task.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取组织状态失败: %w", err)
        }</span>

        // 如果是停用状态，需要检查对子组织的影响
        <span class="cov0" title="0">if org.Status == "INACTIVE" </span><span class="cov0" title="0">{
                children, err := c.hierarchyRepo.GetDirectChildren(ctx, task.Code, task.TenantID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("获取子组织失败: %w", err)
                }</span>

                <span class="cov0" title="0">c.logger.Infof("状态级联检查: 组织 %s 状态为 %s, 影响 %d 个子组织",
                        task.Code, org.Status, len(children))

                // 这里可以实现具体的状态级联逻辑
                // 例如：父组织停用时，是否自动停用子组织
                for _, child := range children </span><span class="cov0" title="0">{
                        c.logger.Warnf("子组织 %s 受父组织状态变化影响", child.Code)
                        // 可以在这里实现具体的业务逻辑
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// processValidateRules 处理业务规则验证
func (c *CascadeUpdateService) processValidateRules(task CascadeTask) error <span class="cov0" title="0">{
        ctx := task.Context
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // 获取组织层级信息
        <span class="cov0" title="0">hierarchy, err := c.hierarchyRepo.GetOrganizationHierarchy(ctx, task.Code, task.TenantID, 17)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取层级结构失败: %w", err)
        }</span>

        // 验证层级深度
        <span class="cov0" title="0">maxDepth := 0
        for _, node := range hierarchy </span><span class="cov0" title="0">{
                if node.Depth &gt; maxDepth </span><span class="cov0" title="0">{
                        maxDepth = node.Depth
                }</span>
        }

        <span class="cov0" title="0">if maxDepth &gt; 17 </span><span class="cov0" title="0">{
                c.logger.Warnf("业务规则违规: 组织 %s 层级深度 %d 超过限制 (17级)", task.Code, maxDepth)
                // 这里可以实现具体的违规处理逻辑
        }</span>

        // 检查循环引用 (通过祖先链长度判断)
        <span class="cov0" title="0">ancestors, err := c.hierarchyRepo.GetAncestorChain(ctx, task.Code, task.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取祖先链失败: %w", err)
        }</span>

        <span class="cov0" title="0">if len(ancestors) &gt; 20 </span><span class="cov0" title="0">{ // 异常长度的祖先链可能表示循环引用
                c.logger.Warnf("可能的循环引用: 组织 %s 祖先链长度 %d", task.Code, len(ancestors))
        }</span>

        <span class="cov0" title="0">c.logger.Infof("业务规则验证完成: 组织 %s, 层级深度 %d, 祖先链长度 %d",
                task.Code, maxDepth, len(ancestors))

        return nil</span>
}

// ScheduleTask 调度任务
func (c *CascadeUpdateService) ScheduleTask(task CascadeTask) bool <span class="cov0" title="0">{
        c.mu.RLock()
        running := c.running
        c.mu.RUnlock()

        if !running </span><span class="cov0" title="0">{
                c.logger.Warnf("级联更新服务未运行，任务被丢弃: %s (组织: %s)", task.Type, task.Code)
                return false
        }</span>

        <span class="cov0" title="0">select </span>{
        case c.taskQueue &lt;- task:<span class="cov0" title="0">
                c.logger.Infof("任务已调度: %s (组织: %s, 优先级: %d)", task.Type, task.Code, task.Priority)
                return true</span>
        default:<span class="cov0" title="0">
                c.logger.Warnf("任务队列已满，任务被丢弃: %s (组织: %s)", task.Type, task.Code)
                return false</span>
        }
}

// ScheduleHierarchyUpdate 调度层级更新任务 (便捷方法)
func (c *CascadeUpdateService) ScheduleHierarchyUpdate(code string, tenantID uuid.UUID, userID string, ctx context.Context) bool <span class="cov0" title="0">{
        task := CascadeTask{
                Type:      TaskTypeUpdateHierarchy,
                Code:      code,
                TenantID:  tenantID,
                UserID:    userID,
                Context:   ctx,
                Timestamp: time.Now(),
                Priority:  1, // 高优先级
        }

        return c.ScheduleTask(task)
}</span>

// SchedulePathUpdate 调度路径更新任务 (便捷方法)
func (c *CascadeUpdateService) SchedulePathUpdate(code string, tenantID uuid.UUID, userID string, ctx context.Context) bool <span class="cov0" title="0">{
        task := CascadeTask{
                Type:      TaskTypeUpdatePaths,
                Code:      code,
                TenantID:  tenantID,
                UserID:    userID,
                Context:   ctx,
                Timestamp: time.Now(),
                Priority:  2, // 中优先级
        }

        return c.ScheduleTask(task)
}</span>

// ScheduleStatusUpdate 调度状态更新任务 (便捷方法)
func (c *CascadeUpdateService) ScheduleStatusUpdate(code string, tenantID uuid.UUID, userID string, ctx context.Context) bool <span class="cov0" title="0">{
        task := CascadeTask{
                Type:      TaskTypeUpdateStatus,
                Code:      code,
                TenantID:  tenantID,
                UserID:    userID,
                Context:   ctx,
                Timestamp: time.Now(),
                Priority:  2, // 中优先级
        }

        return c.ScheduleTask(task)
}</span>

// GetQueueStats 获取队列统计信息
func (c *CascadeUpdateService) GetQueueStats() (queueSize int, workers int, running bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.taskQueue), c.workers, c.running
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package service

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/events"
        orgmiddleware "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/repository"
        validator "cube-castle/internal/organization/validator"
        "cube-castle/internal/types"
        "cube-castle/pkg/database"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
        "github.com/lib/pq"
)

var (
        ErrJobCatalogParentMissing      = errors.New("job catalog parent not found")
        ErrJobCatalogInvalidInput       = errors.New("job catalog input invalid")
        ErrJobCatalogConflict           = errors.New("job catalog conflict")
        ErrJobCatalogPreconditionFailed = errors.New("job catalog precondition failed")
)

const jobCatalogDateLayout = "2006-01-02"

type JobCatalogService struct {
        repo        *repository.JobCatalogRepository
        validator   validator.JobCatalogValidationService
        auditLogger *audit.AuditLogger
        logger      pkglogger.Logger
        outboxRepo  database.OutboxRepository
}

func NewJobCatalogService(repo *repository.JobCatalogRepository, validatorService validator.JobCatalogValidationService, auditLogger *audit.AuditLogger, baseLogger pkglogger.Logger, outboxRepo database.OutboxRepository) *JobCatalogService <span class="cov0" title="0">{
        return &amp;JobCatalogService{
                repo:        repo,
                validator:   validatorService,
                auditLogger: auditLogger,
                logger:      scopedLogger(baseLogger, "jobCatalog", nil),
                outboxRepo:  outboxRepo,
        }
}</span>

func (s *JobCatalogService) validate(operation string, exec func(validator.JobCatalogValidationService) *validator.ValidationResult) error <span class="cov0" title="0">{
        if exec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if s.validator == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := exec(s.validator)
        if result == nil || result.Valid </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return validator.NewValidationFailedError(operation, result)</span>
}

func (s *JobCatalogService) fallbackValidationError(operation, code string, result *validator.ValidationResult, defaultMessage string) error <span class="cov8" title="1">{
        if result == nil </span><span class="cov8" title="1">{
                result = validator.NewValidationResult()
                result.Valid = false
        }</span>

        <span class="cov8" title="1">catalogCode := strings.ToUpper(strings.TrimSpace(code))
        if result.Context == nil </span><span class="cov0" title="0">{
                result.Context = map[string]interface{}{}
        }</span>
        <span class="cov8" title="1">if _, ok := result.Context["operation"]; !ok </span><span class="cov8" title="1">{
                result.Context["operation"] = operation
        }</span>
        <span class="cov8" title="1">result.Context["catalogCode"] = catalogCode
        if _, ok := result.Context["executedRules"]; !ok </span><span class="cov8" title="1">{
                result.Context["executedRules"] = []string{}
        }</span>

        <span class="cov8" title="1">if len(result.Errors) == 0 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, validator.ValidationError{
                        Code:     "JOB_CATALOG_TEMPORAL_CONFLICT",
                        Message:  defaultMessage,
                        Severity: string(validator.SeverityHigh),
                        Context: map[string]interface{}{
                                "ruleId":      "JC-TEMPORAL",
                                "catalogCode": catalogCode,
                        },
                })
        }</span>
        <span class="cov8" title="1">return validator.NewValidationFailedError(operation, result)</span>
}

func (s *JobCatalogService) translateJobCatalogError(ctx context.Context, tenantID uuid.UUID, code string, operation string, req *types.JobCatalogVersionRequest, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var pqErr *pq.Error
        if errors.As(err, &amp;pqErr) </span><span class="cov8" title="1">{
                switch pqErr.Code </span>{
                case "23505":<span class="cov8" title="1">
                        var result *validator.ValidationResult
                        if s.validator != nil </span><span class="cov8" title="1">{
                                switch operation </span>{
                                case "CreateJobFamilyGroupVersion":<span class="cov8" title="1">
                                        result = s.validator.ValidateCreateFamilyGroupVersion(ctx, tenantID, code, req)</span>
                                case "CreateJobFamilyVersion":<span class="cov0" title="0">
                                        parentID := uuid.Nil
                                        if req != nil &amp;&amp; req.ParentRecordID != nil </span><span class="cov0" title="0">{
                                                if parsed, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID)); parseErr == nil </span><span class="cov0" title="0">{
                                                        parentID = parsed
                                                }</span>
                                        }
                                        <span class="cov0" title="0">result = s.validator.ValidateCreateJobFamilyVersion(ctx, tenantID, code, req, parentID)</span>
                                case "CreateJobRoleVersion":<span class="cov0" title="0">
                                        parentID := uuid.Nil
                                        if req != nil &amp;&amp; req.ParentRecordID != nil </span><span class="cov0" title="0">{
                                                if parsed, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID)); parseErr == nil </span><span class="cov0" title="0">{
                                                        parentID = parsed
                                                }</span>
                                        }
                                        <span class="cov0" title="0">result = s.validator.ValidateCreateJobRoleVersion(ctx, tenantID, code, req, parentID)</span>
                                case "CreateJobLevelVersion":<span class="cov0" title="0">
                                        parentID := uuid.Nil
                                        if req != nil &amp;&amp; req.ParentRecordID != nil </span><span class="cov0" title="0">{
                                                if parsed, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID)); parseErr == nil </span><span class="cov0" title="0">{
                                                        parentID = parsed
                                                }</span>
                                        }
                                        <span class="cov0" title="0">result = s.validator.ValidateCreateJobLevelVersion(ctx, tenantID, code, req, parentID)</span>
                                }
                        }
                        <span class="cov8" title="1">return s.fallbackValidationError(operation, code, result, "Job catalog version already exists for effective date")</span>
                case "23503":<span class="cov0" title="0">
                        return ErrJobCatalogParentMissing</span>
                }
        }

        <span class="cov8" title="1">lower := strings.ToLower(err.Error())
        if strings.Contains(lower, "invalid effective date") </span><span class="cov8" title="1">{
                result := validator.NewValidationResult()
                result.Valid = false
                result.Context["operation"] = operation
                result.Context["catalogCode"] = strings.ToUpper(strings.TrimSpace(code))
                result.Context["executedRules"] = []string{"JC-TEMPORAL"}
                result.Errors = append(result.Errors, validator.ValidationError{
                        Code:     "INVALID_EFFECTIVE_DATE",
                        Message:  fmt.Sprintf("effectiveDate must follow format %s", jobCatalogDateLayout),
                        Field:    "effectiveDate",
                        Severity: string(validator.SeverityHigh),
                        Context: map[string]interface{}{
                                "ruleId":          "JC-TEMPORAL",
                                "catalogCode":     strings.ToUpper(strings.TrimSpace(code)),
                                "attemptedDate":   strings.TrimSpace(req.EffectiveDate),
                                "validationScope": "fallback",
                        },
                })
                return validator.NewValidationFailedError(operation, result)
        }</span>

        <span class="cov8" title="1">if strings.Contains(lower, "already exists for effective date") </span><span class="cov0" title="0">{
                var result *validator.ValidationResult
                if s.validator != nil </span><span class="cov0" title="0">{
                        switch operation </span>{
                        case "CreateJobFamilyGroupVersion":<span class="cov0" title="0">
                                result = s.validator.ValidateCreateFamilyGroupVersion(ctx, tenantID, code, req)</span>
                        case "CreateJobFamilyVersion":<span class="cov0" title="0">
                                // ParentRecordID mandatory for versions; reuse request value if present.
                                parentID := uuid.Nil
                                if req.ParentRecordID != nil </span><span class="cov0" title="0">{
                                        if parsed, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID)); parseErr == nil </span><span class="cov0" title="0">{
                                                parentID = parsed
                                        }</span>
                                }
                                <span class="cov0" title="0">result = s.validator.ValidateCreateJobFamilyVersion(ctx, tenantID, code, req, parentID)</span>
                        case "CreateJobRoleVersion":<span class="cov0" title="0">
                                parentID := uuid.Nil
                                if req.ParentRecordID != nil </span><span class="cov0" title="0">{
                                        if parsed, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID)); parseErr == nil </span><span class="cov0" title="0">{
                                                parentID = parsed
                                        }</span>
                                }
                                <span class="cov0" title="0">result = s.validator.ValidateCreateJobRoleVersion(ctx, tenantID, code, req, parentID)</span>
                        case "CreateJobLevelVersion":<span class="cov0" title="0">
                                parentID := uuid.Nil
                                if req.ParentRecordID != nil </span><span class="cov0" title="0">{
                                        if parsed, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID)); parseErr == nil </span><span class="cov0" title="0">{
                                                parentID = parsed
                                        }</span>
                                }
                                <span class="cov0" title="0">result = s.validator.ValidateCreateJobLevelVersion(ctx, tenantID, code, req, parentID)</span>
                        }
                }
                <span class="cov0" title="0">return s.fallbackValidationError(operation, code, result, "Job catalog version already exists for effective date")</span>
        }

        <span class="cov8" title="1">if strings.Contains(lower, "parent job family group not found") </span><span class="cov8" title="1">{
                return ErrJobCatalogParentMissing
        }</span>

        <span class="cov8" title="1">if strings.Contains(lower, "parent record mismatch") </span><span class="cov8" title="1">{
                result := validator.NewValidationResult()
                result.Valid = false
                result.Context["operation"] = operation
                result.Context["catalogCode"] = strings.ToUpper(strings.TrimSpace(code))
                result.Context["executedRules"] = []string{"JC-SEQUENCE"}
                provided := ""
                if req != nil &amp;&amp; req.ParentRecordID != nil </span><span class="cov8" title="1">{
                        provided = strings.TrimSpace(*req.ParentRecordID)
                }</span>
                <span class="cov8" title="1">result.Errors = append(result.Errors, validator.ValidationError{
                        Code:     "JOB_CATALOG_SEQUENCE_MISMATCH",
                        Message:  "parentRecordId must match latest version record",
                        Field:    "parentRecordId",
                        Severity: string(validator.SeverityHigh),
                        Context: map[string]interface{}{
                                "ruleId":             "JC-SEQUENCE",
                                "catalogCode":        strings.ToUpper(strings.TrimSpace(code)),
                                "providedParentId":   provided,
                                "validationScope":    "fallback",
                                "validationFallback": true,
                        },
                })
                return validator.NewValidationFailedError(operation, result)</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (s *JobCatalogService) CreateJobFamilyGroup(ctx context.Context, tenantID uuid.UUID, req *types.CreateJobFamilyGroupRequest, operator types.OperatedByInfo) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        entity, err := s.repo.InsertFamilyGroup(ctx, tx, tenantID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobFamilyGroup", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobFamilyGroupVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, operator types.OperatedByInfo) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        if err := s.validate("CreateJobFamilyGroupVersion", func(v validator.JobCatalogValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCreateFamilyGroupVersion(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        entity, err := s.repo.InsertFamilyGroupVersion(ctx, tx, tenantID, code, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.translateJobCatalogError(ctx, tenantID, code, "CreateJobFamilyGroupVersion", req, err)
        }</span>
        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobFamilyGroupVersion", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobFamily(ctx context.Context, tenantID uuid.UUID, req *types.CreateJobFamilyRequest, operator types.OperatedByInfo) (*types.JobFamily, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        parent, err := s.repo.GetCurrentFamilyGroup(ctx, tx, tenantID, req.JobFamilyGroupCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if parent == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogParentMissing
        }</span>

        <span class="cov0" title="0">entity, err := s.repo.InsertJobFamily(ctx, tx, tenantID, parent.RecordID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "groupCode":   entity.FamilyGroupCode,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobFamily", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobFamilyVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, operator types.OperatedByInfo) (*types.JobFamily, error) <span class="cov0" title="0">{
        if req.ParentRecordID == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogInvalidInput
        }</span>
        <span class="cov0" title="0">parentUUID, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID))
        if parseErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parentRecordId: %w", parseErr)
        }</span>

        <span class="cov0" title="0">if err := s.validate("CreateJobFamilyVersion", func(v validator.JobCatalogValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCreateJobFamilyVersion(ctx, tenantID, code, req, parentUUID)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        entity, err := s.repo.InsertJobFamilyVersion(ctx, tx, tenantID, code, parentUUID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.translateJobCatalogError(ctx, tenantID, code, "CreateJobFamilyVersion", req, err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "groupCode":   entity.FamilyGroupCode,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobFamilyVersion", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobRole(ctx context.Context, tenantID uuid.UUID, req *types.CreateJobRoleRequest, operator types.OperatedByInfo) (*types.JobRole, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        parent, err := s.repo.GetCurrentJobFamily(ctx, tx, tenantID, req.JobFamilyCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if parent == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogParentMissing
        }</span>

        <span class="cov0" title="0">entity, err := s.repo.InsertJobRole(ctx, tx, tenantID, parent.RecordID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "familyCode":  entity.FamilyCode,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobRole", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobRoleVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, operator types.OperatedByInfo) (*types.JobRole, error) <span class="cov0" title="0">{
        if req.ParentRecordID == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogInvalidInput
        }</span>
        <span class="cov0" title="0">parentUUID, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID))
        if parseErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parentRecordId: %w", parseErr)
        }</span>

        <span class="cov0" title="0">if err := s.validate("CreateJobRoleVersion", func(v validator.JobCatalogValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCreateJobRoleVersion(ctx, tenantID, code, req, parentUUID)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        entity, err := s.repo.InsertJobRoleVersion(ctx, tx, tenantID, code, parentUUID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.translateJobCatalogError(ctx, tenantID, code, "CreateJobRoleVersion", req, err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "familyCode":  entity.FamilyCode,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobRoleVersion", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobLevel(ctx context.Context, tenantID uuid.UUID, req *types.CreateJobLevelRequest, operator types.OperatedByInfo) (*types.JobLevel, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        parent, err := s.repo.GetCurrentJobRole(ctx, tx, tenantID, req.JobRoleCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if parent == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogParentMissing
        }</span>

        <span class="cov0" title="0">entity, err := s.repo.InsertJobLevel(ctx, tx, tenantID, parent.RecordID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "roleCode":    entity.RoleCode,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobLevel", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishJobLevelEvent(ctx, tx, tenantID, events.EventJobLevelVersionCreated, "CreateJobLevel", entity, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) CreateJobLevelVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, operator types.OperatedByInfo) (*types.JobLevel, error) <span class="cov0" title="0">{
        if req.ParentRecordID == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogInvalidInput
        }</span>
        <span class="cov0" title="0">parentUUID, parseErr := uuid.Parse(strings.TrimSpace(*req.ParentRecordID))
        if parseErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parentRecordId: %w", parseErr)
        }</span>

        <span class="cov0" title="0">if err := s.validate("CreateJobLevelVersion", func(v validator.JobCatalogValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCreateJobLevelVersion(ctx, tenantID, code, req, parentUUID)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        entity, err := s.repo.InsertJobLevelVersion(ctx, tx, tenantID, code, parentUUID, req)
        if err != nil </span><span class="cov0" title="0">{
                lower := strings.ToLower(err.Error())
                translated := s.translateJobCatalogError(ctx, tenantID, code, "CreateJobLevelVersion", req, err)
                if strings.Contains(lower, "already exists for effective date") </span><span class="cov0" title="0">{
                        s.publishJobLevelConflictEvent(ctx, tenantID, code, "CreateJobLevelVersion", req, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, translated</span>
        }

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        entity.Code,
                "roleCode":    entity.RoleCode,
                "effectiveAt": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeCreate, "CreateJobLevelVersion", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishJobLevelEvent(ctx, tx, tenantID, events.EventJobLevelVersionCreated, "CreateJobLevelVersion", entity, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return entity, nil</span>
}

func (s *JobCatalogService) UpdateJobFamilyGroup(ctx context.Context, tenantID uuid.UUID, code string, req *types.UpdateJobFamilyGroupRequest, ifMatch *string, operator types.OperatedByInfo) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        normalizedCode := strings.ToUpper(strings.TrimSpace(code))
        current, err := s.repo.GetCurrentFamilyGroup(ctx, tx, tenantID, normalizedCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>

        <span class="cov0" title="0">if ifMatch != nil &amp;&amp; current.RecordID.String() != strings.TrimSpace(*ifMatch) </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogPreconditionFailed
        }</span>

        <span class="cov0" title="0">updated, err := s.repo.UpdateFamilyGroup(ctx, tx, tenantID, normalizedCode, current.RecordID, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.mapUpdateError(err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        updated.Code,
                "status":      updated.Status,
                "effectiveAt": updated.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeUpdate, "UpdateJobFamilyGroup", updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

func (s *JobCatalogService) UpdateJobFamily(ctx context.Context, tenantID uuid.UUID, code string, req *types.UpdateJobFamilyRequest, ifMatch *string, operator types.OperatedByInfo) (*types.JobFamily, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        normalizedCode := strings.ToUpper(strings.TrimSpace(code))
        current, err := s.repo.GetCurrentJobFamily(ctx, tx, tenantID, normalizedCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>

        <span class="cov0" title="0">if ifMatch != nil &amp;&amp; current.RecordID.String() != strings.TrimSpace(*ifMatch) </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogPreconditionFailed
        }</span>

        <span class="cov0" title="0">groupCode := current.FamilyGroupCode
        parentRecord := current.ParentRecord
        if req.JobFamilyGroupCode != nil </span><span class="cov0" title="0">{
                normalizedGroup := strings.ToUpper(strings.TrimSpace(*req.JobFamilyGroupCode))
                if normalizedGroup == "" </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogInvalidInput
                }</span>
                <span class="cov0" title="0">group, err := s.repo.GetCurrentFamilyGroup(ctx, tx, tenantID, normalizedGroup)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogParentMissing
                }</span>
                <span class="cov0" title="0">groupCode = group.Code
                parentRecord = group.RecordID</span>
        }

        <span class="cov0" title="0">updated, err := s.repo.UpdateJobFamily(ctx, tx, tenantID, normalizedCode, current.RecordID, groupCode, parentRecord, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.mapUpdateError(err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        updated.Code,
                "groupCode":   updated.FamilyGroupCode,
                "effectiveAt": updated.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeUpdate, "UpdateJobFamily", updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

func (s *JobCatalogService) UpdateJobRole(ctx context.Context, tenantID uuid.UUID, code string, req *types.UpdateJobRoleRequest, ifMatch *string, operator types.OperatedByInfo) (*types.JobRole, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        normalizedCode := strings.ToUpper(strings.TrimSpace(code))
        current, err := s.repo.GetCurrentJobRole(ctx, tx, tenantID, normalizedCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>

        <span class="cov0" title="0">if ifMatch != nil &amp;&amp; current.RecordID.String() != strings.TrimSpace(*ifMatch) </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogPreconditionFailed
        }</span>

        <span class="cov0" title="0">familyCode := current.FamilyCode
        parentRecord := current.ParentRecord
        if req.JobFamilyCode != nil </span><span class="cov0" title="0">{
                normalizedFamily := strings.ToUpper(strings.TrimSpace(*req.JobFamilyCode))
                if normalizedFamily == "" </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogInvalidInput
                }</span>
                <span class="cov0" title="0">family, err := s.repo.GetCurrentJobFamily(ctx, tx, tenantID, normalizedFamily)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if family == nil </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogParentMissing
                }</span>
                <span class="cov0" title="0">familyCode = family.Code
                parentRecord = family.RecordID</span>
        }

        <span class="cov0" title="0">updated, err := s.repo.UpdateJobRole(ctx, tx, tenantID, normalizedCode, current.RecordID, familyCode, parentRecord, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.mapUpdateError(err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        updated.Code,
                "familyCode":  updated.FamilyCode,
                "effectiveAt": updated.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeUpdate, "UpdateJobRole", updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

func (s *JobCatalogService) UpdateJobLevel(ctx context.Context, tenantID uuid.UUID, code string, req *types.UpdateJobLevelRequest, ifMatch *string, operator types.OperatedByInfo) (*types.JobLevel, error) <span class="cov0" title="0">{
        tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        normalizedCode := strings.ToUpper(strings.TrimSpace(code))
        current, err := s.repo.GetCurrentJobLevel(ctx, tx, tenantID, normalizedCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>

        <span class="cov0" title="0">if ifMatch != nil &amp;&amp; current.RecordID.String() != strings.TrimSpace(*ifMatch) </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogPreconditionFailed
        }</span>

        <span class="cov0" title="0">roleCode := current.RoleCode
        parentRecord := current.ParentRecord
        if req.JobRoleCode != nil </span><span class="cov0" title="0">{
                normalizedRole := strings.ToUpper(strings.TrimSpace(*req.JobRoleCode))
                if normalizedRole == "" </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogInvalidInput
                }</span>
                <span class="cov0" title="0">role, err := s.repo.GetCurrentJobRole(ctx, tx, tenantID, normalizedRole)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if role == nil </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogParentMissing
                }</span>
                <span class="cov0" title="0">roleCode = role.Code
                parentRecord = role.RecordID</span>
        }

        <span class="cov0" title="0">levelRank := current.LevelRank
        if req.LevelRank != nil </span><span class="cov0" title="0">{
                if *req.LevelRank &lt; 1 </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogInvalidInput
                }</span>
                <span class="cov0" title="0">levelRank = strconv.Itoa(*req.LevelRank)</span>
        }

        <span class="cov0" title="0">updated, err := s.repo.UpdateJobLevel(ctx, tx, tenantID, normalizedCode, current.RecordID, roleCode, parentRecord, levelRank, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, s.mapUpdateError(err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":        updated.Code,
                "roleCode":    updated.RoleCode,
                "effectiveAt": updated.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logCatalogEvent(ctx, tx, tenantID, operator, audit.EventTypeUpdate, "UpdateJobLevel", updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

func (s *JobCatalogService) mapUpdateError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var pqErr *pq.Error
        if errors.As(err, &amp;pqErr) </span><span class="cov0" title="0">{
                switch pqErr.Code </span>{
                case "23505":<span class="cov0" title="0">
                        return ErrJobCatalogConflict</span>
                case "23503":<span class="cov0" title="0">
                        return ErrJobCatalogParentMissing</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (s *JobCatalogService) logCatalogEvent(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, operator types.OperatedByInfo, eventType, action string, recordID uuid.UUID, after map[string]interface{}) error <span class="cov0" title="0">{
        if s.auditLogger == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">actorID := strings.TrimSpace(operator.ID)
        actorName := strings.TrimSpace(operator.Name)
        actorType := audit.ActorTypeUser
        if actorID == "" </span><span class="cov0" title="0">{
                actorType = audit.ActorTypeSystem
                actorID = "system"
        }</span>
        <span class="cov0" title="0">requestID := orgmiddleware.GetRequestID(ctx)
        correlationID := orgmiddleware.GetCorrelationID(ctx)
        sourceCorrelation := ""
        if src := orgmiddleware.GetCorrelationSource(ctx); src == "header" </span><span class="cov0" title="0">{
                sourceCorrelation = src
        }</span>

        <span class="cov0" title="0">entityCode := ""
        if v, ok := after["code"].(string); ok </span><span class="cov0" title="0">{
                entityCode = strings.TrimSpace(v)
        }</span>

        <span class="cov0" title="0">event := &amp;audit.AuditEvent{
                TenantID:          tenantID,
                EventType:         eventType,
                ResourceType:      audit.ResourceTypeJobCatalog,
                ResourceID:        recordID.String(),
                RecordID:          recordID,
                EntityCode:        entityCode,
                ActorID:           actorID,
                ActorType:         actorType,
                ActorName:         actorName,
                ActionName:        action,
                RequestID:         requestID,
                CorrelationID:     correlationID,
                SourceCorrelation: sourceCorrelation,
                Success:           true,
                AfterData:         after,
                ContextPayload:    after,
        }

        if err := s.auditLogger.LogEventInTransaction(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("[AUDIT] failed to log job catalog event: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *JobCatalogService) publishJobLevelEvent(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, eventType, operation string, level *types.JobLevel, extra map[string]interface{}) error <span class="cov0" title="0">{
        if s.outboxRepo == nil || level == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attrs := map[string]interface{}{
                "roleCode":      level.RoleCode,
                "levelRank":     level.LevelRank,
                "status":        level.Status,
                "effectiveDate": level.EffectiveDate.Format("2006-01-02"),
                "recordId":      level.RecordID.String(),
        }
        if level.ParentRecord != uuid.Nil </span><span class="cov0" title="0">{
                attrs["parentRecordId"] = level.ParentRecord.String()
        }</span>
        <span class="cov0" title="0">attrs = mergeJobCatalogAttributes(attrs, extra)

        eventCtx := s.newEventContext(ctx, tenantID, operation)
        outboxEvent, err := events.NewJobLevelEvent(eventType, eventCtx, level.Code, attrs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.saveOutboxEvent(ctx, tx, outboxEvent)</span>
}

func (s *JobCatalogService) publishJobLevelConflictEvent(ctx context.Context, tenantID uuid.UUID, code string, operation string, req *types.JobCatalogVersionRequest, message string) <span class="cov0" title="0">{
        if s.outboxRepo == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if req == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">attrs := map[string]interface{}{
                "effectiveDate": strings.TrimSpace(req.EffectiveDate),
        }
        if req.Status != "" </span><span class="cov0" title="0">{
                attrs["status"] = strings.TrimSpace(req.Status)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(req.Name) != "" </span><span class="cov0" title="0">{
                attrs["name"] = strings.TrimSpace(req.Name)
        }</span>
        <span class="cov0" title="0">if req.ParentRecordID != nil &amp;&amp; strings.TrimSpace(*req.ParentRecordID) != "" </span><span class="cov0" title="0">{
                attrs["parentRecordId"] = strings.TrimSpace(*req.ParentRecordID)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(message) != "" </span><span class="cov0" title="0">{
                attrs["error"] = strings.TrimSpace(message)
        }</span>

        <span class="cov0" title="0">eventCtx := s.newEventContext(ctx, tenantID, operation)
        outboxEvent, err := events.NewJobLevelEvent(events.EventJobLevelVersionConflict, eventCtx, code, attrs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warnf("[OUTBOX] skip jobLevel conflict event: %v", err)
                return
        }</span>
        <span class="cov0" title="0">if err := s.saveOutboxEvent(ctx, nil, outboxEvent); err != nil </span><span class="cov0" title="0">{
                s.logger.Warnf("[OUTBOX] failed to record jobLevel conflict event: %v", err)
        }</span>
}

func (s *JobCatalogService) saveOutboxEvent(ctx context.Context, tx *sql.Tx, evt *database.OutboxEvent) error <span class="cov0" title="0">{
        if evt == nil || s.outboxRepo == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if tx != nil </span><span class="cov0" title="0">{
                return s.outboxRepo.Save(ctx, database.WrapSQLTx(tx), evt)
        }</span>
        <span class="cov0" title="0">newTx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer newTx.Rollback()

        if err := s.outboxRepo.Save(ctx, database.WrapSQLTx(newTx), evt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return newTx.Commit()</span>
}

func (s *JobCatalogService) newEventContext(ctx context.Context, tenantID uuid.UUID, operation string) events.Context <span class="cov0" title="0">{
        return events.Context{
                TenantID:      tenantID,
                RequestID:     orgmiddleware.GetRequestID(ctx),
                CorrelationID: orgmiddleware.GetCorrelationID(ctx),
                Operation:     operation,
                Source:        events.DefaultSourceCommand,
        }
}</span>

func mergeJobCatalogAttributes(base map[string]interface{}, extra map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        if extra == nil || len(extra) == 0 </span><span class="cov0" title="0">{
                return base
        }</span>
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                base = map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">for k, v := range extra </span><span class="cov0" title="0">{
                if k == "" || v == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">base[k] = v</span>
        }
        <span class="cov0" title="0">return base</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package service

import (
        pkglogger "cube-castle/pkg/logger"
)

func scopedLogger(base pkglogger.Logger, service string, extra pkglogger.Fields) pkglogger.Logger <span class="cov0" title="0">{
        if base == nil </span><span class="cov0" title="0">{
                base = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov0" title="0">fields := pkglogger.Fields{
                "component": "service",
        }
        if service != "" </span><span class="cov0" title="0">{
                fields["service"] = service
        }</span>
        <span class="cov0" title="0">for k, v := range extra </span><span class="cov0" title="0">{
                fields[k] = v
        }</span>
        <span class="cov0" title="0">return base.WithFields(fields)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package service

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/audit"
        "cube-castle/internal/organization/events"
        orgmiddleware "cube-castle/internal/organization/middleware"
        "cube-castle/internal/organization/repository"
        validator "cube-castle/internal/organization/validator"
        "cube-castle/internal/types"
        "cube-castle/pkg/database"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

var (
        ErrPositionNotFound       = errors.New("position not found")
        ErrOrganizationNotFound   = errors.New("organization not found")
        ErrJobCatalogNotFound     = errors.New("job catalog reference not found")
        ErrJobCatalogMismatch     = errors.New("job catalog hierarchy mismatch")
        ErrPositionVersionExists  = errors.New("position version already exists for effective date")
        ErrPositionTimelineUpdate = errors.New("failed to update position timeline")
        ErrVersionConflict        = errors.New("version conflict")
        ErrInvalidTransition      = errors.New("invalid position transition")
        ErrInvalidHeadcount       = errors.New("invalid headcount change")
        ErrAssignmentNotFound     = errors.New("position assignment not found")
        ErrInvalidAssignmentState = errors.New("position assignment state invalid")
)

type PositionService struct {
        positions           *repository.PositionRepository
        assignments         *repository.PositionAssignmentRepository
        jobCatalog          *repository.JobCatalogRepository
        orgRepo             *repository.OrganizationRepository
        auditLogger         *audit.AuditLogger
        logger              pkglogger.Logger
        positionValidator   validator.PositionValidationService
        assignmentValidator validator.AssignmentValidationService
        outboxRepo          database.OutboxRepository
}

func NewPositionService(positions *repository.PositionRepository, assignments *repository.PositionAssignmentRepository, jobCatalog *repository.JobCatalogRepository, orgRepo *repository.OrganizationRepository, positionValidator validator.PositionValidationService, assignmentValidator validator.AssignmentValidationService, auditLogger *audit.AuditLogger, baseLogger pkglogger.Logger, outboxRepo database.OutboxRepository) *PositionService <span class="cov0" title="0">{
        if positionValidator == nil </span><span class="cov0" title="0">{
                positionValidator = validator.NewStubValidationService()
        }</span>
        <span class="cov0" title="0">if assignmentValidator == nil </span><span class="cov0" title="0">{
                assignmentValidator = validator.NewStubValidationService()
        }</span>

        <span class="cov0" title="0">return &amp;PositionService{
                positions:           positions,
                assignments:         assignments,
                jobCatalog:          jobCatalog,
                orgRepo:             orgRepo,
                auditLogger:         auditLogger,
                logger:              scopedLogger(baseLogger, "position", nil),
                positionValidator:   positionValidator,
                assignmentValidator: assignmentValidator,
                outboxRepo:          outboxRepo,
        }</span>
}

func (s *PositionService) newAssignmentFTEError(operation string, position *types.Position, requested float64) error <span class="cov8" title="1">{
        result := validator.NewValidationResult()
        result.Valid = false
        result.Context["operation"] = operation
        if position != nil </span><span class="cov8" title="1">{
                result.Context["positionCode"] = position.Code
        }</span>

        <span class="cov8" title="1">context := map[string]interface{}{
                "ruleId":       "ASSIGN-FTE",
                "requestedFTE": requested,
                "allowedRange": "[0,1]",
        }
        if position != nil </span><span class="cov8" title="1">{
                context["positionCode"] = position.Code
        }</span>

        <span class="cov8" title="1">result.Errors = append(result.Errors, validator.ValidationError{
                Code:     "ASSIGN_FTE_LIMIT",
                Message:  fmt.Sprintf("Assignment FTE %.2f must be between 0 and 1", requested),
                Field:    "fte",
                Value:    requested,
                Severity: string(validator.SeverityHigh),
                Context:  context,
        })

        return validator.NewValidationFailedError(operation, result)</span>
}

func (s *PositionService) newHeadcountExceededError(operation string, position *types.Position, currentUsage, requested, projected float64) error <span class="cov8" title="1">{
        result := validator.NewValidationResult()
        result.Valid = false
        result.Context["operation"] = operation

        headcountLimit := 0.0
        positionCode := ""
        if position != nil </span><span class="cov8" title="1">{
                headcountLimit = position.HeadcountCapacity
                positionCode = position.Code
                result.Context["positionCode"] = positionCode
        }</span>

        <span class="cov8" title="1">result.Context["currentFTE"] = currentUsage
        result.Context["requestedFTE"] = requested
        result.Context["projectedFTE"] = projected
        result.Context["headcountLimit"] = headcountLimit

        context := map[string]interface{}{
                "ruleId":         "POS-HEADCOUNT",
                "headcountLimit": headcountLimit,
                "currentFTE":     currentUsage,
                "requestedFTE":   requested,
                "projectedFTE":   projected,
        }
        if positionCode != "" </span><span class="cov8" title="1">{
                context["positionCode"] = positionCode
        }</span>

        <span class="cov8" title="1">message := fmt.Sprintf("Projected headcount %.2f exceeds capacity %.2f", projected, headcountLimit)
        result.Errors = append(result.Errors, validator.ValidationError{
                Code:     "POS_HEADCOUNT_EXCEEDED",
                Message:  message,
                Field:    "fte",
                Value:    requested,
                Severity: string(validator.SeverityHigh),
                Context:  context,
        })

        return validator.NewValidationFailedError(operation, result)</span>
}

func (s *PositionService) newAssignmentStateError(operation string, assignment *types.PositionAssignment) error <span class="cov8" title="1">{
        result := validator.NewValidationResult()
        result.Valid = false
        result.Context["operation"] = operation

        state := "UNKNOWN"
        context := map[string]interface{}{
                "ruleId": "ASSIGN-STATE",
        }

        if assignment != nil </span><span class="cov8" title="1">{
                state = strings.ToUpper(strings.TrimSpace(assignment.AssignmentStatus))
                result.Context["assignmentId"] = assignment.AssignmentID.String()
                result.Context["positionCode"] = assignment.PositionCode
                context["assignmentId"] = assignment.AssignmentID.String()
                context["positionCode"] = assignment.PositionCode
        }</span>
        <span class="cov8" title="1">context["currentState"] = state
        context["operation"] = operation

        result.Errors = append(result.Errors, validator.ValidationError{
                Code:     "ASSIGN_INVALID_STATE",
                Message:  fmt.Sprintf("Assignment state %s does not allow %s", state, operation),
                Field:    "assignmentStatus",
                Value:    state,
                Severity: string(validator.SeverityCritical),
                Context:  context,
        })

        return validator.NewValidationFailedError(operation, result)</span>
}

func (s *PositionService) failIfInvalid(operation string, result *validator.ValidationResult) error <span class="cov0" title="0">{
        if result == nil || result.Valid </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return validator.NewValidationFailedError(operation, result)</span>
}

func (s *PositionService) validatePosition(operation string, exec func(validator.PositionValidationService) *validator.ValidationResult) error <span class="cov0" title="0">{
        if exec == nil || s.positionValidator == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.failIfInvalid(operation, exec(s.positionValidator))</span>
}

func (s *PositionService) validateAssignment(operation string, exec func(validator.AssignmentValidationService) *validator.ValidationResult) error <span class="cov0" title="0">{
        if exec == nil || s.assignmentValidator == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.failIfInvalid(operation, exec(s.assignmentValidator))</span>
}

type jobCatalogSnapshot struct {
        group  *types.JobFamilyGroup
        family *types.JobFamily
        role   *types.JobRole
        level  *types.JobLevel
}

func (s *PositionService) CreatePosition(ctx context.Context, tenantID uuid.UUID, req *types.PositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        if err := s.validatePosition("CreatePosition", func(v validator.PositionValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCreatePosition(ctx, tenantID, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        org, err := s.orgRepo.GetByCode(ctx, tenantID, req.OrganizationCode)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "组织不存在") </span><span class="cov0" title="0">{
                        return nil, ErrOrganizationNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">catalog, err := s.resolveJobCatalog(ctx, tx, tenantID, req.JobFamilyGroupCode, req.JobFamilyGroupRecordID, req.JobFamilyCode, req.JobFamilyRecordID, req.JobRoleCode, req.JobRoleRecordID, req.JobLevelCode, req.JobLevelRecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">positionCode, err := s.positions.GenerateCode(ctx, tx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entity, err := s.buildPositionEntity(tenantID, positionCode, req, catalog, org, operator, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entity, err = s.positions.InsertPositionVersion(ctx, tx, entity)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        return nil, ErrPositionVersionExists
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if err := s.positions.RecalculatePositionTimeline(ctx, tx, tenantID, entity.Code); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrPositionTimelineUpdate, err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":               entity.Code,
                "title":              entity.Title,
                "organizationCode":   entity.OrganizationCode,
                "jobFamilyGroupCode": entity.JobFamilyGroupCode,
                "jobFamilyCode":      entity.JobFamilyCode,
                "jobRoleCode":        entity.JobRoleCode,
                "jobLevelCode":       entity.JobLevelCode,
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeCreate, "CreatePosition", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishPositionEvent(ctx, tx, tenantID, events.EventPositionCreated, "CreatePosition", entity, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(entity, nil), nil</span>
}

func (s *PositionService) ReplacePosition(ctx context.Context, tenantID uuid.UUID, code string, ifMatch *string, req *types.PositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">if err := s.validatePosition("ReplacePosition", func(v validator.PositionValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateReplacePosition(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if ifMatch != nil &amp;&amp; *ifMatch != "" &amp;&amp; current.RecordID.String() != strings.Trim(*ifMatch, "\"") </span><span class="cov0" title="0">{
                return nil, ErrVersionConflict
        }</span>

        <span class="cov0" title="0">org, err := s.orgRepo.GetByCode(ctx, tenantID, req.OrganizationCode)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "组织不存在") </span><span class="cov0" title="0">{
                        return nil, ErrOrganizationNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">catalog, err := s.resolveJobCatalog(ctx, tx, tenantID, req.JobFamilyGroupCode, req.JobFamilyGroupRecordID, req.JobFamilyCode, req.JobFamilyRecordID, req.JobRoleCode, req.JobRoleRecordID, req.JobLevelCode, req.JobLevelRecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updateEntity, err := s.buildPositionEntity(tenantID, current.Code, req, catalog, org, operator, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">updateEntity.RecordID = current.RecordID
        updateEntity.HeadcountInUse = current.HeadcountInUse
        updateEntity.IsCurrent = current.IsCurrent
        updateEntity.CreatedAt = current.CreatedAt
        updateEntity.OperationType = "UPDATE"

        if _, err := s.positions.UpdatePositionDetails(ctx, tx, updateEntity); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":             updateEntity.Code,
                "title":            updateEntity.Title,
                "organizationCode": updateEntity.OrganizationCode,
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, "UpdatePosition", updateEntity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishPositionEvent(ctx, tx, tenantID, events.EventPositionUpdated, "ReplacePosition", updateEntity, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(updateEntity, nil), nil</span>
}

func (s *PositionService) CreatePositionVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionVersionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">org, err := s.orgRepo.GetByCode(ctx, tenantID, current.OrganizationCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">catalog, err := s.resolveJobCatalog(ctx, tx, tenantID,
                req.JobFamilyGroupCode, req.JobFamilyGroupRecordID,
                req.JobFamilyCode, req.JobFamilyRecordID,
                req.JobRoleCode, req.JobRoleRecordID,
                req.JobLevelCode, req.JobLevelRecordID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">jobProfileCode := req.JobProfileCode
        if jobProfileCode == nil &amp;&amp; current.JobProfileCode.Valid </span><span class="cov0" title="0">{
                val := current.JobProfileCode.String
                jobProfileCode = &amp;val
        }</span>
        <span class="cov0" title="0">jobProfileName := req.JobProfileName
        if jobProfileName == nil &amp;&amp; current.JobProfileName.Valid </span><span class="cov0" title="0">{
                val := current.JobProfileName.String
                jobProfileName = &amp;val
        }</span>
        <span class="cov0" title="0">gradeLevel := req.GradeLevel
        if gradeLevel == nil &amp;&amp; current.GradeLevel.Valid </span><span class="cov0" title="0">{
                val := current.GradeLevel.String
                gradeLevel = &amp;val
        }</span>
        <span class="cov0" title="0">costCenter := req.CostCenterCode
        if costCenter == nil &amp;&amp; current.CostCenterCode.Valid </span><span class="cov0" title="0">{
                val := current.CostCenterCode.String
                costCenter = &amp;val
        }</span>
        <span class="cov0" title="0">reportsTo := req.ReportsTo
        if reportsTo == nil &amp;&amp; current.ReportsToPosition.Valid </span><span class="cov0" title="0">{
                val := current.ReportsToPosition.String
                reportsTo = &amp;val
        }</span>
        <span class="cov0" title="0">var headcountInUsePtr *float64
        if req.HeadcountInUse != nil </span><span class="cov0" title="0">{
                headcountInUsePtr = req.HeadcountInUse
        }</span> else<span class="cov0" title="0"> {
                existing := current.HeadcountInUse
                headcountInUsePtr = &amp;existing
        }</span>

        <span class="cov0" title="0">versionSource := &amp;types.PositionRequest{
                Title:                  req.Title,
                JobProfileCode:         jobProfileCode,
                JobProfileName:         jobProfileName,
                JobFamilyGroupCode:     req.JobFamilyGroupCode,
                JobFamilyGroupRecordID: req.JobFamilyGroupRecordID,
                JobFamilyCode:          req.JobFamilyCode,
                JobFamilyRecordID:      req.JobFamilyRecordID,
                JobRoleCode:            req.JobRoleCode,
                JobRoleRecordID:        req.JobRoleRecordID,
                JobLevelCode:           req.JobLevelCode,
                JobLevelRecordID:       req.JobLevelRecordID,
                OrganizationCode:       current.OrganizationCode,
                PositionType:           valueOrDefault(req.PositionType, current.PositionType),
                EmploymentType:         valueOrDefault(req.EmploymentType, current.EmploymentType),
                HeadcountCapacity:      valueOrDefaultFloat(req.HeadcountCapacity, current.HeadcountCapacity),
                HeadcountInUse:         headcountInUsePtr,
                GradeLevel:             gradeLevel,
                CostCenterCode:         costCenter,
                ReportsToPositionCode:  reportsTo,
                Profile:                req.Profile,
                EffectiveDate:          req.EffectiveDate,
                OperationReason:        req.OperationReason,
        }

        entity, err := s.buildPositionEntity(tenantID, current.Code, versionSource, catalog, org, operator, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">entity.OperationType = "CREATE_VERSION"
        // 新增版本在插入前统一设置为非当前版本，待时间线重算后再确定 current 标记，避免违反唯一约束
        entity.IsCurrent = false

        if _, err := s.positions.InsertPositionVersion(ctx, tx, entity); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        return nil, ErrPositionVersionExists
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if err := s.positions.RecalculatePositionTimeline(ctx, tx, tenantID, current.Code); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrPositionTimelineUpdate, err)
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":          entity.Code,
                "effectiveDate": entity.EffectiveDate.Format("2006-01-02"),
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeCreate, "CreatePositionVersion", entity.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishPositionEvent(ctx, tx, tenantID, events.EventPositionUpdated, "CreatePositionVersion", entity, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(entity, nil), nil</span>
}

// TODO-TEMPORARY: 临时占位以支撑 Stage1 填充流程，待 assignments 模块落地后改由专用服务处理（Owner: 命令服务组，Deadline: 2025-11-15，Plan: 接入统一 assignments API 并移除本地实现）
func (s *PositionService) FillPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.FillPositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        if err := s.validatePosition("FillPosition", func(v validator.PositionValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateFillPosition(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.validateAssignment("CreateAssignment", func(av validator.AssignmentValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return av.ValidateCreateAssignment(ctx, tenantID, code, fillToAssignmentRequest(req))
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updated, assignments, _, err := s.createAssignment(ctx, tenantID, code, req, operator, "FillPosition", func(tx *sql.Tx, updated *types.Position, assignment *types.PositionAssignment) error </span><span class="cov0" title="0">{
                after := map[string]interface{}{
                        "code":                updated.Code,
                        "assignmentId":        assignment.AssignmentID.String(),
                        "assignmentStatus":    assignment.AssignmentStatus,
                        "headcountInUse":      updated.HeadcountInUse,
                        "positionStatus":      updated.Status,
                        "assignmentEffective": assignment.EffectiveDate.Format("2006-01-02"),
                }
                return s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, "FillPosition", updated.RecordID, after)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(updated, assignments), nil</span>
}

func (s *PositionService) createAssignment(ctx context.Context, tenantID uuid.UUID, code string, req *types.FillPositionRequest, operator types.OperatedByInfo, operation string, auditFn func(tx *sql.Tx, updated *types.Position, assignment *types.PositionAssignment) error) (*types.Position, []types.PositionAssignment, *types.PositionAssignment, error) <span class="cov0" title="0">{
        tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">fte := 1.0
        if req.FTE != nil </span><span class="cov0" title="0">{
                fte = *req.FTE
        }</span>
        <span class="cov0" title="0">if fte &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil, nil, s.newAssignmentFTEError(operation, current, fte)
        }</span>

        <span class="cov0" title="0">effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("invalid effectiveDate: %w", err)
        }</span>

        <span class="cov0" title="0">var anticipatedEnd sql.NullTime
        if req.AnticipatedEndDate != nil &amp;&amp; strings.TrimSpace(*req.AnticipatedEndDate) != "" </span><span class="cov0" title="0">{
                endTime, parseErr := time.Parse("2006-01-02", strings.TrimSpace(*req.AnticipatedEndDate))
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, fmt.Errorf("invalid anticipatedEndDate: %w", parseErr)
                }</span>
                <span class="cov0" title="0">if endTime.Before(effectiveDate) </span><span class="cov0" title="0">{
                        return nil, nil, nil, fmt.Errorf("anticipatedEndDate must be on or after effectiveDate")
                }</span>
                <span class="cov0" title="0">anticipatedEnd = sql.NullTime{Time: endTime, Valid: true}</span>
        }

        <span class="cov0" title="0">employeeID, err := uuid.Parse(strings.TrimSpace(req.EmployeeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("employeeId must be UUID: %w", err)
        }</span>

        <span class="cov0" title="0">employeeName := strings.TrimSpace(req.EmployeeName)
        if employeeName == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("employeeName is required")
        }</span>

        <span class="cov0" title="0">assignmentType := strings.ToUpper(strings.TrimSpace(req.AssignmentType))
        if assignmentType == "" </span><span class="cov0" title="0">{
                assignmentType = "PRIMARY"
        }</span>
        <span class="cov0" title="0">if _, ok := map[string]struct{}{"PRIMARY": {}, "SECONDARY": {}, "ACTING": {}}[assignmentType]; !ok </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("unsupported assignmentType: %s", assignmentType)
        }</span>

        <span class="cov0" title="0">actingUntil := sql.NullTime{}
        if strings.EqualFold(assignmentType, "ACTING") </span><span class="cov0" title="0">{
                actingUntil = anticipatedEnd
                anticipatedEnd = sql.NullTime{}
        }</span>

        <span class="cov0" title="0">autoRevert := false
        if req.AutoRevert != nil </span><span class="cov0" title="0">{
                autoRevert = *req.AutoRevert
        }</span>
        <span class="cov0" title="0">if autoRevert &amp;&amp; !strings.EqualFold(assignmentType, "ACTING") </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("autoRevert only supported for ACTING assignments")
        }</span>
        <span class="cov0" title="0">if autoRevert &amp;&amp; !actingUntil.Valid </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("actingUntil is required when autoRevert is enabled")
        }</span>

        <span class="cov0" title="0">activeFTE, err := s.assignments.SumActiveFTE(ctx, tx, tenantID, current.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">projected := activeFTE
        statusNow := strings.ToUpper(current.Status)

        now := time.Now().UTC().Truncate(24 * time.Hour)
        assignmentStatus := "ACTIVE"
        isCurrent := true
        if effectiveDate.After(now) </span><span class="cov0" title="0">{
                assignmentStatus = "PENDING"
                isCurrent = false
        }</span>
        <span class="cov0" title="0">projectedTotal := projected + fte
        if projectedTotal &gt; current.HeadcountCapacity </span><span class="cov0" title="0">{
                return nil, nil, nil, s.newHeadcountExceededError(operation, current, projected, fte, projectedTotal)
        }</span>

        <span class="cov0" title="0">var employeeNumber sql.NullString
        if req.EmployeeNumber != nil </span><span class="cov0" title="0">{
                num := strings.TrimSpace(*req.EmployeeNumber)
                if num != "" </span><span class="cov0" title="0">{
                        employeeNumber = sql.NullString{String: num, Valid: true}
                }</span>
        }

        <span class="cov0" title="0">var notes sql.NullString
        if req.Notes != nil </span><span class="cov0" title="0">{
                text := strings.TrimSpace(*req.Notes)
                if text != "" </span><span class="cov0" title="0">{
                        notes = sql.NullString{String: text, Valid: true}
                }</span>
        }

        <span class="cov0" title="0">assignment := &amp;types.PositionAssignment{
                TenantID:         tenantID,
                PositionCode:     current.Code,
                PositionRecordID: current.RecordID,
                EmployeeID:       employeeID,
                EmployeeName:     employeeName,
                EmployeeNumber:   employeeNumber,
                AssignmentType:   assignmentType,
                AssignmentStatus: assignmentStatus,
                FTE:              fte,
                EffectiveDate:    effectiveDate,
                EndDate:          anticipatedEnd,
                ActingUntil:      actingUntil,
                AutoRevert:       autoRevert,
                IsCurrent:        isCurrent,
                Notes:            notes,
        }

        if assignment, err = s.assignments.CreateAssignment(ctx, tx, assignment); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">activeFTE, err = s.assignments.SumActiveFTE(ctx, tx, tenantID, current.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">if activeFTE &gt; current.HeadcountCapacity+1e-9 </span><span class="cov0" title="0">{
                baseUsage := activeFTE - assignment.FTE
                if baseUsage &lt; 0 </span><span class="cov0" title="0">{
                        baseUsage = 0
                }</span>
                <span class="cov0" title="0">return nil, nil, nil, s.newHeadcountExceededError(operation, current, baseUsage, assignment.FTE, activeFTE)</span>
        }

        <span class="cov0" title="0">switch </span>{
        case activeFTE &gt;= current.HeadcountCapacity:<span class="cov0" title="0">
                statusNow = "FILLED"</span>
        case activeFTE &gt; 0:<span class="cov0" title="0">
                statusNow = "PARTIALLY_FILLED"</span>
        default:<span class="cov0" title="0">
                statusNow = "VACANT"</span>
        }

        <span class="cov0" title="0">opID, opName := resolveOperator(operator)
        if err := s.positions.UpdatePositionHeadcount(ctx, tx, tenantID, current.RecordID, activeFTE, statusNow, "FILL", opName, opID, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">updated, err := s.positions.GetPositionByRecordID(ctx, tx, tenantID, current.RecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">if updated == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">assignments, err := s.assignments.ListByPosition(ctx, tx, tenantID, updated.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">if auditFn != nil </span><span class="cov0" title="0">{
                if err := auditFn(tx, updated, assignment); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := s.publishAssignmentEvent(ctx, tx, tenantID, events.EventAssignmentFilled, operation, assignment, updated, map[string]interface{}{
                "operationReason": strings.TrimSpace(req.OperationReason),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">return updated, assignments, assignment, nil</span>
}

func (s *PositionService) CreateAssignmentRecord(ctx context.Context, tenantID uuid.UUID, code string, req *types.CreateAssignmentRequest, operator types.OperatedByInfo) (*types.PositionAssignmentResponse, error) <span class="cov0" title="0">{
        if err := s.validateAssignment("CreateAssignment", func(v validator.AssignmentValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCreateAssignment(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fillReq := &amp;types.FillPositionRequest{
                EmployeeID:         req.EmployeeID,
                EmployeeName:       req.EmployeeName,
                EmployeeNumber:     req.EmployeeNumber,
                AssignmentType:     req.AssignmentType,
                FTE:                req.FTE,
                EffectiveDate:      req.EffectiveDate,
                AnticipatedEndDate: req.ActingUntil,
                AutoRevert:         req.AutoRevert,
                OperationReason:    req.OperationReason,
                Notes:              req.Notes,
        }

        _, _, assignment, err := s.createAssignment(ctx, tenantID, code, fillReq, operator, "CreateAssignment", func(tx *sql.Tx, updated *types.Position, assignment *types.PositionAssignment) error </span><span class="cov0" title="0">{
                after := map[string]interface{}{
                        "code":             updated.Code,
                        "assignmentId":     assignment.AssignmentID.String(),
                        "assignmentType":   assignment.AssignmentType,
                        "autoRevert":       assignment.AutoRevert,
                        "assignmentStatus": assignment.AssignmentStatus,
                }
                return s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, "CreateAssignment", updated.RecordID, after)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := toAssignmentResponse(*assignment)
        return &amp;resp, nil</span>
}

func (s *PositionService) ListAssignments(ctx context.Context, tenantID uuid.UUID, code string, opts types.AssignmentListOptions) ([]types.PositionAssignmentResponse, int, error) <span class="cov0" title="0">{
        tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, 0, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">assignments, total, err := s.assignments.ListWithOptions(ctx, tx, tenantID, current.Code, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">responses := make([]types.PositionAssignmentResponse, 0, len(assignments))
        for _, item := range assignments </span><span class="cov0" title="0">{
                converted := toAssignmentResponse(item)
                responses = append(responses, converted)
        }</span>

        <span class="cov0" title="0">return responses, total, nil</span>
}

func (s *PositionService) UpdateAssignmentRecord(ctx context.Context, tenantID uuid.UUID, code string, assignmentID uuid.UUID, req *types.UpdateAssignmentRequest, operator types.OperatedByInfo) (*types.PositionAssignmentResponse, error) <span class="cov0" title="0">{
        tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">assignment, err := s.assignments.GetByID(ctx, tx, tenantID, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if assignment == nil || assignment.PositionCode != current.Code </span><span class="cov0" title="0">{
                return nil, ErrAssignmentNotFound
        }</span>
        <span class="cov0" title="0">if strings.EqualFold(assignment.AssignmentStatus, "ENDED") </span><span class="cov0" title="0">{
                return nil, s.newAssignmentStateError("UpdateAssignment", assignment)
        }</span>

        <span class="cov0" title="0">if err := s.validateAssignment("UpdateAssignment", func(v validator.AssignmentValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateUpdateAssignment(ctx, tenantID, code, assignmentID, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updateParams := types.AssignmentUpdateParams{}

        newFTE := assignment.FTE
        if req.FTE != nil </span><span class="cov0" title="0">{
                if *req.FTE &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, s.newAssignmentFTEError("UpdateAssignment", current, *req.FTE)
                }</span>
                <span class="cov0" title="0">updateParams.FTE = req.FTE
                newFTE = *req.FTE</span>
        }

        <span class="cov0" title="0">if req.ActingUntil != nil </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(*req.ActingUntil)
                if trimmed == "" </span><span class="cov0" title="0">{
                        updateParams.ClearActingUntil = true
                }</span> else<span class="cov0" title="0"> {
                        parsed, parseErr := time.Parse("2006-01-02", trimmed)
                        if parseErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid actingUntil: %w", parseErr)
                        }</span>
                        <span class="cov0" title="0">updateParams.ActingUntil = &amp;parsed</span>
                }
        }

        <span class="cov0" title="0">if req.AutoRevert != nil </span><span class="cov0" title="0">{
                updateParams.AutoRevert = req.AutoRevert
        }</span>

        <span class="cov0" title="0">if req.Notes != nil </span><span class="cov0" title="0">{
                updateParams.Notes = req.Notes
        }</span>

        <span class="cov0" title="0">newAutoRevert := assignment.AutoRevert
        if updateParams.AutoRevert != nil </span><span class="cov0" title="0">{
                newAutoRevert = *updateParams.AutoRevert
        }</span>

        <span class="cov0" title="0">newActingUntil := assignment.ActingUntil
        if updateParams.ClearActingUntil </span><span class="cov0" title="0">{
                newActingUntil = sql.NullTime{}
        }</span>
        <span class="cov0" title="0">if updateParams.ActingUntil != nil </span><span class="cov0" title="0">{
                newActingUntil = sql.NullTime{Time: *updateParams.ActingUntil, Valid: true}
        }</span>

        <span class="cov0" title="0">if newAutoRevert &amp;&amp; !strings.EqualFold(assignment.AssignmentType, "ACTING") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("autoRevert only supported for ACTING assignments")
        }</span>
        <span class="cov0" title="0">if newAutoRevert &amp;&amp; !newActingUntil.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("actingUntil is required when autoRevert is enabled")
        }</span>

        <span class="cov0" title="0">if req.FTE != nil &amp;&amp; strings.EqualFold(assignment.AssignmentStatus, "ACTIVE") </span><span class="cov0" title="0">{
                activeFTE, err := s.assignments.SumActiveFTE(ctx, tx, tenantID, current.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">projected := activeFTE - assignment.FTE + newFTE
                if projected &gt; current.HeadcountCapacity </span><span class="cov0" title="0">{
                        baseUsage := activeFTE - assignment.FTE
                        if baseUsage &lt; 0 </span><span class="cov0" title="0">{
                                baseUsage = 0
                        }</span>
                        <span class="cov0" title="0">return nil, s.newHeadcountExceededError("UpdateAssignment", current, baseUsage, newFTE, projected)</span>
                }
        }

        <span class="cov0" title="0">if err := s.assignments.UpdateAssignment(ctx, tx, tenantID, assignmentID, updateParams); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updatedAssignment, err := s.assignments.GetByID(ctx, tx, tenantID, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if updatedAssignment == nil </span><span class="cov0" title="0">{
                return nil, ErrAssignmentNotFound
        }</span>

        <span class="cov0" title="0">if req.FTE != nil &amp;&amp; strings.EqualFold(updatedAssignment.AssignmentStatus, "ACTIVE") </span><span class="cov0" title="0">{
                activeFTE, err := s.assignments.SumActiveFTE(ctx, tx, tenantID, current.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">statusNow := strings.ToUpper(current.Status)
                switch </span>{
                case activeFTE &gt;= current.HeadcountCapacity:<span class="cov0" title="0">
                        statusNow = "FILLED"</span>
                case activeFTE &gt; 0:<span class="cov0" title="0">
                        statusNow = "PARTIALLY_FILLED"</span>
                default:<span class="cov0" title="0">
                        statusNow = "VACANT"</span>
                }

                <span class="cov0" title="0">opID, opName := resolveOperator(operator)
                if err := s.positions.UpdatePositionHeadcount(ctx, tx, tenantID, current.RecordID, activeFTE, statusNow, "ASSIGNMENT_UPDATE", opName, opID, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">after := map[string]interface{}{
                "assignmentId":   updatedAssignment.AssignmentID.String(),
                "assignmentType": updatedAssignment.AssignmentType,
                "autoRevert":     updatedAssignment.AutoRevert,
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, "UpdateAssignment", updatedAssignment.PositionRecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishAssignmentEvent(ctx, tx, tenantID, events.EventAssignmentUpdated, "UpdateAssignment", updatedAssignment, current, map[string]interface{}{
                "operationReason": strings.TrimSpace(req.OperationReason),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := toAssignmentResponse(*updatedAssignment)
        return &amp;resp, nil</span>
}

func (s *PositionService) CloseAssignmentRecord(ctx context.Context, tenantID uuid.UUID, code string, assignmentID uuid.UUID, req *types.CloseAssignmentRequest, operator types.OperatedByInfo) (*types.PositionAssignmentResponse, error) <span class="cov0" title="0">{
        if err := s.validateAssignment("CloseAssignment", func(v validator.AssignmentValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCloseAssignment(ctx, tenantID, code, assignmentID, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">vacateReq := &amp;types.VacatePositionRequest{
                AssignmentID:    assignmentID.String(),
                EffectiveDate:   req.EndDate,
                OperationReason: req.OperationReason,
                Notes:           req.Notes,
        }

        positionResp, err := s.vacatePosition(ctx, tenantID, code, vacateReq, operator, events.EventAssignmentClosed, "CloseAssignment")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, item := range positionResp.AssignmentHistory </span><span class="cov0" title="0">{
                if item.AssignmentID == assignmentID </span><span class="cov0" title="0">{
                        found := item
                        return &amp;found, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, ErrAssignmentNotFound</span>
}

func (s *PositionService) ProcessAutoReverts(ctx context.Context, tenantID uuid.UUID, asOf time.Time, limit int, operator types.OperatedByInfo) ([]types.PositionAssignmentResponse, error) <span class="cov0" title="0">{
        candidates, err := s.assignments.ListAutoRevertCandidates(ctx, nil, tenantID, asOf, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results := make([]types.PositionAssignmentResponse, 0, len(candidates))
        for _, candidate := range candidates </span><span class="cov0" title="0">{
                if !candidate.ActingUntil.Valid </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">vacReq := &amp;types.VacatePositionRequest{
                        AssignmentID:    candidate.AssignmentID.String(),
                        EffectiveDate:   candidate.ActingUntil.Time.Format("2006-01-02"),
                        OperationReason: "AUTO_REVERT_ACTING_ASSIGNMENT",
                }

                resp, err := s.VacatePosition(ctx, tenantID, candidate.PositionCode, vacReq, operator)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorf("[AUTO-REVERT] failed to close assignment %s: %v", candidate.AssignmentID, err)
                        continue</span>
                }

                <span class="cov0" title="0">for _, item := range resp.AssignmentHistory </span><span class="cov0" title="0">{
                        if item.AssignmentID == candidate.AssignmentID </span><span class="cov0" title="0">{
                                results = append(results, item)
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return results, nil</span>
}

func fillToAssignmentRequest(req *types.FillPositionRequest) *types.CreateAssignmentRequest <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;types.CreateAssignmentRequest{
                EmployeeID:      req.EmployeeID,
                EmployeeName:    req.EmployeeName,
                EmployeeNumber:  req.EmployeeNumber,
                AssignmentType:  req.AssignmentType,
                FTE:             req.FTE,
                EffectiveDate:   req.EffectiveDate,
                ActingUntil:     req.AnticipatedEndDate,
                AutoRevert:      req.AutoRevert,
                OperationReason: req.OperationReason,
                Notes:           req.Notes,
        }</span>
}

func (s *PositionService) VacatePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.VacatePositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        return s.vacatePosition(ctx, tenantID, code, req, operator, events.EventAssignmentVacated, "VacatePosition")
}</span>

func (s *PositionService) vacatePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.VacatePositionRequest, operator types.OperatedByInfo, eventType, operation string) (*types.PositionResponse, error) <span class="cov0" title="0">{
        if err := s.validatePosition("VacatePosition", func(v validator.PositionValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateVacatePosition(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">assignmentID, err := uuid.Parse(strings.TrimSpace(req.AssignmentID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignmentId must be UUID: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.validateAssignment("CloseAssignment", func(v validator.AssignmentValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateCloseAssignment(ctx, tenantID, code, assignmentID, &amp;types.CloseAssignmentRequest{
                        EndDate:         req.EffectiveDate,
                        OperationReason: req.OperationReason,
                        Notes:           req.Notes,
                })
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">assignment, err := s.assignments.GetByID(ctx, tx, tenantID, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if assignment == nil || assignment.PositionCode != current.Code </span><span class="cov0" title="0">{
                return nil, ErrAssignmentNotFound
        }</span>

        <span class="cov0" title="0">if strings.EqualFold(assignment.AssignmentStatus, "ENDED") </span><span class="cov0" title="0">{
                return nil, s.newAssignmentStateError("VacatePosition", assignment)
        }</span>

        <span class="cov0" title="0">effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effectiveDate: %w", err)
        }</span>
        <span class="cov0" title="0">if effectiveDate.Before(assignment.EffectiveDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("effectiveDate cannot be earlier than assignment effective date")
        }</span>

        <span class="cov0" title="0">var notes *string
        if req.Notes != nil </span><span class="cov0" title="0">{
                text := strings.TrimSpace(*req.Notes)
                if text != "" </span><span class="cov0" title="0">{
                        notes = &amp;text
                }</span>
        }

        <span class="cov0" title="0">if err := s.assignments.CloseAssignment(ctx, tx, tenantID, assignmentID, effectiveDate, notes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">assignment.AssignmentStatus = "ENDED"
        assignment.EndDate = sql.NullTime{Time: effectiveDate, Valid: true}

        activeFTE, err := s.assignments.SumActiveFTE(ctx, tx, tenantID, current.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status := strings.ToUpper(current.Status)
        switch </span>{
        case activeFTE &gt;= current.HeadcountCapacity:<span class="cov0" title="0">
                status = "FILLED"</span>
        case activeFTE &gt; 0:<span class="cov0" title="0">
                status = "PARTIALLY_FILLED"</span>
        default:<span class="cov0" title="0">
                status = "VACANT"</span>
        }

        <span class="cov0" title="0">opID, opName := resolveOperator(operator)
        if err := s.positions.UpdatePositionHeadcount(ctx, tx, tenantID, current.RecordID, activeFTE, status, "VACATE", opName, opID, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updated, err := s.positions.GetPositionByRecordID(ctx, tx, tenantID, current.RecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if updated == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">assignments, err := s.assignments.ListByPosition(ctx, tx, tenantID, updated.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":               updated.Code,
                "assignmentId":       assignment.AssignmentID.String(),
                "headcountInUse":     updated.HeadcountInUse,
                "positionStatus":     updated.Status,
                "assignmentEndDate":  effectiveDate.Format("2006-01-02"),
                "assignmentPrevious": assignment.AssignmentStatus,
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, operation, updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishAssignmentEvent(ctx, tx, tenantID, eventType, operation, assignment, updated, map[string]interface{}{
                "operationReason": strings.TrimSpace(req.OperationReason),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(updated, assignments), nil</span>
}

// TODO-TEMPORARY: 临时 Transfer 实现，仅在 Stage1 过渡使用（Owner: 命令服务组，Deadline: 2025-11-15，Plan: 引入统一岗位调动服务并删除此实现）
func (s *PositionService) TransferPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.TransferPositionRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        if err := s.validatePosition("TransferPosition", func(v validator.PositionValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateTransferPosition(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        current, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">targetOrg, err := s.orgRepo.GetByCode(ctx, tenantID, req.TargetOrganizationCode)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "组织不存在") </span><span class="cov0" title="0">{
                        return nil, ErrOrganizationNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">opID, opName := resolveOperator(operator)
        if err := s.positions.UpdatePositionOrganization(ctx, tx, tenantID, current.RecordID, targetOrg.Code, &amp;targetOrg.Name, current.Status, "TRANSFER", opID, opName, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updated, err := s.positions.GetPositionByRecordID(ctx, tx, tenantID, current.RecordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if updated == nil </span><span class="cov0" title="0">{
                return nil, ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">assignments, err := s.assignments.ListByPosition(ctx, tx, tenantID, updated.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":             updated.Code,
                "organizationCode": updated.OrganizationCode,
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, "TransferPosition", updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishPositionEvent(ctx, tx, tenantID, events.EventPositionUpdated, "TransferPosition", updated, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(updated, assignments), nil</span>
}

func (s *PositionService) ApplyEvent(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionEventRequest, operator types.OperatedByInfo) (*types.PositionResponse, error) <span class="cov0" title="0">{
        if err := s.validatePosition("ApplyPositionEvent", func(v validator.PositionValidationService) *validator.ValidationResult </span><span class="cov0" title="0">{
                return v.ValidateApplyEvent(ctx, tenantID, code, req)
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tx, err := s.positions.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var target *types.Position
        if req.RecordID != nil &amp;&amp; strings.TrimSpace(*req.RecordID) != "" </span><span class="cov0" title="0">{
                recordUUID, parseErr := uuid.Parse(strings.TrimSpace(*req.RecordID))
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("recordId must be UUID: %w", parseErr)
                }</span>
                <span class="cov0" title="0">target, err = s.positions.GetPositionByRecordID(ctx, tx, tenantID, recordUUID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if target == nil </span><span class="cov0" title="0">{
                        return nil, ErrPositionNotFound
                }</span>
        } else<span class="cov0" title="0"> {
                target, err = s.positions.GetCurrentPosition(ctx, tx, tenantID, code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if target == nil </span><span class="cov0" title="0">{
                        return nil, ErrPositionNotFound
                }</span>
        }

        <span class="cov0" title="0">eventType := strings.ToUpper(strings.TrimSpace(req.EventType))
        opID, opName := resolveOperator(operator)

        switch eventType </span>{
        case "SUSPEND", "INACTIVE":<span class="cov0" title="0">
                payload := map[string]interface{}{
                        "event":         eventType,
                        "effectiveDate": req.EffectiveDate,
                }
                if err := s.positions.UpdatePositionStatus(ctx, tx, tenantID, target.RecordID, "INACTIVE", payload, "SUSPEND", opName, opID, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case "REACTIVATE", "ACTIVATE":<span class="cov0" title="0">
                payload := map[string]interface{}{
                        "event":         eventType,
                        "effectiveDate": req.EffectiveDate,
                }
                if err := s.positions.UpdatePositionStatus(ctx, tx, tenantID, target.RecordID, "ACTIVE", payload, "REACTIVATE", opName, opID, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case "DELETE":<span class="cov0" title="0">
                if err := s.positions.DeletePositionVersion(ctx, tx, tenantID, target.RecordID, opID, opName, stringPointer(req.OperationReason)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := s.positions.RecalculatePositionTimeline(ctx, tx, tenantID, target.Code); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %v", ErrPositionTimelineUpdate, err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, ErrInvalidTransition</span>
        }

        <span class="cov0" title="0">updated, err := s.positions.GetCurrentPosition(ctx, tx, tenantID, target.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if updated == nil </span><span class="cov0" title="0">{
                updated = target
        }</span>

        <span class="cov0" title="0">after := map[string]interface{}{
                "code":      updated.Code,
                "eventType": eventType,
                "status":    updated.Status,
        }
        if err := s.logPositionEvent(ctx, tx, operator, tenantID, audit.EventTypeUpdate, "ApplyPositionEvent", updated.RecordID, after); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.publishPositionEvent(ctx, tx, tenantID, events.EventPositionUpdated, "ApplyPositionEvent", updated, map[string]interface{}{
                "eventType": eventType,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toPositionResponse(updated, nil), nil</span>
}

func (s *PositionService) resolveJobCatalog(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, groupCode string, groupRecord *string, familyCode string, familyRecord *string, roleCode string, roleRecord *string, levelCode string, levelRecord *string) (*jobCatalogSnapshot, error) <span class="cov0" title="0">{
        group, err := s.lookupFamilyGroup(ctx, tx, tenantID, groupCode, groupRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>

        <span class="cov0" title="0">family, err := s.lookupJobFamily(ctx, tx, tenantID, familyCode, familyRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if family == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>
        <span class="cov0" title="0">if family.FamilyGroupCode != group.Code || family.ParentRecord != group.RecordID </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogMismatch
        }</span>

        <span class="cov0" title="0">role, err := s.lookupJobRole(ctx, tx, tenantID, roleCode, roleRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if role == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>
        <span class="cov0" title="0">if role.FamilyCode != family.Code || role.ParentRecord != family.RecordID </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogMismatch
        }</span>

        <span class="cov0" title="0">level, err := s.lookupJobLevel(ctx, tx, tenantID, levelCode, levelRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if level == nil </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogNotFound
        }</span>
        <span class="cov0" title="0">if level.RoleCode != role.Code || level.ParentRecord != role.RecordID </span><span class="cov0" title="0">{
                return nil, ErrJobCatalogMismatch
        }</span>

        <span class="cov0" title="0">return &amp;jobCatalogSnapshot{
                group:  group,
                family: family,
                role:   role,
                level:  level,
        }, nil</span>
}

func (s *PositionService) lookupFamilyGroup(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID *string) (*types.JobFamilyGroup, error) <span class="cov0" title="0">{
        if recordID != nil &amp;&amp; *recordID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(*recordID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid jobFamilyGroupRecordId: %w", err)
                }</span>
                <span class="cov0" title="0">group, err := s.jobCatalog.GetFamilyGroupByRecordID(ctx, tx, tenantID, id)
                if err != nil || group == nil </span><span class="cov0" title="0">{
                        return group, err
                }</span>
                <span class="cov0" title="0">if group.Code != code </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogMismatch
                }</span>
                <span class="cov0" title="0">return group, nil</span>
        }
        <span class="cov0" title="0">return s.jobCatalog.GetCurrentFamilyGroup(ctx, tx, tenantID, code)</span>
}

func (s *PositionService) lookupJobFamily(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID *string) (*types.JobFamily, error) <span class="cov0" title="0">{
        if recordID != nil &amp;&amp; *recordID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(*recordID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid jobFamilyRecordId: %w", err)
                }</span>
                <span class="cov0" title="0">family, err := s.jobCatalog.GetJobFamilyByRecordID(ctx, tx, tenantID, id)
                if err != nil || family == nil </span><span class="cov0" title="0">{
                        return family, err
                }</span>
                <span class="cov0" title="0">if family.Code != code </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogMismatch
                }</span>
                <span class="cov0" title="0">return family, nil</span>
        }
        <span class="cov0" title="0">return s.jobCatalog.GetCurrentJobFamily(ctx, tx, tenantID, code)</span>
}

func (s *PositionService) lookupJobRole(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID *string) (*types.JobRole, error) <span class="cov0" title="0">{
        if recordID != nil &amp;&amp; *recordID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(*recordID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid jobRoleRecordId: %w", err)
                }</span>
                <span class="cov0" title="0">role, err := s.jobCatalog.GetJobRoleByRecordID(ctx, tx, tenantID, id)
                if err != nil || role == nil </span><span class="cov0" title="0">{
                        return role, err
                }</span>
                <span class="cov0" title="0">if role.Code != code </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogMismatch
                }</span>
                <span class="cov0" title="0">return role, nil</span>
        }
        <span class="cov0" title="0">return s.jobCatalog.GetCurrentJobRole(ctx, tx, tenantID, code)</span>
}

func (s *PositionService) lookupJobLevel(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string, recordID *string) (*types.JobLevel, error) <span class="cov0" title="0">{
        if recordID != nil &amp;&amp; *recordID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(*recordID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid jobLevelRecordId: %w", err)
                }</span>
                <span class="cov0" title="0">level, err := s.jobCatalog.GetJobLevelByRecordID(ctx, tx, tenantID, id)
                if err != nil || level == nil </span><span class="cov0" title="0">{
                        return level, err
                }</span>
                <span class="cov0" title="0">if level.Code != code </span><span class="cov0" title="0">{
                        return nil, ErrJobCatalogMismatch
                }</span>
                <span class="cov0" title="0">return level, nil</span>
        }
        <span class="cov0" title="0">return s.jobCatalog.GetCurrentJobLevel(ctx, tx, tenantID, code)</span>
}

func (s *PositionService) buildPositionEntity(tenantID uuid.UUID, code string, req *types.PositionRequest, catalog *jobCatalogSnapshot, org *types.Organization, operator types.OperatedByInfo, isNew bool) (*types.Position, error) <span class="cov0" title="0">{
        effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid effectiveDate: %w", err)
        }</span>

        <span class="cov0" title="0">var profileBytes []byte
        if req.Profile != nil &amp;&amp; strings.TrimSpace(*req.Profile) != "" </span><span class="cov0" title="0">{
                raw := strings.TrimSpace(*req.Profile)
                if !json.Valid([]byte(raw)) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("profile must be a valid JSON object")
                }</span>
                <span class="cov0" title="0">profileBytes = []byte(raw)</span>
        } else<span class="cov0" title="0"> {
                profileBytes = []byte("{}")
        }</span>

        <span class="cov0" title="0">opID, opName := resolveOperator(operator)
        status := "PLANNED"
        if req.Status != nil &amp;&amp; strings.TrimSpace(*req.Status) != "" </span><span class="cov0" title="0">{
                status = strings.ToUpper(strings.TrimSpace(*req.Status))
        }</span>

        <span class="cov0" title="0">headcountInUse := 0.0
        if req.HeadcountInUse != nil </span><span class="cov0" title="0">{
                headcountInUse = *req.HeadcountInUse
        }</span>

        <span class="cov0" title="0">if req.HeadcountCapacity &lt; 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidHeadcount
        }</span>
        <span class="cov0" title="0">if headcountInUse &lt; 0 || headcountInUse &gt; req.HeadcountCapacity </span><span class="cov0" title="0">{
                return nil, ErrInvalidHeadcount
        }</span>

        <span class="cov0" title="0">today := time.Now().UTC().Truncate(24 * time.Hour)
        isCurrent := !effectiveDate.After(today)

        entity := &amp;types.Position{
                TenantID:             tenantID,
                Code:                 code,
                Title:                strings.TrimSpace(req.Title),
                JobProfileCode:       toNullString(req.JobProfileCode),
                JobProfileName:       toNullString(req.JobProfileName),
                JobFamilyGroupCode:   catalog.group.Code,
                JobFamilyGroupName:   catalog.group.Name,
                JobFamilyGroupRecord: catalog.group.RecordID,
                JobFamilyCode:        catalog.family.Code,
                JobFamilyName:        catalog.family.Name,
                JobFamilyRecord:      catalog.family.RecordID,
                JobRoleCode:          catalog.role.Code,
                JobRoleName:          catalog.role.Name,
                JobRoleRecord:        catalog.role.RecordID,
                JobLevelCode:         catalog.level.Code,
                JobLevelName:         catalog.level.Name,
                JobLevelRecord:       catalog.level.RecordID,
                OrganizationCode:     org.Code,
                OrganizationName:     toNullString(stringPointer(org.Name)),
                PositionType:         strings.ToUpper(strings.TrimSpace(req.PositionType)),
                Status:               status,
                EmploymentType:       strings.ToUpper(strings.TrimSpace(req.EmploymentType)),
                HeadcountCapacity:    req.HeadcountCapacity,
                HeadcountInUse:       headcountInUse,
                GradeLevel:           toNullString(req.GradeLevel),
                CostCenterCode:       toNullString(req.CostCenterCode),
                ReportsToPosition:    toNullString(req.ReportsToPositionCode),
                Profile:              profileBytes,
                EffectiveDate:        effectiveDate,
                EndDate:              sql.NullTime{Valid: false},
                IsCurrent:            isCurrent,
                OperationType:        "CREATE",
                OperatedByID:         opID,
                OperatedByName:       opName,
                OperationReason:      toNullString(&amp;req.OperationReason),
        }

        return entity, nil</span>
}

func (s *PositionService) toPositionResponse(entity *types.Position, assignments []types.PositionAssignment) *types.PositionResponse <span class="cov0" title="0">{
        availableHeadcount := entity.HeadcountCapacity - entity.HeadcountInUse
        if availableHeadcount &lt; 0 </span><span class="cov0" title="0">{
                availableHeadcount = 0
        }</span>

        <span class="cov0" title="0">var organizationName *string
        if entity.OrganizationName.Valid </span><span class="cov0" title="0">{
                val := entity.OrganizationName.String
                organizationName = &amp;val
        }</span>

        <span class="cov0" title="0">var jobProfileCode *string
        if entity.JobProfileCode.Valid </span><span class="cov0" title="0">{
                val := entity.JobProfileCode.String
                jobProfileCode = &amp;val
        }</span>

        <span class="cov0" title="0">var jobProfileName *string
        if entity.JobProfileName.Valid </span><span class="cov0" title="0">{
                val := entity.JobProfileName.String
                jobProfileName = &amp;val
        }</span>

        <span class="cov0" title="0">var gradeLevel *string
        if entity.GradeLevel.Valid </span><span class="cov0" title="0">{
                val := entity.GradeLevel.String
                gradeLevel = &amp;val
        }</span>

        <span class="cov0" title="0">var costCenter *string
        if entity.CostCenterCode.Valid </span><span class="cov0" title="0">{
                val := entity.CostCenterCode.String
                costCenter = &amp;val
        }</span>

        <span class="cov0" title="0">var reportsTo *string
        if entity.ReportsToPosition.Valid </span><span class="cov0" title="0">{
                val := entity.ReportsToPosition.String
                reportsTo = &amp;val
        }</span>

        <span class="cov0" title="0">var endDate *time.Time
        if entity.EndDate.Valid </span><span class="cov0" title="0">{
                endDate = &amp;entity.EndDate.Time
        }</span>

        <span class="cov0" title="0">isFuture := entity.EffectiveDate.After(time.Now().UTC().Truncate(24 * time.Hour))

        response := &amp;types.PositionResponse{
                Code:                  entity.Code,
                Title:                 entity.Title,
                JobProfileCode:        jobProfileCode,
                JobProfileName:        jobProfileName,
                JobFamilyGroupCode:    entity.JobFamilyGroupCode,
                JobFamilyGroupName:    entity.JobFamilyGroupName,
                JobFamilyCode:         entity.JobFamilyCode,
                JobFamilyName:         entity.JobFamilyName,
                JobRoleCode:           entity.JobRoleCode,
                JobRoleName:           entity.JobRoleName,
                JobLevelCode:          entity.JobLevelCode,
                JobLevelName:          entity.JobLevelName,
                OrganizationCode:      entity.OrganizationCode,
                OrganizationName:      organizationName,
                PositionType:          entity.PositionType,
                Status:                entity.Status,
                EmploymentType:        entity.EmploymentType,
                HeadcountCapacity:     entity.HeadcountCapacity,
                HeadcountInUse:        entity.HeadcountInUse,
                AvailableHeadcount:    availableHeadcount,
                GradeLevel:            gradeLevel,
                CostCenterCode:        costCenter,
                ReportsToPositionCode: reportsTo,
                EffectiveDate:         entity.EffectiveDate,
                EndDate:               endDate,
                IsCurrent:             entity.IsCurrent,
                IsFuture:              isFuture,
                RecordID:              entity.RecordID,
                CreatedAt:             entity.CreatedAt,
                UpdatedAt:             entity.UpdatedAt,
        }

        if len(assignments) &gt; 0 </span><span class="cov0" title="0">{
                var history []types.PositionAssignmentResponse
                var current *types.PositionAssignmentResponse

                for _, assignment := range assignments </span><span class="cov0" title="0">{
                        resp := toAssignmentResponse(assignment)
                        history = append(history, resp)
                        if assignment.IsCurrent &amp;&amp; strings.EqualFold(assignment.AssignmentStatus, "ACTIVE") </span><span class="cov0" title="0">{
                                assignmentCopy := resp
                                current = &amp;assignmentCopy
                        }</span>
                }

                <span class="cov0" title="0">response.AssignmentHistory = history
                response.CurrentAssignment = current</span>
        }

        <span class="cov0" title="0">return response</span>
}

func toAssignmentResponse(entity types.PositionAssignment) types.PositionAssignmentResponse <span class="cov0" title="0">{
        var employeeNumber *string
        if entity.EmployeeNumber.Valid </span><span class="cov0" title="0">{
                val := strings.TrimSpace(entity.EmployeeNumber.String)
                if val != "" </span><span class="cov0" title="0">{
                        employeeNumber = &amp;val
                }</span>
        }

        <span class="cov0" title="0">var endDate *time.Time
        if entity.EndDate.Valid </span><span class="cov0" title="0">{
                endDate = &amp;entity.EndDate.Time
        }</span>

        <span class="cov0" title="0">var actingUntil *time.Time
        if entity.ActingUntil.Valid </span><span class="cov0" title="0">{
                actingUntil = &amp;entity.ActingUntil.Time
        }</span>

        <span class="cov0" title="0">var reminderSentAt *time.Time
        if entity.ReminderSentAt.Valid </span><span class="cov0" title="0">{
                reminderSentAt = &amp;entity.ReminderSentAt.Time
        }</span>

        <span class="cov0" title="0">var notes *string
        if entity.Notes.Valid </span><span class="cov0" title="0">{
                val := strings.TrimSpace(entity.Notes.String)
                if val != "" </span><span class="cov0" title="0">{
                        notes = &amp;val
                }</span>
        }

        <span class="cov0" title="0">return types.PositionAssignmentResponse{
                AssignmentID:     entity.AssignmentID,
                PositionCode:     entity.PositionCode,
                PositionRecordID: entity.PositionRecordID,
                EmployeeID:       entity.EmployeeID,
                EmployeeName:     entity.EmployeeName,
                EmployeeNumber:   employeeNumber,
                AssignmentType:   entity.AssignmentType,
                AssignmentStatus: entity.AssignmentStatus,
                FTE:              entity.FTE,
                EffectiveDate:    entity.EffectiveDate,
                EndDate:          endDate,
                ActingUntil:      actingUntil,
                AutoRevert:       entity.AutoRevert,
                ReminderSentAt:   reminderSentAt,
                IsCurrent:        entity.IsCurrent,
                Notes:            notes,
                CreatedAt:        entity.CreatedAt,
                UpdatedAt:        entity.UpdatedAt,
        }</span>
}

func (s *PositionService) logPositionEvent(ctx context.Context, tx *sql.Tx, operator types.OperatedByInfo, tenantID uuid.UUID, eventType, action string, recordID uuid.UUID, after map[string]interface{}) error <span class="cov0" title="0">{
        if s.auditLogger == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">opID, opName := resolveOperator(operator)
        actorID := strings.TrimSpace(operator.ID)
        actorType := audit.ActorTypeUser
        if actorID == "" </span><span class="cov0" title="0">{
                actorType = audit.ActorTypeSystem
                actorID = opID.String()
        }</span>

        <span class="cov0" title="0">actorName := strings.TrimSpace(operator.Name)
        if actorName == "" </span><span class="cov0" title="0">{
                actorName = opName
        }</span>

        <span class="cov0" title="0">requestID := orgmiddleware.GetRequestID(ctx)
        correlationID := orgmiddleware.GetCorrelationID(ctx)
        sourceCorrelation := ""
        if src := orgmiddleware.GetCorrelationSource(ctx); src == "header" </span><span class="cov0" title="0">{
                sourceCorrelation = src
        }</span>

        <span class="cov0" title="0">positionCode := ""
        if v, ok := after["code"].(string); ok </span><span class="cov0" title="0">{
                positionCode = strings.TrimSpace(v)
        }</span>

        <span class="cov0" title="0">event := &amp;audit.AuditEvent{
                TenantID:          tenantID,
                EventType:         eventType,
                ResourceType:      audit.ResourceTypePosition,
                ResourceID:        recordID.String(),
                RecordID:          recordID,
                EntityCode:        positionCode,
                ActorID:           actorID,
                ActorType:         actorType,
                ActorName:         actorName,
                ActionName:        action,
                RequestID:         requestID,
                CorrelationID:     correlationID,
                SourceCorrelation: sourceCorrelation,
                Success:           true,
                AfterData:         after,
                ContextPayload:    after,
        }

        if err := s.auditLogger.LogEventInTransaction(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("[AUDIT] failed to log position event: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PositionService) publishPositionEvent(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, eventType, operation string, position *types.Position, extra map[string]interface{}) error <span class="cov0" title="0">{
        if position == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attrs := map[string]interface{}{
                "title":              position.Title,
                "status":             position.Status,
                "organizationCode":   position.OrganizationCode,
                "jobFamilyGroupCode": position.JobFamilyGroupCode,
                "jobFamilyCode":      position.JobFamilyCode,
                "jobRoleCode":        position.JobRoleCode,
                "jobLevelCode":       position.JobLevelCode,
                "headcountCapacity":  position.HeadcountCapacity,
                "headcountInUse":     position.HeadcountInUse,
        }
        if position.OrganizationName.Valid </span><span class="cov0" title="0">{
                attrs["organizationName"] = strings.TrimSpace(position.OrganizationName.String)
        }</span>
        <span class="cov0" title="0">attrs = mergeAttributes(attrs, extra)

        eventCtx := s.newEventContext(ctx, tenantID, operation)
        outboxEvent, err := events.NewPositionEvent(eventType, eventCtx, position.Code, attrs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.saveOutboxEvent(ctx, tx, outboxEvent)</span>
}

func (s *PositionService) publishAssignmentEvent(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, eventType, operation string, assignment *types.PositionAssignment, position *types.Position, extra map[string]interface{}) error <span class="cov0" title="0">{
        if assignment == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attrs := map[string]interface{}{
                "assignmentStatus": assignment.AssignmentStatus,
                "assignmentType":   assignment.AssignmentType,
                "employeeId":       assignment.EmployeeID.String(),
                "employeeName":     assignment.EmployeeName,
                "fte":              assignment.FTE,
                "autoRevert":       assignment.AutoRevert,
                "effectiveDate":    assignment.EffectiveDate.Format("2006-01-02"),
        }
        if assignment.EmployeeNumber.Valid </span><span class="cov0" title="0">{
                attrs["employeeNumber"] = strings.TrimSpace(assignment.EmployeeNumber.String)
        }</span>
        <span class="cov0" title="0">if assignment.EndDate.Valid </span><span class="cov0" title="0">{
                attrs["endDate"] = assignment.EndDate.Time.Format("2006-01-02")
        }</span>
        <span class="cov0" title="0">if assignment.ActingUntil.Valid </span><span class="cov0" title="0">{
                attrs["actingUntil"] = assignment.ActingUntil.Time.Format("2006-01-02")
        }</span>
        <span class="cov0" title="0">if position != nil </span><span class="cov0" title="0">{
                attrs["positionStatus"] = position.Status
                attrs["headcountInUse"] = position.HeadcountInUse
                attrs["headcountCapacity"] = position.HeadcountCapacity
        }</span>
        <span class="cov0" title="0">attrs = mergeAttributes(attrs, extra)

        eventCtx := s.newEventContext(ctx, tenantID, operation)
        outboxEvent, err := events.NewAssignmentEvent(eventType, eventCtx, assignment.AssignmentID.String(), assignment.PositionCode, attrs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.saveOutboxEvent(ctx, tx, outboxEvent)</span>
}

func (s *PositionService) saveOutboxEvent(ctx context.Context, tx *sql.Tx, outboxEvent *database.OutboxEvent) error <span class="cov0" title="0">{
        if s.outboxRepo == nil || outboxEvent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if tx == nil </span><span class="cov0" title="0">{
                return errors.New("outbox requires active transaction")
        }</span>
        <span class="cov0" title="0">if err := s.outboxRepo.Save(ctx, database.WrapSQLTx(tx), outboxEvent); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("[OUTBOX] failed to enqueue %s: %v", outboxEvent.EventType, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *PositionService) newEventContext(ctx context.Context, tenantID uuid.UUID, operation string) events.Context <span class="cov0" title="0">{
        return events.Context{
                TenantID:      tenantID,
                RequestID:     orgmiddleware.GetRequestID(ctx),
                CorrelationID: orgmiddleware.GetCorrelationID(ctx),
                Operation:     operation,
                Source:        events.DefaultSourceCommand,
        }
}</span>

func mergeAttributes(base map[string]interface{}, extra map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        if extra == nil || len(extra) == 0 </span><span class="cov0" title="0">{
                return base
        }</span>
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                base = map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">for k, v := range extra </span><span class="cov0" title="0">{
                if k == "" || v == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">base[k] = v</span>
        }
        <span class="cov0" title="0">return base</span>
}

func toNullString(value *string) sql.NullString <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return sql.NullString{}
        }</span>
        <span class="cov0" title="0">trimmed := strings.TrimSpace(*value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return sql.NullString{}
        }</span>
        <span class="cov0" title="0">return sql.NullString{String: trimmed, Valid: true}</span>
}

func stringPointer(value string) *string <span class="cov0" title="0">{
        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">v := value
        return &amp;v</span>
}

func resolveOperator(operator types.OperatedByInfo) (uuid.UUID, string) <span class="cov0" title="0">{
        if operator.ID != "" </span><span class="cov0" title="0">{
                if parsed, err := uuid.Parse(operator.ID); err == nil </span><span class="cov0" title="0">{
                        name := operator.Name
                        if strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                                name = "system"
                        }</span>
                        <span class="cov0" title="0">return parsed, name</span>
                }
        }
        <span class="cov0" title="0">return uuid.Nil, defaultOperatorName(operator.Name)</span>
}

func defaultOperatorName(name string) string <span class="cov0" title="0">{
        if strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                return "system"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(name)</span>
}

func valueOrDefault(val *string, fallback string) string <span class="cov0" title="0">{
        if val == nil || strings.TrimSpace(*val) == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(*val)</span>
}

func valueOrDefaultFloat(val *float64, fallback float64) float64 <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return *val</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package utils

import (
        "strconv"
        "sync"

        "github.com/prometheus/client_golang/prometheus"
)

const (
        OperationCreate     = "create"
        OperationUpdate     = "update"
        OperationDelete     = "delete"
        OperationSuspend    = "suspend"
        OperationReactivate = "reactivate"

        StatusSuccess = "success"
        StatusError   = "error"
)

var (
        registerOnce sync.Once

        temporalOperationsTotal *prometheus.CounterVec
        auditWritesTotal        *prometheus.CounterVec
        httpRequestsTotal       *prometheus.CounterVec
        outboxDispatchTotal     *prometheus.CounterVec
)

func ensureRegistered() <span class="cov0" title="0">{
        registerOnce.Do(func() </span><span class="cov0" title="0">{
                temporalOperationsTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "temporal_operations_total",
                                Help: "Total number of temporal operations grouped by operation type and outcome.",
                        },
                        []string{"operation", "status"},
                )

                auditWritesTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "audit_writes_total",
                                Help: "Total number of audit log writes grouped by outcome.",
                        },
                        []string{"status"},
                )

                httpRequestsTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "http_requests_total",
                                Help: "Total HTTP requests handled by the command service grouped by method, route, and status code.",
                        },
                        []string{"method", "route", "status"},
                )

                outboxDispatchTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "outbox_dispatch_total",
                                Help: "Total number of outbox dispatch operations grouped by result and event type",
                        },
                        []string{"result", "event_type"},
                )

                prometheus.MustRegister(temporalOperationsTotal, auditWritesTotal, httpRequestsTotal, outboxDispatchTotal)
        }</span>)
}

func RecordTemporalOperation(operation string, err error) <span class="cov0" title="0">{
        ensureRegistered()

        status := StatusSuccess
        if err != nil </span><span class="cov0" title="0">{
                status = StatusError
        }</span>

        <span class="cov0" title="0">temporalOperationsTotal.WithLabelValues(operation, status).Inc()</span>
}

func RecordAuditWrite(err error) <span class="cov0" title="0">{
        ensureRegistered()

        status := StatusSuccess
        if err != nil </span><span class="cov0" title="0">{
                status = StatusError
        }</span>

        <span class="cov0" title="0">auditWritesTotal.WithLabelValues(status).Inc()</span>
}

func RecordHTTPRequest(method, route string, statusCode int) <span class="cov0" title="0">{
        ensureRegistered()

        code := strconv.Itoa(statusCode)
        httpRequestsTotal.WithLabelValues(method, route, code).Inc()
}</span>

// RecordOutboxDispatch 记录 outbox 中继的派发结果。
func RecordOutboxDispatch(result, eventType string) <span class="cov0" title="0">{
        ensureRegistered()
        if eventType == "" </span><span class="cov0" title="0">{
                eventType = "unknown"
        }</span>
        <span class="cov0" title="0">outboxDispatchTotal.WithLabelValues(result, eventType).Inc()</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package utils

import "strings"

const RootParentCode = "0000000"

var legacyRootCodes = []string{"0", RootParentCode}

// NormalizeParentCodePointer normalizes parent code input by trimming spaces and
// treating legacy root codes ("0"、"0000000") 或空值为 nil，以便服务内部统一使用 nil 表示根节点。
// 返回的指针会指向一个新的字符串副本，避免直接引用调用方的可变变量。
func NormalizeParentCodePointer(value *string) *string <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">trimmed := strings.TrimSpace(*value)
        if trimmed == "" || IsRootParentCode(trimmed) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">normalized := trimmed
        return &amp;normalized</span>
}

// IsRootParentCode 判断给定的父组织编码是否代表根节点占位符。
func IsRootParentCode(value string) bool <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(value)
        for _, candidate := range legacyRootCodes </span><span class="cov8" title="1">{
                if trimmed == candidate </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"
)

// APIResponse 统一API响应结构
type APIResponse struct {
        Success   bool        `json:"success"`
        Data      interface{} `json:"data,omitempty"`
        Error     *APIError   `json:"error,omitempty"`
        Message   string      `json:"message,omitempty"`
        Timestamp string      `json:"timestamp"`
        RequestID string      `json:"requestId,omitempty"`
        Meta      *Meta       `json:"meta,omitempty"`
}

// APIError API错误结构
type APIError struct {
        Code    string      `json:"code"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
        Stack   string      `json:"stack,omitempty"`
}

// Meta 元数据信息
type Meta struct {
        Version       string            `json:"version,omitempty"`
        ExecutionTime string            `json:"executionTime,omitempty"`
        Server        string            `json:"server,omitempty"`
        Headers       map[string]string `json:"headers,omitempty"`
        Path          string            `json:"path,omitempty"`
        Method        string            `json:"method,omitempty"`
}

// ValidationError 验证错误详情
type ValidationError struct {
        Field   string      `json:"field"`
        Value   interface{} `json:"value,omitempty"`
        Message string      `json:"message"`
        Code    string      `json:"code,omitempty"`
        Context interface{} `json:"context,omitempty"`
}

// PaginationMeta 分页元数据
type PaginationMeta struct {
        Total       int64 `json:"total"`
        Page        int   `json:"page"`
        Limit       int   `json:"limit"`
        TotalPages  int   `json:"totalPages"`
        HasNext     bool  `json:"hasNext"`
        HasPrevious bool  `json:"hasPrevious"`
}

// ResponseBuilder API响应构建器
type ResponseBuilder struct {
        response *APIResponse
}

// NewResponseBuilder 创建响应构建器
func NewResponseBuilder() *ResponseBuilder <span class="cov8" title="1">{
        return &amp;ResponseBuilder{
                response: &amp;APIResponse{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                },
        }
}</span>

// Success 设置成功状态
func (rb *ResponseBuilder) Success(success bool) *ResponseBuilder <span class="cov0" title="0">{
        rb.response.Success = success
        return rb
}</span>

// Data 设置响应数据
func (rb *ResponseBuilder) Data(data interface{}) *ResponseBuilder <span class="cov8" title="1">{
        rb.response.Data = data
        rb.response.Success = true
        return rb
}</span>

// Error 设置错误信息
func (rb *ResponseBuilder) Error(code, message string, details interface{}) *ResponseBuilder <span class="cov8" title="1">{
        rb.response.Success = false
        rb.response.Error = &amp;APIError{
                Code:    code,
                Message: message,
                Details: details,
        }
        return rb
}</span>

// ValidationErrors 设置验证错误
func (rb *ResponseBuilder) ValidationErrors(errors []ValidationError) *ResponseBuilder <span class="cov8" title="1">{
        rb.response.Success = false
        rb.response.Error = &amp;APIError{
                Code:    "VALIDATION_ERROR",
                Message: "输入验证失败",
                Details: map[string]interface{}{
                        "validationErrors": errors,
                        "errorCount":       len(errors),
                },
        }
        return rb
}</span>

// Message 设置消息
func (rb *ResponseBuilder) Message(message string) *ResponseBuilder <span class="cov8" title="1">{
        rb.response.Message = message
        return rb
}</span>

// RequestID 设置请求ID
func (rb *ResponseBuilder) RequestID(requestID string) *ResponseBuilder <span class="cov8" title="1">{
        rb.response.RequestID = requestID
        return rb
}</span>

// Meta 设置元数据
func (rb *ResponseBuilder) Meta(meta *Meta) *ResponseBuilder <span class="cov0" title="0">{
        rb.response.Meta = meta
        return rb
}</span>

// WithExecutionTime 添加执行时间
func (rb *ResponseBuilder) WithExecutionTime(startTime time.Time) *ResponseBuilder <span class="cov8" title="1">{
        if rb.response.Meta == nil </span><span class="cov8" title="1">{
                rb.response.Meta = &amp;Meta{}
        }</span>
        <span class="cov8" title="1">rb.response.Meta.ExecutionTime = time.Since(startTime).String()
        return rb</span>
}

// WithPagination 添加分页信息
func (rb *ResponseBuilder) WithPagination(pagination *PaginationMeta) *ResponseBuilder <span class="cov8" title="1">{
        if rb.response.Meta == nil </span><span class="cov0" title="0">{
                rb.response.Meta = &amp;Meta{}
        }</span>
        <span class="cov8" title="1">if rb.response.Meta.Headers == nil </span><span class="cov8" title="1">{
                rb.response.Meta.Headers = make(map[string]string)
        }</span>
        <span class="cov8" title="1">rb.response.Meta.Headers["X-Total-Count"] = fmt.Sprintf("%d", pagination.Total)
        rb.response.Meta.Headers["X-Page"] = fmt.Sprintf("%d", pagination.Page)
        rb.response.Meta.Headers["X-Limit"] = fmt.Sprintf("%d", pagination.Limit)

        // 将分页信息也添加到data中
        if rb.response.Data != nil </span><span class="cov8" title="1">{
                if dataMap, ok := rb.response.Data.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        dataMap["pagination"] = pagination
                }</span>
        }

        <span class="cov8" title="1">return rb</span>
}

// Build 构建最终响应
func (rb *ResponseBuilder) Build() *APIResponse <span class="cov0" title="0">{
        return rb.response
}</span>

// WriteJSON 写入JSON响应
func (rb *ResponseBuilder) WriteJSON(w http.ResponseWriter, statusCode int) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.Header().Set("X-Frame-Options", "DENY")
        w.Header().Set("X-XSS-Protection", "1; mode=block")

        // 设置CORS头部
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Accept, Authorization, Content-Type, X-CSRF-Token, X-Tenant-ID")

        // 添加请求ID到响应头
        if rb.response.RequestID != "" </span><span class="cov8" title="1">{
                w.Header().Set("X-Request-ID", rb.response.RequestID)
        }</span>

        <span class="cov8" title="1">w.WriteHeader(statusCode)
        return json.NewEncoder(w).Encode(rb.response)</span>
}

// 快捷方法

// WriteSuccess 快速写入成功响应
func WriteSuccess(w http.ResponseWriter, data interface{}, message, requestID string) error <span class="cov8" title="1">{
        return NewResponseBuilder().
                Data(data).
                Message(message).
                RequestID(requestID).
                WriteJSON(w, http.StatusOK)
}</span>

// WriteCreated 快速写入创建成功响应
func WriteCreated(w http.ResponseWriter, data interface{}, message, requestID string) error <span class="cov8" title="1">{
        return NewResponseBuilder().
                Data(data).
                Message(message).
                RequestID(requestID).
                WriteJSON(w, http.StatusCreated)
}</span>

// WriteError 快速写入错误响应
func WriteError(w http.ResponseWriter, statusCode int, code, message, requestID string, details interface{}) error <span class="cov8" title="1">{
        return NewResponseBuilder().
                Error(code, message, details).
                RequestID(requestID).
                WriteJSON(w, statusCode)
}</span>

// WriteBadRequest 快速写入400错误
func WriteBadRequest(w http.ResponseWriter, code, message, requestID string, details interface{}) error <span class="cov0" title="0">{
        return WriteError(w, http.StatusBadRequest, code, message, requestID, details)
}</span>

// WriteNotFound 快速写入404错误
func WriteNotFound(w http.ResponseWriter, message, requestID string) error <span class="cov8" title="1">{
        return WriteError(w, http.StatusNotFound, "NOT_FOUND", message, requestID, nil)
}</span>

// WriteUnauthorized 快速写入401错误
func WriteUnauthorized(w http.ResponseWriter, requestID string) error <span class="cov8" title="1">{
        return WriteError(w, http.StatusUnauthorized, "UNAUTHORIZED", "未授权访问", requestID, nil)
}</span>

// WriteForbidden 快速写入403错误
func WriteForbidden(w http.ResponseWriter, requestID string) error <span class="cov8" title="1">{
        return WriteError(w, http.StatusForbidden, "FORBIDDEN", "访问被禁止", requestID, nil)
}</span>

// WriteConflict 快速写入409错误
func WriteConflict(w http.ResponseWriter, code, message, requestID string, details interface{}) error <span class="cov0" title="0">{
        return WriteError(w, http.StatusConflict, code, message, requestID, details)
}</span>

// WriteInternalError 快速写入500错误
func WriteInternalError(w http.ResponseWriter, requestID string, details interface{}) error <span class="cov8" title="1">{
        return WriteError(w, http.StatusInternalServerError, "INTERNAL_ERROR", "服务器内部错误", requestID, details)
}</span>

// WriteValidationError 快速写入验证错误响应
func WriteValidationError(w http.ResponseWriter, errors []ValidationError, requestID string) error <span class="cov8" title="1">{
        return NewResponseBuilder().
                ValidationErrors(errors).
                RequestID(requestID).
                WriteJSON(w, http.StatusBadRequest)
}</span>

// ConvertValidationError 转换验证错误为标准格式
func ConvertValidationError(field, message string, value interface{}) ValidationError <span class="cov8" title="1">{
        return ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
                Code:    "FIELD_INVALID",
        }
}</span>

// ConvertValidationErrors 转换多个验证错误
func ConvertValidationErrors(errs map[string]string) []ValidationError <span class="cov8" title="1">{
        var validationErrors []ValidationError
        for field, message := range errs </span><span class="cov8" title="1">{
                validationErrors = append(validationErrors, ConvertValidationError(field, message, nil))
        }</span>
        <span class="cov8" title="1">return validationErrors</span>
}

// WriteHealthCheck 写入健康检查响应
func WriteHealthCheck(w http.ResponseWriter, service string, healthy bool, details interface{}, requestID string) error <span class="cov0" title="0">{
        status := "unhealthy"
        statusCode := http.StatusServiceUnavailable

        if healthy </span><span class="cov0" title="0">{
                status = "healthy"
                statusCode = http.StatusOK
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "service": service,
                "status":  status,
                "details": details,
        }

        return NewResponseBuilder().
                Data(data).
                Success(healthy).
                Message(fmt.Sprintf("Service %s status check", service)).
                RequestID(requestID).
                WriteJSON(w, statusCode)</span>
}

// WriteList 写入列表响应（带分页）
func WriteList(w http.ResponseWriter, items interface{}, pagination *PaginationMeta, message, requestID string) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "items": items,
        }

        if pagination != nil </span><span class="cov0" title="0">{
                data["pagination"] = pagination
        }</span>

        <span class="cov0" title="0">return NewResponseBuilder().
                Data(data).
                Message(message).
                RequestID(requestID).
                WithPagination(pagination).
                WriteJSON(w, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package utils

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "cube-castle/internal/types"
)

var (
        organizationCodeRegex       = regexp.MustCompile(types.OrganizationCodePattern)
        organizationParentCodeRegex = regexp.MustCompile(types.OrganizationParentCodePattern)
        validUnitTypes              = map[types.UnitType]struct{}{
                types.UnitTypeDepartment:       {},
                types.UnitTypeOrganizationUnit: {},
                types.UnitTypeCompany:          {},
                types.UnitTypeProjectTeam:      {},
        }
)

// ValidateOrganizationCode 验证组织代码格式
func ValidateOrganizationCode(code string) error <span class="cov8" title="1">{
        if code == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("组织代码不能为空")
        }</span>

        <span class="cov8" title="1">if !organizationCodeRegex.MatchString(code) </span><span class="cov8" title="1">{
                return fmt.Errorf("组织代码格式无效，必须为7位数字且首位不可为0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateSuspendRequest 验证停用请求
func ValidateSuspendRequest(reason string) error <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(reason)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(trimmed) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("停用原因至少需要5个字符")
        }</span>

        <span class="cov0" title="0">if len(trimmed) &gt; 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("停用原因不能超过200个字符")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateActivateRequest 验证激活请求
func ValidateActivateRequest(reason string) error <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(reason)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(trimmed) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("激活原因至少需要5个字符")
        }</span>

        <span class="cov0" title="0">if len(trimmed) &gt; 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("激活原因不能超过200个字符")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateCreateVersionRequest 验证创建版本请求 (基于OpenAPI契约v4.4.0)
func ValidateCreateVersionRequest(req *types.CreateVersionRequest) error <span class="cov8" title="1">{
        // 1. 名称验证
        if strings.TrimSpace(req.Name) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("组织名称不能为空")
        }</span>

        <span class="cov8" title="1">if len(req.Name) &gt; types.OrganizationNameMaxLength </span><span class="cov0" title="0">{
                return fmt.Errorf("组织名称不能超过%d个字符", types.OrganizationNameMaxLength)
        }</span>

        // 名称格式验证 - 支持Unicode字符
        <span class="cov8" title="1">namePattern := regexp.MustCompile(`^[\p{L}\p{N}\s\-]+$`)
        if !namePattern.MatchString(req.Name) </span><span class="cov0" title="0">{
                return fmt.Errorf("组织名称包含无效字符，只允许字母、数字、中文、空格和连字符")
        }</span>

        // 2. 组织类型验证
        <span class="cov8" title="1">if req.UnitType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("组织类型不能为空")
        }</span>

        <span class="cov8" title="1">if _, ok := validUnitTypes[types.UnitType(req.UnitType)]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("无效的组织类型: %s", req.UnitType)
        }</span>

        // 3. 父组织代码验证（如果提供）
        <span class="cov8" title="1">if req.ParentCode != nil </span><span class="cov8" title="1">{
                normalizedParent := NormalizeParentCodePointer(req.ParentCode)
                req.ParentCode = normalizedParent
                if normalizedParent != nil </span><span class="cov8" title="1">{
                        if !organizationParentCodeRegex.MatchString(*normalizedParent) </span><span class="cov8" title="1">{
                                return fmt.Errorf("父组织代码格式无效，需为0或合法的7位数字编码")
                        }</span>
                }
        }

        // 4. 描述验证（如果提供）
        <span class="cov8" title="1">if req.Description != nil &amp;&amp; len(*req.Description) &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("描述长度不能超过1000个字符")
        }</span>

        // 5. 排序顺序验证（如果提供）
        <span class="cov8" title="1">if req.SortOrder != nil </span><span class="cov8" title="1">{
                if *req.SortOrder &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("排序顺序不能为负数")
                }</span>
                <span class="cov8" title="1">if *req.SortOrder &gt; 9999 </span><span class="cov0" title="0">{
                        return fmt.Errorf("排序顺序不能超过9999")
                }</span>
        }

        // 6. 生效日期验证
        <span class="cov8" title="1">if req.EffectiveDate == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("生效日期不能为空")
        }</span>

        <span class="cov8" title="1">effectiveDate, err := time.Parse("2006-01-02", req.EffectiveDate)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("生效日期格式无效，必须为YYYY-MM-DD格式: %v", err)
        }</span>

        // 7. 失效日期验证（如果提供）
        <span class="cov8" title="1">if req.EndDate != nil &amp;&amp; *req.EndDate != "" </span><span class="cov8" title="1">{
                endDate, err := time.Parse("2006-01-02", *req.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("失效日期格式无效，必须为YYYY-MM-DD格式: %v", err)
                }</span>

                <span class="cov8" title="1">if !endDate.After(effectiveDate) </span><span class="cov8" title="1">{
                        return fmt.Errorf("失效日期必须晚于生效日期")
                }</span>
        }

        // 8. 操作原因验证（可选）
        <span class="cov8" title="1">trimmedReason := strings.TrimSpace(req.OperationReason)
        if trimmedReason != "" </span><span class="cov8" title="1">{
                if len(trimmedReason) &lt; 5 </span><span class="cov8" title="1">{
                        return fmt.Errorf("操作原因至少需要5个字符")
                }</span>

                <span class="cov8" title="1">if len(trimmedReason) &gt; types.OrganizationOperationReasonMaxLength </span><span class="cov0" title="0">{
                        return fmt.Errorf("操作原因不能超过%d个字符", types.OrganizationOperationReasonMaxLength)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package validator

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "time"

        "cube-castle/internal/organization/repository"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// BusinessRuleValidator 业务规则验证器
type BusinessRuleValidator struct {
        hierarchyRepo hierarchyRepository
        orgRepo       organizationRepository
        logger        pkglogger.Logger
}

type hierarchyRepository interface {
        GetOrganization(ctx context.Context, code string, tenantID uuid.UUID) (*types.Organization, error)
        GetOrganizationDepth(ctx context.Context, code string, tenantID uuid.UUID) (int, error)
        GetAncestorChain(ctx context.Context, code string, tenantID uuid.UUID) ([]repository.OrganizationNode, error)
        GetDirectChildren(ctx context.Context, code string, tenantID uuid.UUID) ([]repository.OrganizationNode, error)
        GetOrganizationAtDate(ctx context.Context, code string, tenantID uuid.UUID, ts time.Time) (*repository.OrganizationNode, error)
}

type organizationRepository interface {
        GetByCode(ctx context.Context, tenantID uuid.UUID, code string) (*types.Organization, error)
}

// ValidationResult 验证结果
type ValidationResult struct {
        Valid    bool                   `json:"valid"`
        Errors   []ValidationError      `json:"errors"`
        Warnings []ValidationWarning    `json:"warnings"`
        Context  map[string]interface{} `json:"context"`
}

// NewValidationResult 创建默认有效的验证结果
func NewValidationResult() *ValidationResult <span class="cov8" title="1">{
        return &amp;ValidationResult{
                Valid:    true,
                Errors:   []ValidationError{},
                Warnings: []ValidationWarning{},
                Context:  make(map[string]interface{}),
        }
}</span>

// ValidationError 验证错误
type ValidationError struct {
        Code     string                 `json:"code"`
        Message  string                 `json:"message"`
        Field    string                 `json:"field,omitempty"`
        Value    interface{}            `json:"value,omitempty"`
        Severity string                 `json:"severity"` // CRITICAL, HIGH, MEDIUM, LOW
        Context  map[string]interface{} `json:"context,omitempty"`
}

// ValidationWarning 验证警告
type ValidationWarning struct {
        Code    string      `json:"code"`
        Message string      `json:"message"`
        Field   string      `json:"field,omitempty"`
        Value   interface{} `json:"value,omitempty"`
}

// 业务规则错误代码
const (
        // 层级结构规则
        ErrorCodeDepthExceeded      = "DEPTH_EXCEEDED"
        ErrorCodeCircularReference  = "CIRCULAR_REFERENCE"
        ErrorCodeOrphanOrganization = "ORPHAN_ORGANIZATION"
        ErrorCodeInvalidParent      = "INVALID_PARENT"

        // 数据一致性规则
        ErrorCodePathInconsistency  = "PATH_INCONSISTENCY"
        ErrorCodeLevelInconsistency = "LEVEL_INCONSISTENCY"
        ErrorCodeDuplicateCode      = "DUPLICATE_CODE"

        // 业务逻辑规则
        ErrorCodeInvalidStatus    = "INVALID_STATUS"
        ErrorCodeStatusConflict   = "STATUS_CONFLICT"
        ErrorCodeTemporalConflict = "TEMPORAL_CONFLICT"
        ErrorCodePermissionDenied = "PERMISSION_DENIED"
)

var validUnitTypes = map[string]struct{}{
        string(types.UnitTypeDepartment):       {},
        string(types.UnitTypeOrganizationUnit): {},
        string(types.UnitTypeCompany):          {},
        string(types.UnitTypeProjectTeam):      {},
}

var validOrganizationStatuses = map[string]struct{}{
        string(types.OrganizationStatusActive):   {},
        string(types.OrganizationStatusInactive): {},
        string(types.OrganizationStatusPlanned):  {},
        string(types.OrganizationStatusDeleted):  {},
}

var (
        organizationCodeRegex       = regexp.MustCompile(types.OrganizationCodePattern)
        organizationParentCodeRegex = regexp.MustCompile(types.OrganizationParentCodePattern)
        organizationNameRegex       = regexp.MustCompile(`^[\p{L}\p{N}\s\-\(\)（）]+$`)
)

func NewBusinessRuleValidator(hierarchyRepo *repository.HierarchyRepository, orgRepo *repository.OrganizationRepository, baseLogger pkglogger.Logger) *BusinessRuleValidator <span class="cov8" title="1">{
        return &amp;BusinessRuleValidator{
                hierarchyRepo: hierarchyRepo,
                orgRepo:       orgRepo,
                logger: baseLogger.WithFields(pkglogger.Fields{
                        "component": "validator",
                        "module":    "organization",
                }),
        }
}</span>

// ValidateOrganizationCreation 验证组织创建
func (v *BusinessRuleValidator) ValidateOrganizationCreation(ctx context.Context, req *types.CreateOrganizationRequest, tenantID uuid.UUID) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        v.validateCreateRequestBasics(req, result)

        selfReferentialParent := false
        if req.Code != nil &amp;&amp; req.ParentCode != nil &amp;&amp; strings.EqualFold(*req.Code, *req.ParentCode) </span><span class="cov8" title="1">{
                selfReferentialParent = true
                result.Errors = append(result.Errors, ValidationError{
                        Code:     "ORG_CYCLE_DETECTED",
                        Message:  "Organization cannot be its own parent",
                        Field:    "parentCode",
                        Severity: string(SeverityCritical),
                        Context: map[string]interface{}{
                                "ruleId":          "ORG-CIRC",
                                "attemptedParent": *req.ParentCode,
                        },
                })
        }</span>

        <span class="cov8" title="1">if req.ParentCode != nil &amp;&amp; *req.ParentCode != "" </span><span class="cov8" title="1">{
                if selfReferentialParent </span><span class="cov8" title="1">{
                        result.Valid = false
                        return result
                }</span>

                <span class="cov8" title="1">parent, err := v.hierarchyRepo.GetOrganization(ctx, *req.ParentCode, tenantID)
                if err != nil || parent == nil </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     ErrorCodeInvalidParent,
                                Message:  fmt.Sprintf("父组织不存在或无效: %s", *req.ParentCode),
                                Field:    "parentCode",
                                Severity: string(SeverityHigh),
                        })
                        result.Valid = false
                        return result
                }</span>

                <span class="cov8" title="1">result.Context["parent_organization"] = parent
                if strings.EqualFold(parent.Status, "INACTIVE") || strings.EqualFold(parent.Status, "DELETED") </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Code:    "PARENT_INACTIVE",
                                Message: fmt.Sprintf("父组织状态为 %s，可能影响子组织功能", parent.Status),
                                Field:   "parentCode",
                                Value:   parent.Status,
                        })
                }</span>
        }

        <span class="cov8" title="1">chain := v.buildOrganizationCreateChain(req)
        subject := &amp;organizationCreateSubject{
                TenantID: tenantID,
                Request:  req,
        }

        outcome := chain.Execute(ctx, subject)
        result.Errors = append(result.Errors, outcome.Errors...)
        result.Warnings = append(result.Warnings, outcome.Warnings...)
        for k, v := range outcome.Context </span><span class="cov8" title="1">{
                result.Context[k] = v
        }</span>

        <span class="cov8" title="1">if req.Code != nil </span><span class="cov8" title="1">{
                if err := v.validateCodeUniqueness(ctx, *req.Code, tenantID, result); err != nil </span><span class="cov8" title="1">{
                        v.logger.Warnf("代码唯一性验证失败: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if err := v.validateTemporalData(req.EffectiveDate, req.EndDate, result); err != nil </span><span class="cov8" title="1">{
                v.logger.Warnf("时态数据验证失败: %v", err)
        }</span>

        <span class="cov8" title="1">result.Valid = len(result.Errors) == 0
        return result</span>
}

// ValidateOrganizationUpdate 验证组织更新
func (v *BusinessRuleValidator) ValidateOrganizationUpdate(ctx context.Context, code string, req *types.UpdateOrganizationRequest, tenantID uuid.UUID) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        // 1. 验证目标组织存在
        existingOrg, err := v.hierarchyRepo.GetOrganization(ctx, code, tenantID)
        if err != nil </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Code:     "ORGANIZATION_NOT_FOUND",
                        Message:  fmt.Sprintf("目标组织不存在: %s", code),
                        Value:    code,
                        Severity: string(SeverityCritical),
                })
                result.Valid = false
                return result
        }</span>

        <span class="cov8" title="1">result.Context["existing_organization"] = existingOrg

        v.validateUpdateRequestBasics(req, result, existingOrg)

        if req.EffectiveDate != nil || req.EndDate != nil </span><span class="cov0" title="0">{
                if err := v.validateTemporalData(req.EffectiveDate, req.EndDate, result); err != nil </span><span class="cov0" title="0">{
                        v.logger.Warnf("时态数据验证失败: %v", err)
                }</span>
        }

        <span class="cov8" title="1">chain := v.buildOrganizationUpdateChain(existingOrg, req)

        subject := &amp;organizationUpdateSubject{
                TenantID: tenantID,
                Code:     code,
                Request:  req,
                Existing: existingOrg,
        }

        outcome := chain.Execute(ctx, subject)
        result.Errors = append(result.Errors, outcome.Errors...)
        result.Warnings = append(result.Warnings, outcome.Warnings...)
        for k, v := range outcome.Context </span><span class="cov8" title="1">{
                result.Context[k] = v
        }</span>

        <span class="cov8" title="1">result.Valid = len(result.Errors) == 0
        return result</span>
}

// ValidateTemporalParentAvailability 提供给 handler 的时态父级校验入口
func (v *BusinessRuleValidator) ValidateTemporalParentAvailability(ctx context.Context, tenantID uuid.UUID, parentCode string, effectiveDate time.Time) *ValidationResult <span class="cov8" title="1">{
        parent := strings.TrimSpace(parentCode)
        chain := NewValidationChain(
                v.logger,
                WithOperationLabel("TemporalParentAvailability"),
                WithBaseContext(map[string]interface{}{
                        "operation": "TemporalParentAvailability",
                }),
        )
        chain.Register(&amp;Rule{
                ID:           "ORG-TEMPORAL",
                Priority:     10,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      v.newOrgTemporalRule(parent, &amp;effectiveDate),
        })

        result := chain.Execute(ctx, &amp;organizationUpdateSubject{
                TenantID: tenantID,
        })
        result.Valid = len(result.Errors) == 0
        return result
}</span>

// validateCodeUniqueness 验证代码唯一性
func (v *BusinessRuleValidator) validateCodeUniqueness(ctx context.Context, code string, tenantID uuid.UUID, result *ValidationResult) error <span class="cov8" title="1">{
        _, err := v.hierarchyRepo.GetOrganization(ctx, code, tenantID)
        if err == nil </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Code:     ErrorCodeDuplicateCode,
                        Message:  fmt.Sprintf("组织代码 %s 已存在", code),
                        Field:    "code",
                        Value:    code,
                        Severity: string(SeverityHigh),
                })
                return fmt.Errorf("duplicate code: %s", code)
        }</span>

        <span class="cov8" title="1">return nil</span> // 组织不存在，代码可用
}

// validateTemporalData 验证时态数据
func (v *BusinessRuleValidator) validateTemporalData(effectiveDate, endDate *types.Date, result *ValidationResult) error <span class="cov8" title="1">{
        if effectiveDate == nil </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Code:    "MISSING_EFFECTIVE_DATE",
                        Message: "未指定生效日期，将使用当前日期",
                        Field:   "effectiveDate",
                })
                return nil
        }</span>

        <span class="cov8" title="1">if endDate != nil &amp;&amp; effectiveDate != nil </span><span class="cov8" title="1">{
                if endDate.Before(effectiveDate.Time) </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     ErrorCodeTemporalConflict,
                                Message:  "结束日期不能早于生效日期",
                                Field:    "endDate",
                                Value:    endDate.String(),
                                Severity: "MEDIUM",
                        })
                        return fmt.Errorf("temporal conflict: endDate &lt; effectiveDate")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (v *BusinessRuleValidator) validateCreateRequestBasics(req *types.CreateOrganizationRequest, result *ValidationResult) <span class="cov8" title="1">{
        req.Name = strings.TrimSpace(req.Name)
        if req.Name == "" </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Code:     "ORG_NAME_REQUIRED",
                        Message:  "组织名称不能为空",
                        Field:    "name",
                        Severity: string(SeverityHigh),
                })
        }</span> else<span class="cov8" title="1"> {
                if len(req.Name) &gt; types.OrganizationNameMaxLength </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_NAME_TOO_LONG",
                                Message:  fmt.Sprintf("组织名称不能超过%d个字符", types.OrganizationNameMaxLength),
                                Field:    "name",
                                Severity: string(SeverityHigh),
                        })
                }</span>
                <span class="cov8" title="1">if !organizationNameRegex.MatchString(req.Name) </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_NAME_INVALID",
                                Message:  "组织名称包含无效字符，只允许字母、数字、中文、空格、连字符和括号",
                                Field:    "name",
                                Severity: string(SeverityHigh),
                        })
                }</span>
        }

        <span class="cov8" title="1">unitType := strings.TrimSpace(req.UnitType)
        if unitType == "" </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, ValidationError{
                        Code:     "ORG_UNIT_TYPE_REQUIRED",
                        Message:  "组织类型不能为空",
                        Field:    "unitType",
                        Severity: string(SeverityHigh),
                })
        }</span> else<span class="cov8" title="1"> {
                unitTypeUpper := strings.ToUpper(unitType)
                if _, ok := validUnitTypes[unitTypeUpper]; !ok </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_UNIT_TYPE_INVALID",
                                Message:  fmt.Sprintf("无效的组织类型: %s", unitType),
                                Field:    "unitType",
                                Value:    unitType,
                                Severity: string(SeverityHigh),
                        })
                }</span> else<span class="cov8" title="1"> {
                        req.UnitType = unitTypeUpper
                }</span>
        }

        <span class="cov8" title="1">if req.Code != nil </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(*req.Code)
                if trimmed == "" </span><span class="cov0" title="0">{
                        req.Code = nil
                }</span> else<span class="cov8" title="1"> if !organizationCodeRegex.MatchString(trimmed) </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_CODE_INVALID",
                                Message:  "组织代码格式无效，必须为7位数字且首位不可为0",
                                Field:    "code",
                                Value:    trimmed,
                                Severity: string(SeverityHigh),
                        })
                }</span> else<span class="cov8" title="1"> {
                        req.Code = &amp;trimmed
                }</span>
        }

        <span class="cov8" title="1">if req.ParentCode != nil </span><span class="cov8" title="1">{
                trimmedParent := strings.TrimSpace(*req.ParentCode)
                if trimmedParent == "" </span><span class="cov0" title="0">{
                        req.ParentCode = nil
                }</span> else<span class="cov8" title="1"> if !organizationParentCodeRegex.MatchString(trimmedParent) </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_PARENT_INVALID",
                                Message:  "父组织代码格式无效，需为0或合法的7位数字编码",
                                Field:    "parentCode",
                                Value:    trimmedParent,
                                Severity: string(SeverityHigh),
                        })
                        req.ParentCode = nil
                }</span> else<span class="cov8" title="1"> {
                        req.ParentCode = &amp;trimmedParent
                }</span>
        }

        <span class="cov8" title="1">if req.SortOrder &lt; 0 || req.SortOrder &gt; 9999 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Code:     "ORG_SORT_ORDER_INVALID",
                        Message:  "排序顺序需在0到9999之间",
                        Field:    "sortOrder",
                        Value:    req.SortOrder,
                        Severity: string(SeverityHigh),
                })
        }</span>

        <span class="cov8" title="1">req.Description = strings.TrimSpace(req.Description)
        if len(req.Description) &gt; types.OrganizationDescriptionMaxLength </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Code:     "ORG_DESCRIPTION_TOO_LONG",
                        Message:  fmt.Sprintf("描述长度不能超过%d个字符", types.OrganizationDescriptionMaxLength),
                        Field:    "description",
                        Severity: string(SeverityHigh),
                })
        }</span>
}

func (v *BusinessRuleValidator) validateUpdateRequestBasics(req *types.UpdateOrganizationRequest, result *ValidationResult, existing *types.Organization) <span class="cov8" title="1">{
        if req.Name != nil </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(*req.Name)
                if trimmed == "" </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_NAME_REQUIRED",
                                Message:  "组织名称不能为空",
                                Field:    "name",
                                Severity: string(SeverityHigh),
                        })
                }</span> else<span class="cov8" title="1"> {
                        if len(trimmed) &gt; types.OrganizationNameMaxLength </span><span class="cov0" title="0">{
                                result.Errors = append(result.Errors, ValidationError{
                                        Code:     "ORG_NAME_TOO_LONG",
                                        Message:  fmt.Sprintf("组织名称不能超过%d个字符", types.OrganizationNameMaxLength),
                                        Field:    "name",
                                        Severity: string(SeverityHigh),
                                })
                        }</span>
                        <span class="cov8" title="1">if !organizationNameRegex.MatchString(trimmed) </span><span class="cov0" title="0">{
                                result.Errors = append(result.Errors, ValidationError{
                                        Code:     "ORG_NAME_INVALID",
                                        Message:  "组织名称包含无效字符，只允许字母、数字、中文、空格、连字符和括号",
                                        Field:    "name",
                                        Severity: string(SeverityHigh),
                                })
                        }</span>
                        <span class="cov8" title="1">req.Name = &amp;trimmed</span>
                }
        }

        <span class="cov8" title="1">if req.UnitType != nil </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(*req.UnitType)
                if trimmed == "" </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_UNIT_TYPE_REQUIRED",
                                Message:  "组织类型不能为空",
                                Field:    "unitType",
                                Severity: string(SeverityHigh),
                        })
                }</span> else<span class="cov0" title="0"> {
                        unitTypeUpper := strings.ToUpper(trimmed)
                        if _, ok := validUnitTypes[unitTypeUpper]; !ok </span><span class="cov0" title="0">{
                                result.Errors = append(result.Errors, ValidationError{
                                        Code:     "ORG_UNIT_TYPE_INVALID",
                                        Message:  fmt.Sprintf("无效的组织类型: %s", trimmed),
                                        Field:    "unitType",
                                        Value:    trimmed,
                                        Severity: string(SeverityHigh),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                req.UnitType = &amp;unitTypeUpper
                        }</span>
                }
        }

        <span class="cov8" title="1">if req.ParentCode != nil </span><span class="cov8" title="1">{
                trimmedParent := strings.TrimSpace(*req.ParentCode)
                if trimmedParent == "" </span><span class="cov0" title="0">{
                        req.ParentCode = nil
                }</span> else<span class="cov8" title="1"> if !organizationParentCodeRegex.MatchString(trimmedParent) </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_PARENT_INVALID",
                                Message:  "父组织代码格式无效，需为0或合法的7位数字编码",
                                Field:    "parentCode",
                                Value:    trimmedParent,
                                Severity: string(SeverityHigh),
                        })
                        req.ParentCode = nil
                }</span> else<span class="cov8" title="1"> {
                        req.ParentCode = &amp;trimmedParent
                }</span>
        }

        <span class="cov8" title="1">if req.SortOrder != nil </span><span class="cov8" title="1">{
                if *req.SortOrder &lt; 0 || *req.SortOrder &gt; 9999 </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_SORT_ORDER_INVALID",
                                Message:  "排序顺序需在0到9999之间",
                                Field:    "sortOrder",
                                Value:    *req.SortOrder,
                                Severity: string(SeverityHigh),
                        })
                }</span>
        }

        <span class="cov8" title="1">if req.Status != nil </span><span class="cov8" title="1">{
                trimmedStatus := strings.ToUpper(strings.TrimSpace(*req.Status))
                if trimmedStatus == "" </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_STATUS_REQUIRED",
                                Message:  "状态不能为空",
                                Field:    "status",
                                Severity: string(SeverityHigh),
                        })
                }</span> else<span class="cov8" title="1"> if _, ok := validOrganizationStatuses[trimmedStatus]; !ok </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_STATUS_INVALID",
                                Message:  fmt.Sprintf("无效的组织状态: %s", trimmedStatus),
                                Field:    "status",
                                Value:    trimmedStatus,
                                Severity: string(SeverityHigh),
                        })
                }</span> else<span class="cov8" title="1"> {
                        req.Status = &amp;trimmedStatus
                }</span>
        }

        <span class="cov8" title="1">if req.Description != nil </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(*req.Description)
                if len(trimmed) &gt; types.OrganizationDescriptionMaxLength </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "ORG_DESCRIPTION_TOO_LONG",
                                Message:  fmt.Sprintf("描述长度不能超过%d个字符", types.OrganizationDescriptionMaxLength),
                                Field:    "description",
                                Severity: string(SeverityHigh),
                        })
                }</span>
                <span class="cov8" title="1">req.Description = &amp;trimmed</span>
        }

        // 当未提供新状态时，保持现有状态写回上下文，便于后续规则判断。
        <span class="cov8" title="1">if req.Status == nil &amp;&amp; existing != nil </span><span class="cov8" title="1">{
                result.Context["existingStatus"] = strings.ToUpper(strings.TrimSpace(existing.Status))
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package validator

import (
        "context"
        "errors"
        "io"
        "net/http"
        "sort"
        "strings"
        "sync"
        "time"

        pkglogger "cube-castle/pkg/logger"
)

// RuleSeverity 标准化严重级别枚举，保持与审计/错误码对齐。
type RuleSeverity string

const (
        SeverityCritical RuleSeverity = "CRITICAL"
        SeverityHigh     RuleSeverity = "HIGH"
        SeverityMedium   RuleSeverity = "MEDIUM"
        SeverityLow      RuleSeverity = "LOW"

        defaultRulePriority = 100
)

// RuleHandler 执行单条规则，返回增量校验结果。
type RuleHandler func(ctx context.Context, subject interface{}) (*RuleOutcome, error)

// RuleOutcome 表示规则执行后产生的错误、警告及附加上下文。
type RuleOutcome struct {
        Errors   []ValidationError
        Warnings []ValidationWarning
        Context  map[string]interface{}
}

// Rule 定义链式执行中的单条业务校验规则。
type Rule struct {
        ID            string
        Description   string
        Severity      RuleSeverity
        Priority      int
        ShortCircuit  bool
        Handler       RuleHandler
        TelemetryOnly bool // 如为 true，失败不会影响 Valid（后续规则仍可执行）
}

// ValidationChain 负责按照优先级顺序执行规则并聚合结果。
type ValidationChain struct {
        mu          sync.RWMutex
        rules       []*Rule
        sorted      bool
        baseContext map[string]interface{}
        logger      pkglogger.Logger
        operation   string
}

// ChainOption 配置链式执行器。
type ChainOption func(*ValidationChain)

// WithBaseContext 预设链路级上下文，会注入到最终 ValidationResult.Context。
func WithBaseContext(ctx map[string]interface{}) ChainOption <span class="cov8" title="1">{
        return func(chain *ValidationChain) </span><span class="cov8" title="1">{
                if len(ctx) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">copied := make(map[string]interface{}, len(ctx))
                for k, v := range ctx </span><span class="cov8" title="1">{
                        copied[k] = v
                }</span>
                <span class="cov8" title="1">chain.baseContext = copied</span>
        }
}

// WithOperationLabel 为验证链记录 operation 标签，便于指标聚合。
func WithOperationLabel(operation string) ChainOption <span class="cov8" title="1">{
        return func(chain *ValidationChain) </span><span class="cov8" title="1">{
                operation = strings.TrimSpace(operation)
                if operation == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">chain.operation = operation</span>
        }
}

// NewValidationChain 创建链式执行器，若 logger 为空则使用静默记录器。
func NewValidationChain(logger pkglogger.Logger, opts ...ChainOption) *ValidationChain <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = pkglogger.NewLogger(
                        pkglogger.WithWriter(io.Discard),
                        pkglogger.WithLevel(pkglogger.LevelError),
                )
        }</span>

        <span class="cov8" title="1">chain := &amp;ValidationChain{
                rules:       make([]*Rule, 0),
                baseContext: map[string]interface{}{},
                logger: logger.WithFields(pkglogger.Fields{
                        "component": "validator",
                        "layer":     "chain",
                }),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                if opt != nil </span><span class="cov8" title="1">{
                        opt(chain)
                }</span>
        }
        <span class="cov8" title="1">return chain</span>
}

// Register 向链式执行器注册规则。
func (c *ValidationChain) Register(rule *Rule) error <span class="cov8" title="1">{
        if rule == nil </span><span class="cov8" title="1">{
                return errors.New("validator chain: nil rule provided")
        }</span>
        <span class="cov8" title="1">ruleID := strings.TrimSpace(strings.ToUpper(rule.ID))
        if ruleID == "" </span><span class="cov0" title="0">{
                return errors.New("validator chain: rule ID is required")
        }</span>
        <span class="cov8" title="1">if rule.Handler == nil </span><span class="cov0" title="0">{
                return errors.New("validator chain: handler is required")
        }</span>

        <span class="cov8" title="1">if rule.Priority == 0 </span><span class="cov8" title="1">{
                rule.Priority = defaultRulePriority
        }</span>
        <span class="cov8" title="1">rule.ID = ruleID
        rule.Severity = normalizeSeverity(rule.Severity)

        c.mu.Lock()
        defer c.mu.Unlock()
        c.rules = append(c.rules, rule)
        c.sorted = false
        return nil</span>
}

// Execute 依次执行规则并聚合结果，支持短路控制。
func (c *ValidationChain) Execute(ctx context.Context, subject interface{}) *ValidationResult <span class="cov8" title="1">{
        overallStart := time.Now()
        result := NewValidationResult()
        for k, v := range c.baseContext </span><span class="cov8" title="1">{
                result.Context[k] = v
        }</span>

        <span class="cov8" title="1">rules := c.snapshotRules()
        executedRuleIDs := make([]string, 0, len(rules))

        for _, rule := range rules </span><span class="cov8" title="1">{
                if ctx.Err() != nil </span><span class="cov8" title="1">{
                        c.logger.WithFields(pkglogger.Fields{
                                "ruleId": rule.ID,
                                "error":  ctx.Err(),
                        }).Warn("validation chain aborted due to context cancellation")
                        result.Context["cancelled"] = true
                        break</span>
                }

                <span class="cov8" title="1">start := time.Now()
                outcome, err := rule.Handler(ctx, subject)
                duration := time.Since(start)

                c.logger.WithFields(pkglogger.Fields{
                        "ruleId":       rule.ID,
                        "durationMs":   duration.Milliseconds(),
                        "shortCircuit": rule.ShortCircuit,
                }).Debug("validation rule executed")

                executedRuleIDs = append(executedRuleIDs, rule.ID)

                ruleOutcomeLabel := ruleOutcomeLabelSuccess

                if err != nil </span><span class="cov0" title="0">{
                        c.logger.WithFields(pkglogger.Fields{
                                "ruleId": rule.ID,
                                "error":  err,
                        }).Error("validation rule execution failed")

                        result.Errors = append(result.Errors, ValidationError{
                                Code:     "VALIDATION_RULE_EXECUTION_ERROR",
                                Message:  err.Error(),
                                Severity: string(SeverityCritical),
                                Context: map[string]interface{}{
                                        "ruleId":       rule.ID,
                                        "internal":     true,
                                        "shortCircuit": rule.ShortCircuit,
                                },
                        })

                        ruleOutcomeLabel = ruleOutcomeLabelError
                        observeRuleMetrics(rule.ID, ruleOutcomeLabel, duration)

                        if rule.ShortCircuit &amp;&amp; !rule.TelemetryOnly </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if outcome == nil </span><span class="cov8" title="1">{
                        observeRuleMetrics(rule.ID, ruleOutcomeLabel, duration)
                        continue</span>
                }

                <span class="cov8" title="1">mergeRuleOutcome(result, rule, outcome)

                if len(outcome.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        ruleOutcomeLabel = ruleOutcomeLabelFailed
                }</span> else<span class="cov8" title="1"> if len(outcome.Warnings) &gt; 0 </span><span class="cov8" title="1">{
                        ruleOutcomeLabel = ruleOutcomeLabelWarning
                }</span>

                <span class="cov8" title="1">observeRuleMetrics(rule.ID, ruleOutcomeLabel, duration)

                if rule.ShortCircuit &amp;&amp; len(outcome.Errors) &gt; 0 &amp;&amp; !rule.TelemetryOnly </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if len(executedRuleIDs) &gt; 0 </span><span class="cov8" title="1">{
                result.Context["executedRules"] = executedRuleIDs
        }</span> else<span class="cov8" title="1"> if _, ok := result.Context["executedRules"]; !ok </span><span class="cov8" title="1">{
                result.Context["executedRules"] = []string{}
        }</span>

        <span class="cov8" title="1">result.Valid = len(result.Errors) == 0

        operation, _ := result.Context["operation"].(string)
        if operation == "" </span><span class="cov8" title="1">{
                operation = c.operation
        }</span>

        <span class="cov8" title="1">outcomeLabel := chainOutcomeLabelSuccess
        if cancelled, ok := result.Context["cancelled"].(bool); ok &amp;&amp; cancelled </span><span class="cov8" title="1">{
                outcomeLabel = chainOutcomeLabelCancelled
        }</span> else<span class="cov8" title="1"> if !result.Valid </span><span class="cov8" title="1">{
                outcomeLabel = chainOutcomeLabelFailed
        }</span>
        <span class="cov8" title="1">observeChainMetrics(operation, outcomeLabel, time.Since(overallStart))

        return result</span>
}

// SeverityToHTTPStatus 将严重级别映射到 HTTP 状态码，用于统一错误转换。
func SeverityToHTTPStatus(severity string) int <span class="cov8" title="1">{
        switch strings.ToUpper(strings.TrimSpace(severity)) </span>{
        case string(SeverityCritical):<span class="cov8" title="1">
                return http.StatusBadRequest</span>
        case string(SeverityHigh):<span class="cov8" title="1">
                return http.StatusBadRequest</span>
        case string(SeverityMedium):<span class="cov8" title="1">
                return http.StatusUnprocessableEntity</span>
        case string(SeverityLow):<span class="cov8" title="1">
                return http.StatusOK</span>
        default:<span class="cov8" title="1">
                return http.StatusBadRequest</span>
        }
}

func (c *ValidationChain) snapshotRules() []*Rule <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if !c.sorted </span><span class="cov8" title="1">{
                sort.SliceStable(c.rules, func(i, j int) bool </span><span class="cov8" title="1">{
                        if c.rules[i].Priority == c.rules[j].Priority </span><span class="cov0" title="0">{
                                return c.rules[i].ID &lt; c.rules[j].ID
                        }</span>
                        <span class="cov8" title="1">return c.rules[i].Priority &lt; c.rules[j].Priority</span>
                })
                <span class="cov8" title="1">c.sorted = true</span>
        }

        <span class="cov8" title="1">copied := make([]*Rule, len(c.rules))
        copy(copied, c.rules)
        return copied</span>
}

func mergeRuleOutcome(result *ValidationResult, rule *Rule, outcome *RuleOutcome) <span class="cov8" title="1">{
        if len(outcome.Context) &gt; 0 </span><span class="cov8" title="1">{
                result.Context["rule:"+rule.ID] = outcome.Context
        }</span>

        <span class="cov8" title="1">for _, errItem := range outcome.Errors </span><span class="cov8" title="1">{
                if errItem.Context == nil </span><span class="cov8" title="1">{
                        errItem.Context = map[string]interface{}{}
                }</span>
                <span class="cov8" title="1">if _, exists := errItem.Context["ruleId"]; !exists </span><span class="cov8" title="1">{
                        errItem.Context["ruleId"] = rule.ID
                }</span>
                <span class="cov8" title="1">if errItem.Severity == "" </span><span class="cov8" title="1">{
                        errItem.Severity = string(rule.Severity)
                }</span>
                <span class="cov8" title="1">result.Errors = append(result.Errors, errItem)</span>
        }

        <span class="cov8" title="1">for _, warnItem := range outcome.Warnings </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings, warnItem)
        }</span>
}

func normalizeSeverity(severity RuleSeverity) RuleSeverity <span class="cov8" title="1">{
        switch strings.ToUpper(strings.TrimSpace(string(severity))) </span>{
        case string(SeverityCritical):<span class="cov8" title="1">
                return SeverityCritical</span>
        case string(SeverityHigh):<span class="cov8" title="1">
                return SeverityHigh</span>
        case string(SeverityMedium):<span class="cov8" title="1">
                return SeverityMedium</span>
        case string(SeverityLow):<span class="cov0" title="0">
                return SeverityLow</span>
        default:<span class="cov8" title="1">
                return SeverityHigh</span>
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package validator

import (
        "fmt"
)

// ValidationFailedError 表示业务规则校验未通过，并携带完整的 ValidationResult。
type ValidationFailedError struct {
        operation string
        result    *ValidationResult
}

// NewValidationFailedError 构造校验失败错误，operation 为调用方上下文（如命令名称）。
func NewValidationFailedError(operation string, result *ValidationResult) error <span class="cov8" title="1">{
        if result == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validator: validation failed without result for %s", operation)
        }</span>
        <span class="cov8" title="1">return &amp;ValidationFailedError{
                operation: operation,
                result:    result,
        }</span>
}

func (e *ValidationFailedError) Error() string <span class="cov8" title="1">{
        if e.result == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("validation failed: %s (no details)", e.operation)
        }</span>
        <span class="cov8" title="1">if len(e.result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("validation failed: %s (%s)", e.operation, e.result.Errors[0].Code)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("validation failed: %s", e.operation)</span>
}

// Result 返回完整的验证结果。
func (e *ValidationFailedError) Result() *ValidationResult <span class="cov8" title="1">{
        return e.result
}</span>

// Operation 返回触发验证的操作名称。
func (e *ValidationFailedError) Operation() string <span class="cov8" title="1">{
        return e.operation
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package validator

import (
        "context"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/organization/repository"
        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

const (
        jobCatalogTemporalRuleID = "JC-TEMPORAL"
        jobCatalogSequenceRuleID = "JC-SEQUENCE"
        dateLayout               = "2006-01-02"

        errorCodeTemporalConflict      = "JOB_CATALOG_TEMPORAL_CONFLICT"
        errorCodeSequenceMismatch      = "JOB_CATALOG_SEQUENCE_MISMATCH"
        errorCodeSequenceMissingParent = "JOB_CATALOG_SEQUENCE_MISSING_PARENT"
        errorCodeSequenceMissingBase   = "JOB_CATALOG_SEQUENCE_MISSING_BASE"
        errorCodeTimelineUnavailable   = "JOB_CATALOG_TIMELINE_UNAVAILABLE"
)

type jobCatalogTimelineRepository interface {
        ListFamilyGroupTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        ListJobFamilyTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        ListJobRoleTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        ListJobLevelTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
}

type jobCatalogValidationService struct {
        repo   jobCatalogTimelineRepository
        logger pkglogger.Logger
}

// NewJobCatalogValidationService 构建 Job Catalog 业务规则验证器。
func NewJobCatalogValidationService(repo jobCatalogTimelineRepository, baseLogger pkglogger.Logger) JobCatalogValidationService <span class="cov8" title="1">{
        logger := baseLogger
        if logger == nil </span><span class="cov0" title="0">{
                logger = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov8" title="1">return &amp;jobCatalogValidationService{
                repo: repo,
                logger: logger.WithFields(pkglogger.Fields{
                        "component": "validator",
                        "module":    "job-catalog",
                }),
        }</span>
}

func (s *jobCatalogValidationService) ValidateCreateFamilyGroupVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest) *ValidationResult <span class="cov8" title="1">{
        cfg := jobCatalogVersionConfig{
                operation: "CreateJobFamilyGroupVersion",
                entity:    "JOB_FAMILY_GROUP",
                tenantID:  tenantID,
                code:      code,
                request:   req,
                loader:    s.repo.ListFamilyGroupTimeline,
        }
        return s.validateVersion(ctx, cfg)
}</span>

func (s *jobCatalogValidationService) ValidateCreateJobFamilyVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, parentRecordID uuid.UUID) *ValidationResult <span class="cov8" title="1">{
        cfg := jobCatalogVersionConfig{
                operation:      "CreateJobFamilyVersion",
                entity:         "JOB_FAMILY",
                tenantID:       tenantID,
                code:           code,
                request:        req,
                loader:         s.repo.ListJobFamilyTimeline,
                requireParent:  true,
                parentRecordID: &amp;parentRecordID,
        }
        return s.validateVersion(ctx, cfg)
}</span>

func (s *jobCatalogValidationService) ValidateCreateJobRoleVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, parentRecordID uuid.UUID) *ValidationResult <span class="cov8" title="1">{
        cfg := jobCatalogVersionConfig{
                operation:      "CreateJobRoleVersion",
                entity:         "JOB_ROLE",
                tenantID:       tenantID,
                code:           code,
                request:        req,
                loader:         s.repo.ListJobRoleTimeline,
                requireParent:  true,
                parentRecordID: &amp;parentRecordID,
        }
        return s.validateVersion(ctx, cfg)
}</span>

func (s *jobCatalogValidationService) ValidateCreateJobLevelVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.JobCatalogVersionRequest, parentRecordID uuid.UUID) *ValidationResult <span class="cov8" title="1">{
        cfg := jobCatalogVersionConfig{
                operation:      "CreateJobLevelVersion",
                entity:         "JOB_LEVEL",
                tenantID:       tenantID,
                code:           code,
                request:        req,
                loader:         s.repo.ListJobLevelTimeline,
                requireParent:  true,
                parentRecordID: &amp;parentRecordID,
        }
        return s.validateVersion(ctx, cfg)
}</span>

type jobCatalogVersionConfig struct {
        operation      string
        entity         string
        tenantID       uuid.UUID
        code           string
        request        *types.JobCatalogVersionRequest
        loader         func(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        requireParent  bool
        parentRecordID *uuid.UUID
}

func (s *jobCatalogValidationService) validateVersion(ctx context.Context, cfg jobCatalogVersionConfig) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()
        normalizedCode := strings.ToUpper(strings.TrimSpace(cfg.code))

        result.Context["operation"] = cfg.operation
        result.Context["catalogCode"] = normalizedCode
        result.Context["tenantId"] = cfg.tenantID.String()
        if cfg.parentRecordID != nil </span><span class="cov8" title="1">{
                result.Context["parentRecordId"] = cfg.parentRecordID.String()
        }</span>

        <span class="cov8" title="1">if cfg.request == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov8" title="1">effectiveDate, err := s.parseEffectiveDate(cfg.request.EffectiveDate)
        if err != nil </span><span class="cov8" title="1">{
                return s.invalidEffectiveDateResult(cfg.operation, normalizedCode, cfg.request.EffectiveDate)
        }</span>

        <span class="cov8" title="1">timeline, err := cfg.loader(ctx, cfg.tenantID, normalizedCode)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.WithFields(pkglogger.Fields{
                        "operation": cfg.operation,
                        "code":      normalizedCode,
                        "error":     err,
                }).Error("加载 Job Catalog 时态版本失败")
                return s.timelineFailureResult(cfg.operation, normalizedCode, err)
        }</span>

        <span class="cov8" title="1">subject := &amp;jobCatalogVersionSubject{
                TenantID:       cfg.tenantID,
                Code:           normalizedCode,
                Entity:         cfg.entity,
                EffectiveDate:  effectiveDate,
                Timeline:       timeline,
                ParentRecordID: cfg.parentRecordID,
                RequireParent:  cfg.requireParent,
        }

        chain := s.newJobCatalogChain(cfg.operation, normalizedCode, cfg.tenantID, cfg.parentRecordID)
        if err := chain.Register(&amp;Rule{
                ID:           jobCatalogTemporalRuleID,
                Priority:     10,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newJobCatalogTemporalRule(),
        }); err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{
                        "operation": cfg.operation,
                        "code":      normalizedCode,
                        "error":     err,
                }).Error("注册 JC-TEMPORAL 规则失败")
                return s.timelineFailureResult(cfg.operation, normalizedCode, err)
        }</span>

        <span class="cov8" title="1">if cfg.requireParent </span><span class="cov8" title="1">{
                if err := chain.Register(&amp;Rule{
                        ID:           jobCatalogSequenceRuleID,
                        Priority:     20,
                        Severity:     SeverityHigh,
                        ShortCircuit: true,
                        Handler:      s.newJobCatalogSequenceRule(),
                }); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithFields(pkglogger.Fields{
                                "operation": cfg.operation,
                                "code":      normalizedCode,
                                "error":     err,
                        }).Error("注册 JC-SEQUENCE 规则失败")
                        return s.timelineFailureResult(cfg.operation, normalizedCode, err)
                }</span>
        }

        <span class="cov8" title="1">return chain.Execute(ctx, subject)</span>
}

func (s *jobCatalogValidationService) parseEffectiveDate(raw string) (time.Time, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(raw)
        if trimmed == "" </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("effective date is required")
        }</span>
        <span class="cov8" title="1">return time.Parse(dateLayout, trimmed)</span>
}

func (s *jobCatalogValidationService) newJobCatalogChain(operation, code string, tenantID uuid.UUID, parent *uuid.UUID) *ValidationChain <span class="cov8" title="1">{
        ctx := map[string]interface{}{
                "operation":   operation,
                "catalogCode": code,
                "tenantId":    tenantID.String(),
        }
        if parent != nil </span><span class="cov8" title="1">{
                ctx["parentRecordId"] = parent.String()
        }</span>
        <span class="cov8" title="1">return NewValidationChain(
                s.logger,
                WithBaseContext(ctx),
                WithOperationLabel(operation),
        )</span>
}

func (s *jobCatalogValidationService) invalidEffectiveDateResult(operation, code, attempted string) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()
        result.Valid = false
        result.Context["operation"] = operation
        result.Context["catalogCode"] = code
        result.Context["executedRules"] = []string{}
        result.Errors = append(result.Errors, ValidationError{
                Code:     "INVALID_EFFECTIVE_DATE",
                Message:  fmt.Sprintf("effectiveDate must follow format %s", dateLayout),
                Field:    "effectiveDate",
                Value:    strings.TrimSpace(attempted),
                Severity: string(SeverityHigh),
                Context: map[string]interface{}{
                        "ruleId":        jobCatalogTemporalRuleID,
                        "catalogCode":   code,
                        "attemptedDate": strings.TrimSpace(attempted),
                },
        })
        return result
}</span>

func (s *jobCatalogValidationService) timelineFailureResult(operation, code string, err error) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()
        result.Valid = false
        result.Context["operation"] = operation
        result.Context["catalogCode"] = code
        result.Context["executedRules"] = []string{}
        result.Errors = append(result.Errors, ValidationError{
                Code:     errorCodeTimelineUnavailable,
                Message:  "无法加载 Job Catalog 时间线以完成校验",
                Severity: string(SeverityCritical),
                Context: map[string]interface{}{
                        "ruleId":      jobCatalogTemporalRuleID,
                        "catalogCode": code,
                        "internal":    true,
                        "error":       err.Error(),
                },
        })
        return result
}</span>

func (s *jobCatalogValidationService) newJobCatalogTemporalRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                version, ok := subject.(*jobCatalogVersionSubject)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("JC-TEMPORAL rule expects jobCatalogVersionSubject, got %T", subject)
                }</span>

                <span class="cov8" title="1">outcome := &amp;RuleOutcome{
                        Context: map[string]interface{}{
                                "ruleId":        jobCatalogTemporalRuleID,
                                "timelineSize":  len(version.Timeline),
                                "catalogCode":   version.Code,
                                "entity":        version.Entity,
                                "effectiveDate": version.EffectiveDate.Format(dateLayout),
                        },
                }

                if len(version.Timeline) == 0 </span><span class="cov8" title="1">{
                        return outcome, nil
                }</span>

                <span class="cov8" title="1">latest := version.Timeline[len(version.Timeline)-1]
                outcome.Context["latestEffective"] = latest.EffectiveDate.Format(dateLayout)
                outcome.Context["latestRecordId"] = latest.RecordID.String()

                if !version.EffectiveDate.After(latest.EffectiveDate) </span><span class="cov8" title="1">{
                        outcome.Errors = append(outcome.Errors, ValidationError{
                                Code:     errorCodeTemporalConflict,
                                Message:  fmt.Sprintf("effectiveDate %s must be after latest version %s", version.EffectiveDate.Format(dateLayout), latest.EffectiveDate.Format(dateLayout)),
                                Field:    "effectiveDate",
                                Severity: string(SeverityHigh),
                                Context: map[string]interface{}{
                                        "ruleId":             jobCatalogTemporalRuleID,
                                        "catalogCode":        version.Code,
                                        "latestEffective":    latest.EffectiveDate.Format(dateLayout),
                                        "attemptedEffective": version.EffectiveDate.Format(dateLayout),
                                        "latestRecordId":     latest.RecordID.String(),
                                },
                        })
                }</span>

                <span class="cov8" title="1">return outcome, nil</span>
        }
}

func (s *jobCatalogValidationService) newJobCatalogSequenceRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                version, ok := subject.(*jobCatalogVersionSubject)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("JC-SEQUENCE rule expects jobCatalogVersionSubject, got %T", subject)
                }</span>

                <span class="cov8" title="1">outcome := &amp;RuleOutcome{
                        Context: map[string]interface{}{
                                "ruleId":         jobCatalogSequenceRuleID,
                                "catalogCode":    version.Code,
                                "requiresParent": version.RequireParent,
                        },
                }

                if !version.RequireParent </span><span class="cov0" title="0">{
                        return outcome, nil
                }</span>

                <span class="cov8" title="1">if len(version.Timeline) == 0 </span><span class="cov8" title="1">{
                        outcome.Errors = append(outcome.Errors, ValidationError{
                                Code:     errorCodeSequenceMissingBase,
                                Message:  "cannot create version without existing timeline entries",
                                Severity: string(SeverityHigh),
                                Context: map[string]interface{}{
                                        "ruleId":      jobCatalogSequenceRuleID,
                                        "catalogCode": version.Code,
                                },
                        })
                        return outcome, nil
                }</span>

                <span class="cov8" title="1">expected := version.Timeline[len(version.Timeline)-1].RecordID
                outcome.Context["expectedParentRecordId"] = expected.String()

                if version.ParentRecordID == nil </span><span class="cov8" title="1">{
                        outcome.Errors = append(outcome.Errors, ValidationError{
                                Code:     errorCodeSequenceMissingParent,
                                Message:  "parentRecordId is required to link version sequence",
                                Field:    "parentRecordId",
                                Severity: string(SeverityHigh),
                                Context: map[string]interface{}{
                                        "ruleId":                 jobCatalogSequenceRuleID,
                                        "expectedParentRecordId": expected.String(),
                                },
                        })
                        return outcome, nil
                }</span>

                <span class="cov8" title="1">outcome.Context["providedParentRecordId"] = version.ParentRecordID.String()

                if expected != *version.ParentRecordID </span><span class="cov8" title="1">{
                        outcome.Errors = append(outcome.Errors, ValidationError{
                                Code:     errorCodeSequenceMismatch,
                                Message:  "parentRecordId does not match latest version record",
                                Field:    "parentRecordId",
                                Value:    version.ParentRecordID.String(),
                                Severity: string(SeverityHigh),
                                Context: map[string]interface{}{
                                        "ruleId":                 jobCatalogSequenceRuleID,
                                        "expectedParentRecordId": expected.String(),
                                        "providedParentRecordId": version.ParentRecordID.String(),
                                },
                        })
                }</span>

                <span class="cov8" title="1">return outcome, nil</span>
        }
}

type jobCatalogVersionSubject struct {
        TenantID       uuid.UUID
        Code           string
        Entity         string
        EffectiveDate  time.Time
        Timeline       []repository.JobCatalogTimelineEntry
        ParentRecordID *uuid.UUID
        RequireParent  bool
}

var _ JobCatalogValidationService = (*jobCatalogValidationService)(nil)
</pre>
		
		<pre class="file" id="file66" style="display: none">package validator

import (
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

const (
        ruleOutcomeLabelSuccess = "success"
        ruleOutcomeLabelWarning = "warning"
        ruleOutcomeLabelFailed  = "failed"
        ruleOutcomeLabelError   = "error"

        chainOutcomeLabelSuccess   = "success"
        chainOutcomeLabelFailed    = "failed"
        chainOutcomeLabelCancelled = "cancelled"
)

var (
        metricsOnce sync.Once

        validatorRuleDurationSeconds *prometheus.HistogramVec
        validatorRuleOutcomeTotal    *prometheus.CounterVec
        validatorChainDuration       *prometheus.HistogramVec
        validatorChainOutcomeTotal   *prometheus.CounterVec
)

func ensureValidatorMetricsRegistered() <span class="cov8" title="1">{
        metricsOnce.Do(func() </span><span class="cov8" title="1">{
                validatorRuleDurationSeconds = prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "validator_rule_duration_seconds",
                                Help:    "Histogram of validation rule execution durations.",
                                Buckets: prometheus.DefBuckets,
                        },
                        []string{"rule_id"},
                )

                validatorRuleOutcomeTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "validator_rule_outcome_total",
                                Help: "Total number of validation rule executions grouped by outcome.",
                        },
                        []string{"rule_id", "outcome"},
                )

                validatorChainDuration = prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "validator_chain_duration_seconds",
                                Help:    "Histogram of validation chain execution durations.",
                                Buckets: prometheus.DefBuckets,
                        },
                        []string{"operation"},
                )

                validatorChainOutcomeTotal = prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "validator_chain_outcome_total",
                                Help: "Total number of validation chain executions grouped by outcome.",
                        },
                        []string{"operation", "outcome"},
                )

                prometheus.MustRegister(
                        validatorRuleDurationSeconds,
                        validatorRuleOutcomeTotal,
                        validatorChainDuration,
                        validatorChainOutcomeTotal,
                )
        }</span>)
}

func observeRuleMetrics(ruleID, outcome string, duration time.Duration) <span class="cov8" title="1">{
        if ruleID == "" </span><span class="cov0" title="0">{
                ruleID = "UNKNOWN"
        }</span>
        <span class="cov8" title="1">if outcome == "" </span><span class="cov0" title="0">{
                outcome = ruleOutcomeLabelSuccess
        }</span>

        <span class="cov8" title="1">ensureValidatorMetricsRegistered()
        validatorRuleDurationSeconds.WithLabelValues(ruleID).Observe(duration.Seconds())
        validatorRuleOutcomeTotal.WithLabelValues(ruleID, outcome).Inc()</span>
}

func observeChainMetrics(operation, outcome string, duration time.Duration) <span class="cov8" title="1">{
        if operation == "" </span><span class="cov8" title="1">{
                operation = "unknown"
        }</span>
        <span class="cov8" title="1">if outcome == "" </span><span class="cov0" title="0">{
                outcome = chainOutcomeLabelSuccess
        }</span>

        <span class="cov8" title="1">ensureValidatorMetricsRegistered()
        validatorChainDuration.WithLabelValues(operation).Observe(duration.Seconds())
        validatorChainOutcomeTotal.WithLabelValues(operation, outcome).Inc()</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package validator

import (
        "context"
        "fmt"
        "strings"
        "time"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

const (
        maxOrganizationDepth  = 17
        depthWarningThreshold = 15
)

type organizationCreateSubject struct {
        TenantID uuid.UUID
        Request  *types.CreateOrganizationRequest
}

type organizationUpdateSubject struct {
        TenantID uuid.UUID
        Code     string
        Request  *types.UpdateOrganizationRequest
        Existing *types.Organization
}

func (v *BusinessRuleValidator) buildOrganizationCreateChain(req *types.CreateOrganizationRequest) *ValidationChain <span class="cov8" title="1">{
        chain := NewValidationChain(
                v.logger,
                WithOperationLabel("CreateOrganization"),
                WithBaseContext(map[string]interface{}{"operation": "CreateOrganization"}),
        )

        parentCode := ""
        if req.ParentCode != nil </span><span class="cov8" title="1">{
                parentCode = strings.TrimSpace(*req.ParentCode)
        }</span>

        <span class="cov8" title="1">if parentCode != "" </span><span class="cov8" title="1">{
                chain.Register(&amp;Rule{
                        ID:           "ORG-DEPTH",
                        Priority:     10,
                        Severity:     SeverityHigh,
                        ShortCircuit: true,
                        Handler:      v.newOrgDepthRule(parentCode),
                })

                if req.EffectiveDate != nil </span><span class="cov8" title="1">{
                        effective := req.EffectiveDate.Time
                        chain.Register(&amp;Rule{
                                ID:           "ORG-TEMPORAL",
                                Priority:     15,
                                Severity:     SeverityHigh,
                                ShortCircuit: true,
                                Handler:      v.newOrgTemporalRule(parentCode, &amp;effective),
                        })
                }</span>
        }

        <span class="cov8" title="1">return chain</span>
}

func (v *BusinessRuleValidator) buildOrganizationUpdateChain(existing *types.Organization, req *types.UpdateOrganizationRequest) *ValidationChain <span class="cov8" title="1">{
        chain := NewValidationChain(
                v.logger,
                WithOperationLabel("UpdateOrganization"),
                WithBaseContext(map[string]interface{}{"operation": "UpdateOrganization"}),
        )

        parentCode := ""
        if req.ParentCode != nil </span><span class="cov8" title="1">{
                parentCode = strings.TrimSpace(*req.ParentCode)
        }</span>

        <span class="cov8" title="1">if parentCode != "" </span><span class="cov8" title="1">{
                chain.Register(&amp;Rule{
                        ID:           "ORG-DEPTH",
                        Priority:     10,
                        Severity:     SeverityHigh,
                        ShortCircuit: true,
                        Handler:      v.newOrgDepthRule(parentCode),
                })

                chain.Register(&amp;Rule{
                        ID:           "ORG-CIRC",
                        Priority:     20,
                        Severity:     SeverityCritical,
                        ShortCircuit: true,
                        Handler:      v.newOrgCircularRule(parentCode),
                })
        }</span>

        <span class="cov8" title="1">if req.Status != nil </span><span class="cov8" title="1">{
                chain.Register(&amp;Rule{
                        ID:       "ORG-STATUS",
                        Priority: 30,
                        Severity: SeverityCritical,
                        Handler:  v.newOrgStatusRule(existing),
                })
        }</span>

        <span class="cov8" title="1">if parentCode != "" </span><span class="cov8" title="1">{
                var effectiveAt *time.Time
                if req != nil &amp;&amp; req.EffectiveDate != nil </span><span class="cov0" title="0">{
                        t := req.EffectiveDate.Time
                        effectiveAt = &amp;t
                }</span> else<span class="cov8" title="1"> if existing != nil &amp;&amp; existing.EffectiveDate != nil </span><span class="cov8" title="1">{
                        t := existing.EffectiveDate.Time
                        effectiveAt = &amp;t
                }</span>

                <span class="cov8" title="1">if effectiveAt != nil </span><span class="cov8" title="1">{
                        chain.Register(&amp;Rule{
                                ID:           "ORG-TEMPORAL",
                                Priority:     25,
                                Severity:     SeverityHigh,
                                ShortCircuit: true,
                                Handler:      v.newOrgTemporalRule(parentCode, effectiveAt),
                        })
                }</span>
        }

        <span class="cov8" title="1">return chain</span>
}

func (v *BusinessRuleValidator) newOrgDepthRule(parentCode string) RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                switch s := subject.(type) </span>{
                case *organizationCreateSubject:<span class="cov8" title="1">
                        return v.evaluateDepth(ctx, s.TenantID, parentCode)</span>
                case *organizationUpdateSubject:<span class="cov8" title="1">
                        return v.evaluateDepth(ctx, s.TenantID, parentCode)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("ORG-DEPTH rule: unsupported subject type %T", subject)</span>
                }
        }
}

func (v *BusinessRuleValidator) evaluateDepth(ctx context.Context, tenantID uuid.UUID, parentCode string) (*RuleOutcome, error) <span class="cov8" title="1">{
        depth, err := v.hierarchyRepo.GetOrganizationDepth(ctx, parentCode, tenantID)
        if err != nil </span><span class="cov8" title="1">{
                errMsg := strings.ToLower(err.Error())
                if strings.Contains(errMsg, "not found") || strings.Contains(errMsg, "depth not found") </span><span class="cov8" title="1">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "INVALID_PARENT",
                                        Message:  fmt.Sprintf("Parent organization %s does not exist", parentCode),
                                        Field:    "parentCode",
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId": "ORG-DEPTH",
                                        },
                                }},
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("fetch parent depth failed: %w", err)</span>
        }

        <span class="cov8" title="1">attemptedDepth := depth + 1

        if attemptedDepth &gt; maxOrganizationDepth </span><span class="cov8" title="1">{
                return &amp;RuleOutcome{
                        Errors: []ValidationError{{
                                Code:     "ORG_DEPTH_LIMIT",
                                Message:  fmt.Sprintf("Organization depth exceeds maximum of %d levels", maxOrganizationDepth),
                                Field:    "parentCode",
                                Severity: string(SeverityHigh),
                                Context: map[string]interface{}{
                                        "ruleId":         "ORG-DEPTH",
                                        "maxDepth":       maxOrganizationDepth,
                                        "attemptedDepth": attemptedDepth,
                                },
                        }},
                }, nil
        }</span>

        <span class="cov8" title="1">if attemptedDepth &gt;= depthWarningThreshold </span><span class="cov8" title="1">{
                return &amp;RuleOutcome{
                        Warnings: []ValidationWarning{{
                                Code:    "ORG_DEPTH_NEAR_LIMIT",
                                Message: fmt.Sprintf("Organization depth is near the limit (%d/%d)", attemptedDepth, maxOrganizationDepth),
                                Field:   "parentCode",
                                Value:   attemptedDepth,
                        }},
                        Context: map[string]interface{}{
                                "ruleId":         "ORG-DEPTH",
                                "attemptedDepth": attemptedDepth,
                        },
                }, nil
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

func (v *BusinessRuleValidator) newOrgCircularRule(parentCode string) RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                update, ok := subject.(*organizationUpdateSubject)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ORG-CIRC rule expects organizationUpdateSubject, got %T", subject)
                }</span>

                <span class="cov8" title="1">if parentCode == "" </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if strings.EqualFold(parentCode, update.Code) </span><span class="cov0" title="0">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "ORG_CYCLE_DETECTED",
                                        Message:  "Organization cannot be its own parent",
                                        Field:    "parentCode",
                                        Severity: string(SeverityCritical),
                                        Context: map[string]interface{}{
                                                "ruleId":          "ORG-CIRC",
                                                "attemptedParent": parentCode,
                                        },
                                }},
                        }, nil
                }</span>

                <span class="cov8" title="1">ancestors, err := v.hierarchyRepo.GetAncestorChain(ctx, parentCode, update.TenantID)
                if err != nil </span><span class="cov0" title="0">{
                        errMsg := strings.ToLower(err.Error())
                        if strings.Contains(errMsg, "not found") </span><span class="cov0" title="0">{
                                return &amp;RuleOutcome{
                                        Errors: []ValidationError{{
                                                Code:     "INVALID_PARENT",
                                                Message:  fmt.Sprintf("Parent organization %s does not exist", parentCode),
                                                Field:    "parentCode",
                                                Severity: string(SeverityHigh),
                                                Context: map[string]interface{}{
                                                        "ruleId": "ORG-CIRC",
                                                },
                                        }},
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("fetch ancestor chain failed: %w", err)</span>
                }

                <span class="cov8" title="1">for _, ancestor := range ancestors </span><span class="cov8" title="1">{
                        if strings.EqualFold(ancestor.Code, update.Code) </span><span class="cov8" title="1">{
                                return &amp;RuleOutcome{
                                        Errors: []ValidationError{{
                                                Code:     "ORG_CYCLE_DETECTED",
                                                Message:  fmt.Sprintf("Detected circular reference: %s -&gt; %s", update.Code, parentCode),
                                                Field:    "parentCode",
                                                Severity: string(SeverityCritical),
                                                Context: map[string]interface{}{
                                                        "ruleId":           "ORG-CIRC",
                                                        "attemptedParent":  parentCode,
                                                        "ancestorDetected": ancestor.Code,
                                                },
                                        }},
                                }, nil
                        }</span>
                }

                <span class="cov0" title="0">return nil, nil</span>
        }
}

func (v *BusinessRuleValidator) newOrgStatusRule(existing *types.Organization) RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                update, ok := subject.(*organizationUpdateSubject)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ORG-STATUS rule expects organizationUpdateSubject, got %T", subject)
                }</span>
                <span class="cov8" title="1">if update.Request == nil || update.Request.Status == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">currentStatus := strings.ToUpper(strings.TrimSpace(existing.Status))
                newStatus := strings.ToUpper(strings.TrimSpace(*update.Request.Status))

                if currentStatus == "" || newStatus == "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if currentStatus == newStatus </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">validTransitions := map[string][]string{
                        "ACTIVE":   {"INACTIVE", "DELETED"},
                        "INACTIVE": {"ACTIVE", "DELETED"},
                        "PLANNED":  {"ACTIVE", "DELETED"},
                }

                targets, ok := validTransitions[currentStatus]
                if !ok </span><span class="cov0" title="0">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "ORG_STATUS_GUARD",
                                        Message:  fmt.Sprintf("Unsupported current status %s for transition", currentStatus),
                                        Field:    "status",
                                        Severity: string(SeverityCritical),
                                        Context: map[string]interface{}{
                                                "ruleId":          "ORG-STATUS",
                                                "currentStatus":   currentStatus,
                                                "requestedStatus": newStatus,
                                        },
                                }},
                        }, nil
                }</span>

                <span class="cov8" title="1">for _, allowed := range targets </span><span class="cov8" title="1">{
                        if allowed == newStatus </span><span class="cov8" title="1">{
                                return nil, nil
                        }</span>
                }

                <span class="cov8" title="1">return &amp;RuleOutcome{
                        Errors: []ValidationError{{
                                Code:     "ORG_STATUS_GUARD",
                                Message:  fmt.Sprintf("Cannot transition from %s to %s", currentStatus, newStatus),
                                Field:    "status",
                                Severity: string(SeverityCritical),
                                Context: map[string]interface{}{
                                        "ruleId":          "ORG-STATUS",
                                        "currentStatus":   currentStatus,
                                        "requestedStatus": newStatus,
                                },
                        }},
                }, nil</span>
        }
}

func (v *BusinessRuleValidator) newOrgTemporalRule(parentCode string, effectiveDate *time.Time) RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                if parentCode == "" || effectiveDate == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">var tenantID uuid.UUID
                switch s := subject.(type) </span>{
                case *organizationCreateSubject:<span class="cov8" title="1">
                        tenantID = s.TenantID</span>
                case *organizationUpdateSubject:<span class="cov8" title="1">
                        tenantID = s.TenantID</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("ORG-TEMPORAL rule: unsupported subject type %T", subject)</span>
                }

                <span class="cov8" title="1">parent, err := v.hierarchyRepo.GetOrganizationAtDate(ctx, parentCode, tenantID, *effectiveDate)
                if err != nil </span><span class="cov0" title="0">{
                        errMsg := strings.ToLower(err.Error())
                        if strings.Contains(errMsg, "not found") </span><span class="cov0" title="0">{
                                return &amp;RuleOutcome{
                                        Errors: []ValidationError{{
                                                Code:     "INVALID_PARENT",
                                                Message:  fmt.Sprintf("Parent organization %s does not exist", parentCode),
                                                Field:    "parentCode",
                                                Severity: string(SeverityHigh),
                                                Context: map[string]interface{}{
                                                        "ruleId": "ORG-TEMPORAL",
                                                },
                                        }},
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("fetch temporal parent failed: %w", err)</span>
                }

                <span class="cov8" title="1">if parent == nil || !strings.EqualFold(parent.Status, "ACTIVE") </span><span class="cov8" title="1">{
                        ctxMap := map[string]interface{}{
                                "ruleId":     "ORG-TEMPORAL",
                                "parentCode": parentCode,
                                "effective":  effectiveDate.Format(time.RFC3339),
                        }
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "ORG_TEMPORAL_PARENT_INACTIVE",
                                        Message:  fmt.Sprintf("Parent %s is not active at %s", parentCode, effectiveDate.Format("2006-01-02")),
                                        Field:    "parentCode",
                                        Severity: string(SeverityHigh),
                                        Context:  ctxMap,
                                }},
                        }, nil
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package validator

import (
        "context"

        "cube-castle/internal/types"
        "github.com/google/uuid"
)

// stubValidationService 为职位/任职命令提供默认通过的占位实现，确保命令层可提前注入校验链。
type stubValidationService struct{}

// NewStubValidationService 返回一个所有验证直接通过的实现，供 219C2C 前置阶段使用。
func NewStubValidationService() *stubValidationService <span class="cov8" title="1">{
        return &amp;stubValidationService{}
}</span>

func (s *stubValidationService) result() *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()
        result.Context["executedRules"] = []string{}
        return result
}</span>

// Position 验证占位实现
func (s *stubValidationService) ValidateCreatePosition(ctx context.Context, tenantID uuid.UUID, req *types.PositionRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateReplacePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateCreateVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionVersionRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateFillPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.FillPositionRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateVacatePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.VacatePositionRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateTransferPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.TransferPositionRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateApplyEvent(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionEventRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

// Assignment 验证占位实现
func (s *stubValidationService) ValidateCreateAssignment(ctx context.Context, tenantID uuid.UUID, positionCode string, req *types.CreateAssignmentRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateUpdateAssignment(ctx context.Context, tenantID uuid.UUID, positionCode string, assignmentID uuid.UUID, req *types.UpdateAssignmentRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

func (s *stubValidationService) ValidateCloseAssignment(ctx context.Context, tenantID uuid.UUID, positionCode string, assignmentID uuid.UUID, req *types.CloseAssignmentRequest) *ValidationResult <span class="cov8" title="1">{
        return s.result()
}</span>

// Enforce interface compliance at compile time.
var (
        _ PositionValidationService   = (*stubValidationService)(nil)
        _ AssignmentValidationService = (*stubValidationService)(nil)
)
</pre>
		
		<pre class="file" id="file69" style="display: none">package validator

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "cube-castle/internal/types"
        pkglogger "cube-castle/pkg/logger"
        "github.com/google/uuid"
)

// jobCatalogRepository 定义职位验证所需的 Job Catalog 查询接口。
type jobCatalogRepository interface {
        GetCurrentFamilyGroup(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamilyGroup, error)
        GetCurrentJobFamily(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamily, error)
        GetCurrentJobRole(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobRole, error)
        GetCurrentJobLevel(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobLevel, error)
}

// positionRepository 定义职位验证所需的职位查询接口。
type positionRepository interface {
        GetCurrentPosition(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.Position, error)
}

// positionAssignmentRepository 定义任职验证所需的仓储接口。
type positionAssignmentRepository interface {
        SumActiveFTE(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, positionCode string) (float64, error)
        GetByID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, assignmentID uuid.UUID) (*types.PositionAssignment, error)
}

// positionAssignmentValidationService 实现职位与任职验证器接口。
type positionAssignmentValidationService struct {
        orgRepo        organizationRepository
        jobCatalogRepo jobCatalogRepository
        positionRepo   positionRepository
        assignmentRepo positionAssignmentRepository
        logger         pkglogger.Logger
}

// NewPositionAssignmentValidationService 构建职位与任职业务规则验证器。
func NewPositionAssignmentValidationService(
        orgRepo organizationRepository,
        jobCatalogRepo jobCatalogRepository,
        positionRepo positionRepository,
        assignmentRepo positionAssignmentRepository,
        baseLogger pkglogger.Logger,
) (PositionValidationService, AssignmentValidationService) <span class="cov8" title="1">{
        logger := baseLogger
        if logger == nil </span><span class="cov0" title="0">{
                logger = pkglogger.NewNoopLogger()
        }</span>

        <span class="cov8" title="1">service := &amp;positionAssignmentValidationService{
                orgRepo:        orgRepo,
                jobCatalogRepo: jobCatalogRepo,
                positionRepo:   positionRepo,
                assignmentRepo: assignmentRepo,
                logger: logger.WithFields(pkglogger.Fields{
                        "component": "validator",
                        "module":    "position-assignment",
                }),
        }
        return service, service</span>
}

// ValidateCreatePosition 校验创建职位请求。
func (s *positionAssignmentValidationService) ValidateCreatePosition(ctx context.Context, tenantID uuid.UUID, req *types.PositionRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">subject := &amp;positionCreateSubject{
                TenantID: tenantID,
                Request:  req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("CreatePosition"),
                WithBaseContext(map[string]interface{}{
                        "operation": "CreatePosition",
                }),
        )
        s.registerPositionCreateRules(chain)

        result := chain.Execute(ctx, subject)
        s.mergeJobCatalogContext(ctx, result, tenantID, req)
        return result</span>
}

// ValidateReplacePosition 校验替换职位请求。
func (s *positionAssignmentValidationService) ValidateReplacePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">subject := &amp;positionUpdateSubject{
                TenantID: tenantID,
                Code:     strings.TrimSpace(code),
                Request:  req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("ReplacePosition"),
                WithBaseContext(map[string]interface{}{
                        "operation":     "ReplacePosition",
                        "positionCode":  subject.Code,
                        "tenantId":      tenantID.String(),
                        "targetVersion": "CURRENT",
                }),
        )
        s.registerPositionCreateRules(chain)

        result := chain.Execute(ctx, subject)
        s.mergeJobCatalogContext(ctx, result, tenantID, req)
        return result</span>
}

// ValidateCreateVersion 校验新增职位版本请求。
func (s *positionAssignmentValidationService) ValidateCreateVersion(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionVersionRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">subject := &amp;positionVersionSubject{
                TenantID: tenantID,
                Code:     strings.TrimSpace(code),
                Request:  req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("CreatePositionVersion"),
                WithBaseContext(map[string]interface{}{
                        "operation":    "CreatePositionVersion",
                        "positionCode": subject.Code,
                        "tenantId":     tenantID.String(),
                }),
        )

        chain.Register(&amp;Rule{
                ID:           "POS-ORG",
                Priority:     10,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newPosOrgRule(),
        })

        result := chain.Execute(ctx, subject)
        return result</span>
}

// ValidateFillPosition 校验填充职位请求（创建任职）。
func (s *positionAssignmentValidationService) ValidateFillPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.FillPositionRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">position, organization, currentFTE, err := s.loadPositionContext(ctx, tenantID, code)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{"error": err}).Error("load position context failed for FillPosition")
                return NewValidationResult()
        }</span>
        <span class="cov8" title="1">if position == nil || organization == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">requestedFTE := resolveRequestedFTE(req.FTE)

        subject := &amp;positionFillSubject{
                TenantID:     tenantID,
                Position:     position,
                Organization: organization,
                CurrentFTE:   currentFTE,
                RequestedFTE: requestedFTE,
                Request:      req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("FillPosition"),
                WithBaseContext(map[string]interface{}{
                        "operation":    "FillPosition",
                        "positionCode": position.Code,
                        "tenantId":     tenantID.String(),
                }),
        )
        s.registerAssignmentCreationRules(chain)

        return chain.Execute(ctx, subject)</span>
}

// ValidateVacatePosition 校验清空职位请求。
func (s *positionAssignmentValidationService) ValidateVacatePosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.VacatePositionRequest) *ValidationResult <span class="cov8" title="1">{
        return NewValidationResult()
}</span>

// ValidateTransferPosition 校验职位转移请求。
func (s *positionAssignmentValidationService) ValidateTransferPosition(ctx context.Context, tenantID uuid.UUID, code string, req *types.TransferPositionRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">targetOrg := strings.TrimSpace(req.TargetOrganizationCode)
        if targetOrg == "" </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">subject := &amp;positionTransferSubject{
                TenantID: tenantID,
                Code:     strings.TrimSpace(code),
                Target:   targetOrg,
                Request:  req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("TransferPosition"),
                WithBaseContext(map[string]interface{}{
                        "operation":       "TransferPosition",
                        "positionCode":    subject.Code,
                        "targetOrg":       targetOrg,
                        "tenantId":        tenantID.String(),
                        "requestedAt":     req.EffectiveDate,
                        "crossDomainRule": true,
                }),
        )
        chain.Register(&amp;Rule{
                ID:           "POS-ORG",
                Priority:     10,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newPosOrgRule(),
        })
        return chain.Execute(ctx, subject)</span>
}

// ValidateApplyEvent 校验职位事件请求。
func (s *positionAssignmentValidationService) ValidateApplyEvent(ctx context.Context, tenantID uuid.UUID, code string, req *types.PositionEventRequest) *ValidationResult <span class="cov8" title="1">{
        return NewValidationResult()
}</span>

// ValidateCreateAssignment 校验创建任职请求（Position Assignment API）。
func (s *positionAssignmentValidationService) ValidateCreateAssignment(ctx context.Context, tenantID uuid.UUID, positionCode string, req *types.CreateAssignmentRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">position, organization, currentFTE, err := s.loadPositionContext(ctx, tenantID, positionCode)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{"error": err}).Error("load position context failed for CreateAssignment")
                return NewValidationResult()
        }</span>
        <span class="cov8" title="1">if position == nil || organization == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">requestedFTE := resolveRequestedFTE(req.FTE)

        subject := &amp;assignmentCreateSubject{
                TenantID:     tenantID,
                Position:     position,
                Organization: organization,
                CurrentFTE:   currentFTE,
                RequestedFTE: requestedFTE,
                Request:      req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("CreateAssignment"),
                WithBaseContext(map[string]interface{}{
                        "operation":    "CreateAssignment",
                        "positionCode": position.Code,
                        "tenantId":     tenantID.String(),
                }),
        )
        s.registerAssignmentCreationRules(chain)

        return chain.Execute(ctx, subject)</span>
}

// ValidateUpdateAssignment 校验更新任职请求。
func (s *positionAssignmentValidationService) ValidateUpdateAssignment(ctx context.Context, tenantID uuid.UUID, positionCode string, assignmentID uuid.UUID, req *types.UpdateAssignmentRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">position, organization, currentFTE, err := s.loadPositionContext(ctx, tenantID, positionCode)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{"error": err}).Error("load position context failed for UpdateAssignment")
                return NewValidationResult()
        }</span>
        <span class="cov8" title="1">if position == nil || organization == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">assignment, err := s.assignmentRepo.GetByID(ctx, nil, tenantID, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{"error": err}).Error("load assignment failed for UpdateAssignment")
                return NewValidationResult()
        }</span>
        <span class="cov8" title="1">if assignment == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">requestedFTE := assignment.FTE
        if req.FTE != nil </span><span class="cov8" title="1">{
                requestedFTE = *req.FTE
        }</span>

        <span class="cov8" title="1">subject := &amp;assignmentUpdateSubject{
                TenantID:         tenantID,
                Position:         position,
                Organization:     organization,
                Assignment:       assignment,
                CurrentFTE:       currentFTE,
                RequestedFTE:     requestedFTE,
                Request:          req,
                AssignmentID:     assignmentID,
                OriginalFTE:      assignment.FTE,
                AssignmentStatus: strings.ToUpper(strings.TrimSpace(assignment.AssignmentStatus)),
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("UpdateAssignment"),
                WithBaseContext(map[string]interface{}{
                        "operation":      "UpdateAssignment",
                        "positionCode":   position.Code,
                        "assignmentId":   assignmentID.String(),
                        "tenantId":       tenantID.String(),
                        "currentStatus":  assignment.AssignmentStatus,
                        "requestedFTE":   requestedFTE,
                        "existingFTE":    assignment.FTE,
                        "existingStatus": assignment.AssignmentStatus,
                }),
        )
        s.registerAssignmentUpdateRules(chain)

        return chain.Execute(ctx, subject)</span>
}

// ValidateCloseAssignment 校验关闭任职请求。
func (s *positionAssignmentValidationService) ValidateCloseAssignment(ctx context.Context, tenantID uuid.UUID, positionCode string, assignmentID uuid.UUID, req *types.CloseAssignmentRequest) *ValidationResult <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">assignment, err := s.assignmentRepo.GetByID(ctx, nil, tenantID, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(pkglogger.Fields{"error": err}).Error("load assignment failed for CloseAssignment")
                return NewValidationResult()
        }</span>
        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                return NewValidationResult()
        }</span>

        <span class="cov8" title="1">subject := &amp;assignmentCloseSubject{
                TenantID:   tenantID,
                Assignment: assignment,
                Request:    req,
        }

        chain := NewValidationChain(
                s.logger,
                WithOperationLabel("CloseAssignment"),
                WithBaseContext(map[string]interface{}{
                        "operation":    "CloseAssignment",
                        "positionCode": strings.TrimSpace(positionCode),
                        "assignmentId": assignmentID.String(),
                        "tenantId":     tenantID.String(),
                }),
        )

        chain.Register(&amp;Rule{
                ID:           "ASSIGN-STATE",
                Priority:     10,
                Severity:     SeverityCritical,
                ShortCircuit: true,
                Handler:      s.newAssignStateRule(),
        })

        return chain.Execute(ctx, subject)</span>
}

// ===== 规则注册 &amp; Subject 定义 =====

func (s *positionAssignmentValidationService) registerPositionCreateRules(chain *ValidationChain) <span class="cov8" title="1">{
        _ = chain.Register(&amp;Rule{
                ID:           "POS-ORG",
                Priority:     10,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newPosOrgRule(),
        })

        _ = chain.Register(&amp;Rule{
                ID:       "POS-JC-LINK",
                Priority: 20,
                Severity: SeverityMedium,
                Handler:  s.newPosJobCatalogRule(),
        })
}</span>

func (s *positionAssignmentValidationService) registerAssignmentCreationRules(chain *ValidationChain) <span class="cov8" title="1">{
        _ = chain.Register(&amp;Rule{
                ID:           "ASSIGN-FTE",
                Priority:     5,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newAssignFTERule(),
        })

        _ = chain.Register(&amp;Rule{
                ID:           "ASSIGN-STATE",
                Priority:     8,
                Severity:     SeverityCritical,
                ShortCircuit: true,
                Handler:      s.newAssignStateRule(),
        })

        _ = chain.Register(&amp;Rule{
                ID:           "CROSS-ACTIVE",
                Priority:     10,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newCrossActiveRule(),
        })

        _ = chain.Register(&amp;Rule{
                ID:           "POS-HEADCOUNT",
                Priority:     20,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newPosHeadcountRule(),
        })
}</span>

func (s *positionAssignmentValidationService) registerAssignmentUpdateRules(chain *ValidationChain) <span class="cov8" title="1">{
        _ = chain.Register(&amp;Rule{
                ID:           "ASSIGN-FTE",
                Priority:     5,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newAssignFTERule(),
        })

        _ = chain.Register(&amp;Rule{
                ID:           "ASSIGN-STATE",
                Priority:     8,
                Severity:     SeverityCritical,
                ShortCircuit: true,
                Handler:      s.newAssignStateRule(),
        })

        _ = chain.Register(&amp;Rule{
                ID:           "POS-HEADCOUNT",
                Priority:     15,
                Severity:     SeverityHigh,
                ShortCircuit: true,
                Handler:      s.newPosHeadcountRule(),
        })
}</span>

type positionCreateSubject struct {
        TenantID uuid.UUID
        Request  *types.PositionRequest
}

type positionUpdateSubject struct {
        TenantID uuid.UUID
        Code     string
        Request  *types.PositionRequest
}

type positionVersionSubject struct {
        TenantID uuid.UUID
        Code     string
        Request  *types.PositionVersionRequest
}

type positionFillSubject struct {
        TenantID     uuid.UUID
        Position     *types.Position
        Organization *types.Organization
        CurrentFTE   float64
        RequestedFTE float64
        Request      *types.FillPositionRequest
}

type positionTransferSubject struct {
        TenantID uuid.UUID
        Code     string
        Target   string
        Request  *types.TransferPositionRequest
}

type assignmentCreateSubject struct {
        TenantID     uuid.UUID
        Position     *types.Position
        Organization *types.Organization
        CurrentFTE   float64
        RequestedFTE float64
        Request      *types.CreateAssignmentRequest
}

type assignmentUpdateSubject struct {
        TenantID         uuid.UUID
        Position         *types.Position
        Organization     *types.Organization
        Assignment       *types.PositionAssignment
        CurrentFTE       float64
        RequestedFTE     float64
        Request          *types.UpdateAssignmentRequest
        AssignmentID     uuid.UUID
        OriginalFTE      float64
        AssignmentStatus string
}

type assignmentCloseSubject struct {
        TenantID   uuid.UUID
        Assignment *types.PositionAssignment
        Request    *types.CloseAssignmentRequest
}

// ===== Rule Handlers =====

func (s *positionAssignmentValidationService) newPosOrgRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                tenantID, orgCode := s.resolveOrgContext(subject)
                if tenantID == uuid.Nil || orgCode == "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">org, err := s.orgRepo.GetByCode(ctx, tenantID, orgCode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pos-org: fetch organization %s failed: %w", orgCode, err)
                }</span>
                <span class="cov8" title="1">if org == nil </span><span class="cov8" title="1">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "POS_ORG_INACTIVE",
                                        Message:  fmt.Sprintf("Organization %s does not exist or is inactive", orgCode),
                                        Field:    "organizationCode",
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId":           "POS-ORG",
                                                "organizationCode": orgCode,
                                                "status":           "UNKNOWN",
                                        },
                                }},
                        }, nil
                }</span>
                <span class="cov8" title="1">status := strings.ToUpper(strings.TrimSpace(org.Status))
                if status != string(types.OrganizationStatusActive) </span><span class="cov8" title="1">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "POS_ORG_INACTIVE",
                                        Message:  fmt.Sprintf("Organization %s status %s is not ACTIVE", orgCode, status),
                                        Field:    "organizationCode",
                                        Value:    status,
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId":           "POS-ORG",
                                                "organizationCode": orgCode,
                                                "status":           status,
                                        },
                                }},
                        }, nil
                }</span>

                <span class="cov8" title="1">return &amp;RuleOutcome{
                        Context: map[string]interface{}{
                                "organizationCode": orgCode,
                                "status":           status,
                        },
                }, nil</span>
        }
}

func (s *positionAssignmentValidationService) newPosJobCatalogRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                req := s.extractPositionRequest(subject)
                if req == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">tenantID := s.extractTenant(subject)
                if tenantID == uuid.Nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">group, err := s.jobCatalogRepo.GetCurrentFamilyGroup(ctx, nil, tenantID, strings.TrimSpace(req.JobFamilyGroupCode))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pos-jc-link: fetch job family group failed: %w", err)
                }</span>
                <span class="cov8" title="1">if group == nil || !strings.EqualFold(group.Status, "ACTIVE") </span><span class="cov0" title="0">{
                        return jobCatalogViolation("JobFamilyGroup", req.JobFamilyGroupCode), nil
                }</span>

                <span class="cov8" title="1">family, err := s.jobCatalogRepo.GetCurrentJobFamily(ctx, nil, tenantID, strings.TrimSpace(req.JobFamilyCode))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pos-jc-link: fetch job family failed: %w", err)
                }</span>
                <span class="cov8" title="1">if family == nil || !strings.EqualFold(family.Status, "ACTIVE") </span><span class="cov0" title="0">{
                        return jobCatalogViolation("JobFamily", req.JobFamilyCode), nil
                }</span>

                <span class="cov8" title="1">role, err := s.jobCatalogRepo.GetCurrentJobRole(ctx, nil, tenantID, strings.TrimSpace(req.JobRoleCode))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pos-jc-link: fetch job role failed: %w", err)
                }</span>
                <span class="cov8" title="1">if role == nil || !strings.EqualFold(role.Status, "ACTIVE") </span><span class="cov8" title="1">{
                        return jobCatalogViolation("JobRole", req.JobRoleCode), nil
                }</span>

                <span class="cov0" title="0">level, err := s.jobCatalogRepo.GetCurrentJobLevel(ctx, nil, tenantID, strings.TrimSpace(req.JobLevelCode))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pos-jc-link: fetch job level failed: %w", err)
                }</span>
                <span class="cov0" title="0">if level == nil || !strings.EqualFold(level.Status, "ACTIVE") </span><span class="cov0" title="0">{
                        return jobCatalogViolation("JobLevel", req.JobLevelCode), nil
                }</span>

                <span class="cov0" title="0">return &amp;RuleOutcome{
                        Context: map[string]interface{}{
                                "jobFamilyGroup": req.JobFamilyGroupCode,
                                "jobFamily":      req.JobFamilyCode,
                                "jobRole":        req.JobRoleCode,
                                "jobLevel":       req.JobLevelCode,
                        },
                }, nil</span>
        }
}

func (s *positionAssignmentValidationService) newAssignFTERule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                requested := s.extractRequestedFTE(subject)
                if requested &lt;= 0 || requested &gt; 1.0 </span><span class="cov8" title="1">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "ASSIGN_FTE_LIMIT",
                                        Message:  fmt.Sprintf("Assignment FTE %.2f must be between 0 and 1", requested),
                                        Field:    "fte",
                                        Value:    requested,
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId":        "ASSIGN-FTE",
                                                "requestedFTE":  requested,
                                                "allowedRange":  "[0,1]",
                                                "shortCircuit":  true,
                                                "operationType": s.extractOperation(subject),
                                        },
                                }},
                        }, nil
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        }
}

func (s *positionAssignmentValidationService) newAssignStateRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                operation := s.extractOperation(subject)
                switch sub := subject.(type) </span>{
                case *positionFillSubject:<span class="cov8" title="1">
                        if isInactivePositionStatus(sub.Position.Status) </span><span class="cov0" title="0">{
                                return assignStateViolation(sub.Position.Status, operation), nil
                        }</span>
                case *assignmentCreateSubject:<span class="cov8" title="1">
                        if isInactivePositionStatus(sub.Position.Status) </span><span class="cov0" title="0">{
                                return assignStateViolation(sub.Position.Status, operation), nil
                        }</span>
                case *assignmentUpdateSubject:<span class="cov8" title="1">
                        if strings.EqualFold(sub.AssignmentStatus, "ENDED") </span><span class="cov0" title="0">{
                                return assignStateViolation(sub.AssignmentStatus, operation), nil
                        }</span>
                case *assignmentCloseSubject:<span class="cov8" title="1">
                        if !strings.EqualFold(sub.Assignment.AssignmentStatus, "ACTIVE") </span><span class="cov8" title="1">{
                                return assignStateViolation(sub.Assignment.AssignmentStatus, operation), nil
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, nil</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        }
}

func (s *positionAssignmentValidationService) newCrossActiveRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                position := s.extractPosition(subject)
                org := s.extractOrganization(subject)
                if position == nil || org == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">status := strings.ToUpper(strings.TrimSpace(position.Status))
                if status == "INACTIVE" || status == "DELETED" </span><span class="cov0" title="0">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "CROSS_ACTIVATION_CONFLICT",
                                        Message:  fmt.Sprintf("Position %s status %s does not allow assignment operations", position.Code, status),
                                        Field:    "status",
                                        Value:    status,
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId":         "CROSS-ACTIVE",
                                                "positionCode":   position.Code,
                                                "positionStatus": status,
                                        },
                                }},
                        }, nil
                }</span>

                <span class="cov8" title="1">orgStatus := strings.ToUpper(strings.TrimSpace(org.Status))
                if orgStatus != string(types.OrganizationStatusActive) </span><span class="cov8" title="1">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "CROSS_ACTIVATION_CONFLICT",
                                        Message:  fmt.Sprintf("Organization %s status %s does not allow assignment operations", org.Code, orgStatus),
                                        Field:    "organizationCode",
                                        Value:    orgStatus,
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId":             "CROSS-ACTIVE",
                                                "organizationCode":   org.Code,
                                                "organizationStatus": orgStatus,
                                        },
                                }},
                        }, nil
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        }
}

func (s *positionAssignmentValidationService) newPosHeadcountRule() RuleHandler <span class="cov8" title="1">{
        return func(ctx context.Context, subject interface{}) (*RuleOutcome, error) </span><span class="cov8" title="1">{
                position := s.extractPosition(subject)
                if position == nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">current := s.extractCurrentFTE(subject)
                requested := s.extractRequestedFTE(subject)
                original := s.extractOriginalFTE(subject)

                projected := current + requested
                if original &gt; 0 </span><span class="cov8" title="1">{
                        projected = current - original + requested
                }</span>

                <span class="cov8" title="1">limit := position.HeadcountCapacity
                if projected &gt; limit+1e-9 </span><span class="cov8" title="1">{
                        return &amp;RuleOutcome{
                                Errors: []ValidationError{{
                                        Code:     "POS_HEADCOUNT_EXCEEDED",
                                        Message:  fmt.Sprintf("Projected headcount %.2f exceeds capacity %.2f", projected, limit),
                                        Field:    "fte",
                                        Value:    requested,
                                        Severity: string(SeverityHigh),
                                        Context: map[string]interface{}{
                                                "ruleId":         "POS-HEADCOUNT",
                                                "positionCode":   position.Code,
                                                "headcountLimit": limit,
                                                "currentFTE":     current,
                                                "requestedFTE":   requested,
                                                "projectedFTE":   projected,
                                        },
                                }},
                        }, nil
                }</span>

                <span class="cov0" title="0">return &amp;RuleOutcome{
                        Context: map[string]interface{}{
                                "currentFTE":     current,
                                "requestedFTE":   requested,
                                "projectedFTE":   projected,
                                "headcountLimit": limit,
                        },
                }, nil</span>
        }
}

// ===== Helper Methods =====

func (s *positionAssignmentValidationService) loadPositionContext(ctx context.Context, tenantID uuid.UUID, code string) (*types.Position, *types.Organization, float64, error) <span class="cov8" title="1">{
        position, err := s.positionRepo.GetCurrentPosition(ctx, nil, tenantID, strings.TrimSpace(code))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, 0, fmt.Errorf("load current position failed: %w", err)
        }</span>
        <span class="cov8" title="1">if position == nil </span><span class="cov0" title="0">{
                return nil, nil, 0, nil
        }</span>

        <span class="cov8" title="1">org, err := s.orgRepo.GetByCode(ctx, tenantID, strings.TrimSpace(position.OrganizationCode))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, 0, fmt.Errorf("load position organization failed: %w", err)
        }</span>
        <span class="cov8" title="1">if org == nil </span><span class="cov0" title="0">{
                return position, nil, 0, nil
        }</span>

        <span class="cov8" title="1">currentFTE, err := s.assignmentRepo.SumActiveFTE(ctx, nil, tenantID, position.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, 0, fmt.Errorf("calculate active assignment FTE failed: %w", err)
        }</span>

        <span class="cov8" title="1">return position, org, currentFTE, nil</span>
}

func (s *positionAssignmentValidationService) mergeJobCatalogContext(ctx context.Context, result *ValidationResult, tenantID uuid.UUID, req *types.PositionRequest) <span class="cov8" title="1">{
        if result == nil || result.Context == nil || req == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">result.Context["jobCatalog"] = map[string]string{
                "group":  req.JobFamilyGroupCode,
                "family": req.JobFamilyCode,
                "role":   req.JobRoleCode,
                "level":  req.JobLevelCode,
        }
        result.Context["tenantId"] = tenantID.String()</span>
}

func (s *positionAssignmentValidationService) resolveOrgContext(subject interface{}) (uuid.UUID, string) <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionCreateSubject:<span class="cov8" title="1">
                return sub.TenantID, strings.TrimSpace(sub.Request.OrganizationCode)</span>
        case *positionUpdateSubject:<span class="cov8" title="1">
                return sub.TenantID, strings.TrimSpace(sub.Request.OrganizationCode)</span>
        case *positionFillSubject:<span class="cov8" title="1">
                if sub.Position != nil </span><span class="cov8" title="1">{
                        return sub.TenantID, strings.TrimSpace(sub.Position.OrganizationCode)
                }</span>
        case *assignmentCreateSubject:<span class="cov8" title="1">
                if sub.Position != nil </span><span class="cov8" title="1">{
                        return sub.TenantID, strings.TrimSpace(sub.Position.OrganizationCode)
                }</span>
        case *positionTransferSubject:<span class="cov8" title="1">
                return sub.TenantID, strings.TrimSpace(sub.Target)</span>
        case *assignmentUpdateSubject:<span class="cov8" title="1">
                if sub.Position != nil </span><span class="cov8" title="1">{
                        return sub.TenantID, strings.TrimSpace(sub.Position.OrganizationCode)
                }</span>
        }
        <span class="cov8" title="1">return uuid.Nil, ""</span>
}

func (s *positionAssignmentValidationService) extractPositionRequest(subject interface{}) *types.PositionRequest <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionCreateSubject:<span class="cov8" title="1">
                return sub.Request</span>
        case *positionUpdateSubject:<span class="cov8" title="1">
                return sub.Request</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (s *positionAssignmentValidationService) extractTenant(subject interface{}) uuid.UUID <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionCreateSubject:<span class="cov8" title="1">
                return sub.TenantID</span>
        case *positionUpdateSubject:<span class="cov8" title="1">
                return sub.TenantID</span>
        case *positionVersionSubject:<span class="cov0" title="0">
                return sub.TenantID</span>
        case *positionFillSubject:<span class="cov8" title="1">
                return sub.TenantID</span>
        case *assignmentCreateSubject:<span class="cov0" title="0">
                return sub.TenantID</span>
        case *assignmentUpdateSubject:<span class="cov0" title="0">
                return sub.TenantID</span>
        case *assignmentCloseSubject:<span class="cov8" title="1">
                return sub.TenantID</span>
        default:<span class="cov8" title="1">
                return uuid.Nil</span>
        }
}

func (s *positionAssignmentValidationService) extractOperation(subject interface{}) string <span class="cov8" title="1">{
        switch subject.(type) </span>{
        case *positionFillSubject:<span class="cov8" title="1">
                return "FillPosition"</span>
        case *assignmentCreateSubject:<span class="cov8" title="1">
                return "CreateAssignment"</span>
        case *assignmentUpdateSubject:<span class="cov8" title="1">
                return "UpdateAssignment"</span>
        case *assignmentCloseSubject:<span class="cov8" title="1">
                return "CloseAssignment"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

func (s *positionAssignmentValidationService) extractRequestedFTE(subject interface{}) float64 <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionFillSubject:<span class="cov8" title="1">
                return sub.RequestedFTE</span>
        case *assignmentCreateSubject:<span class="cov8" title="1">
                return sub.RequestedFTE</span>
        case *assignmentUpdateSubject:<span class="cov8" title="1">
                return sub.RequestedFTE</span>
        default:<span class="cov8" title="1">
                return 1.0</span>
        }
}

func (s *positionAssignmentValidationService) extractOriginalFTE(subject interface{}) float64 <span class="cov8" title="1">{
        if sub, ok := subject.(*assignmentUpdateSubject); ok </span><span class="cov8" title="1">{
                return sub.OriginalFTE
        }</span>
        <span class="cov8" title="1">return 0</span>
}

func (s *positionAssignmentValidationService) extractCurrentFTE(subject interface{}) float64 <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionFillSubject:<span class="cov8" title="1">
                return sub.CurrentFTE</span>
        case *assignmentCreateSubject:<span class="cov8" title="1">
                return sub.CurrentFTE</span>
        case *assignmentUpdateSubject:<span class="cov8" title="1">
                return sub.CurrentFTE</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

func (s *positionAssignmentValidationService) extractPosition(subject interface{}) *types.Position <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionFillSubject:<span class="cov8" title="1">
                return sub.Position</span>
        case *assignmentCreateSubject:<span class="cov8" title="1">
                return sub.Position</span>
        case *assignmentUpdateSubject:<span class="cov8" title="1">
                return sub.Position</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

func (s *positionAssignmentValidationService) extractOrganization(subject interface{}) *types.Organization <span class="cov8" title="1">{
        switch sub := subject.(type) </span>{
        case *positionFillSubject:<span class="cov8" title="1">
                return sub.Organization</span>
        case *assignmentCreateSubject:<span class="cov8" title="1">
                return sub.Organization</span>
        case *assignmentUpdateSubject:<span class="cov0" title="0">
                return sub.Organization</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

func jobCatalogViolation(entity, code string) *RuleOutcome <span class="cov8" title="1">{
        return &amp;RuleOutcome{
                Errors: []ValidationError{{
                        Code:     "JOB_CATALOG_NOT_FOUND",
                        Message:  fmt.Sprintf("%s %s is inactive or missing", entity, strings.TrimSpace(code)),
                        Field:    strings.ToLower(entity) + "Code",
                        Value:    strings.TrimSpace(code),
                        Severity: string(SeverityMedium),
                        Context: map[string]interface{}{
                                "ruleId":        "POS-JC-LINK",
                                "catalogEntity": entity,
                                "referenceCode": strings.TrimSpace(code),
                        },
                }},
        }
}</span>

func assignStateViolation(status string, operation string) *RuleOutcome <span class="cov8" title="1">{
        state := strings.ToUpper(strings.TrimSpace(status))
        return &amp;RuleOutcome{
                Errors: []ValidationError{{
                        Code:     "ASSIGN_INVALID_STATE",
                        Message:  fmt.Sprintf("Assignment state %s does not allow %s", state, operation),
                        Field:    "assignmentStatus",
                        Value:    state,
                        Severity: string(SeverityCritical),
                        Context: map[string]interface{}{
                                "ruleId":       "ASSIGN-STATE",
                                "currentState": state,
                                "operation":    operation,
                        },
                }},
        }
}</span>

func resolveRequestedFTE(ftePtr *float64) float64 <span class="cov8" title="1">{
        if ftePtr == nil </span><span class="cov8" title="1">{
                return 1.0
        }</span>
        <span class="cov8" title="1">return *ftePtr</span>
}

func isInactivePositionStatus(status string) bool <span class="cov8" title="1">{
        value := strings.ToUpper(strings.TrimSpace(status))
        return value == "INACTIVE" || value == "DELETED"
}</span>

// Enforce interface compliance.
var (
        _ PositionValidationService   = (*positionAssignmentValidationService)(nil)
        _ AssignmentValidationService = (*positionAssignmentValidationService)(nil)
)
</pre>
		
		<pre class="file" id="file70" style="display: none">package validator

import (
        "context"
        "database/sql"
        "time"

        "cube-castle/internal/organization/repository"
        "cube-castle/internal/types"
        "github.com/google/uuid"
)

// 以下轻量级 stub 供 219C2C 单元测试复用，避免在测试中重复定义跨域依赖。

type StubHierarchyRepository struct {
        GetOrganizationFn       func(ctx context.Context, code string, tenantID uuid.UUID) (*types.Organization, error)
        GetOrganizationDepthFn  func(ctx context.Context, code string, tenantID uuid.UUID) (int, error)
        GetAncestorChainFn      func(ctx context.Context, code string, tenantID uuid.UUID) ([]repository.OrganizationNode, error)
        GetDirectChildrenFn     func(ctx context.Context, code string, tenantID uuid.UUID) ([]repository.OrganizationNode, error)
        GetOrganizationAtDateFn func(ctx context.Context, code string, tenantID uuid.UUID, ts time.Time) (*repository.OrganizationNode, error)
}

func (s *StubHierarchyRepository) GetOrganization(ctx context.Context, code string, tenantID uuid.UUID) (*types.Organization, error) <span class="cov8" title="1">{
        if s.GetOrganizationFn != nil </span><span class="cov8" title="1">{
                return s.GetOrganizationFn(ctx, code, tenantID)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubHierarchyRepository) GetOrganizationDepth(ctx context.Context, code string, tenantID uuid.UUID) (int, error) <span class="cov8" title="1">{
        if s.GetOrganizationDepthFn != nil </span><span class="cov8" title="1">{
                return s.GetOrganizationDepthFn(ctx, code, tenantID)
        }</span>
        <span class="cov8" title="1">return 0, nil</span>
}

func (s *StubHierarchyRepository) GetAncestorChain(ctx context.Context, code string, tenantID uuid.UUID) ([]repository.OrganizationNode, error) <span class="cov8" title="1">{
        if s.GetAncestorChainFn != nil </span><span class="cov8" title="1">{
                return s.GetAncestorChainFn(ctx, code, tenantID)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubHierarchyRepository) GetDirectChildren(ctx context.Context, code string, tenantID uuid.UUID) ([]repository.OrganizationNode, error) <span class="cov8" title="1">{
        if s.GetDirectChildrenFn != nil </span><span class="cov8" title="1">{
                return s.GetDirectChildrenFn(ctx, code, tenantID)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubHierarchyRepository) GetOrganizationAtDate(ctx context.Context, code string, tenantID uuid.UUID, ts time.Time) (*repository.OrganizationNode, error) <span class="cov8" title="1">{
        if s.GetOrganizationAtDateFn != nil </span><span class="cov8" title="1">{
                return s.GetOrganizationAtDateFn(ctx, code, tenantID, ts)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

type StubJobCatalogRepository struct {
        GetCurrentFamilyGroupFn func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamilyGroup, error)
        GetCurrentJobFamilyFn   func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamily, error)
        GetCurrentJobRoleFn     func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobRole, error)
        GetCurrentJobLevelFn    func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobLevel, error)
}

func (s *StubJobCatalogRepository) GetCurrentFamilyGroup(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamilyGroup, error) <span class="cov8" title="1">{
        if s.GetCurrentFamilyGroupFn != nil </span><span class="cov8" title="1">{
                return s.GetCurrentFamilyGroupFn(ctx, tx, tenantID, code)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubJobCatalogRepository) GetCurrentJobFamily(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobFamily, error) <span class="cov8" title="1">{
        if s.GetCurrentJobFamilyFn != nil </span><span class="cov8" title="1">{
                return s.GetCurrentJobFamilyFn(ctx, tx, tenantID, code)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubJobCatalogRepository) GetCurrentJobRole(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobRole, error) <span class="cov8" title="1">{
        if s.GetCurrentJobRoleFn != nil </span><span class="cov8" title="1">{
                return s.GetCurrentJobRoleFn(ctx, tx, tenantID, code)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubJobCatalogRepository) GetCurrentJobLevel(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.JobLevel, error) <span class="cov8" title="1">{
        if s.GetCurrentJobLevelFn != nil </span><span class="cov8" title="1">{
                return s.GetCurrentJobLevelFn(ctx, tx, tenantID, code)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

type StubJobCatalogTimelineRepository struct {
        ListFamilyGroupTimelineFn func(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        ListJobFamilyTimelineFn   func(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        ListJobRoleTimelineFn     func(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
        ListJobLevelTimelineFn    func(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error)
}

func (s *StubJobCatalogTimelineRepository) ListFamilyGroupTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error) <span class="cov8" title="1">{
        if s == nil || s.ListFamilyGroupTimelineFn == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return s.ListFamilyGroupTimelineFn(ctx, tenantID, code)</span>
}

func (s *StubJobCatalogTimelineRepository) ListJobFamilyTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error) <span class="cov8" title="1">{
        if s == nil || s.ListJobFamilyTimelineFn == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return s.ListJobFamilyTimelineFn(ctx, tenantID, code)</span>
}

func (s *StubJobCatalogTimelineRepository) ListJobRoleTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error) <span class="cov8" title="1">{
        if s == nil || s.ListJobRoleTimelineFn == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return s.ListJobRoleTimelineFn(ctx, tenantID, code)</span>
}

func (s *StubJobCatalogTimelineRepository) ListJobLevelTimeline(ctx context.Context, tenantID uuid.UUID, code string) ([]repository.JobCatalogTimelineEntry, error) <span class="cov8" title="1">{
        if s == nil || s.ListJobLevelTimelineFn == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return s.ListJobLevelTimelineFn(ctx, tenantID, code)</span>
}

type StubOrganizationRepository struct {
        GetByCodeFn func(ctx context.Context, tenantID uuid.UUID, code string) (*types.Organization, error)
}

func (s *StubOrganizationRepository) GetByCode(ctx context.Context, tenantID uuid.UUID, code string) (*types.Organization, error) <span class="cov8" title="1">{
        if s.GetByCodeFn != nil </span><span class="cov8" title="1">{
                return s.GetByCodeFn(ctx, tenantID, code)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

type StubAssignmentRepository struct {
        GetByIDFn      func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, assignmentID uuid.UUID) (*types.PositionAssignment, error)
        SumActiveFTEFn func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, positionCode string) (float64, error)
}

func (s *StubAssignmentRepository) GetByID(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, assignmentID uuid.UUID) (*types.PositionAssignment, error) <span class="cov8" title="1">{
        if s.GetByIDFn != nil </span><span class="cov8" title="1">{
                return s.GetByIDFn(ctx, tx, tenantID, assignmentID)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *StubAssignmentRepository) SumActiveFTE(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, positionCode string) (float64, error) <span class="cov8" title="1">{
        if s.SumActiveFTEFn != nil </span><span class="cov8" title="1">{
                return s.SumActiveFTEFn(ctx, tx, tenantID, positionCode)
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

type StubPositionRepository struct {
        GetCurrentPositionFn func(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.Position, error)
}

func (s *StubPositionRepository) GetCurrentPosition(ctx context.Context, tx *sql.Tx, tenantID uuid.UUID, code string) (*types.Position, error) <span class="cov8" title="1">{
        if s.GetCurrentPositionFn != nil </span><span class="cov8" title="1">{
                return s.GetCurrentPositionFn(ctx, tx, tenantID, code)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
