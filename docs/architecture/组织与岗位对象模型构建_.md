

# **组织与岗位核心实体对象模型权威规约**

## **引言**

### **目的与权威性**

本文档旨在为本HR SaaS平台提供OrganizationUnit（组织单元）与Position（岗位）这两个核心人力资源（Core HR）资源的规范性、权威性对象模型。此规约是其设计、实现与未来演进的唯一事实来源（Single Source of Truth）。任何与这两个实体相关的开发、集成或扩展工作，都必须严格遵循本规约所定义的结构、行为和治理原则。

### **战略背景**

这两个核心实体模型并非孤立的技术定义，而是平台“城堡模型”（Castle Model）架构的直接技术实现，其设计思想和强制性约束均源自于平台的最高技术宪章——《元合约v6.0》 1。根据城堡模型的划分，

OrganizationUnit与Position实体被归属于core-hr.keep命名空间。这一命名不仅是逻辑上的分类，更是一种架构上的宣告：它们是整个系统“主堡”（The Keep）的基石，是平台最核心、防卫最森严的业务领域，为所有其他“塔楼”（Towers）模块提供基础的人力资源上下文与能力 1。

### **指导原则**

本规约的设计与定义严格遵循并体现了平台架构的四大核心原则，这些原则共同确保了模型的灵活性、健壮性与面向未来的可扩展性：

* **设计驱动的多态性 (Polymorphism by Design)**：采用统一的“核心模型 \+ 嵌套多态档案”模式，以优雅、可扩展的方式管理企业中多样化的组织单元与岗位类型，满足真实世界HR场景的复杂性 1。  
* **事件驱动的时态性 (Event-Driven Temporality)**：所有对核心实体状态的变更，都必须通过发布不可变的、带有生效日期的业务事件来驱动。严禁任何对核心数据表的直接修改（UPDATE）或删除（DELETE）操作。这一原则确保了所有变更历史的完整性、可审计性与可追溯性，使得“时间旅行”式查询成为可能 1。  
* **声明式的混合持久化 (Declarative Hybrid Persistence)**：通过在元合约中进行声明式配置，一份单一的规约即可同时定义实体在关系型“记录系统”（System of Record, 如PostgreSQL）和图数据库“洞察系统”（System of Insight, 如Neo4j）中的持久化策略。这为自动化、可靠的数据同步提供了治理依据 1。  
* **安全作为基石 (Security as a Foundation)**：所有模型从设计之初就内嵌了平台的“默认安全”、多租户隔离架构。通过嵌入式策略引擎（OPA）和数据库行级安全（RLS）等多层防御机制，确保数据访问的绝对安全与合规 1。

---

## **第一部分：组织单元对象模型 (OrganizationUnit)**

本部分详细定义了OrganizationUnit实体。该实体是一个高度通用的概念，旨在代表企业内部任何形式的组织性分组，例如传统的职能部门、事业部，也包括财务核算用的成本中心，或是为特定任务组建的临时项目团队 1。

### **1.1 核心身份与基础属性**

本节所定义的属性构成了任何OrganizationUnit实例绝对基础的、不可变的通用属性，无论其具体类型为何。这些属性并非简单的字段集合，而是由《元合约v6.0》强制规定的“宪法DNA”，是确保每个实体在平台内具有唯一性、隔离性、可审计性和多态性的技术基石 1。设计一个新的核心实体，本质上并非一次创造性的自由练习，而是一次严格遵循宪法模板的实例化过程，这确保了整个系统的高度一致性、可预测性和可治理性。

The following table:

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| id | UUID | 是 | 实体的全局唯一、不可变标识符，是其在系统中的绝对地址。《元合约》强制使用UUID，以确保在分布式环境中ID生成的无冲突性，并解除了对中央序列生成器的依赖，为系统的可伸缩性和解耦性提供支持 1。 |
| tenant\_id | UUID | 是 | 标识该组织单元记录所属的企业客户。此字段不可为空，是实现SaaS平台多租户数据隔离的基石。《元合约》规约EAC-003和8.7要求，所有数据库查询和业务逻辑都必须强制以此字段作为过滤条件，并通过数据库行级安全（RLS）提供最终保障，从根本上防止数据泄露 1。 |
| unitType | enum | 是 | 关键的**鉴别器 (Discriminator)** 字段。其值（如DEPARTMENT, COST\_CENTER）明确了该组织单元的顶层分类，并动态决定了下方profile插槽中应填充何种具体的数据结构。这是实现平台多态性战略的核心，直接响应了企业需要管理多样化组织类型（如监管组织、成本中心等）的业务需求 1。 |
| name | string | 是 | 组织单元的人类可读名称，例如“研发部”。这是基础的业务标识符 1。 |
| description | string | 否 | 对该单元职责或目的的详细描述，为业务提供额外上下文。 |
| parentUnitId | UUID | 否 | 一个指向另一个OrganizationUnit记录id的自引用外键。这是构建组织层级结构（例如，部门隶属于事业部）的主要机制。值为null表示该单元为顶层组织。该字段直接实现了对Workday监管组织层级结构的对标 1。 |
| status | enum | 是 | 组织单元的当前运营状态。可选值包括ACTIVE（激活）、INACTIVE（停用）、PLANNED（规划中）。此状态对业务流程至关重要，例如，系统应阻止将岗位分配给一个已停用的部门。 |
| created\_at | ISO8601 DateTime | 是 | 记录在数据库中被创建的精确时间戳。此字段由系统自动维护，作为不可篡改的审计信息，用于追踪记录的生命周期起点 1。 |
| updated\_at | ISO8601 DateTime | 是 | 记录最后一次被修改的精确时间戳。同样由系统自动维护，为数据变更历史和问题排查提供关键的审计线索 1。 |

### **1.2 多态结构**

本节详细阐述了平台为应对企业组织结构多样性而设计的“核心模型 \+ 嵌套多态档案”模式。该模式是《元合约》中polymorphism规约的直接体现 1，它允许我们用一个统一的

OrganizationUnit资源来表示不同类型的组织，同时为每种类型提供精确的、差异化的属性建模。

其核心机制在于OrganizationUnit模型中的profile字段。该字段本身是一个“插槽”（Slot），其具体的数据结构由核心身份中的unitType鉴别器字段的值动态决定。这种设计避免了创建臃肿、包含大量空字段的“胖模型”，也避免了为每种组织类型维护一套独立API的复杂性。下表清晰地将业务需求（源自对Workday等行业最佳实践的分析 1）映射到具体的技术实现方案，为开发者和业务分析师提供了明确的、可执行的规约。

The following table:

| 档案名称 (Profile Name) | unitType枚举值 | 描述 | 关键属性 | 需求来源 |
| :---- | :---- | :---- | :---- | :---- |
| DepartmentProfile | DEPARTMENT | 代表企业内标准的职能或业务单元，是构建监管层级的基础。 | headOfUnitPersonId (UUID): 该部门负责人的员工ID。 | 对标Workday的监管组织（Supervisory Organizations）1 |
| CostCenterProfile | COST\_CENTER | 代表一个用于财务责任划分和预算管理的单元。 | costCenterCode (string): 成本中心的唯一业务编码。 financialOwnerId (UUID): 财务负责人的员工ID。 | 对标Workday的成本中心（Cost Centers）1 |
| CompanyProfile | COMPANY | 代表企业内的一个法律实体，用于管理跨法人实体的组织。 | legalEntityId (string): 法律实体的官方注册号。 taxId (string): 税务登记号。 | 对标Workday的公司层级（Company Hierarchy）1 |
| ProjectTeamProfile | PROJECT\_TEAM | 代表一个为特定目标而组建的、通常是临时的、跨职能的团队。 | projectLeadPersonId (UUID): 项目负责人的员工ID。 projectStartDate (Date): 项目开始日期。 projectEndDate (Date): 项目预计结束日期。 | 对标Workday的自定义组织或矩阵组织（Custom/Matrix Organizations）1 |

### **1.3 时态特征与历史**

本节定义了OrganizationUnit模型如何捕捉随时间发生的所有变更，从而实现全面的历史追溯和“时间旅行”式查询。这直接满足了企业需要查看任意时间点（“截至日期”报告）的组织结构、理解组织演变并分析重组影响的核心需求 1。

其实现方式并非传统地在数据表上进行修改，而是基于《元合约》temporality\_paradigm: EVENT\_DRIVEN和state\_transition\_model: EVENT\_DRIVEN的强制性规约 1。这意味着

OrganizationUnit的生命周期状态完全由一系列按时间顺序排列的、不可变的业务事件所决定。

在这种架构范式下，我们对“数据”的理解发生了根本性的转变。传统的系统将“当前状态”的表视作事实的来源，历史记录只是其变更的日志。而我们的架构则将这个关系彻底反转：**不可变的事件日志本身才是最终的、唯一的、可审计的“事实来源”（Source of Truth）**。我们看到的“当前组织结构”，仅仅是系统将所有历史事件按顺序“重放”后得到的一个物化视图或缓存。

这种设计的战略价值是巨大的：

* **审计与合规**：完整的事件日志本身就是一份无可辩驳的、细粒度的审计轨迹，详细记录了“谁、在何时、以何种业务理由、做了什么变更”。  
* **分析与洞察**：可以通过分析事件流来洞察组织变革的频率、模式和影响，为战略性劳动力规划提供数据支持。  
* **错误修正**：如果发生错误，我们无需尝试“修复”已损坏的数据，而是通过发布一个新的“补偿事件”来纠正历史，这在架构上更为稳健和安全。

为了实现这一点，数据库层面会设计一个独立的OrganizationUnitHistory表。每当一个影响OrganizationUnit的业务事件（如创建、重命名、层级变更）被处理时，系统都会在此历史表中创建一条新的记录，该记录拥有自己的effectiveDate（生效日期）和endDate（失效日期），精确地定义了该版本组织单元的有效时间区间。

### **1.4 关联维度与关系**

本节定义OrganizationUnit与其他核心实体之间的关键关联关系。至关重要的是，这些关系定义不仅服务于传统的数据库外键约束，更通过《元合约》的persistence\_profile和linkable\_objects规约，为图数据库中的“边”（Edge）提供了声明式的、可治理的定义 1。

这种设计体现了元合约作为\*\*“统一模式注册中心”\*\*的强大能力。开发者只需在一个地方（元合约的YAML文件）定义关系，系统即可同时获得关系型数据库和图数据库的模式信息。这从根本上杜绝了两种数据模型之间发生“漂移”或不一致的可能性。更进一步，平台内置的“进程内事务性发件箱”工作线程可以读取这份合约，自动地、无需任何定制化代码地将关系型数据库的行变更，可靠地翻译为图数据库中正确的节点和边的创建/更新操作 1。这是一种高度自动化、声明式、自服务的的数据拓扑治理方式。

* **层级关系 (父子关系)**  
  * **关系型实现**: 通过OrganizationUnit表上的parentUnitId自引用外键实现。  
  * **图模型实现**: 此关系被显式建模为图的一条边，在元合约中声明如下：  
    * rel: up (遵循IANA标准，表示指向父资源的链接)  
    * is\_graph\_edge: true  
    * graph\_edge\_label: PART\_OF  
    * graph\_edge\_direction: OUTGOING (表示本组织单元是另一个更大单元的“一部分”)  
* **包含关系 (组织单元 \-\> 岗位)**  
  * **关系型实现**: 通过在Position表上设置departmentId外键，将岗位与组织单元关联。  
  * **图模型实现**: 这同样是一条对组织分析至关重要的图的边：  
    * rel: item (遵循IANA标准，表示被包含的项)  
    * is\_graph\_edge: true  
    * graph\_edge\_label: CONTAINS\_POSITION  
    * graph\_edge\_direction: OUTGOING (表示本组织单元“包含”若干岗位)

### **1.5 内嵌安全与隐私态势**

本节重申并具体化了应用于OrganizationUnit实体的、不可协商的安全与隐私规则。这些规则并非附加功能，而是实体本身固有的属性，由《元合约》强制规定，并由平台架构提供纵深防御 1。

* **认证 (Authentication)**: 对OrganizationUnit资源的任何访问，都必须通过平台标准的OAuth 2.0 / OpenID Connect (OIDC)流程进行身份验证。  
* **授权 (Authorization)**: 采用基于角色的访问控制（RBAC）作为基础，并叠加基于属性的访问控制（ABAC）进行更精细的权限判断。  
  * **示例**: 一个拥有HR Business Partner角色的用户（RBAC），其权限可能被进一步限制为只能访问其所支持的业务线（如“销售部”及其下属所有单元）的组织数据。这个“所支持业务线”就是一个ABAC属性。  
* **租户隔离 (Tenant Isolation)**: 这是SaaS平台最核心的安全保障。  
  * **策略引擎强制执行**: 在OrganizationUnit的元合约安全模型中，enforce\_tenant\_boundary标志被设为true。这意味着嵌入式OPA策略引擎会依据EAC-003规约，自动拒绝任何试图访问当前用户tenant\_id之外的组织单元的请求 1。  
  * **数据库最终保障**: 作为最后一道防线，应用代码在执行任何数据库查询前，都必须遵循元合约规约8.7，在当前事务中执行SET LOCAL app.current\_tenant\_id \= '...'。数据库中所有受保护的表都应用了依赖此会话变量的行级安全（Row-Level Security, RLS）策略。这使得数据库自身成为数据隔离的最终仲裁者，从根本上防止了任何代码缺陷或恶意攻击导致的跨租户数据访问 1。

---

## **第二部分：岗位对象模型 (Position)**

本部分详细定义了Position实体。该实体代表了组织内一个具体的、有编制预算的“椅子”或角色。它并非员工本身，而是员工将要“占据”的组织资源。Position是实现战略性劳动力规划、人员编制控制和招聘管理的核心与基石 1。

### **2.1 核心身份与基础属性**

本节定义了构成任何Position实例的核心属性。其设计严格遵循了Workday分析中提炼出的“岗位即资源”（Position as a Resource）的核心理念：岗位是一个独立于员工的、拥有自身生命周期和历史的持久性资源 1。这一理念对于强大的劳动力规划、预算编制和历史分析至关重要，因为它允许我们独立于具体的人来跟踪角色和编制的演变。

The following table:

| 属性 | 类型 | 必需 | 说明/理由 |
| :---- | :---- | :---- | :---- |
| id | UUID | 是 | 岗位的全局唯一、不可变标识符。 |
| tenant\_id | UUID | 是 | 标识该岗位记录所属的企业客户，是多租户隔离的基石。 |
| positionType | enum | 是 | **鉴别器 (Discriminator)** 字段。其值（如FULL\_TIME, CONTINGENT\_WORKER）决定了下方details插槽中应填充何种具体的数据结构。这直接满足了企业管理“混合型劳动力”的需求 1。 |
| jobProfileId | UUID | 是 | 指向JobProfile实体（职位说明书）的外键。JobProfile定义了该类岗位的通用信息，如职位名称、职级、任职资格等。此设计将岗位的“实例”（这张具体的椅子）与其“模板”（这类椅子的规格）解耦 1。 |
| departmentId | UUID | 是 | 指向该岗位所属OrganizationUnit实体的外键。 |
| managerPositionId | UUID | 否 | 一个指向另一个Position记录id的自引用外键。这是构建**监管汇报层级**（“谁向谁汇报”）的核心机制。值为null表示该岗位为顶层岗位。 |
| status | enum | 是 | 岗位的当前生命周期状态。可选值包括OPEN（空缺）、FILLED（已填充）、FROZEN（已冻结）、PENDING\_ELIMINATION（待撤销）。此状态是招聘和预算流程的关键输入 1。 |
| budgetedFTE | Decimal | 是 | 预算内的全职等效工时（Full-Time Equivalent）。例如，1.0代表全职，0.5代表半职。这是进行精确的预算控制和承诺会计的核心字段 1。 |

### **2.2 多态结构**

本节详细阐述了Position模型如何通过positionType鉴别器和details插槽，来优雅地管理现代企业中日益普遍的“混合型劳动力”（Blended Workforce），例如全职员工、兼职员工、实习生和外部派遣顾问等 1。每种用工类型在管理上都有其独特的属性和业务规则，多态结构为此提供了精确的建模能力。

The following table:

| 档案名称 (Profile Name) | positionType枚举值 | 描述 | 关键属性 | 需求来源 |
| :---- | :---- | :---- | :---- | :---- |
| FullTimePositionDetails | FULL\_TIME | 一个常规的、全职的、永久性的岗位。 | salaryBand (string): 薪酬等级。 bonusEligible (boolean): 是否享有奖金资格。 | 基础岗位管理需求 1 |
| PartTimePositionDetails | PART\_TIME | 一个常规的、非全职的、永久性的岗位。 | standardHoursPerWeek (Decimal): 每周标准工作小时数。 | 基础岗位管理需求 1 |
| ContingentWorkerDetails | CONTINGENT\_WORKER | 为外部供应商提供的临时工或合同工所设的岗位。 | vendorId (UUID): 供应商ID。 hourlyRate (Money): 小时费率。 contractEndDate (Date): 合同结束日期。 | 对标Workday对派遣员工的管理能力 1 |
| InternPositionDetails | INTERN | 为实习生计划所设的临时性岗位。 | internshipProgramId (UUID): 实习生项目ID。 mentorPersonId (UUID): 导师的员工ID。 | 满足企业特殊用工场景 |

### **2.3 时态特征与历史**

本节定义了如何全面追踪一个岗位的完整历史。Workday分析明确指出，即使员工调动或离职，岗位自身的属性（如所属部门、汇报关系）依然保留在岗位上，且其历史需要被完整追踪 1。

为了实现这一目标，并保持数据模型的概念纯粹性，一个关键的设计决策是将岗位的历史拆分为两个独立的、正交的维度进行记录：**岗位自身属性的历史**和**岗位被占据的历史**。

这种分离设计提供了无与伦比的分析灵活性和清晰度。业务分析师可以独立地提出两类问题，而无需进行复杂的逻辑处理：

1. **关于“椅子”本身的问题**：“这个‘软件工程师’岗位在过去五年中，其汇报关系和所属部门是如何演变的？”——这通过查询PositionAttributeHistory表即可得到答案。  
2. **关于“坐在椅子上的人”的问题**：“过去五年里，先后有哪几位员工担任过这个‘软件工程师’岗位？他们各自的任期是多久？”——这通过查询PositionOccupancyHistory表即可得到答案。

这一设计同样完全基于事件驱动的范式 1。

* **岗位属性历史 (PositionAttributeHistory)**: 这是一个独立的、不可变的历史表。每当岗位的核心属性（如departmentId, managerPositionId, status, jobProfileId等）发生变更时，系统都会在此表中追加一条新的、带effectiveDate和endDate的版本记录。  
* **岗位占据历史 (PositionOccupancyHistory)**: 这同样是一个独立的、不可变的历史表。它专门用于记录在某个时间段内，是哪一位Employee占据了某一个Position。其核心字段包括positionId, employeeId, startDate, endDate。

### **2.4 生命周期与状态驱动定义**

本节阐述了平台如何管理与岗位相关的复杂业务流程，如岗位的创建、调动、晋升、冻结/解冻等。直接对岗位实体进行增删改查（CRUD）是被《元合约》所禁止的 1。取而代之的，是采用“流程即资源”（Process as a Resource）的设计模式 1。

* **流程取代CRUD**: 用户或系统不直接“更新”一个岗位的状态，而是“发起”一个业务流程。例如，要将一个岗位从研发部调动到产品部，用户需要通过API发起一个POST /position-transfer-requests请求。  
* **流程资源**: 该请求会创建一个PositionTransferRequest资源。这个资源自身拥有一个状态机（例如，status字段，其值可以为DRAFT, PENDING\_APPROVAL, APPROVED, REJECTED, EXECUTED）。整个调动过程的每一步（如提交、审批、驳回）都是对这个流程资源状态的更新。  
* **原子性更新**: 只有当流程资源成功完成并达到最终批准状态（如EXECUTED）时，一个后端的、拥有特权的事件处理器服务，才会被触发去原子性地发布相应的业务事件（如PositionAttributesChangedEvent）。这个事件最终被用来更新PositionAttributeHistory等核心历史表。

这种模式确保了复杂、多步骤、可能长期运行的组织与岗位变更的事务完整性，彻底避免了因流程中途失败或被拒绝而导致核心数据处于不一致状态（即“幽灵数据”）的风险 1。

### **2.5 关联维度与关系**

本节定义了Position实体在关系图谱中的关键链接，这些链接是生成动态组织结构图、进行劳动力分析和执行权限检查的基础。

* **汇报关系 (经理 \-\> 下属)**  
  * **关系型实现**: 通过Position表上的managerPositionId自引用外键实现。  
  * **图模型实现**: 这是组织分析中最重要的图关系，在元合约中声明如下：  
    * rel: manager  
    * is\_graph\_edge: true  
    * graph\_edge\_label: REPORTS\_TO  
    * graph\_edge\_direction: OUTGOING (表示本岗位“汇报给”其经理岗位)  
* **占据关系 (岗位 \-\> 员工)**  
  * **关系型实现**: 通过PositionOccupancyHistory历史表进行建模。  
  * **图模型实现**: 这是一个带时间属性的图关系，表示在某个时间段内的占据情况：  
    * rel: occupant  
    * is\_graph\_edge: true  
    * graph\_edge\_label: OCCUPIED\_BY  
    * graph\_edge\_direction: OUTGOING (表示本岗位“被...占据”)  
    * **边属性**: 这条图的边（Edge）自身会包含startDate和endDate等属性，以支持时态图查询。

---

## **第三部分：元合约遵从性与治理**

本结论部分提供了一份最终的、权威的符合性清单，旨在正式地、可审计地证明上文定义的OrganizationUnit和Position对象模型完全遵循并满足了平台最高技术宪章《元合约v6.0》的所有相关强制性规约 1。

这份清单不仅是设计文档的总结，更是一个强有力的治理工具。在进行架构评审、代码审查或自动化CI/CD流水线检查时，它提供了一份清晰的、可被机器和人类共同理解的“合宪性证明”，确保了所有核心实体的设计并非任意为之，而是平台统一治理框架下的、纪律严明的产物。

The following table:

**元合约v6.0符合性审计清单**

| 规约领域 | OrganizationUnit 模型符合性 | Position 模型符合性 |
| :---- | :---- | :---- |
| **核心身份** |  |  |
| namespace | core-hr.keep (符合{module-name}.{castle-component}格式) | core-hr.keep (符合{module-name}.{castle-component}格式) |
| resource\_type | ENTITY (符合持久化业务实体的定义) | ENTITY (符合持久化业务实体的定义) |
| primary\_key类型 | UUID (符合分布式唯一性要求) | UUID (符合分布式唯一性要求) |
| **时态与状态模型** |  |  |
| temporality\_paradigm | EVENT\_DRIVEN (符合历史追溯和审计要求) | EVENT\_DRIVEN (符合历史追溯和审计要求) |
| state\_transition\_model | EVENT\_DRIVEN (强制要求核心实体的状态变更由事件驱动) | EVENT\_DRIVEN (强制要求核心实体的状态变更由事件驱动) |
| **持久化策略** |  |  |
| persistence\_profile | 已定义：primary\_store: RELATIONAL, indexed\_in:, graph\_node\_label: 'OrgUnit' | 已定义：primary\_store: RELATIONAL, indexed\_in:, graph\_node\_label: 'Position' |
| **关系与图模型** |  |  |
| 图关系定义 | 已通过linkable\_objects和is\_graph\_edge: true声明PART\_OF和CONTAINS\_POSITION等图的边。 | 已通过linkable\_objects和is\_graph\_edge: true声明REPORTS\_TO和OCCUPIED\_BY等图的边。 |
| **安全与租户模型** |  |  |
| 安全模型遵循性 | 完全合规：采用OAuth 2.0认证，RBAC+ABAC授权，并通过enforce\_tenant\_boundary: true和数据库RLS强制执行租户隔离。 | 完全合规：采用OAuth 2.0认证，RBAC+ABAC授权，并通过enforce\_tenant\_boundary: true和数据库RLS强制执行租户隔离。 |

#### **引用的著作**

1. 蓝图1.0员工对象模型