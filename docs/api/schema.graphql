schema {
  query: Query
}

type AssignmentStats {
  positionCode: PositionCode
  organizationCode: String
  totalAssignments: Int!
  activeAssignments: Int!
  pendingAssignments: Int!
  endedAssignments: Int!
  primaryAssignments: Int!
  secondaryAssignments: Int!
  actingAssignments: Int!
  lastUpdatedAt: DateTime!
}

type AuditLogDetail {
  auditId: String!
  recordId: String!
  """Specific organization temporal version being audited"""
  operation: String!
  timestamp: String!
  operationReason: String
  """Change tracking data"""
  beforeData: String
  """Organization state before the change (JSON string)"""
  afterData: String
  """Organization state after the change (JSON string)"""
  modifiedFields: [String!]!
  """List of field names that were modified"""
  changes: [FieldChange!]!
}

type CacheInconsistency {
  code: String!
  fieldName: String!
  cachedValue: String!
  calculatedValue: String!
  impactLevel: String!
}

type CircularReference {
  affectedCodes: [String!]!
  circularPath: [String!]!
  severity: String!
}

enum ConsistencyCheckMode {
  FAST
  """Cache field consistency only (< 5s)"""
  DEEP
  """Full recursive validation (30s-5min)"""
  TARGETED
}

type ConsistencyFindings {
  pathMismatches: [PathMismatch!]!
  levelInconsistencies: [LevelInconsistency!]!
  orphanedNodes: [OrphanedNode!]!
  circularReferences: [CircularReference!]!
  depthViolations: [DepthViolation!]!
  cacheInconsistencies: [CacheInconsistency!]!
}

type DataChanges {
  beforeData: JSON
  afterData: JSON
  modifiedFields: [String!]!
}

"""Scalar Types"""
scalar Date

type DateRange {
  earliest: DateTime!
  latest: DateTime!
}

input DateRangeInput {
  from: String
  to: String
}

scalar DateTime

type DepthDistribution {
  depth: Int!
  count: Int!
}

type DepthViolation {
  code: String!
  currentDepth: Int!
  maxAllowedDepth: Int!
  parentChain: [String!]!
}

enum EmploymentType {
  FULL_TIME
  PART_TIME
  INTERN
}

type FamilyHeadcount {
  jobFamilyCode: JobFamilyCode!
  jobFamilyName: String
  capacity: Float!
  utilized: Float!
  available: Float!
}

type FieldChange {
  field: String!
  """Name of the changed field"""
  oldValue: String
  """Previous value as string (null for CREATE operations)"""
  newValue: String
  """New value as string (null for DELETE operations)"""
  dataType: String!
}

type HeadcountStats {
  organizationCode: String!
  organizationName: String!
  totalCapacity: Float!
  totalFilled: Float!
  totalAvailable: Float!
  fillRate: Float!
  byLevel: [LevelHeadcount!]!
  byType: [TypeHeadcount!]!
  byFamily: [FamilyHeadcount!]!
}

type HierarchyConsistencyReport {
  checkId: String!
  tenantId: String!
  executedAt: DateTime!
  executionTimeMs: Int!
  totalChecked: Int!
  issuesFound: Int!
  checkMode: ConsistencyCheckMode!
  consistencyReport: ConsistencyFindings!
  repairSuggestions: [RepairSuggestion!]!
  healthScore: Float!
  recommendedActions: [String!]!
}

type HierarchyStatistics {
  tenantId: String!
  totalOrganizations: Int!
  maxDepth: Int!
  avgDepth: Float!
  depthDistribution: [DepthDistribution!]!
  rootOrganizations: Int!
  leafOrganizations: Int!
  integrityIssues: [IntegrityIssue!]!
  lastAnalyzed: String!
}

type IntegrityIssue {
  type: String!
  count: Int!
  affectedCodes: [String!]!
}

scalar JSON

enum JobCatalogStatus {
  ACTIVE
  INACTIVE
}

type JobFamily {
  code: JobFamilyCode!
  recordId: UUID!
  groupCode: JobFamilyGroupCode!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  description: String
}

scalar JobFamilyCode

type JobFamilyGroup {
  code: JobFamilyGroupCode!
  recordId: UUID!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  description: String
}

scalar JobFamilyGroupCode

type JobLevel {
  code: JobLevelCode!
  recordId: UUID!
  roleCode: JobRoleCode!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  levelRank: Int!
  description: String
}

scalar JobLevelCode

type JobRole {
  code: JobRoleCode!
  recordId: UUID!
  familyCode: JobFamilyCode!
  name: String!
  status: JobCatalogStatus!
  effectiveDate: Date!
  endDate: Date
  description: String
}

scalar JobRoleCode

type LevelHeadcount {
  jobLevelCode: JobLevelCode!
  capacity: Float!
  utilized: Float!
  available: Float!
}

type LevelInconsistency {
  code: String!
  expectedLevel: Int!
  actualLevel: Int!
  parentCode: String!
  reason: String!
}

type LevelStatistic {
  level: Int!
  count: Int!
}

"""Supporting Types"""
type OperatedBy {
  id: String!
  name: String!
}

enum OperationType {
  CREATE
  """New organization creation"""
  UPDATE
  """Data modification (PUT/PATCH)  """
  SUSPEND
  """Suspension operation (endpoint: POST /suspend)"""
  REACTIVATE
  """Reactivation operation (endpoint: POST /activate)"""
  DEACTIVATE
  """Deactivation (timeline correction / planned removal)"""
  DELETE
}

type OperationsSummary {
  create: Int!
  update: Int!
  suspend: Int!
  reactivate: Int!
  delete: Int!
}

"""Core Data Types"""
type Organization {
  """Business Identifiers"""
  code: String!
  parentCode: String!
  """
  Parent organization code. Use "0" for root organizations, or valid 7-digit code for child organizations
  """
  tenantId: String!
  """Basic Information"""
  name: String!
  unitType: UnitType!
  """
  Business status (one-dimensional): ACTIVE | INACTIVE | DELETED
  Soft-delete 判定完全依赖该字段，DELETED 表示记录不再对外展示
  ADR-008: 一维业务状态模型，INACTIVE 等价于停用/暂停语义
  """
  status: Status!
  """Hierarchy Information"""
  level: Int!
  sortOrder: Int
  codePath: String!
  namePath: String!
  path: String @deprecated(reason: "使用 codePath/namePath 作为唯一事实来源，path 将在后续版本移除")
  """Configuration"""
  description: String
  profile: String
  changeReason: String
  """
  Temporal Information
  Notes:
  - isTemporal is a derived concept (NOT a stored column): endDate != null
  - isFuture is derived using Beijing business day (UTC+8): effectiveDate > today(CN)
  """
  effectiveDate: String!
  endDate: String
  """Audit Information"""
  createdAt: String!
  updatedAt: String!
  recordId: String!
  """Temporal Status Information (derived)"""
  isCurrent: Boolean!
  isTemporal: Boolean!
  isFuture: Boolean!
  hierarchyDepth: Int!
  childrenCount: Int!
  """Soft delete & suspension audit fields (optional)"""
  deletedAt: String
  deletedBy: String
  deletionReason: String
  suspendedAt: String
  suspendedBy: String
  suspensionReason: String
}

type OrganizationConnection {
  data: [Organization!]!
  pagination: PaginationInfo!
  temporal: TemporalInfo!
}

"""Input Types"""
input OrganizationFilter {
  """Temporal Filtering"""
  asOfDate: String
  includeFuture: Boolean = false
  onlyFuture: Boolean = false
  """Business Filtering"""
  unitType: UnitType
  status: Status
  parentCode: String
  codes: [String!]
  excludeCodes: [String!]
  excludeDescendantsOf: String
  includeDisabledAncestors: Boolean = false
  """Hierarchy Filtering"""
  level: Int
  minLevel: Int
  maxLevel: Int
  rootsOnly: Boolean = false
  leavesOnly: Boolean = false
  """Text Search"""
  searchText: String
  searchFields: [SearchField!] = [NAME, DESCRIPTION]
  """Advanced Filtering"""
  hasChildren: Boolean
  hasProfile: Boolean
  profileContains: JSON
  """Audit Filtering"""
  operationType: OperationType
  operatedBy: String
  operationDateRange: DateRangeInput
}

type OrganizationHierarchy {
  code: String!
  name: String!
  level: Int!
  hierarchyDepth: Int!
  codePath: String!
  namePath: String!
  parentChain: [String!]!
  childrenCount: Int!
  isRoot: Boolean!
  isLeaf: Boolean!
  children: [OrganizationHierarchy!]!
}

type OrganizationStats {
  totalCount: Int!
  activeCount: Int!
  inactiveCount: Int!
  plannedCount: Int!
  deletedCount: Int!
  byType: [TypeStatistic!]!
  byStatus: [StatusStatistic!]!
  byLevel: [LevelStatistic!]!
  temporalStats: TemporalStatistics!
}

type OrphanedNode {
  code: String!
  name: String!
  parentCode: String!
  reason: String!
}

type PaginationInfo {
  total: Int!
  page: Int!
  pageSize: Int!
  hasNext: Boolean!
  hasPrevious: Boolean!
}

input PaginationInput {
  page: Int = 1
  pageSize: Int = 50
  """Max 1000"""
  sortBy: String = "code"
  sortOrder: String = "asc"
}

type PathMismatch {
  code: String!
  expectedCodePath: String!
  actualCodePath: String!
  expectedNamePath: String!
  actualNamePath: String!
  severity: String!
}

type Position {
  code: PositionCode!
  recordId: UUID!
  tenantId: UUID!
  title: String!
  jobProfileCode: String
  jobProfileName: String
  jobFamilyGroupCode: JobFamilyGroupCode!
  jobFamilyCode: JobFamilyCode!
  jobRoleCode: JobRoleCode!
  jobLevelCode: JobLevelCode!
  organizationCode: String!
  organizationName: String
  positionType: PositionType!
  employmentType: EmploymentType!
  gradeLevel: String
  headcountCapacity: Float!
  headcountInUse: Float!
  availableHeadcount: Float!
  currentAssignment: PositionAssignment
  assignmentHistory: [PositionAssignment!]!
  reportsToPositionCode: PositionCode
  status: PositionStatus!
  effectiveDate: Date!
  endDate: Date
  isCurrent: Boolean!
  isFuture: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PositionAssignment {
  assignmentId: UUID!
  positionCode: PositionCode!
  positionRecordId: UUID!
  employeeId: UUID!
  employeeName: String!
  employeeNumber: String
  assignmentType: PositionAssignmentType!
  assignmentStatus: PositionAssignmentStatus!
  fte: Float!
  effectiveDate: Date!
  endDate: Date
  actingUntil: Date
  autoRevert: Boolean!
  reminderSentAt: DateTime
  isCurrent: Boolean!
  notes: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PositionAssignmentAudit {
  assignmentId: UUID!
  eventType: String!
  effectiveDate: Date!
  endDate: Date
  actor: String!
  changes: JSON
  createdAt: DateTime!
}

type PositionAssignmentAuditConnection {
  data: [PositionAssignmentAudit!]!
  pagination: PaginationInfo!
  totalCount: Int!
}

type PositionAssignmentConnection {
  edges: [PositionAssignmentEdge!]!
  pagination: PaginationInfo!
  data: [PositionAssignment!]!
  totalCount: Int!
}

type PositionAssignmentEdge {
  cursor: String!
  node: PositionAssignment!
}

input PositionAssignmentFilterInput {
  employeeId: UUID
  status: PositionAssignmentStatus
  assignmentTypes: [PositionAssignmentType!]
  dateRange: DateRangeInput
  asOfDate: Date
  includeHistorical: Boolean = true
  includeActingOnly: Boolean = false
}

enum PositionAssignmentSortField {
  EFFECTIVE_DATE
  END_DATE
  CREATED_AT
}

input PositionAssignmentSortInput {
  field: PositionAssignmentSortField!
  direction: SortOrder = DESC
}

enum PositionAssignmentStatus {
  PENDING
  ACTIVE
  ENDED
}

enum PositionAssignmentType {
  PRIMARY
  SECONDARY
  ACTING
}

scalar PositionCode

type PositionConnection {
  edges: [PositionEdge!]!
  pagination: PaginationInfo!
  data: [Position!]!
  totalCount: Int!
}

type PositionEdge {
  cursor: String!
  node: Position!
}

input PositionFilterInput {
  organizationCode: String
  positionCodes: [PositionCode!]
  status: PositionStatus
  jobFamilyGroupCodes: [JobFamilyGroupCode!]
  jobFamilyCodes: [JobFamilyCode!]
  jobRoleCodes: [JobRoleCode!]
  jobLevelCodes: [JobLevelCode!]
  positionTypes: [PositionType!]
  employmentTypes: [EmploymentType!]
  effectiveRange: DateRangeInput
}

enum PositionSortField {
  CODE
  TITLE
  EFFECTIVE_DATE
  STATUS
}

input PositionSortInput {
  field: PositionSortField!
  direction: SortOrder = ASC
}

enum PositionStatus {
  PLANNED
  ACTIVE
  FILLED
  VACANT
  INACTIVE
  DELETED
}

enum PositionTimelineCategory {
  POSITION_VERSION
  POSITION_ASSIGNMENT
}

type PositionTimelineEntry {
  recordId: UUID!
  status: PositionStatus!
  title: String!
  effectiveDate: Date!
  endDate: Date
  isCurrent: Boolean!
  changeReason: String
  timelineCategory: PositionTimelineCategory!
  assignmentType: PositionAssignmentType
  assignmentStatus: PositionAssignmentStatus
}

type PositionTransfer {
  transferId: UUID!
  positionCode: PositionCode!
  fromOrganizationCode: String!
  toOrganizationCode: String!
  effectiveDate: Date!
  initiatedBy: OperatedBy!
  operationReason: String
  createdAt: DateTime!
}

type PositionTransferConnection {
  edges: [PositionTransferEdge!]!
  pagination: PaginationInfo!
  data: [PositionTransfer!]!
  totalCount: Int!
}

type PositionTransferEdge {
  cursor: String!
  node: PositionTransfer!
}

enum PositionType {
  REGULAR
  TEMPORARY
  CONTRACTOR
}

"""
Organization Units Management GraphQL Schema
Version: 4.7.0
Architecture: CQRS Query Layer (Read Operations Only)
Data Source: PostgreSQL with temporal data support
Authentication: OAuth 2.0 Bearer Token required

Features:
- Temporal data queries with asOfDate parameter
- 17-level hierarchy depth support with intelligent caching
- Precise audit trail tracking individual temporal versions (recordId)
- Multi-tenant isolation and security
- Index-optimized for common filters and access patterns

Permission Requirements:
- organizations, organization: org:read
- organizationAtDate, organizationHistory, organizationVersions: org:read:history  
- organizationHierarchy, organizationSubtree: org:read:hierarchy
- organizationStats: org:read:stats
- auditHistory: org:read:audit

Recent Changes (v4.6.0):
- BREAKING: Audit system redesigned for precise recordId tracking
- Removed organizationAuditHistory query (replaced with auditHistory)
- AuditLogDetail now tracks specific temporal versions via recordId field only
- Simplified audit queries: single auditHistory(recordId) for precise tracking
- Removed businessEntityId field from AuditLogDetail (replaced by recordId)
- Enhanced audit precision: each temporal version has independent audit lifecycle
"""
type Query {
  """Basic Organization Queries"""
  organizations(filter: OrganizationFilter, pagination: PaginationInput): OrganizationConnection!
  organization(code: String!, asOfDate: String): Organization
  organizationStats(asOfDate: String, includeHistorical: Boolean = false): OrganizationStats!
  """Advanced Hierarchy Queries"""
  organizationHierarchy(code: String!, tenantId: String!): OrganizationHierarchy
  organizationSubtree(code: String!, tenantId: String!, maxDepth: Int = 10, includeInactive: Boolean = false): [OrganizationHierarchy!]!
  hierarchyStatistics(tenantId: String!, includeIntegrityCheck: Boolean = false): HierarchyStatistics!
  """Position Queries"""
  positions(filter: PositionFilterInput, pagination: PaginationInput, sorting: [PositionSortInput!]): PositionConnection!
  position(code: PositionCode!, asOfDate: Date): Position
  positionTimeline(code: PositionCode!, startDate: Date, endDate: Date): [PositionTimelineEntry!]!
  positionVersions(code: PositionCode!, includeDeleted: Boolean = false): [Position!]!
  positionAssignments(positionCode: PositionCode!, filter: PositionAssignmentFilterInput, pagination: PaginationInput, sorting: [PositionAssignmentSortInput!]): PositionAssignmentConnection!
  positionAssignmentAudit(positionCode: PositionCode!, assignmentId: UUID, dateRange: DateRangeInput, pagination: PaginationInput): PositionAssignmentAuditConnection!
  assignments(organizationCode: String, positionCode: PositionCode, filter: PositionAssignmentFilterInput, pagination: PaginationInput, sorting: [PositionAssignmentSortInput!]): PositionAssignmentConnection!
  assignmentHistory(positionCode: PositionCode!, filter: PositionAssignmentFilterInput, pagination: PaginationInput, sorting: [PositionAssignmentSortInput!]): PositionAssignmentConnection!
  assignmentStats(organizationCode: String, positionCode: PositionCode): AssignmentStats!
  vacantPositions(filter: VacantPositionFilterInput, pagination: PaginationInput, sorting: [VacantPositionSortInput!]): VacantPositionConnection!
  positionTransfers(positionCode: PositionCode, organizationCode: String, pagination: PaginationInput): PositionTransferConnection!
  positionHeadcountStats(organizationCode: String!, includeSubordinates: Boolean = true): HeadcountStats!
  """Audit and Analysis Queries"""
  auditHistory(recordId: String!, startDate: String, endDate: String, operation: OperationType, userId: String, limit: Int = 50): [AuditLogDetail!]!
  auditLog(auditId: String!): AuditLogDetail
  organizationVersions(code: String!, includeDeleted: Boolean): [Organization!]!
  """Job Catalog Queries"""
  jobFamilyGroups(includeInactive: Boolean = false, asOfDate: Date): [JobFamilyGroup!]!
  jobFamilies(groupCode: JobFamilyGroupCode!, includeInactive: Boolean = false, asOfDate: Date): [JobFamily!]!
  jobRoles(familyCode: JobFamilyCode!, includeInactive: Boolean = false, asOfDate: Date): [JobRole!]!
  jobLevels(roleCode: JobRoleCode!, includeInactive: Boolean = false, asOfDate: Date): [JobLevel!]!
}

type RepairSuggestion {
  issueType: String!
  affectedCodes: [String!]!
  suggestedAction: String!
  automatable: Boolean!
  riskLevel: String!
}

enum SearchField {
  NAME
  DESCRIPTION
  CODE_PATH
  NAME_PATH
}

enum SortField {
  CODE
  NAME
  CREATED_AT
  UPDATED_AT
  EFFECTIVE_DATE
  LEVEL
  SORT_ORDER
}

enum SortOrder {
  ASC
  DESC
}

enum Status {
  ACTIVE
  """Actively operating unit"""
  INACTIVE
  """Non-active but existing unit (等价于停用/暂停)"""
  PLANNED
  """Planned unit (未来计划单位)"""
  DELETED
}

type StatusStatistic {
  status: Status!
  count: Int!
}

type TemporalInfo {
  asOfDate: String!
  currentCount: Int!
  futureCount: Int!
  historicalCount: Int!
}

type TemporalStatistics {
  totalVersions: Int!
  averageVersionsPerOrg: Float!
  oldestEffectiveDate: String!
  newestEffectiveDate: String!
}

type TypeHeadcount {
  positionType: PositionType!
  capacity: Float!
  filled: Float!
  available: Float!
}

type TypeStatistic {
  unitType: UnitType!
  count: Int!
}

scalar UUID

"""Enums"""
enum UnitType {
  DEPARTMENT
  """Regular business department"""
  ORGANIZATION_UNIT
  """Generic organizational unit"""
  COMPANY
  """Legal entity company"""
  PROJECT_TEAM
}

type UserInfo {
  userId: String!
  userName: String!
  role: String
}

type VacantPosition {
  positionCode: PositionCode!
  organizationCode: String!
  organizationName: String
  jobFamilyCode: JobFamilyCode!
  jobRoleCode: JobRoleCode!
  jobLevelCode: JobLevelCode!
  vacantSince: Date!
  headcountCapacity: Float!
  headcountAvailable: Float!
  totalAssignments: Int!
}

type VacantPositionConnection {
  edges: [VacantPositionEdge!]!
  pagination: PaginationInfo!
  data: [VacantPosition!]!
  totalCount: Int!
}

type VacantPositionEdge {
  cursor: String!
  node: VacantPosition!
}

input VacantPositionFilterInput {
  organizationCodes: [String!]
  jobFamilyCodes: [JobFamilyCode!]
  jobRoleCodes: [JobRoleCode!]
  jobLevelCodes: [JobLevelCode!]
  positionTypes: [PositionType!]
  minimumVacantDays: Int
  asOfDate: Date
}

enum VacantPositionSortField {
  VACANT_SINCE
  HEADCOUNT_AVAILABLE
  HEADCOUNT_CAPACITY
}

input VacantPositionSortInput {
  field: VacantPositionSortField!
  direction: SortOrder = DESC
}

type _Service {
  sdl: String!
}
