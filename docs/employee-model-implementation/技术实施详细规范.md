# 技术实施详细规范

## 概述

本文档提供员工模型系统功能实现的详细技术规范，包括架构组件设计、接口定义、数据模型和实现细节。

---

## 第一部分：架构组件详细设计

### 1.1 元合约编译器技术规范

#### 核心组件架构

```go
// cmd/metacontract-compiler/main.go
package main

import (
    "github.com/gaogu/cube-castle/internal/metacontract"
    "github.com/gaogu/cube-castle/internal/codegen"
)

type Compiler struct {
    parser      metacontract.Parser
    validator   metacontract.Validator  
    entGenerator codegen.EntGenerator
    apiGenerator codegen.APIGenerator
}

func (c *Compiler) Compile(inputPath, outputPath string) error {
    // 1. 解析元合约YAML
    contract, err := c.parser.Parse(inputPath)
    if err != nil {
        return fmt.Errorf("parse failed: %w", err)
    }
    
    // 2. 验证元合约完整性
    if err := c.validator.Validate(contract); err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }
    
    // 3. 生成Ent Schema
    if err := c.entGenerator.Generate(contract, outputPath); err != nil {
        return fmt.Errorf("ent generation failed: %w", err)
    }
    
    // 4. 生成API路由
    if err := c.apiGenerator.Generate(contract, outputPath); err != nil {
        return fmt.Errorf("api generation failed: %w", err)
    }
    
    return nil
}
```

#### 元合约数据结构

```go
// internal/metacontract/types.go
type MetaContract struct {
    SpecificationVersion string                 `yaml:"specification_version"`
    APIID               uuid.UUID              `yaml:"api_id"`
    Namespace           string                 `yaml:"namespace"`
    ResourceName        string                 `yaml:"resource_name"`
    Version             string                 `yaml:"version"`
    DataStructure       DataStructure          `yaml:"data_structure"`
    SecurityModel       SecurityModel          `yaml:"security_model"`
    TemporalBehavior    TemporalBehaviorModel  `yaml:"temporal_behavior"`
    Relationships       []RelationshipDef      `yaml:"relationships"`
}

type DataStructure struct {
    Fields               []FieldDefinition      `yaml:"fields"`
    PrimaryKey          string                 `yaml:"primary_key"`
    DataClassification  string                 `yaml:"data_classification"`
    PersistenceProfile  *PersistenceProfile    `yaml:"persistence_profile,omitempty"`
    Polymorphism        *PolymorphismDef       `yaml:"polymorphism,omitempty"`
}

type FieldDefinition struct {
    Name                string   `yaml:"name"`
    Type                string   `yaml:"type"`
    Required            bool     `yaml:"required"`
    Unique              bool     `yaml:"unique"`
    DataClassification  string   `yaml:"data_classification"`
    ValidationRules     []string `yaml:"validation_rules,omitempty"`
}

type PersistenceProfile struct {
    PrimaryStore         string   `yaml:"primary_store"`
    IndexedIn           []string  `yaml:"indexed_in,omitempty"`
    GraphNodeLabel      string    `yaml:"graph_node_label,omitempty"`
    GraphEdgeDefinitions []string `yaml:"graph_edge_definitions,omitempty"`
}
```

#### Ent生成器实现

```go
// internal/codegen/ent_generator.go
type EntGenerator struct {
    templateEngine *template.Template
}

func (g *EntGenerator) Generate(contract *MetaContract, outputDir string) error {
    // 生成主实体Schema
    if err := g.generateEntitySchema(contract, outputDir); err != nil {
        return err
    }
    
    // 生成关系定义
    if err := g.generateRelationships(contract, outputDir); err != nil {
        return err
    }
    
    // 生成时态历史实体（如果需要）
    if contract.TemporalBehavior.TemporalityParadigm == "EVENT_DRIVEN" {
        if err := g.generateHistoryEntities(contract, outputDir); err != nil {
            return err
        }
    }
    
    return nil
}

func (g *EntGenerator) generateEntitySchema(contract *MetaContract, outputDir string) error {
    data := struct {
        Contract *MetaContract
        Fields   []EntFieldDefinition
        Edges    []EntEdgeDefinition
    }{
        Contract: contract,
        Fields:   g.convertFields(contract.DataStructure.Fields),
        Edges:    g.convertRelationships(contract.Relationships),
    }
    
    tmpl := `// Code generated by metacontract-compiler. DO NOT EDIT.
package schema

import (
    "time"
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
    "entgo.io/ent/schema/edge" 
    "entgo.io/ent/schema/index"
    "github.com/google/uuid"
    "github.com/gaogu/cube-castle/internal/ent/annotations"
)

// {{.Contract.ResourceName | title}} holds the schema definition for {{.Contract.ResourceName}}.
type {{.Contract.ResourceName | title}} struct {
    ent.Schema
}

// Fields of {{.Contract.ResourceName | title}}.
func ({{.Contract.ResourceName | title}}) Fields() []ent.Field {
    return []ent.Field{
        {{range .Fields}}
        {{.GenerateField}},
        {{end}}
    }
}

// Edges of {{.Contract.ResourceName | title}}.
func ({{.Contract.ResourceName | title}}) Edges() []ent.Edge {
    return []ent.Edge{
        {{range .Edges}}
        {{.GenerateEdge}},
        {{end}}
    }
}

// Indexes of {{.Contract.ResourceName | title}}.
func ({{.Contract.ResourceName | title}}) Indexes() []ent.Index {
    return []ent.Index{
        // 租户隔离索引
        index.Fields("tenant_id"),
        
        // 时间查询优化索引
        {{if eq .Contract.TemporalBehavior.TemporalityParadigm "EVENT_DRIVEN"}}
        index.Fields("tenant_id", "effective_date"),
        {{end}}
    }
}
`
    
    return g.renderTemplate(tmpl, data, filepath.Join(outputDir, contract.ResourceName+".go"))
}
```

### 1.2 增强型工作流引擎

#### 员工生命周期工作流

```go
// internal/workflow/employee_lifecycle.go
package workflow

import (
    "time"
    "go.temporal.io/sdk/workflow"
    "github.com/google/uuid"
)

// EmployeeLifecycleRequest 员工生命周期请求
type EmployeeLifecycleRequest struct {
    TenantID        uuid.UUID            `json:"tenant_id"`
    OnboardingID    uuid.UUID            `json:"onboarding_id"`
    PersonData      PersonCreationData   `json:"person_data"`
    InitialPosition PositionData         `json:"initial_position"`
    StartDate       time.Time            `json:"start_date"`
    RequestedBy     uuid.UUID            `json:"requested_by"`
}

type PersonCreationData struct {
    FirstName   string `json:"first_name"`
    LastName    string `json:"last_name"`
    Email       string `json:"email"`
    PhoneNumber string `json:"phone_number"`
    DateOfBirth string `json:"date_of_birth"`
}

type PositionData struct {
    PositionTitle   string    `json:"position_title"`
    Department      string    `json:"department"`
    ReportsTo       *uuid.UUID `json:"reports_to,omitempty"`
    JobLevel        string    `json:"job_level"`
    EmploymentType  string    `json:"employment_type"`
    Location        string    `json:"location"`
}

// EmployeeLifecycleWorkflow 完整的员工生命周期工作流
func EmployeeLifecycleWorkflow(ctx workflow.Context, req EmployeeLifecycleRequest) (*EmployeeLifecycleResult, error) {
    logger := workflow.GetLogger(ctx)
    logger.Info("Starting employee lifecycle workflow", 
        "tenant_id", req.TenantID, 
        "onboarding_id", req.OnboardingID)
    
    // 设置活动选项
    activityOptions := workflow.ActivityOptions{
        StartToCloseTimeout: time.Minute * 10,
        RetryPolicy: &temporal.RetryPolicy{
            InitialInterval:    time.Second * 10,
            BackoffCoefficient: 2.0,
            MaximumInterval:    time.Minute * 5,
            MaximumAttempts:    3,
        },
    }
    ctx = workflow.WithActivityOptions(ctx, activityOptions)
    
    var result EmployeeLifecycleResult
    
    // 阶段1: 验证入职条件
    logger.Info("Phase 1: Validating onboarding prerequisites")
    var validationResult OnboardingValidationResult
    err := workflow.ExecuteActivity(ctx, 
        activities.ValidateOnboardingPrerequisitesActivity, 
        OnboardingValidationRequest{
            TenantID:     req.TenantID,
            OnboardingID: req.OnboardingID,
            PersonData:   req.PersonData,
        }).Get(ctx, &validationResult)
    
    if err != nil {
        logger.Error("Onboarding validation failed", "error", err)
        return &EmployeeLifecycleResult{
            Success: false,
            Error:   err.Error(),
        }, err
    }
    
    if !validationResult.IsValid {
        logger.Warn("Onboarding validation rejected", "reason", validationResult.Reason)
        return &EmployeeLifecycleResult{
            Success: false,
            Error:   validationResult.Reason,
        }, nil
    }
    
    // 阶段2: 等待最终确认信号（可选的人工审批）
    if validationResult.RequiresManualApproval {
        logger.Info("Phase 2: Waiting for manual approval")
        
        var approvalSignal ApprovalSignal
        signalChan := workflow.GetSignalChannel(ctx, "employee_onboarding_approval")
        
        // 设置7天超时
        approvalCtx, cancel := workflow.WithTimeout(ctx, 7*24*time.Hour)
        defer cancel()
        
        received := signalChan.ReceiveAsync(approvalCtx, &approvalSignal)
        if !received {
            logger.Error("Approval timeout")
            return &EmployeeLifecycleResult{
                Success: false,
                Error:   "Approval timeout - onboarding cancelled",
            }, nil
        }
        
        if !approvalSignal.Approved {
            logger.Info("Onboarding rejected by approver", "reason", approvalSignal.Reason)
            return &EmployeeLifecycleResult{
                Success: false,
                Error:   "Onboarding rejected: " + approvalSignal.Reason,
            }, nil
        }
    }
    
    // 阶段3: 创建员工记录（核心业务逻辑）
    logger.Info("Phase 3: Creating employee records")
    var employeeResult CreateEmployeeResult
    err = workflow.ExecuteActivity(ctx,
        activities.CreateEmployeeRecordActivity,
        CreateEmployeeRequest{
            TenantID:     req.TenantID,
            OnboardingID: req.OnboardingID,
            PersonData:   req.PersonData,
            RequestedBy:  req.RequestedBy,
        }).Get(ctx, &employeeResult)
    
    if err != nil {
        logger.Error("Employee creation failed", "error", err)
        return &EmployeeLifecycleResult{
            Success: false,
            Error:   err.Error(),
        }, err
    }
    
    result.EmployeeID = employeeResult.EmployeeID
    result.PersonID = employeeResult.PersonID
    
    // 阶段4: 创建初始职位记录
    logger.Info("Phase 4: Creating initial position record")
    var positionResult CreatePositionResult
    err = workflow.ExecuteActivity(ctx,
        activities.CreateInitialPositionActivity,
        CreatePositionRequest{
            TenantID:      req.TenantID,
            EmployeeID:    employeeResult.EmployeeID,
            PositionData:  req.InitialPosition,
            EffectiveDate: req.StartDate,
            CreatedBy:     req.RequestedBy,
        }).Get(ctx, &positionResult)
    
    if err != nil {
        logger.Error("Position creation failed", "error", err)
        // 这里可以选择回滚或继续
        result.Warnings = append(result.Warnings, "Position creation failed: "+err.Error())
    } else {
        result.InitialPositionID = &positionResult.PositionID
    }
    
    // 阶段5: 系统集成和权限设置
    logger.Info("Phase 5: System integration and permissions")
    
    // 并行执行多个集成任务
    selector := workflow.NewSelector(ctx)
    
    // 任务1: 创建系统账户
    var accountResult CreateAccountResult
    accountFuture := workflow.ExecuteActivity(ctx,
        activities.CreateSystemAccountActivity,
        CreateAccountRequest{
            TenantID:   req.TenantID,
            EmployeeID: employeeResult.EmployeeID,
            Email:      req.PersonData.Email,
            FirstName:  req.PersonData.FirstName,
            LastName:   req.PersonData.LastName,
        })
    
    selector.AddFuture(accountFuture, func(f workflow.Future) {
        err := f.Get(ctx, &accountResult)
        if err != nil {
            logger.Error("Account creation failed", "error", err)
            result.Warnings = append(result.Warnings, "Account creation failed: "+err.Error())
        } else {
            result.SystemAccountID = &accountResult.AccountID
        }
    })
    
    // 任务2: 发送欢迎邮件
    var emailResult SendEmailResult
    emailFuture := workflow.ExecuteActivity(ctx,
        activities.SendWelcomeEmailActivity,
        SendEmailRequest{
            TenantID:     req.TenantID,
            EmployeeID:   employeeResult.EmployeeID,
            EmailAddress: req.PersonData.Email,
            FirstName:    req.PersonData.FirstName,
            StartDate:    req.StartDate,
        })
    
    selector.AddFuture(emailFuture, func(f workflow.Future) {
        err := f.Get(ctx, &emailResult)
        if err != nil {
            logger.Error("Welcome email failed", "error", err)
            result.Warnings = append(result.Warnings, "Welcome email failed: "+err.Error())
        }
    })
    
    // 任务3: 通知经理
    if req.InitialPosition.ReportsTo != nil {
        var managerResult NotifyManagerResult
        managerFuture := workflow.ExecuteActivity(ctx,
            activities.NotifyManagerActivity,
            NotifyManagerRequest{
                TenantID:      req.TenantID,
                ManagerID:     *req.InitialPosition.ReportsTo,
                NewEmployeeID: employeeResult.EmployeeID,
                StartDate:     req.StartDate,
            })
        
        selector.AddFuture(managerFuture, func(f workflow.Future) {
            err := f.Get(ctx, &managerResult)
            if err != nil {
                logger.Error("Manager notification failed", "error", err)
                result.Warnings = append(result.Warnings, "Manager notification failed: "+err.Error())
            }
        })
    }
    
    // 等待所有任务完成
    for i := 0; i < selector.Len(); i++ {
        selector.Select(ctx)
    }
    
    // 阶段6: 完成入职流程
    logger.Info("Phase 6: Finalizing onboarding")
    err = workflow.ExecuteActivity(ctx,
        activities.FinalizeOnboardingActivity,
        FinalizeOnboardingRequest{
            TenantID:     req.TenantID,
            OnboardingID: req.OnboardingID,
            EmployeeID:   employeeResult.EmployeeID,
            Status:       "COMPLETED",
        }).Get(ctx, nil)
    
    if err != nil {
        logger.Error("Onboarding finalization failed", "error", err)
        result.Warnings = append(result.Warnings, "Onboarding finalization failed: "+err.Error())
    }
    
    result.Success = true
    result.Status = "ACTIVE"
    result.CompletedAt = workflow.Now(ctx)
    
    logger.Info("Employee lifecycle workflow completed successfully",
        "employee_id", result.EmployeeID,
        "warnings_count", len(result.Warnings))
    
    return &result, nil
}

type EmployeeLifecycleResult struct {
    Success           bool       `json:"success"`
    EmployeeID        uuid.UUID  `json:"employee_id,omitempty"`
    PersonID          uuid.UUID  `json:"person_id,omitempty"`
    InitialPositionID *uuid.UUID `json:"initial_position_id,omitempty"`
    SystemAccountID   *string    `json:"system_account_id,omitempty"`
    Status            string     `json:"status"`
    CompletedAt       time.Time  `json:"completed_at,omitempty"`
    Error             string     `json:"error,omitempty"`
    Warnings          []string   `json:"warnings,omitempty"`
}

// 支持信号处理
type ApprovalSignal struct {
    Approved  bool   `json:"approved"`
    Reason    string `json:"reason,omitempty"`
    ApprovedBy uuid.UUID `json:"approved_by"`
    ApprovedAt time.Time `json:"approved_at"`
}
```

#### 职位变更工作流

```go
// internal/workflow/position_change.go
func PositionChangeWorkflow(ctx workflow.Context, req PositionChangeRequest) (*PositionChangeResult, error) {
    logger := workflow.GetLogger(ctx)
    logger.Info("Starting position change workflow",
        "employee_id", req.EmployeeID,
        "effective_date", req.EffectiveDate)
    
    // 设置活动选项
    activityOptions := workflow.ActivityOptions{
        StartToCloseTimeout: time.Minute * 5,
        RetryPolicy: &temporal.RetryPolicy{
            InitialInterval:    time.Second * 10,
            BackoffCoefficient: 2.0,
            MaximumInterval:    time.Minute * 2,
            MaximumAttempts:    3,
        },
    }
    ctx = workflow.WithActivityOptions(ctx, activityOptions)
    
    // 阶段1: 验证变更合法性
    var validationResult PositionChangeValidationResult
    err := workflow.ExecuteActivity(ctx,
        activities.ValidatePositionChangeActivity,
        PositionChangeValidationRequest{
            TenantID:      req.TenantID,
            EmployeeID:    req.EmployeeID,
            NewPosition:   req.NewPosition,
            EffectiveDate: req.EffectiveDate,
            ChangeReason:  req.ChangeReason,
        }).Get(ctx, &validationResult)
    
    if err != nil {
        return &PositionChangeResult{
            Success: false,
            Error:   err.Error(),
        }, err
    }
    
    if !validationResult.IsValid {
        return &PositionChangeResult{
            Success: false,
            Error:   validationResult.ValidationError,
        }, nil
    }
    
    // 阶段2: 处理时间线逻辑
    isRetroactive := req.EffectiveDate.Before(workflow.Now(ctx))
    isFuture := req.EffectiveDate.After(workflow.Now(ctx))
    
    var timelineResult TimelineProcessingResult
    if isRetroactive {
        logger.Info("Processing retroactive position change")
        
        // 处理追溯变更
        err = workflow.ExecuteActivity(ctx,
            activities.ProcessRetroactivePositionChangeActivity,
            ProcessRetroactiveRequest{
                TenantID:      req.TenantID,
                EmployeeID:    req.EmployeeID,
                EffectiveDate: req.EffectiveDate,
                ChangeData:    req.NewPosition,
            }).Get(ctx, &timelineResult)
        
        if err != nil {
            return &PositionChangeResult{
                Success: false,
                Error:   "Retroactive processing failed: " + err.Error(),
            }, err
        }
        
        // 如果需要触发下游重算
        if timelineResult.RequiresRecalculation {
            logger.Info("Triggering downstream recalculation")
            
            // 启动子工作流处理薪酬重算
            childWorkflowOptions := workflow.ChildWorkflowOptions{
                WorkflowID: fmt.Sprintf("payroll-recalc-%s-%d", 
                    req.EmployeeID.String(), 
                    req.EffectiveDate.Unix()),
            }
            
            childCtx := workflow.WithChildOptions(ctx, childWorkflowOptions)
            childFuture := workflow.ExecuteChildWorkflow(childCtx,
                PayrollRecalculationWorkflow,
                PayrollRecalculationRequest{
                    TenantID:      req.TenantID,
                    EmployeeID:    req.EmployeeID,
                    EffectiveDate: req.EffectiveDate,
                    ChangeType:    "POSITION_CHANGE",
                })
            
            // 不等待子工作流完成，继续主流程
            logger.Info("Payroll recalculation workflow started")
        }
        
    } else if isFuture {
        logger.Info("Scheduling future position change")
        
        // 对于未来日期的变更，创建调度记录
        err = workflow.ExecuteActivity(ctx,
            activities.ScheduleFuturePositionChangeActivity,
            ScheduleFutureChangeRequest{
                TenantID:      req.TenantID,
                EmployeeID:    req.EmployeeID,
                EffectiveDate: req.EffectiveDate,
                ChangeData:    req.NewPosition,
                ScheduledBy:   req.RequestedBy,
            }).Get(ctx, &timelineResult)
        
        if err != nil {
            return &PositionChangeResult{
                Success: false,
                Error:   "Future scheduling failed: " + err.Error(),
            }, err
        }
    }
    
    // 阶段3: 创建职位历史记录
    var positionHistoryResult CreatePositionHistoryResult
    err = workflow.ExecuteActivity(ctx,
        activities.CreatePositionHistoryActivity,
        CreatePositionHistoryRequest{
            TenantID:      req.TenantID,
            EmployeeID:    req.EmployeeID,
            PositionData:  req.NewPosition,
            EffectiveDate: req.EffectiveDate,
            ChangeReason:  req.ChangeReason,
            CreatedBy:     req.RequestedBy,
            IsRetroactive: isRetroactive,
        }).Get(ctx, &positionHistoryResult)
    
    if err != nil {
        return &PositionChangeResult{
            Success: false,
            Error:   "Position history creation failed: " + err.Error(),
        }, err
    }
    
    // 阶段4: 更新组织关系图
    if req.NewPosition.ReportsTo != validationResult.CurrentPosition.ReportsTo {
        logger.Info("Updating organization structure")
        
        err = workflow.ExecuteActivity(ctx,
            activities.UpdateOrganizationStructureActivity,
            UpdateOrgStructureRequest{
                TenantID:        req.TenantID,
                EmployeeID:      req.EmployeeID,
                OldManagerID:    validationResult.CurrentPosition.ReportsTo,
                NewManagerID:    req.NewPosition.ReportsTo,
                EffectiveDate:   req.EffectiveDate,
            }).Get(ctx, nil)
        
        if err != nil {
            logger.Error("Organization structure update failed", "error", err)
            // 不终止流程，仅记录警告
        }
    }
    
    // 阶段5: 发送通知
    selector := workflow.NewSelector(ctx)
    
    // 通知员工
    employeeNotificationFuture := workflow.ExecuteActivity(ctx,
        activities.NotifyEmployeePositionChangeActivity,
        NotifyEmployeeRequest{
            TenantID:   req.TenantID,
            EmployeeID: req.EmployeeID,
            ChangeData: req.NewPosition,
            EffectiveDate: req.EffectiveDate,
        })
    
    selector.AddFuture(employeeNotificationFuture, func(f workflow.Future) {
        var result NotificationResult
        if err := f.Get(ctx, &result); err != nil {
            logger.Error("Employee notification failed", "error", err)
        }
    })
    
    // 通知新经理（如果有变化）
    if req.NewPosition.ReportsTo != nil && 
       req.NewPosition.ReportsTo != validationResult.CurrentPosition.ReportsTo {
        
        managerNotificationFuture := workflow.ExecuteActivity(ctx,
            activities.NotifyNewManagerActivity,
            NotifyManagerRequest{
                TenantID:   req.TenantID,
                ManagerID:  *req.NewPosition.ReportsTo,
                EmployeeID: req.EmployeeID,
                ChangeData: req.NewPosition,
                EffectiveDate: req.EffectiveDate,
            })
        
        selector.AddFuture(managerNotificationFuture, func(f workflow.Future) {
            var result NotificationResult
            if err := f.Get(ctx, &result); err != nil {
                logger.Error("Manager notification failed", "error", err)
            }
        })
    }
    
    // 等待所有通知完成
    for i := 0; i < selector.Len(); i++ {
        selector.Select(ctx)
    }
    
    result := &PositionChangeResult{
        Success:           true,
        PositionHistoryID: positionHistoryResult.ID,
        EffectiveDate:     req.EffectiveDate,
        IsRetroactive:     isRetroactive,
        ProcessedAt:       workflow.Now(ctx),
    }
    
    if timelineResult.RequiresRecalculation {
        result.TriggeredRecalculation = true
    }
    
    logger.Info("Position change workflow completed successfully",
        "position_history_id", result.PositionHistoryID)
    
    return result, nil
}

type PositionChangeRequest struct {
    TenantID      uuid.UUID    `json:"tenant_id"`
    EmployeeID    uuid.UUID    `json:"employee_id"`
    NewPosition   PositionData `json:"new_position"`
    EffectiveDate time.Time    `json:"effective_date"`
    ChangeReason  string       `json:"change_reason"`
    RequestedBy   uuid.UUID    `json:"requested_by"`
}

type PositionChangeResult struct {
    Success               bool      `json:"success"`
    PositionHistoryID     uuid.UUID `json:"position_history_id,omitempty"`
    EffectiveDate         time.Time `json:"effective_date"`
    IsRetroactive         bool      `json:"is_retroactive"`
    TriggeredRecalculation bool     `json:"triggered_recalculation"`
    ProcessedAt           time.Time `json:"processed_at"`
    Error                 string    `json:"error,omitempty"`
}
```

### 1.3 事务性发件箱增强

#### 自动化同步服务

```go
// internal/outbox/sync_service.go
package outbox

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
    "go.uber.org/zap"
)

type SyncService struct {
    db           *sql.DB
    neo4jDriver  neo4j.DriverWithContext
    logger       *zap.Logger
    config       SyncConfig
    
    // 处理器注册表
    processors   map[string]EventProcessor
}

type SyncConfig struct {
    BatchSize        int           `yaml:"batch_size"`
    ProcessInterval  time.Duration `yaml:"process_interval"`
    RetryAttempts    int           `yaml:"retry_attempts"`
    RetryBackoff     time.Duration `yaml:"retry_backoff"`
    MaxConcurrency   int           `yaml:"max_concurrency"`
}

type EventProcessor interface {
    ProcessEvent(ctx context.Context, event *OutboxEvent) error
    GetEventTypes() []string
}

// StartSyncLoop 启动自动同步循环
func (s *SyncService) StartSyncLoop(ctx context.Context) error {
    ticker := time.NewTicker(s.config.ProcessInterval)
    defer ticker.Stop()
    
    s.logger.Info("Starting outbox sync loop",
        zap.Duration("interval", s.config.ProcessInterval),
        zap.Int("batch_size", s.config.BatchSize))
    
    for {
        select {
        case <-ctx.Done():
            s.logger.Info("Sync loop stopped")
            return ctx.Err()
            
        case <-ticker.C:
            if err := s.processBatch(ctx); err != nil {
                s.logger.Error("Batch processing failed", zap.Error(err))
            }
        }
    }
}

func (s *SyncService) processBatch(ctx context.Context) error {
    // 获取待处理事件
    events, err := s.getPendingEvents(ctx, s.config.BatchSize)
    if err != nil {
        return fmt.Errorf("failed to get pending events: %w", err)
    }
    
    if len(events) == 0 {
        return nil
    }
    
    s.logger.Debug("Processing event batch", zap.Int("count", len(events)))
    
    // 按事件类型分组处理
    eventGroups := s.groupEventsByType(events)
    
    // 并发处理不同类型的事件
    semaphore := make(chan struct{}, s.config.MaxConcurrency)
    errChan := make(chan error, len(eventGroups))
    
    for eventType, typeEvents := range eventGroups {
        go func(eventType string, events []*OutboxEvent) {
            semaphore <- struct{}{}
            defer func() { <-semaphore }()
            
            if err := s.processEventGroup(ctx, eventType, events); err != nil {
                errChan <- fmt.Errorf("failed to process %s events: %w", eventType, err)
            } else {
                errChan <- nil
            }
        }(eventType, typeEvents)
    }
    
    // 等待所有处理完成
    var errors []error
    for i := 0; i < len(eventGroups); i++ {
        if err := <-errChan; err != nil {
            errors = append(errors, err)
        }
    }
    
    if len(errors) > 0 {
        return fmt.Errorf("batch processing had %d errors: %v", len(errors), errors)
    }
    
    return nil
}

func (s *SyncService) processEventGroup(ctx context.Context, eventType string, events []*OutboxEvent) error {
    processor, exists := s.processors[eventType]
    if !exists {
        s.logger.Warn("No processor found for event type", zap.String("type", eventType))
        // 标记为已处理以避免重复处理
        return s.markEventsProcessed(ctx, events, "NO_PROCESSOR")
    }
    
    for _, event := range events {
        if err := s.processEvent(ctx, processor, event); err != nil {
            s.logger.Error("Event processing failed",
                zap.String("event_id", event.ID.String()),
                zap.String("event_type", eventType),
                zap.Error(err))
            
            // 更新重试计数
            if err := s.incrementRetryCount(ctx, event); err != nil {
                s.logger.Error("Failed to update retry count", zap.Error(err))
            }
        }
    }
    
    return nil
}

func (s *SyncService) processEvent(ctx context.Context, processor EventProcessor, event *OutboxEvent) error {
    // 处理单个事件
    if err := processor.ProcessEvent(ctx, event); err != nil {
        return err
    }
    
    // 标记为已处理
    return s.markEventProcessed(ctx, event.ID, "SUCCESS")
}

// EmployeeEventProcessor 员工事件处理器
type EmployeeEventProcessor struct {
    neo4jDriver neo4j.DriverWithContext
    logger      *zap.Logger
}

func (p *EmployeeEventProcessor) GetEventTypes() []string {
    return []string{
        "HR.Employee.Created",
        "HR.Employee.Updated", 
        "HR.Employee.Terminated",
        "HR.Employee.PositionChanged",
    }
}

func (p *EmployeeEventProcessor) ProcessEvent(ctx context.Context, event *OutboxEvent) error {
    session := p.neo4jDriver.NewSession(ctx, neo4j.SessionConfig{})
    defer session.Close(ctx)
    
    switch event.EventType {
    case "HR.Employee.Created":
        return p.handleEmployeeCreated(ctx, session, event)
    case "HR.Employee.Updated":
        return p.handleEmployeeUpdated(ctx, session, event)
    case "HR.Employee.PositionChanged":
        return p.handlePositionChanged(ctx, session, event)
    case "HR.Employee.Terminated":
        return p.handleEmployeeTerminated(ctx, session, event)
    default:
        return fmt.Errorf("unknown event type: %s", event.EventType)
    }
}

func (p *EmployeeEventProcessor) handleEmployeeCreated(ctx context.Context, session neo4j.SessionWithContext, event *OutboxEvent) error {
    var payload EmployeeCreatedPayload
    if err := json.Unmarshal(event.Payload, &payload); err != nil {
        return fmt.Errorf("failed to unmarshal payload: %w", err)
    }
    
    // 创建员工节点
    query := `
        MERGE (e:Employee {
            employee_id: $employee_id,
            tenant_id: $tenant_id
        })
        SET 
            e.first_name = $first_name,
            e.last_name = $last_name,
            e.email = $email,
            e.employee_number = $employee_number,
            e.hire_date = $hire_date,
            e.status = $status,
            e.created_at = $created_at,
            e.updated_at = $updated_at
    `
    
    params := map[string]interface{}{
        "employee_id":     payload.EmployeeID.String(),
        "tenant_id":       payload.TenantID.String(),
        "first_name":      payload.FirstName,
        "last_name":       payload.LastName,
        "email":           payload.Email,
        "employee_number": payload.EmployeeNumber,
        "hire_date":       payload.HireDate,
        "status":          payload.Status,
        "created_at":      payload.CreatedAt,
        "updated_at":      payload.UpdatedAt,
    }
    
    _, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
        result, err := tx.Run(ctx, query, params)
        if err != nil {
            return nil, err
        }
        return result.Consume(ctx)
    })
    
    if err != nil {
        return fmt.Errorf("failed to create employee node: %w", err)
    }
    
    p.logger.Info("Employee node created in Neo4j",
        zap.String("employee_id", payload.EmployeeID.String()),
        zap.String("tenant_id", payload.TenantID.String()))
    
    return nil
}

func (p *EmployeeEventProcessor) handlePositionChanged(ctx context.Context, session neo4j.SessionWithContext, event *OutboxEvent) error {
    var payload PositionChangedPayload
    if err := json.Unmarshal(event.Payload, &payload); err != nil {
        return fmt.Errorf("failed to unmarshal payload: %w", err)
    }
    
    // 更新或创建汇报关系
    query := `
        MATCH (e:Employee {employee_id: $employee_id, tenant_id: $tenant_id})
        
        // 删除旧的汇报关系
        OPTIONAL MATCH (e)-[old:REPORTS_TO]->(oldManager)
        DELETE old
        
        // 如果有新经理，创建新的汇报关系
        WITH e
        CALL {
            WITH e
            OPTIONAL MATCH (newManager:Employee {employee_id: $new_manager_id, tenant_id: $tenant_id})
            WHERE $new_manager_id IS NOT NULL
            MERGE (e)-[r:REPORTS_TO]->(newManager)
            SET r.effective_date = $effective_date,
                r.created_at = $created_at
            RETURN r
        }
        
        // 更新员工的职位信息
        SET 
            e.position_title = $position_title,
            e.department = $department,
            e.job_level = $job_level,
            e.location = $location,
            e.updated_at = $updated_at
        
        RETURN e.employee_id as employee_id
    `
    
    params := map[string]interface{}{
        "employee_id":     payload.EmployeeID.String(),
        "tenant_id":       payload.TenantID.String(),
        "new_manager_id":  nil,
        "position_title":  payload.NewPosition.PositionTitle,
        "department":      payload.NewPosition.Department,
        "job_level":       payload.NewPosition.JobLevel,
        "location":        payload.NewPosition.Location,
        "effective_date":  payload.EffectiveDate,
        "created_at":      time.Now(),
        "updated_at":      time.Now(),
    }
    
    if payload.NewPosition.ReportsTo != nil {
        params["new_manager_id"] = payload.NewPosition.ReportsTo.String()
    }
    
    _, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
        result, err := tx.Run(ctx, query, params)
        if err != nil {
            return nil, err
        }
        return result.Consume(ctx)
    })
    
    if err != nil {
        return fmt.Errorf("failed to update position in Neo4j: %w", err)
    }
    
    p.logger.Info("Position updated in Neo4j",
        zap.String("employee_id", payload.EmployeeID.String()),
        zap.String("new_position", payload.NewPosition.PositionTitle))
    
    return nil
}

// 事件负载定义
type EmployeeCreatedPayload struct {
    EmployeeID     uuid.UUID `json:"employee_id"`
    TenantID       uuid.UUID `json:"tenant_id"`
    FirstName      string    `json:"first_name"`
    LastName       string    `json:"last_name"`
    Email          string    `json:"email"`
    EmployeeNumber string    `json:"employee_number"`
    HireDate       time.Time `json:"hire_date"`
    Status         string    `json:"status"`
    CreatedAt      time.Time `json:"created_at"`
    UpdatedAt      time.Time `json:"updated_at"`
}

type PositionChangedPayload struct {
    EmployeeID    uuid.UUID    `json:"employee_id"`
    TenantID      uuid.UUID    `json:"tenant_id"`
    NewPosition   PositionData `json:"new_position"`
    EffectiveDate time.Time    `json:"effective_date"`
    ChangeReason  string       `json:"change_reason"`
    CreatedBy     uuid.UUID    `json:"created_by"`
}
```

---

## 第二部分：数据访问层详细设计

### 2.1 Ent Schema完整定义

#### Person基础实体

```go
// ent/schema/person.go
package schema

import (
    "time"
    
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
    "entgo.io/ent/schema/edge"
    "entgo.io/ent/schema/index"
    "entgo.io/ent/schema/mixin"
    "github.com/google/uuid"
    
    "github.com/gaogu/cube-castle/internal/ent/annotations"
    "github.com/gaogu/cube-castle/internal/ent/mixins"
)

// Person 通用人员实体
type Person struct {
    ent.Schema
}

// Mixin 复用通用字段
func (Person) Mixin() []ent.Mixin {
    return []ent.Mixin{
        mixins.TenantMixin{},     // 租户隔离
        mixins.AuditMixin{},      // 审计字段
        mixins.SoftDeleteMixin{}, // 软删除
    }
}

// Fields 字段定义
func (Person) Fields() []ent.Field {
    return []ent.Field{
        // 多态鉴别器
        field.String("person_type").
            Comment("人员类型：EMPLOYEE, EXTERNAL_COLLABORATOR, CONTRACTOR").
            NotEmpty(),
            
        // 基础身份信息
        field.String("first_name").
            Comment("名").
            NotEmpty().
            MaxLen(50).
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "CONFIDENTIAL",
                ComplianceTags:     []string{"GDPR", "PII"},
            }),
            
        field.String("last_name").
            Comment("姓").
            NotEmpty().
            MaxLen(50).
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "CONFIDENTIAL", 
                ComplianceTags:     []string{"GDPR", "PII"},
            }),
            
        field.String("email").
            Comment("邮箱地址").
            Unique().
            NotEmpty().
            MaxLen(255).
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "CONFIDENTIAL",
                ComplianceTags:     []string{"GDPR", "PII"},
            }),
            
        field.String("phone_number").
            Comment("电话号码").
            Optional().
            MaxLen(20).
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "CONFIDENTIAL",
                ComplianceTags:     []string{"GDPR", "PII"},
            }),
            
        field.Time("date_of_birth").
            Comment("出生日期").
            Optional().
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "RESTRICTED",
                ComplianceTags:     []string{"GDPR", "PII", "SENSITIVE"},
            }),
            
        // 状态字段
        field.Enum("status").
            Comment("人员状态").
            Values("ACTIVE", "INACTIVE", "PENDING", "TERMINATED").
            Default("PENDING"),
    }
}

// Edges 关联关系
func (Person) Edges() []ent.Edge {
    return []ent.Edge{
        // 多态档案关系 - 使用显式一对一边
        edge.To("employee_profile", EmployeeProfile.Type).
            Comment("员工档案").
            Unique(),
            
        edge.To("external_collaborator_profile", ExternalCollaboratorProfile.Type).
            Comment("外部协作者档案").
            Unique(),
            
        // 用户账户关系
        edge.To("user_account", UserAccount.Type).
            Comment("系统用户账户").
            Unique(),
    }
}

// Indexes 索引定义
func (Person) Indexes() []ent.Index {
    return []ent.Index{
        // 租户内邮箱唯一性
        index.Fields("tenant_id", "email").
            Unique(),
            
        // 人员类型查询优化
        index.Fields("tenant_id", "person_type", "status"),
        
        // 姓名搜索优化
        index.Fields("tenant_id", "last_name", "first_name"),
        
        // 软删除查询优化
        index.Fields("tenant_id", "deleted_at").
            Where(field.IsNull("deleted_at")),
    }
}

// Annotations 实体注解
func (Person) Annotations() []schema.Annotation {
    return []schema.Annotation{
        annotations.MetaContractAnnotation{
            DataClassification: "CONFIDENTIAL",
            ComplianceTags:     []string{"GDPR", "SOX", "PII"},
            PersistenceProfile: &annotations.PersistenceProfile{
                PrimaryStore:    "RELATIONAL",
                IndexedIn:       []string{"GRAPH"},
                GraphNodeLabel:  "Person",
                GraphEdgeDefinitions: []string{
                    "EMPLOYED_BY",
                    "COLLABORATES_WITH",
                },
            },
        },
    }
}
```

#### EmployeeProfile员工档案

```go
// ent/schema/employee_profile.go
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
    "entgo.io/ent/schema/edge"
    "entgo.io/ent/schema/index"
)

// EmployeeProfile 员工档案
type EmployeeProfile struct {
    ent.Schema
}

func (EmployeeProfile) Mixin() []ent.Mixin {
    return []ent.Mixin{
        mixins.TenantMixin{},
        mixins.AuditMixin{},
        mixins.SoftDeleteMixin{},
    }
}

func (EmployeeProfile) Fields() []ent.Field {
    return []ent.Field{
        // 员工编号
        field.String("employee_number").
            Comment("员工工号").
            Unique().
            NotEmpty().
            MaxLen(20),
            
        // 入职信息
        field.Time("hire_date").
            Comment("入职日期"),
            
        field.Time("termination_date").
            Comment("离职日期").
            Optional(),
            
        field.String("termination_reason").
            Comment("离职原因").
            Optional().
            MaxLen(500),
            
        // 就业信息
        field.Enum("employment_type").
            Comment("就业类型").
            Values("FULL_TIME", "PART_TIME", "CONTRACT", "INTERN").
            Default("FULL_TIME"),
            
        field.Enum("employment_status").
            Comment("就业状态").
            Values("ACTIVE", "ON_LEAVE", "TERMINATED", "SUSPENDED").
            Default("ACTIVE"),
            
        // 紧急联系人
        field.String("emergency_contact_name").
            Comment("紧急联系人姓名").
            Optional().
            MaxLen(100).
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "CONFIDENTIAL",
                ComplianceTags:     []string{"PII"},
            }),
            
        field.String("emergency_contact_phone").
            Comment("紧急联系人电话").
            Optional().
            MaxLen(20).
            Annotations(annotations.MetaContractAnnotation{
                DataClassification: "CONFIDENTIAL", 
                ComplianceTags:     []string{"PII"},
            }),
    }
}

func (EmployeeProfile) Edges() []ent.Edge {
    return []ent.Edge{
        // 反向边，指向Person
        edge.From("person", Person.Type).
            Comment("关联的人员记录").
            Ref("employee_profile").
            Unique().
            Required(),
            
        // 职位历史
        edge.To("position_history", PositionHistory.Type).
            Comment("职位变更历史"),
            
        // 薪酬历史
        edge.To("compensation_history", CompensationHistory.Type).
            Comment("薪酬变更历史"),
            
        // 绩效记录
        edge.To("performance_records", PerformanceRecord.Type).
            Comment("绩效考核记录"),
            
        // 培训记录
        edge.To("training_records", TrainingRecord.Type).
            Comment("培训记录"),
            
        // 假期记录
        edge.To("leave_requests", LeaveRequest.Type).
            Comment("假期申请记录"),
    }
}

func (EmployeeProfile) Indexes() []ent.Index {
    return []ent.Index{
        // 租户内员工编号唯一性
        index.Fields("tenant_id", "employee_number").
            Unique(),
            
        // 就业状态查询
        index.Fields("tenant_id", "employment_status", "hire_date"),
        
        // 入职日期范围查询
        index.Fields("tenant_id", "hire_date"),
        
        // 在职员工查询（未离职）
        index.Fields("tenant_id", "employment_status").
            Where(field.IsNull("termination_date")),
    }
}

func (EmployeeProfile) Annotations() []schema.Annotation {
    return []schema.Annotation{
        annotations.MetaContractAnnotation{
            DataClassification: "CONFIDENTIAL",
            ComplianceTags:     []string{"SOX", "LABOR_LAW"},
            PersistenceProfile: &annotations.PersistenceProfile{
                PrimaryStore:   "RELATIONAL",
                IndexedIn:      []string{"GRAPH"},
                GraphNodeLabel: "Employee",
                GraphEdgeDefinitions: []string{
                    "REPORTS_TO",
                    "MANAGES", 
                    "WORKS_IN_DEPARTMENT",
                    "HAS_POSITION",
                },
            },
        },
    }
}
```

#### PositionHistory职位历史

```go
// ent/schema/position_history.go
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
    "entgo.io/ent/schema/edge"
    "entgo.io/ent/schema/index"
)

// PositionHistory 职位历史记录（时态数据）
type PositionHistory struct {
    ent.Schema
}

func (PositionHistory) Mixin() []ent.Mixin {
    return []ent.Mixin{
        mixins.TenantMixin{},
        mixins.AuditMixin{},
        // 注意：职位历史不支持软删除，保持完整审计链
    }
}

func (PositionHistory) Fields() []ent.Field {
    return []ent.Field{
        // 职位信息
        field.String("position_title").
            Comment("职位名称").
            NotEmpty().
            MaxLen(100),
            
        field.String("department").
            Comment("部门").
            NotEmpty().
            MaxLen(100),
            
        field.String("job_level").
            Comment("职级").
            Optional().
            MaxLen(50),
            
        field.String("location").
            Comment("工作地点").
            Optional().
            MaxLen(100),
            
        field.Enum("employment_type").
            Comment("就业类型").
            Values("FULL_TIME", "PART_TIME", "CONTRACT", "INTERN").
            Default("FULL_TIME"),
            
        // 汇报关系
        field.UUID("reports_to_employee_id").
            Comment("直接上级员工ID").
            Optional(),
            
        // 时态字段
        field.Time("effective_date").
            Comment("生效日期"),
            
        field.Time("end_date").
            Comment("失效日期，当前记录为NULL").
            Optional(),
            
        // 变更元数据
        field.String("change_reason").
            Comment("变更原因").
            Optional().
            MaxLen(500),
            
        field.Bool("is_retroactive").
            Comment("是否为追溯变更").
            Default(false),
            
        field.UUID("created_by").
            Comment("创建人ID"),
            
        // 薪酬范围（可选）
        field.Float("min_salary").
            Comment("最低薪酬").
            Optional().
            Positive(),
            
        field.Float("max_salary").
            Comment("最高薪酬").
            Optional().
            Positive(),
            
        field.String("currency").
            Comment("薪酬币种").
            Optional().
            Default("CNY").
            MaxLen(3),
    }
}

func (PositionHistory) Edges() []ent.Edge {
    return []ent.Edge{
        // 关联员工档案
        edge.From("employee", EmployeeProfile.Type).
            Comment("所属员工").
            Ref("position_history").
            Unique().
            Required(),
            
        // 关联组织单元
        edge.To("organization_unit", OrganizationUnit.Type).
            Comment("所属组织单元").
            Unique(),
            
        // 关联岗位档案
        edge.To("job_profile", JobProfile.Type).
            Comment("岗位档案").
            Unique(),
            
        // 关联直接上级（自引用）
        edge.To("reports_to", EmployeeProfile.Type).
            Comment("直接上级").
            Unique().
            Field("reports_to_employee_id"),
    }
}

func (PositionHistory) Indexes() []ent.Index {
    return []ent.Index{
        // 租户+员工+时间范围查询
        index.Fields("tenant_id", "employee_id", "effective_date").
            Comment("时间线查询优化"),
            
        // 当前职位查询（end_date为NULL）
        index.Fields("tenant_id", "employee_id").
            Where(field.IsNull("end_date")).
            Comment("当前职位查询"),
            
        // 部门内员工查询
        index.Fields("tenant_id", "department", "effective_date"),
        
        // 汇报关系查询
        index.Fields("tenant_id", "reports_to_employee_id", "effective_date").
            Where(field.IsNull("end_date")),
            
        // 时间范围内的变更查询
        index.Fields("tenant_id", "effective_date", "end_date"),
        
        // 追溯变更查询
        index.Fields("tenant_id", "is_retroactive", "created_at"),
    }
}

func (PositionHistory) Annotations() []schema.Annotation {
    return []schema.Annotation{
        annotations.MetaContractAnnotation{
            DataClassification: "INTERNAL",
            ComplianceTags:     []string{"SOX", "AUDIT_TRAIL"},
            PersistenceProfile: &annotations.PersistenceProfile{
                PrimaryStore:   "RELATIONAL",
                IndexedIn:      []string{"GRAPH"},
                GraphNodeLabel: "Position",
                GraphEdgeDefinitions: []string{
                    "POSITION_IN_DEPARTMENT",
                    "REPORTS_TO_POSITION",
                },
            },
        },
    }
}

// Hooks 实体钩子
func (PositionHistory) Hooks() []ent.Hook {
    return []ent.Hook{
        // 创建时自动设置审计字段
        hook.On(
            func(next ent.Mutator) ent.Mutator {
                return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
                    if m.Op().Is(ent.OpCreate) {
                        // 验证时态一致性
                        if err := validateTemporalConsistency(ctx, m); err != nil {
                            return nil, err
                        }
                        
                        // 自动关闭之前的记录
                        if err := closePreviousPositionRecord(ctx, m); err != nil {
                            return nil, err
                        }
                    }
                    return next.Mutate(ctx, m)
                })
            },
            ent.OpCreate,
        ),
    }
}
```

### 2.2 查询服务层

#### 员工查询服务

```go
// internal/service/employee_query_service.go
package service

import (
    "context"
    "fmt"
    "time"
    
    "github.com/google/uuid"
    "go.uber.org/zap"
    
    "github.com/gaogu/cube-castle/ent"
    "github.com/gaogu/cube-castle/ent/person"
    "github.com/gaogu/cube-castle/ent/employeeprofile" 
    "github.com/gaogu/cube-castle/ent/positionhistory"
)

type EmployeeQueryService struct {
    client *ent.Client
    logger *zap.Logger
}

// EmployeeQueryOptions 查询选项
type EmployeeQueryOptions struct {
    TenantID          uuid.UUID `json:"tenant_id"`
    IncludeTerminated bool      `json:"include_terminated"`
    AsOfDate          *time.Time `json:"as_of_date,omitempty"`
    Department        string    `json:"department,omitempty"`
    EmploymentType    string    `json:"employment_type,omitempty"`
    Limit             int       `json:"limit,omitempty"`
    Offset            int       `json:"offset,omitempty"`
}

// EmployeeWithPosition 员工及其职位信息
type EmployeeWithPosition struct {
    // 基础信息
    PersonID          uuid.UUID `json:"person_id"`
    EmployeeID        uuid.UUID `json:"employee_id"`
    EmployeeNumber    string    `json:"employee_number"`
    FirstName         string    `json:"first_name"`
    LastName          string    `json:"last_name"`
    Email             string    `json:"email"`
    
    // 就业信息
    HireDate          time.Time  `json:"hire_date"`
    EmploymentType    string     `json:"employment_type"`
    EmploymentStatus  string     `json:"employment_status"`
    TerminationDate   *time.Time `json:"termination_date,omitempty"`
    
    // 当前职位信息
    CurrentPosition   *PositionInfo `json:"current_position,omitempty"`
    
    // 元数据
    CreatedAt         time.Time `json:"created_at"`
    UpdatedAt         time.Time `json:"updated_at"`
}

type PositionInfo struct {
    PositionHistoryID uuid.UUID  `json:"position_history_id"`
    PositionTitle     string     `json:"position_title"`
    Department        string     `json:"department"`
    JobLevel          string     `json:"job_level"`
    Location          string     `json:"location"`
    ReportsToID       *uuid.UUID `json:"reports_to_id,omitempty"`
    ReportsToName     string     `json:"reports_to_name,omitempty"`
    EffectiveDate     time.Time  `json:"effective_date"`
    EndDate           *time.Time `json:"end_date,omitempty"`
}

// GetEmployeeWithCurrentPosition 获取员工及其当前职位信息
func (s *EmployeeQueryService) GetEmployeeWithCurrentPosition(
    ctx context.Context, 
    tenantID, employeeID uuid.UUID,
    asOfDate *time.Time,
) (*EmployeeWithPosition, error) {
    
    if asOfDate == nil {
        now := time.Now()
        asOfDate = &now
    }
    
    // 构建复杂查询
    query := s.client.Person.Query().
        Where(
            person.HasEmployeeProfileWith(
                employeeprofile.ID(employeeID),
            ),
            person.TenantIDEQ(tenantID),
            person.DeletedAtIsNil(),
        ).
        WithEmployeeProfile(func(q *ent.EmployeeProfileQuery) {
            q.WithPositionHistory(func(pq *ent.PositionHistoryQuery) {
                // 查询指定日期的有效职位
                pq.Where(
                    positionhistory.EffectiveDateLTE(*asOfDate),
                    positionhistory.Or(
                        positionhistory.EndDateIsNil(),
                        positionhistory.EndDateGT(*asOfDate),
                    ),
                ).
                WithReportsTo(func(rq *ent.EmployeeProfileQuery) {
                    rq.WithPerson()
                }).
                Order(ent.Desc(positionhistory.FieldEffectiveDate)).
                Limit(1)
            })
        })
    
    personEntity, err := query.Only(ctx)
    if err != nil {
        if ent.IsNotFound(err) {
            return nil, fmt.Errorf("employee not found: %w", err)
        }
        return nil, fmt.Errorf("failed to query employee: %w", err)
    }
    
    employee := personEntity.Edges.EmployeeProfile
    if employee == nil {
        return nil, fmt.Errorf("employee profile not found")
    }
    
    result := &EmployeeWithPosition{
        PersonID:         personEntity.ID,
        EmployeeID:       employee.ID,
        EmployeeNumber:   employee.EmployeeNumber,
        FirstName:        personEntity.FirstName,
        LastName:         personEntity.LastName,
        Email:            personEntity.Email,
        HireDate:         employee.HireDate,
        EmploymentType:   employee.EmploymentType,
        EmploymentStatus: employee.EmploymentStatus,
        TerminationDate:  employee.TerminationDate,
        CreatedAt:        personEntity.CreatedAt,
        UpdatedAt:        personEntity.UpdatedAt,
    }
    
    // 如果有职位历史，填充当前职位信息
    if len(employee.Edges.PositionHistory) > 0 {
        pos := employee.Edges.PositionHistory[0]
        posInfo := &PositionInfo{
            PositionHistoryID: pos.ID,
            PositionTitle:     pos.PositionTitle,
            Department:        pos.Department,
            JobLevel:          pos.JobLevel,
            Location:          pos.Location,
            EffectiveDate:     pos.EffectiveDate,
            EndDate:           pos.EndDate,
        }
        
        // 如果有上级信息
        if pos.Edges.ReportsTo != nil && pos.Edges.ReportsTo.Edges.Person != nil {
            manager := pos.Edges.ReportsTo.Edges.Person
            posInfo.ReportsToID = &pos.Edges.ReportsTo.ID
            posInfo.ReportsToName = manager.FirstName + " " + manager.LastName
        }
        
        result.CurrentPosition = posInfo
    }
    
    return result, nil
}

// ListEmployeesWithPositions 列出员工及其职位信息
func (s *EmployeeQueryService) ListEmployeesWithPositions(
    ctx context.Context,
    options EmployeeQueryOptions,
) ([]*EmployeeWithPosition, int, error) {
    
    asOfDate := time.Now()
    if options.AsOfDate != nil {
        asOfDate = *options.AsOfDate
    }
    
    // 构建基础查询条件
    predicates := []predicate.Person{
        person.TenantIDEQ(options.TenantID),
        person.DeletedAtIsNil(),
        person.PersonTypeEQ("EMPLOYEE"),
    }
    
    // 添加员工档案条件
    employeePredicates := []predicate.EmployeeProfile{
        employeeprofile.DeletedAtIsNil(),
    }
    
    if !options.IncludeTerminated {
        employeePredicates = append(employeePredicates,
            employeeprofile.EmploymentStatusNEQ("TERMINATED"))
    }
    
    if options.EmploymentType != "" {
        employeePredicates = append(employeePredicates,
            employeeprofile.EmploymentTypeEQ(options.EmploymentType))
    }
    
    predicates = append(predicates,
        person.HasEmployeeProfileWith(employeePredicates...))
    
    // 如果指定了部门，需要通过职位历史查询
    if options.Department != "" {
        predicates = append(predicates,
            person.HasEmployeeProfileWith(
                employeeprofile.HasPositionHistoryWith(
                    positionhistory.DepartmentEQ(options.Department),
                    positionhistory.EffectiveDateLTE(asOfDate),
                    positionhistory.Or(
                        positionhistory.EndDateIsNil(),
                        positionhistory.EndDateGT(asOfDate),
                    ),
                ),
            ))
    }
    
    // 执行查询获取总数
    totalQuery := s.client.Person.Query().Where(predicates...)
    total, err := totalQuery.Count(ctx)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to count employees: %w", err)
    }
    
    // 构建主查询
    query := s.client.Person.Query().
        Where(predicates...).
        WithEmployeeProfile(func(q *ent.EmployeeProfileQuery) {
            q.WithPositionHistory(func(pq *ent.PositionHistoryQuery) {
                pq.Where(
                    positionhistory.EffectiveDateLTE(asOfDate),
                    positionhistory.Or(
                        positionhistory.EndDateIsNil(),
                        positionhistory.EndDateGT(asOfDate),
                    ),
                ).
                WithReportsTo(func(rq *ent.EmployeeProfileQuery) {
                    rq.WithPerson()
                }).
                Order(ent.Desc(positionhistory.FieldEffectiveDate)).
                Limit(1)
            })
        }).
        Order(ent.Asc(person.FieldLastName), ent.Asc(person.FieldFirstName))
    
    // 应用分页
    if options.Limit > 0 {
        query = query.Limit(options.Limit)
    }
    if options.Offset > 0 {
        query = query.Offset(options.Offset)
    }
    
    persons, err := query.All(ctx)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to query employees: %w", err)
    }
    
    // 转换结果
    results := make([]*EmployeeWithPosition, len(persons))
    for i, personEntity := range persons {
        employee := personEntity.Edges.EmployeeProfile
        
        result := &EmployeeWithPosition{
            PersonID:         personEntity.ID,
            EmployeeID:       employee.ID,
            EmployeeNumber:   employee.EmployeeNumber,
            FirstName:        personEntity.FirstName,
            LastName:         personEntity.LastName,
            Email:            personEntity.Email,
            HireDate:         employee.HireDate,
            EmploymentType:   employee.EmploymentType,
            EmploymentStatus: employee.EmploymentStatus,
            TerminationDate:  employee.TerminationDate,
            CreatedAt:        personEntity.CreatedAt,
            UpdatedAt:        personEntity.UpdatedAt,
        }
        
        // 填充职位信息
        if len(employee.Edges.PositionHistory) > 0 {
            pos := employee.Edges.PositionHistory[0]
            posInfo := &PositionInfo{
                PositionHistoryID: pos.ID,
                PositionTitle:     pos.PositionTitle,
                Department:        pos.Department,
                JobLevel:          pos.JobLevel,
                Location:          pos.Location,
                EffectiveDate:     pos.EffectiveDate,
                EndDate:           pos.EndDate,
            }
            
            if pos.Edges.ReportsTo != nil && pos.Edges.ReportsTo.Edges.Person != nil {
                manager := pos.Edges.ReportsTo.Edges.Person
                posInfo.ReportsToID = &pos.Edges.ReportsTo.ID
                posInfo.ReportsToName = manager.FirstName + " " + manager.LastName
            }
            
            result.CurrentPosition = posInfo
        }
        
        results[i] = result
    }
    
    return results, total, nil
}

// GetEmployeePositionHistory 获取员工完整职位历史
func (s *EmployeeQueryService) GetEmployeePositionHistory(
    ctx context.Context,
    tenantID, employeeID uuid.UUID,
) ([]*PositionInfo, error) {
    
    positions, err := s.client.PositionHistory.Query().
        Where(
            positionhistory.HasEmployeeWith(
                employeeprofile.ID(employeeID),
                employeeprofile.TenantIDEQ(tenantID),
            ),
            positionhistory.TenantIDEQ(tenantID),
        ).
        WithReportsTo(func(q *ent.EmployeeProfileQuery) {
            q.WithPerson()
        }).
        Order(ent.Desc(positionhistory.FieldEffectiveDate)).
        All(ctx)
    
    if err != nil {
        return nil, fmt.Errorf("failed to query position history: %w", err)
    }
    
    results := make([]*PositionInfo, len(positions))
    for i, pos := range positions {
        posInfo := &PositionInfo{
            PositionHistoryID: pos.ID,
            PositionTitle:     pos.PositionTitle,
            Department:        pos.Department,
            JobLevel:          pos.JobLevel,
            Location:          pos.Location,
            EffectiveDate:     pos.EffectiveDate,
            EndDate:           pos.EndDate,
        }
        
        if pos.Edges.ReportsTo != nil && pos.Edges.ReportsTo.Edges.Person != nil {
            manager := pos.Edges.ReportsTo.Edges.Person
            posInfo.ReportsToID = &pos.Edges.ReportsTo.ID
            posInfo.ReportsToName = manager.FirstName + " " + manager.LastName
        }
        
        results[i] = posInfo
    }
    
    return results, nil
}
```

---

## 第三部分：AI集成详细设计

### 3.1 情境感知模型(SAM)完整实现

#### 核心SAM引擎

```go
// internal/intelligence/sam_engine.go
package intelligence

import (
    "context"
    "encoding/json"
    "fmt"
    "strings"
    "time"
    
    "go.uber.org/zap"
    "github.com/google/uuid"
    
    "github.com/gaogu/cube-castle/internal/opa"
)

// SituationalAwarenessModel 情境感知模型
type SituationalAwarenessModel struct {
    intentClassifier  IntentClassifier
    entityExtractor   EntityExtractor
    contextEnricher   ContextEnricher
    authorizer        *opa.Authorizer
    logger            *zap.Logger
    
    // 配置
    config SAMConfig
}

type SAMConfig struct {
    ConfidenceThreshold  float64 `yaml:"confidence_threshold"`
    MaxEntityCount       int     `yaml:"max_entity_count"`
    ContextTimeoutMs     int     `yaml:"context_timeout_ms"`
    EnableDebugLogging   bool    `yaml:"enable_debug_logging"`
}

// UIContext UI上下文信息
type UIContext struct {
    PageID          string                 `json:"page_id"`
    PageType        string                 `json:"page_type"`
    DataContext     map[string]interface{} `json:"data_context"`
    AffordedIntents []string               `json:"afforded_intents"`
    UserActions     []UserAction           `json:"recent_actions,omitempty"`
}

type UserAction struct {
    ActionType  string    `json:"action_type"`
    Target      string    `json:"target"`
    Timestamp   time.Time `json:"timestamp"`
    Parameters  map[string]interface{} `json:"parameters,omitempty"`
}

// UserContext 用户上下文
type UserContext struct {
    UserID      uuid.UUID              `json:"user_id"`
    TenantID    uuid.UUID              `json:"tenant_id"`
    Roles       []string               `json:"roles"`
    Permissions []string               `json:"permissions"`
    Department  string                 `json:"department,omitempty"`
    Language    string                 `json:"language"`
    Timezone    string                 `json:"timezone"`
    Preferences map[string]interface{} `json:"preferences,omitempty"`
}

// QueryRequest 查询请求
type QueryRequest struct {
    Query       string      `json:"query"`
    UIContext   UIContext   `json:"ui_context"`
    UserContext UserContext `json:"user_context"`
    SessionID   string      `json:"session_id"`
}

// IntentResponse 意图识别响应
type IntentResponse struct {
    Intent      ClassifiedIntent       `json:"intent"`
    Entities    []ExtractedEntity      `json:"entities"`
    Confidence  float64                `json:"confidence"`
    Status      string                 `json:"status"`
    Message     string                 `json:"message,omitempty"`
    NextAction  *NextAction            `json:"next_action,omitempty"`
    Debug       *DebugInfo             `json:"debug,omitempty"`
}

type ClassifiedIntent struct {
    Name           string                 `json:"name"`
    Category       string                 `json:"category"`
    Description    string                 `json:"description"`
    Confidence     float64                `json:"confidence"`
    Parameters     map[string]interface{} `json:"parameters,omitempty"`
    RequiredEntities []string             `json:"required_entities"`
}

type ExtractedEntity struct {
    Name       string      `json:"name"`
    Type       string      `json:"type"`
    Value      interface{} `json:"value"`
    Confidence float64     `json:"confidence"`
    Source     string      `json:"source"` // "query", "context", "inference"
}

type NextAction struct {
    ActionType   string                 `json:"action_type"`
    Target       string                 `json:"target,omitempty"`
    Parameters   map[string]interface{} `json:"parameters,omitempty"`
    Confirmation *ConfirmationRequest   `json:"confirmation,omitempty"`
}

type ConfirmationRequest struct {
    Message     string                 `json:"message"`
    Parameters  map[string]interface{} `json:"parameters"`
    Timeout     time.Duration          `json:"timeout"`
}

type DebugInfo struct {
    ProcessingTime     time.Duration          `json:"processing_time"`
    IntentCandidates   []ClassifiedIntent     `json:"intent_candidates,omitempty"`
    EntityCandidates   []ExtractedEntity      `json:"entity_candidates,omitempty"`
    ContextEnrichment  map[string]interface{} `json:"context_enrichment,omitempty"`
    AuthorizationTrace []string               `json:"authorization_trace,omitempty"`
}

// ProcessEmployeeQuery 处理员工相关查询
func (sam *SituationalAwarenessModel) ProcessEmployeeQuery(
    ctx context.Context,
    req QueryRequest,
) (*IntentResponse, error) {
    
    startTime := time.Now()
    var debugInfo *DebugInfo
    
    if sam.config.EnableDebugLogging {
        debugInfo = &DebugInfo{
            IntentCandidates:  []ClassifiedIntent{},
            EntityCandidates:  []ExtractedEntity{},
            ContextEnrichment: make(map[string]interface{}),
            AuthorizationTrace: []string{},
        }
    }
    
    sam.logger.Info("Processing employee query",
        zap.String("session_id", req.SessionID),
        zap.String("user_id", req.UserContext.UserID.String()),
        zap.String("page_id", req.UIContext.PageID))
    
    // 阶段1: 上下文增强
    enrichedQuery, contextData, err := sam.contextEnricher.EnrichQuery(
        ctx, req.Query, req.UIContext, req.UserContext)
    if err != nil {
        return nil, fmt.Errorf("context enrichment failed: %w", err)
    }
    
    if debugInfo != nil {
        debugInfo.ContextEnrichment = contextData
    }
    
    sam.logger.Debug("Query enriched",
        zap.String("original", req.Query),
        zap.String("enriched", enrichedQuery))
    
    // 阶段2: 意图分类
    intentCandidates, err := sam.intentClassifier.ClassifyIntent(
        ctx, enrichedQuery, req.UIContext.AffordedIntents)
    if err != nil {
        return nil, fmt.Errorf("intent classification failed: %w", err)
    }
    
    if len(intentCandidates) == 0 {
        return &IntentResponse{
            Status:  "NO_INTENT_FOUND",
            Message: "抱歉，我无法理解您的请求。请尝试更具体的描述。",
            Debug:   debugInfo,
        }, nil
    }
    
    // 选择最高置信度的意图
    primaryIntent := intentCandidates[0]
    
    if debugInfo != nil {
        debugInfo.IntentCandidates = intentCandidates
    }
    
    // 检查置信度阈值
    if primaryIntent.Confidence < sam.config.ConfidenceThreshold {
        return &IntentResponse{
            Intent:     primaryIntent,
            Status:     "LOW_CONFIDENCE",
            Message:    fmt.Sprintf("我理解您可能想要%s，但不太确定。请提供更多细节。", primaryIntent.Description),
            Confidence: primaryIntent.Confidence,
            Debug:      debugInfo,
        }, nil
    }
    
    // 阶段3: 实体抽取
    entities, err := sam.entityExtractor.ExtractEntities(
        ctx, enrichedQuery, primaryIntent, req.UIContext.DataContext)
    if err != nil {
        return nil, fmt.Errorf("entity extraction failed: %w", err)
    }
    
    if debugInfo != nil {
        debugInfo.EntityCandidates = entities
    }
    
    // 验证必需实体
    missingEntities := sam.validateRequiredEntities(primaryIntent, entities)
    if len(missingEntities) > 0 {
        return &IntentResponse{
            Intent:     primaryIntent,
            Entities:   entities,
            Status:     "MISSING_ENTITIES",
            Message:    fmt.Sprintf("请提供以下信息：%s", strings.Join(missingEntities, "、")),
            Confidence: primaryIntent.Confidence,
            Debug:      debugInfo,
        }, nil
    }
    
    // 阶段4: 权限验证
    authInput := opa.AuthorizationInput{
        UserID:      req.UserContext.UserID,
        TenantID:    req.UserContext.TenantID,
        Intent:      primaryIntent.Name,
        Entities:    entities,
        Context:     req.UIContext.DataContext,
        Permissions: req.UserContext.Permissions,
    }
    
    authResult, err := sam.authorizer.IsAuthorized(ctx, authInput)
    if err != nil {
        return nil, fmt.Errorf("authorization check failed: %w", err)
    }
    
    if debugInfo != nil {
        debugInfo.AuthorizationTrace = authResult.Trace
    }
    
    if !authResult.Allowed {
        sam.logger.Warn("Authorization denied",
            zap.String("intent", primaryIntent.Name),
            zap.String("user_id", req.UserContext.UserID.String()),
            zap.String("reason", authResult.Reason))
        
        return &IntentResponse{
            Intent:     primaryIntent,
            Entities:   entities,
            Status:     "UNAUTHORIZED",
            Message:    "您没有权限执行此操作。",
            Confidence: primaryIntent.Confidence,
            Debug:      debugInfo,
        }, nil
    }
    
    // 阶段5: 确定下一步行动
    nextAction, err := sam.determineNextAction(ctx, primaryIntent, entities, req.UIContext)
    if err != nil {
        return nil, fmt.Errorf("action determination failed: %w", err)
    }
    
    if debugInfo != nil {
        debugInfo.ProcessingTime = time.Since(startTime)
    }
    
    sam.logger.Info("Query processed successfully",
        zap.String("intent", primaryIntent.Name),
        zap.Float64("confidence", primaryIntent.Confidence),
        zap.String("next_action", nextAction.ActionType),
        zap.Duration("processing_time", time.Since(startTime)))
    
    return &IntentResponse{
        Intent:     primaryIntent,
        Entities:   entities,
        Confidence: primaryIntent.Confidence,
        Status:     "AUTHORIZED",
        NextAction: nextAction,
        Debug:      debugInfo,
    }, nil
}

func (sam *SituationalAwarenessModel) validateRequiredEntities(
    intent ClassifiedIntent, 
    entities []ExtractedEntity,
) []string {
    
    entityMap := make(map[string]bool)
    for _, entity := range entities {
        entityMap[entity.Name] = true
    }
    
    var missing []string
    for _, required := range intent.RequiredEntities {
        if !entityMap[required] {
            missing = append(missing, required)
        }
    }
    
    return missing
}

func (sam *SituationalAwarenessModel) determineNextAction(
    ctx context.Context,
    intent ClassifiedIntent,
    entities []ExtractedEntity,
    uiContext UIContext,
) (*NextAction, error) {
    
    switch intent.Name {
    case "QueryEmployeeInfo":
        return &NextAction{
            ActionType: "QUERY_EMPLOYEE",
            Target:     "employee_service",
            Parameters: sam.buildQueryParameters(entities),
        }, nil
        
    case "UpdateEmployeePosition":
        return &NextAction{
            ActionType: "UPDATE_POSITION",
            Target:     "position_workflow",
            Parameters: sam.buildPositionUpdateParameters(entities),
            Confirmation: &ConfirmationRequest{
                Message:    "确认要更新员工职位吗？",
                Parameters: sam.buildConfirmationParameters(entities),
                Timeout:    30 * time.Second,
            },
        }, nil
        
    case "CreateEmployee":
        return &NextAction{
            ActionType: "CREATE_EMPLOYEE",
            Target:     "employee_lifecycle_workflow",
            Parameters: sam.buildEmployeeCreationParameters(entities),
            Confirmation: &ConfirmationRequest{
                Message:    "确认要创建新员工档案吗？",
                Parameters: sam.buildEmployeeConfirmationParameters(entities),
                Timeout:    60 * time.Second,
            },
        }, nil
        
    case "QueryReportingStructure":
        return &NextAction{
            ActionType: "QUERY_ORGANIZATION",
            Target:     "graph_query_service",
            Parameters: sam.buildOrganizationQueryParameters(entities),
        }, nil
        
    default:
        return &NextAction{
            ActionType: "UNKNOWN",
            Parameters: map[string]interface{}{
                "intent": intent.Name,
                "entities": entities,
            },
        }, nil
    }
}

func (sam *SituationalAwarenessModel) buildQueryParameters(entities []ExtractedEntity) map[string]interface{} {
    params := make(map[string]interface{})
    
    for _, entity := range entities {
        switch entity.Name {
        case "employee_id":
            params["employee_id"] = entity.Value
        case "employee_name":
            params["employee_name"] = entity.Value
        case "department":
            params["department"] = entity.Value
        case "date_range":
            params["date_range"] = entity.Value
        }
    }
    
    return params
}

func (sam *SituationalAwarenessModel) buildPositionUpdateParameters(entities []ExtractedEntity) map[string]interface{} {
    params := make(map[string]interface{})
    
    for _, entity := range entities {
        switch entity.Name {
        case "employee_id":
            params["employee_id"] = entity.Value
        case "new_position":
            params["new_position"] = entity.Value
        case "new_department":
            params["new_department"] = entity.Value
        case "effective_date":
            params["effective_date"] = entity.Value
        case "change_reason":
            params["change_reason"] = entity.Value
        }
    }
    
    return params
}
```

#### 意图分类器实现

```go
// internal/intelligence/intent_classifier.go
package intelligence

import (
    "context"
    "strings"
    "sort"
)

// IntentClassifier 意图分类器
type IntentClassifier struct {
    // 预定义意图库
    intentDefinitions map[string]IntentDefinition
    
    // 上下文感知分类器
    contextClassifier ContextAwareClassifier
    
    // ML模型接口（可扩展）
    mlClassifier MLClassifier
}

type IntentDefinition struct {
    Name             string   `json:"name"`
    Category         string   `json:"category"`
    Description      string   `json:"description"`
    Keywords         []string `json:"keywords"`
    Patterns         []string `json:"patterns"`
    RequiredEntities []string `json:"required_entities"`
    ContextHints     []string `json:"context_hints"`
    Confidence       float64  `json:"base_confidence"`
}

// 员工管理相关意图定义
var EmployeeManagementIntents = map[string]IntentDefinition{
    "QueryEmployeeInfo": {
        Name:        "QueryEmployeeInfo",
        Category:    "EMPLOYEE_QUERY",
        Description: "查询员工信息",
        Keywords:    []string{"查询", "查看", "员工", "信息", "档案", "详情"},
        Patterns: []string{
            "查看.*员工.*信息",
            ".*员工.*档案",
            "谁是.*",
            ".*的信息",
            "查询.*",
        },
        RequiredEntities: []string{"employee_identifier"},
        ContextHints:     []string{"employee_list_page", "employee_detail_page"},
        Confidence:       0.8,
    },
    
    "UpdateEmployeePosition": {
        Name:        "UpdateEmployeePosition",
        Category:    "EMPLOYEE_MANAGEMENT",
        Description: "更新员工职位",
        Keywords:    []string{"更新", "修改", "调整", "职位", "岗位", "晋升", "调岗"},
        Patterns: []string{
            "更新.*职位",
            "修改.*岗位",
            ".*晋升.*",
            "调整.*到.*",
            ".*调岗.*",
        },
        RequiredEntities: []string{"employee_identifier", "new_position"},
        ContextHints:     []string{"employee_detail_page", "position_management_page"},
        Confidence:       0.85,
    },
    
    "CreateEmployee": {
        Name:        "CreateEmployee", 
        Category:    "EMPLOYEE_LIFECYCLE",
        Description: "创建新员工",
        Keywords:    []string{"创建", "新增", "添加", "员工", "入职", "录入"},
        Patterns: []string{
            "创建.*员工",
            "新增.*员工",
            "添加.*员工",
            ".*入职.*",
            "录入.*信息",
        },
        RequiredEntities: []string{"employee_name", "position", "department"},
        ContextHints:     []string{"employee_creation_page", "onboarding_page"},
        Confidence:       0.9,
    },
    
    "QueryReportingStructure": {
        Name:        "QueryReportingStructure",
        Category:    "ORGANIZATION_QUERY", 
        Description: "查询组织架构和汇报关系",
        Keywords:    []string{"汇报", "上级", "下级", "组织", "架构", "团队", "经理", "主管"},
        Patterns: []string{
            ".*的上级.*",
            ".*汇报.*给谁",
            ".*的团队.*",
            ".*下属.*",
            "组织.*架构",
        },
        RequiredEntities: []string{"employee_identifier"},
        ContextHints:     []string{"organization_chart_page", "team_page"},
        Confidence:       0.85,
    },
    
    "QueryEmployeeHistory": {
        Name:        "QueryEmployeeHistory",
        Category:    "EMPLOYEE_QUERY",
        Description: "查询员工历史记录",
        Keywords:    []string{"历史", "记录", "变更", "轨迹", "过往", "之前"},
        Patterns: []string{
            ".*历史.*",
            ".*记录.*",
            ".*变更.*轨迹",
            "之前.*职位",
            "过往.*经历",
        },
        RequiredEntities: []string{"employee_identifier"},
        ContextHints:     []string{"employee_detail_page", "history_page"},
        Confidence:       0.8,
    },
}

// ClassifyIntent 分类意图
func (ic *IntentClassifier) ClassifyIntent(
    ctx context.Context,
    query string,
    affordedIntents []string,
) ([]ClassifiedIntent, error) {
    
    query = strings.ToLower(strings.TrimSpace(query))
    var candidates []ClassifiedIntent
    
    // 1. 基于关键词和模式的分类
    for intentName, definition := range ic.intentDefinitions {
        // 如果指定了可用意图列表，检查是否在列表中
        if len(affordedIntents) > 0 && !contains(affordedIntents, intentName) {
            continue
        }
        
        confidence := ic.calculateConfidence(query, definition)
        if confidence > 0.1 { // 最低阈值
            candidates = append(candidates, ClassifiedIntent{
                Name:             intentName,
                Category:         definition.Category,
                Description:      definition.Description,
                Confidence:       confidence,
                RequiredEntities: definition.RequiredEntities,
            })
        }
    }
    
    // 2. 如果启用了ML分类器，使用机器学习增强
    if ic.mlClassifier != nil {
        mlCandidates, err := ic.mlClassifier.Classify(ctx, query)
        if err == nil {
            candidates = ic.mergeCandidates(candidates, mlCandidates)
        }
    }
    
    // 3. 按置信度排序
    sort.Slice(candidates, func(i, j int) bool {
        return candidates[i].Confidence > candidates[j].Confidence
    })
    
    // 返回前5个最佳候选
    if len(candidates) > 5 {
        candidates = candidates[:5]
    }
    
    return candidates, nil
}

func (ic *IntentClassifier) calculateConfidence(query string, definition IntentDefinition) float64 {
    var score float64
    
    // 关键词匹配得分 (40%)
    keywordScore := ic.calculateKeywordScore(query, definition.Keywords)
    score += keywordScore * 0.4
    
    // 模式匹配得分 (40%)
    patternScore := ic.calculatePatternScore(query, definition.Patterns)
    score += patternScore * 0.4
    
    // 基础置信度 (20%)
    score += definition.Confidence * 0.2
    
    return score
}

func (ic *IntentClassifier) calculateKeywordScore(query string, keywords []string) float64 {
    if len(keywords) == 0 {
        return 0
    }
    
    matchCount := 0
    for _, keyword := range keywords {
        if strings.Contains(query, keyword) {
            matchCount++
        }
    }
    
    return float64(matchCount) / float64(len(keywords))
}

func (ic *IntentClassifier) calculatePatternScore(query string, patterns []string) float64 {
    if len(patterns) == 0 {
        return 0
    }
    
    for _, pattern := range patterns {
        // 简化的模式匹配，实际可以使用正则表达式
        if ic.simplePatternMatch(query, pattern) {
            return 1.0
        }
    }
    
    return 0.0
}

func (ic *IntentClassifier) simplePatternMatch(query, pattern string) bool {
    // 简化实现：将.*替换为通配符匹配
    pattern = strings.ReplaceAll(pattern, ".*", "")
    parts := strings.Split(pattern, "")
    
    for _, part := range parts {
        if part != "" && !strings.Contains(query, part) {
            return false
        }
    }
    
    return true
}
```

---

本技术实施详细规范文档为员工模型系统功能的具体实现提供了完整的技术蓝图，涵盖了从元合约编译器到AI集成的各个层面。后续将继续补充API接口设计、测试策略和部署配置等内容。