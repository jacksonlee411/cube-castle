# 41号文档：TemporalMonitor 监控服务质量分析

## 背景与单一事实来源
- 本文聚焦 `cmd/organization-command-service/internal/services/temporal_monitor.go`，该文件实现 `TemporalMonitor` 的指标收集、告警判定与周期性监控逻辑，是命令服务侧时态数据健康监控的唯一事实来源。分析仅基于当前源码及其直接依赖（如 `auth.GetTenantID`），未引入其他事实来源，确保资源唯一性与跨层一致性。

## 现状问题
1. **上下文使用不当**：`StartPeriodicMonitoring` 直接复用外部传入的 `ctx` 做长生命周期循环，并将其传递给所有数据库查询。若该 `ctx` 来源于 HTTP 请求，会在请求结束时被取消，导致监控提前退出；同时没有为每轮查询设置超时或隔离上下文，无法防止慢查询阻塞。
2. **SQL 重复与维护成本高**：`collectBasicStats`、`collectConsistencyStats` 中大量 SQL 以“有租户/无租户”复制粘贴，查询逻辑高度重复且难以维护；部分查询（如 `NOT IN` 嵌套）在大数据量下性能开销大，却缺少分段或索引提示。
3. **统计逻辑与 PBAC 模型耦合不足**：仅通过 `auth.GetTenantID(ctx)` 判定租户，但巡检任务（后台调用）默认走“全租户汇总”，未结合 PBAC/角色校验，存在越权读取风险；缺少对上下文中租户 ID 格式的验证。
4. **健康分与告警缺乏校准**：`calculateHealthScore` 采用固定扣分模型，未考虑组织规模差异；`AlertRule` 阈值为硬编码常量，且未与指标单位保持一致（如 `HEALTH_SCORE` 以 `int(metrics.HealthScore)` 比较，丢失小数精度）。
5. **缺少审计与可观察性落盘**：`CheckAlerts` 仅在日志里打印结果，未将指标与告警写入专用表或监控系统，无法追踪历史趋势；任何失败均只返回错误，缺少重试/降级策略。

## 改进建议
1. **重构上下文管理**：在周期任务内使用 `context.Background()` 派生新的 `loopCtx`，每次查询再嵌套 `context.WithTimeout`（如 5s）；避免直接复用请求级 `ctx`，确保监控服务稳定运行并可在取消时正确清理。
2. **抽象 SQL 生成与分区**：封装通用查询函数或使用参数化模板来处理“租户限定/全量”两种模式，减少重复代码；对大表扫描的查询可引入物化视图或临时表，加上必要索引（如 `(tenant_id, code, is_current)`）提升性能。
3. **校验 tenant/权限信息**：在进入监控逻辑前校验 `tenantID` 是否为合法 UUID，并结合 PBAC 角色决定是否允许全租户汇总；后台任务应显式传入系统租户或执行白名单校验，避免潜在越权。
4. **可配置的告警策略**：将 `AlertRule` 阈值、扣分权重改为可配置项（环境变量或配置文件），并对 `HealthScore` 使用浮点比较；同时增加指标归一化（按总组织数占比）以适配不同规模的数据集。
5. **持久化监控结果**：新增监控记录写入（如 `monitoring_health_log` 表或 Prometheus exporter），记录指标、告警与时间戳；在 `CheckAlerts` 中增加重试/退避策略，并提供钩子发布到外部告警渠道。

## 验收标准
- [ ] 周期监控使用独立上下文与查询级超时，出现慢查询或取消时不会阻塞或提前停止服务。
- [ ] SQL 查询抽象为复用函数，租户/全局两种模式不再重复，关键查询在大数据量下通过基准测试。
- [ ] 监控入口校验租户身份与权限，后台任务可显式配置系统租户或安全白名单。
- [ ] 告警规则与健康分支持配置化，并以浮点精度比较；新增测试覆盖不同阈值场景。
- [ ] 监控结果持久化并可追踪历史，`CheckAlerts` 提供可靠的错误处理与重试机制。

## 一致性校验说明
- 以上结论与建议全部来源于 `temporal_monitor.go` 当前实现；后续改动需同步校验 `OperationalHandler` 等调用方以及监控/审计契约，确保字段与权限模型保持一致。
- 文档保存于 `docs/development-plans/`，待整改完成后可归档至 `docs/archive/development-plans/`，持续维护唯一事实来源。

