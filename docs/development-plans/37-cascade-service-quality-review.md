# 37号文档：层级级联服务质量分析

## 背景与单一事实来源
- 本文聚焦 `cmd/organization-command-service/internal/services/cascade.go`，该文件实现命令服务内部的 `CascadeUpdateService`、`CascadeTask` 及相关处理流程，是当前层级级联逻辑的唯一事实来源。分析未引用外部脚本或历史实现，以保证资源唯一性与跨层一致性。

## 现状问题
1. **任务上下文泄漏风险**：`CascadeTask` 持有 `context.Context` 并在子任务中直接复用；若上游请求在调度后超时取消，任务仍会携带已过期的 context 继续执行，也可能造成背景任务引用被关闭的资源。
2. **级联深度受限且不可配置**：路径更新任务通过 `Priority < 5` 限制递归，实际仅允许 3 层扩散（初始值 2），对超过 3 层的组织树无法完成完整级联；该限制写死在代码中且无告警。
3. **任务投递可靠性不足**：子任务调度使用 `go c.ScheduleTask(childTask)`，返回值被忽略；当队列已满或服务停止时任务被 silently 丢弃，仅写日志，缺少重试或落盘策略。
4. **协程生命周期控制薄弱**：`Start`/`Stop` 通过关闭 `taskQueue` + `shutdown` 管道停止 worker，但在 `Stop` 调用后仍可能有 goroutine 继续调用 `ScheduleTask`（例如并发路径更新），当前实现虽通过 `running` 判断避免写入，但未提供同步钩子，调用方无法得知任务是否真正执行。
5. **业务逻辑实现不完整**：`processStatusUpdate`、`processValidateRules` 仅打印日志或统计结果，缺少对子组织状态、违规场景的实际处理/回滚策略，难以满足“级联更新”的业务需求。

## 改进建议
1. **上下文最小化传递**：任务结构中仅保存必要的 metadata（tenant、用户等），在 worker 内部派生 `context.Background()` 并通过超时/取消策略控制；如需追踪请求，可传递 requestId 等轻量标识。
2. **可配置的级联策略**：将递归深度、队列长度、worker 数量提取为配置项，并在限制达到时明确返回错误或调度后续批次，确保深层组织树能覆盖更新。
3. **可靠调度与回压**：调度函数应返回错误并由调用方处理；内部可使用 `select` + timeout、重试队列或延迟任务，避免任务在高峰期被直接丢弃。必要时引入持久化队列或数据库表记录未完成任务。
4. **完善生命周期管理**：提供 `Wait()` 或 `Drain()` 能力，确保在 `Stop` 前可等待现有任务完成；同时移除多余的 `go ScheduleTask` 包装，使用同步调用并在失败时立即反馈。
5. **补全业务逻辑**：在状态级联、规则验证中明确业务决策（自动停用子组织、告警记录、触发补偿任务等），并与审计/监控系统对接，确保级联服务不仅记录日志，还能驱动作业。

## 验收标准
- [ ] 任务调度与处理逻辑移除对 `context.Context` 的结构体持久化，改用可控的上下文派生；新增测试验证在超时/取消后不会持有已关闭资源。
- [ ] 队列深度、递归限制、worker 数等参数可配置，并在超限时提供明确告警或重试策略。
- [ ] `ScheduleTask` 返回错误码，调用方在所有入口检查并处理；新增测试覆盖队列满、服务停止等异常场景。
- [ ] 服务停止前可显式等待已投递任务完成，确保无任务遗失；相关流程具备单元测试。
- [ ] 状态级联与规则校验具备可验证的业务处理逻辑（例如实际更新或记录任务），并通过测试覆盖关键场景。

## 一致性校验说明
- 文档所述问题与建议全部来源于 `cascade.go` 当前实现；在执行改进时需同时审视 `internal/repository` 提供的层级接口和 `handlers` 调度入口，确保更新后契约一致。
- 本分析文件保存于 `docs/development-plans/`，完成整改后可归档至 `docs/archive/development-plans/`，持续维护唯一事实来源。

