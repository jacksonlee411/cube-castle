# 38号文档：运维调度器质量分析

## 背景与单一事实来源
- 本文聚焦 `cmd/organization-command-service/internal/services/operational_scheduler.go`，该文件实现 `OperationalScheduler` 及其默认任务配置，是当前运维调度能力的唯一事实来源。分析过程中仅基于该源码，不引入外部文档或历史实现，确保资源唯一性与跨层一致性。

## 现状问题
1. **任务状态非持久**：`GetTaskStatus` 每次调用都重新生成默认任务，`LastRun`/`NextRun` 信息无法反映真实执行情况，调度结果既不内存保存也未持久化。
2. **生命周期管理薄弱**：`Start` 只要被多次调用即跳过，但 `Stop` 未重建 `stopCh`；当调度器停止后再次 `Start`，旧的 `stopCh` 已关闭，`schedulingLoop` 会立刻退出，导致调度器无法重新运行。
3. **脚本路径依赖 `PWD`**：构造脚本目录时假定存在环境变量 `PWD`，在部分部署环境或服务以不同工作目录启动时会失败，缺乏显式配置与错误反馈。
4. **任务执行缺少隔离**：`executeTask` 直接执行 SQL 脚本或监控逻辑，没有设置超时、重试或并发控制；默认以 `go s.executeTask` 异步执行，若脚本阻塞可能导致大量并发占用。
5. **任务配置不可扩展**：默认任务列表写死，缺少外部配置或动态注册机制；新的运维任务需改动代码并重新部署，违背灵活运维需求。

## 改进建议
1. **引入状态存储**：为任务维护内存状态表，或将执行结果写入数据库/文件，`GetTaskStatus` 基于真实数据返回；同时暴露历史查询接口以便审计。
2. **重构生命周期控制**：`Stop` 后重建 `stopCh` 并确保 `Start` 可被安全重用；可引入 `sync.Once` 或使用上下文派生新的 cancel 函数来控制调度循环。
3. **配置化脚本目录**：通过显式配置（环境变量或注入参数）指定脚本目录，`PWD` 不可用时及时报错并阻止启动；同时加入日志提示。
4. **任务执行防护**：在 `executeTask` 内为脚本执行设置超时上下文，必要时引入重试策略与并发上限；将监控任务与 SQL 脚本区分到独立的 worker 池，避免相互影响。
5. **支持动态任务定义**：提供注册接口或读取配置文件/数据库以加载任务清单，允许运维在不改代码的情况下调整调度策略、执行脚本与启停状态。

## 验收标准
- [ ] 调度器内可追踪真实任务状态（含最后执行时间、结果）；`GetTaskStatus` 返回持久化/缓存的数据而非固定默认值。
- [ ] `Start`/`Stop` 可重复调用且无竞态，停止后重新启动能够继续调度任务。
- [ ] 脚本目录使用配置驱动，并在目录不存在或不可访问时给出显式错误日志。
- [ ] 任务执行具备超时与重试机制，阻塞脚本不会无限占用资源；相关逻辑附带单元测试。
- [ ] 运维任务清单支持通过配置或注册扩展，无需修改源码即可新增或调整任务；新增测试验证动态配置路径。

## 一致性校验说明
- 所有结论与建议严格基于 `operational_scheduler.go` 当前实现；后续改动需同步检查调用方（`OperationalHandler` 等）与相关文档，确保契约一致。
- 文档存放于 `docs/development-plans/`，完成整改后可归档至 `docs/archive/development-plans/`，保持唯一事实来源。

